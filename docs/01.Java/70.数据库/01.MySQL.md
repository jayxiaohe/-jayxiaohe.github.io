---
title: MySQL
date: 2022-03-28 23:49:32
permalink: /pages/mysql01/
categories:
  - Java
  - 数据库
tags:
  - 
---

::: note 参考文档🎈

[JavaGuide - MySQL知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL)

[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

[《读Mysql实战》我发现了一些不得了的事情(四)](https://mp.weixin.qq.com/s/6GAYut1ubRU-m9mYfZqitA)

[美团技术团队 - mysql类文章](https://tech.meituan.com/tags/mysql.html)
:::

## left join, inner join等的区别？

1、join等价于inner join内连接，是返回两个表中都有的符合条件集合。即交集。
2、left join左连接，是返回左表中所有的行及右表中符合条件的行，（左表中所有的记录以及右表中连接字段相等的记录）如果右侧没有返回null，返回行数与左边相同
3、right join右连接，是返回右表中所有的行及左表中符合条件的行。（右表中所有的记录以及左表中连接字段相等的记录）如果左侧没有返回null，返回行数与右边相同
4、full join全连接，是返回左表中所有的行及右表中所有的行，并按条件连接。left join + right join

> 通常情况下，left join肯定比inner join返回的行数多


RANK()、DENSE_RANK()的区别？

## MySQL如何分页？

### 使用limit关键字来进行分页：

limit函数的介绍：`select * from table limit m,n`
其中m是指记录开始的index，从0开始，表示第一条记录，n是指从第m+1条开始，取n条。
所以我们就能限制m和n来达到分页效果。
pageIndex是你的页数，pageSize是你每一页的数据大小
`select * from tb_test limit (pageIndex-1) * pageSize,pageSize`

### 用主键索引加limit实现：

`select * from 表名称 where id_pk > (pageIndex\*pageSize) limit pageSize`
id_pk就是你的主键索引。
如果用这个方法的话要注意，你的页数是从0开始的，而不是1了。
**适应场景: 适用于数据量多的情况(元组数上万)。**
**原因**：索引扫描,速度会很快。因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况。

## 巨量数据分页查询，怎么优化性能？

## sql解析过程？

## mysql数据结构？

## MySQL/Oracle互相迁移时，需要注意什么？

事务级别，分页等

## MySQL的事务隔离级别？每个级别都会存在什么样的问题？

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |


mysql默认的事务隔离级别为**可重复读（repeatable-read）**。可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。

> **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
>
> **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
>
> **幻读**：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。


> **小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。**

## Mysql怎么去实现的隔离级别的？

## 事物隔离级别查看及修改

首先说明一下MySQL查看和修改事务隔离级别的几个命令：

- 查看事务隔离级别使用select @@tx_isolation
- 修改当前会话事务隔离级别使用**SET session TRANSACTION ISOLATION LEVEL Serializable;**（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）
- 修改全局事务隔离级别使用**SET global TRANSACTION ISOLATION LEVEL Serializable;**（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）

修改了会话的事务隔离级别，比如MyBatis，getSqlSession()的时候，只针对这一次拿到的Session有效；比如CMD命令行，只对这一次的窗口有效。
修改了全局的事务隔离级别，那么针对此后所有的会话有效，**当前已经存在的会话不受影响**。

## 说一下MVCC？

MVCC，全称`Multi-Version Concurrency Control`，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。
准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念。
MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作；MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现；各数据库中MVCC实现并不统一。推荐阅读：[MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)

## MVCC带来的好处是？

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题：

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 降低了死锁的概率，这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

## MVCC的实现？

[**知乎 - MVCC 原理**](https://zhuanlan.zhihu.com/p/147372839)
InnoDB 实现多版本控制 （MVCC）是通过 ReadView+ UndoLog 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。

## 有多个SQL语句模拟ID分发器的业务，判断在默认隔离级别下会不会存在并发上的问题（实际上考察的是innodb的多版本并发控制机制）？

## Read View 是啥？

如果一个事务要查询行记录，需要读取哪个版本的行记录呢？ Read View 就是来解决这个问题的。Read View 可以帮助我们解决可见性问题。 Read View 保存了**当前事务开启时所有活跃的事务列表**。换个角度，可以理解为: **Read View 保存了不应该让这个事务看到的其他事务 ID 列表。**

1. trx_ids 系统当前正在活跃的事务ID集合。
1. low_limit_id ,活跃事务的最大的事务 ID。
1. up_limit_id 活跃的事务中最小的事务 ID。
1. creator_trx_id，创建这个 ReadView 的事务ID。

![1](https://cdn.jsdelivr.net/gh/jayxiaohe/blog_img/img/20220328234949.jpeg)



如果当前事务的 creator_trx_id 想要读取某个行记录，这个行记录ID 的trx_id ，这样会有以下的情况：

- 如果 trx_id < 活跃的最小事务ID（up_limit_id）,也就是说这个行记录在**这些活跃的事务创建前就已经提交了，那么这个行记录对当前事务是可见的。**
- 如果trx_id > 活跃的最大事务ID（low_limit_id），这个说明行记录在这些活跃的事务之后才创建，说明**这个行记录对当前事务是不可见的。**
- 如果 up_limit_id < trx_id <low_limit_id,说明该记录需要在 trx_ids 集合中，可能还处于活跃状态，因此我们需要在 trx_ids 集合中遍历 ，如果trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见，否则 ，trx_id 不存在于 trx_ids 集合中，说明事务trx_id 已经提交了，这行记录是可见的。

## MVCC模式下如何查询一条记录？

1. 获取事务自己的版本号，即 事务ID
1. 获取 Read View
1. 查询得到的数据，然后 Read View 中的事务版本号进行比较。
1. 如果不符合 ReadView 规则， 那么就需要 UndoLog 中历史快照；
1. 最后返回符合规则的数据

> **如果事务隔离级别是 ReadCommit** ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。
> **如果事务的隔离级别是可重读**，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.

## MySQL共有多少种索引？

**索引类型**
Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。
**索引种类**

- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词，进行搜索

## 什么是查询回表？

> **MySQL innodb的主键索引是簇集索引，也就是索引的叶子节点存的是整个单条记录的所有字段值，不是主键索引的就是非簇集索引，非簇集索引的叶子节点存的是主键字段的值。**

如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。

> 参考：[https://www.xttblog.com/?p=4225](https://www.xttblog.com/?p=4225)

## 如何避免回表？

表tbl有a,b,c三个字段，其中a是主键，b上建了索引，然后编写sql语句
`SELECT * FROM tbl WHERE a=1`
这样不会产生回表，因为所有的数据在a的索引树中均能找到
`SELECT * FROM tbl WHERE b=1`
这样就会产生回表，因为where条件是b字段，那么会去b的索引树里查找数据，但b的索引里面只有a,b两个字段的值，没有c，那么这个查询为了取到c字段，就要取出主键a的值，然后去a的索引树去找c字段的数据。查了两个索引树，这就叫回表。
**索引覆盖就是查这个索引能查到你所需要的所有数据**，不需要去另外的数据结构去查。其实就是不用回表。
怎么避免？不是必须的字段就不要出现在SELECT里面。或者b,c建联合索引。但具体情况要具体分析，索引字段多了，存储和插入数据时的消耗会更大。这是个平衡问题。
[知乎 - 到底什么情况下mysql innodb会发生回表操作?](https://www.zhihu.com/question/347087093/answer/830934717)

## SQL性能优化？

[JavaGuide - MySQL 高性能优化规范建议](https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE)

[腾讯面试：一条SQL语句执行得很慢的原因有哪些？](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd)

## MySQL中myIsam跟Innodb的区别？

1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
1. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
1. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

> MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
> 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。


4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；
4. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了
4. MyISAM表格可以被压缩后进行查询操作
4. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
4. InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有
4. Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
   Innodb：frm是表定义文件，ibd是数据文件
   Myisam：frm是表定义文件，myd是数据文件，myi是索引文件

> **InnoDB为什么推荐使用自增ID作为主键？**
> 答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

## redolog和binlog？

[mysql日志系统之redo log和bin log](https://www.jianshu.com/p/4bcfffb27ed5)
binlog是mysql实现的二进制日志文件 , 一般用于crash-safe , 我之前还用他来做过缓存和数据库的双写一致性 , 用阿里的canal去订阅binlog,数据库更新的时候顺带删除redis缓存

## binlog的几种格式说一下

一个是statement, 一个是row , 还有一个mix混合模式 , statement没办法复原一些函数操作 , row数据量会比较大 , 所以有mix模式,不涉及函数的操作就用statement , 不然就用row

## redo log何时写入磁盘？

## 为什么要用B+树实现索引？不用B树？

B+树只有叶节点存放数据，其余节点用来索引。
而B-树是每个索引节点都会有Data域。这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。
B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问了。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）
**总结：**
1、 **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2、**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3、**B+树更便于遍历**：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
4、**B+树更适合基于范围的查询**：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。


## Mysql执行过程？

[参考 - 一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)

**查询：**连接器 -> 查询缓存 -> 分析器 -> 优化器 -> 执行器

1. **连接器**
   辅助与客户端建立连接、获取权限、位置和管理连接。
1. **查询缓存**
   MySql 在执行查询时会先对查询缓存进行查询，是否之前执行过此查询，之前执行过的语句会以key-value形式，被直接缓存在内存当中key为语句。将MySQL参数 query_cache_type 设置为 DEMAND 这样SQL语句都不会使用缓存，对于需要使用查询缓存的查询语句可以用SQL_CACHE显示指定。（MySQL8.0 已经将查询缓存模块移除）
   `mysql> select SQL_CACHE * from user where id=1`

在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。

3. **分析器**
   对sql语句做解析。MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。
   做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。
   如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。
3. **优化器**
   优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的链接顺序。
3. **执行器**
   开始执行的时候，要先判断一下你对这个表有没有执行查询的权限，如果没有，就会返回没有权限的错误。
   如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

**更新：**

`UPDATE TEST SET c = c + 1 WHERE ID = 1;`

1. **查找记录**：执行器先找引擎取id=1这一行。ID是主键，引擎直接用树搜索找到这一行。如果id=1这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回；
1. **执行器**拿到引擎返回的行数据，把c+1，得到新的一行数据，再调用引擎接口写入这行新数据；
1. 引擎将这行新数据更新到**内存**中，同时**将这个更新操作记录到redo log里面**，此时redo log处于**prepare**状态；
1. 引擎告知执行器，我执行完成了，你随时可以调我的接口提交事务了；
1. 执行器生成这个操作的binlog，并把**binlog**写入磁盘。
1. **执行器调用引擎的提交事务接口**，引擎把刚刚写入的redo log改成**提交commit**状态，更新完成。

![](https://cdn.jsdelivr.net/gh/jayxiaohe/blog_img/img/20220328234949.jpeg)

## Mysql性能优化？

[MySQL 性能优化的最佳20多条经验分享](https://www.cnblogs.com/crystaltu/p/6369134.html)

## 讲一下事务？

关系性数据库需要遵循ACID规则，具体内容如下：
**原子性**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
**一致性**： 执行事务前后，数据保持一致；
**隔离性**： 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；
**持久性**: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。
为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：
**READ_UNCOMMITTED（读未提交）**: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
**READ_COMMITTED（读提交）**: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
**REPEATABLE_READ（可重复读）**: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
**SERIALIZABLE（串行）**: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

这里需要注意的是：Mysql  InnoDB默认采用的 **REPEATABLE_READ**隔离级别，Oracle 默认采用的 **READ_COMMITTED**隔离级别。
事务隔离机制的实现**基于锁机制和并发调度**。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

## mysql的事务ACID以及都是如何实现的？

答:A原子性用undo log实现
I隔离性说了MVCC,以及readview,表隐式字段,快照读,版本链,如何判断当前事物能不能读某个版本,等等...(MVCC推荐看b站IT老哥讲解的视频)
D持久性说了redo log和mysql的buffer那一套(这里面问的特别深,顺序IO和随机IO,redo log写入策略..)
C一致性:一致性怎么实现这个问题难我很久了,之前搜博客也没看到很好的解答,我就按照自己理解说其他三个都能保证的话就具备了一致性,面试官否定~

## Mysql中有哪几种锁？

从锁的类别上来讲，有共享锁和排他锁：
**共享锁：**又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁.共享锁可以同时加上多个。
**排他锁：**又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁.排他锁只可以加一个，他和其他的排他锁。共享锁都相斥。

从锁的粒度来说，分为表锁和行锁：
**表级锁**：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
**行级锁**：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。
MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。
锁的粒度取决于具体的存储引擎。InnoDB实现了行级锁，页级锁，表级锁。他们的加锁开销从大大小,并发能力也是从大到小。

## gap lock？

## next-key lock？

## 间隙锁？

## mysql锁升级过程？

## MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？

## mysql存储引擎索引结构，以及原因优点，有哪些存储引擎？

## NOW() 和CURRENT_DATE() 有什么区别？

**NOW()**  命令用于显示当前年份，月份，日期，小时，分钟和秒。
**CURRENT_DATE()**  仅显示当前年份，月份和日期。

## 如何查看为表格定义的所有索引？

索引是通过以下方式为表格定义的：
`SHOW INDEX FROM <tablename>;`

## Hash索引和B+树所有有什么区别或者说优劣呢?

**底层实现原理：**
hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据。
那么可以看出他们有以下的不同：

- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。

因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。

- hash索引不支持使用索引进行排序，原理同上。
- hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。**AAAA**和**AAAAB**的索引没有相关性。
- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
- hash索引虽然在等值查询上较快，但是不稳定，性能不可预测。当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。

## 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?

在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。
当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

## 非聚簇索引一定会回表查询吗?

不一定。这涉及到查询语句所要求的字段是否全部命中了索引。如果全部命中了索引，那么就不必再进行回表查询。
举个简单的例子。假设我们在员工表的`年龄`上建立了索引，那么当进行`select age from employee where age < 20`的查询时，在索引的叶子节点上已经包含了age信息，不会再次进行回表查询。

## 联合索引是什么?为什么需要注意联合索引中的顺序?

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。
具体原因为：
MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。
当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找...以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

## 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?

MySQL提供了explain命令来查看语句的执行计划。MySQL在执行某个语句之前,会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引。例如possilbe_key，key，key_len等字段，分别说明了此语句可能会使用的索引，实际使用的索引以及使用的索引长度。

## 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?

- 使用不等于查询
- 列参与了数学运算或者函数
- 在字符串like时左边是通配符。类似于'%aaa'
- 当mysql分析全表扫描比使用索引快的时候不使用索引
- 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引
- 不同的字符集进行比较前需要进行转换会造成索引失效

## explain出来的各种item的意义？

[explain结果每个字段的含义说明](https://www.jianshu.com/p/8fab76bbf448)

## [❌]profile的意义以及使用场景？

## [❌]慢日志都是怎么查询的？

## B+树的原理？

**B+树的原理**

　　B+树是B树的一种变形，它把数据都存储在叶子节点，内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点；B+树的遍历高效，将所以叶子节点串联成链表即可从头到尾遍历。

**B+树的优点**

1. 非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
1. 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

## 最左前缀？

## 为什么B+树比B树更适合做系统的数据库索引和文件索引？

1）B+树的磁盘读写代价更低
因为B+树内部结点没有指向关键字具体信息的指针，内部结点相对B树小
2）B+树的查询更加稳定
因为非终端结点并不是指向文件内容的结点，仅仅是作为叶子结点的关键字索引，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。即s所有关键字查询的长度是一样的，查询效率稳定。

## select子句顺序？

| **子句**     | **说明**               | **是否必须使用**           |
| ------------ | ---------------------- | -------------------------- |
| **select**   | **要返回的列或表示式** | **是**                     |
| **form**     | **从中检索数据的表**   | **仅在从表选择数据时使用** |
| **where**    | **行级过滤**           | **否**                     |
| **group by** | **分组说明**           | **仅在按组计算聚集时使用** |
| **having**   | **组级过滤**           | **否**                     |
| **order by** | **输出排序顺序**       | **否**                     |
| **limit**    | **要检索的行数**       | **否**                     |


## 数据库的三范式是什么？

**简单归纳：**

第一范式(1NF)：字段不可分；

第二范式(2NF)：有主键，非主键字段依赖主键；

第三范式(3NF)：非主键字段不能相互依赖。

**解释：**

1NF：原子性。 字段不可再分,否则就不是关系数据库;

2NF：唯一性 。一个表只说明一个事物；

3NF：每列都与主键有直接关系，不存在传递依赖。

## 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

1.InnoDB：因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。所以记录的ID是`6`

2.MylSAM：因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。所以记录的ID是`8`

## 其他

**分布式事务、二阶段提交(2PC)、三阶段提交(3PC)、脑裂问题...**

