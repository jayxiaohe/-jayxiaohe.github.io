---
title: JVM面试题
date: 2022-05-21 16:32:26
permalink: /jvm/interview/
categories:
  - JVM
tags:
  - 
---



## 介绍下 Java 内存区域（运行时数据区）

JDK 1.8 和之前的版本略有不同。

![1](https://javaguide.cn/assets/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.406fed56.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区（1.8之前**hotspot**的实现方式是**永久代**。之后是**元空间**，使用的是直接内存）
- 直接内存 （非运行时数据区的一部分）

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，**分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成**。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“**线程私有**”的内存。

**程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

具体内容见 [这里](/jvm/register/)

### Java虚拟机栈

Java 虚拟机栈是由一个个栈帧组成。与程序计数器一样，**也是线程私有的**，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

- **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

**在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。**

### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例以及数组都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

在 JDK 8 版本之前，堆内存被通常分为下面三部分：

1. 新生代(Young Generation)（Eden S0 S1。8:1:1）
2. 老年代(Old Generation)
3. 永久代(Permanent Generation)（永久代可以不考虑。把它看作方法区的具体实现。）

堆这里最容易出现的就是 `OutOfMemoryError` 错误

### 方法区

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的。

虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

:::note

方法区相当于 『接口』，永久代和元空间则是1.7和1.8版本对它的『实现』。

方法区是 Java 虚拟机规范中的定义，永久代是 HotSpot 的概念。其他的虚拟机实现并没有永久代这一说法。

:::

垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

**常用参数：**

```java
// 1.7
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
// 1.8。
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

与永久代不同，如果不指定`Metaspace`大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

#### 为什么要将永久代替换为元空间？

主要原因：

1. 永久代有固定大小的限制，但有时很难确定。动态加载的类过多，容易产生Perm区的OOM。
2. 对永久代进行调优是很困难的。
3. 在JDK8合并 HotSpot 和 JRockit。要考虑JRockit客户不配置永久代的习惯。

具体见 [这里](/jvm/methodarea/#_5-1-演进细节)

### 运行时常量池（方法区的一部分）

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

会受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

1. JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代
2. JDK1.7 字符串常量池被**从方法区拿到了堆中**, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。
3. JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)

### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## Java 对象的创建过程

![img](D:\0.devTools\19.vuepress\blog\docs\.vuepress\public\img\assets\628b24650e3e74749fb884b5.png)



具体见 [这里](/jvm/object/#_1-1-创建对象的方式)


## 对象的访问定位的两种方式（句柄和直接指针两种方式）



## String 类和常量池

## 8 种基本类型的包装类和常量池

