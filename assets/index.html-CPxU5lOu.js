import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as i,e as t}from"./app-BUJ2iQsf.js";const l={},n=t('<h2 id="jvm整体结构" tabindex="-1"><a class="header-anchor" href="#jvm整体结构"><span>JVM整体结构</span></a></h2><figure><img src="https://fastly.jsdelivr.net/gh/jayxiaohe/blog_img/img/20220521164421.png" alt="1595048291864-59d04e29-0e91-4b7d-a756-1b4505979a17" tabindex="0" loading="lazy"><figcaption>1595048291864-59d04e29-0e91-4b7d-a756-1b4505979a17</figcaption></figure><ol><li>方法区和堆区是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</li><li>Java栈又叫做jvm虚拟机栈</li><li>方法区（永久代）在<code>jdk8</code>以后又叫做元空间<code>Metaspace</code><ul><li>方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT编译器，英文写作<strong>Just-In-Time Compiler</strong>）编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li><li>在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</li><li>在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</li><li>在JDK1.8之后JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域</li></ul></li><li>java代码执行流程：</li></ol><p>java程序 -&gt;（编译javac）-&gt; 字节码文件.class -&gt; 类装载子系统化身为反射类Class -&gt; 运行时数据区 -&gt; （解释执行）-&gt; 操作系统（Win，Linux，Mac JVM）</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>运行时环境，和JDK中的 Runtime 类对应。这个类也是单例的。</p></div><h2 id="jvm的生命周期" tabindex="-1"><a class="header-anchor" href="#jvm的生命周期"><span>JVM的生命周期</span></a></h2><h3 id="启动" tabindex="-1"><a class="header-anchor" href="#启动"><span>启动</span></a></h3><p>Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="执行" tabindex="-1"><a class="header-anchor" href="#执行"><span>执行</span></a></h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h3 id="退出" tabindex="-1"><a class="header-anchor" href="#退出"><span>退出</span></a></h3><p>有以下几种情况：</p><ul><li>程序正常执行结束</li><li>程序异常或错误而异常终止</li><li>操作系统错误导致终止</li><li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作</li><li>除此之外，JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li></ul><h2 id="jvm发展历程" tabindex="-1"><a class="header-anchor" href="#jvm发展历程"><span>JVM发展历程</span></a></h2><h3 id="sun-classic-vm" tabindex="-1"><a class="header-anchor" href="#sun-classic-vm"><span>Sun Classic VM</span></a></h3><ul><li>第一款商用Java虚拟机，JDK1.4时被淘汰</li><li>只提供了解释器，效率较差。如果需要JIT编译器（及时编译器），就要进行外挂。但二者不能协同工作</li><li>JIT会把热点代码（执行次数较多的）编译成本地机器指令，并缓存起来。提升了效率</li><li>JIT的缺点：如果把<strong>所有代码</strong>都编译成本地机器指令，会导致暂停时间太长，导致卡顿</li><li>现在hotspot内置了此虚拟机</li></ul><h3 id="exact-vm" tabindex="-1"><a class="header-anchor" href="#exact-vm"><span>Exact VM</span></a></h3><ul><li>jdk1.2时由sun提供</li><li>Exact menory management: 准确式内存管理——虚拟机可以知道内存中某个位置的数据具体是什么类型</li><li>具有热点探测、编译器与解释器混合工作模式</li><li>只在Solaris平台短暂使用，其他平台上还是classic vm</li></ul><h3 id="hotspot-vm" tabindex="-1"><a class="header-anchor" href="#hotspot-vm"><span>HotSpot VM</span></a></h3><ul><li>1997年由sun收购而来。JDK1.3时，成为默认虚拟机</li><li>Sun/Oracle JDK 和 OpenJDK的默认虚拟机</li><li>名字中的 hotspot 指的是它的<strong>热点代码探测技术</strong><ul><li>通过计数器找到最具编译价值的代码。触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="bea-的-jrockit" tabindex="-1"><a class="header-anchor" href="#bea-的-jrockit"><span>BEA 的 JRockit</span></a></h3><ul><li>专注于服务器端应用。它可以不太关注程序启动速度，因此JRock内部不包含解析器实现，全部代码都靠即时编译器编译后执行</li><li>JRockit JVM是世界上最快的JVM</li><li>优势：全面的Java运行时解决方案组合</li><li>2008年，BEA被Oracle收购。Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 跹的优秀特性。</li></ul><h3 id="ibm-的-j9" tabindex="-1"><a class="header-anchor" href="#ibm-的-j9"><span>IBM 的 J9</span></a></h3><ul><li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</li><li>市场定位与 HotSpott 接近，服务器端、桌而应用、嵌入式等多用途 VM</li><li>广泛用于IBM的各种Java产品。</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机</li></ul>',24),o=[n];function s(r,c){return i(),e("div",null,o)}const d=a(l,[["render",s],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/01java/40jvm/intro/","title":"JVM简介","lang":"zh-CN","frontmatter":{"title":"JVM简介","date":"2022-05-21T16:32:26.000Z","order":1,"permalink":"/01java/40jvm/intro/","icon":"wenzhang","description":"JVM整体结构 1595048291864-59d04e29-0e91-4b7d-a756-1b4505979a171595048291864-59d04e29-0e91-4b7d-a756-1b4505979a17 方法区和堆区是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。 Java栈又叫做jvm虚拟机栈...","head":[["meta",{"property":"og:url","content":"https://i.iyes.life/01java/40jvm/intro/"}],["meta",{"property":"og:site_name","content":"Mr.He"}],["meta",{"property":"og:title","content":"JVM简介"}],["meta",{"property":"og:description","content":"JVM整体结构 1595048291864-59d04e29-0e91-4b7d-a756-1b4505979a171595048291864-59d04e29-0e91-4b7d-a756-1b4505979a17 方法区和堆区是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。 Java栈又叫做jvm虚拟机栈..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://fastly.jsdelivr.net/gh/jayxiaohe/blog_img/img/20220521164421.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-01T16:22:14.000Z"}],["meta",{"property":"article:author","content":"Mr.He"}],["meta",{"property":"article:published_time","content":"2022-05-21T16:32:26.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-01T16:22:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM简介\\",\\"image\\":[\\"https://fastly.jsdelivr.net/gh/jayxiaohe/blog_img/img/20220521164421.png\\"],\\"datePublished\\":\\"2022-05-21T16:32:26.000Z\\",\\"dateModified\\":\\"2023-01-01T16:22:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.He\\",\\"url\\":\\"https://i.iyes.life\\"}]}"]]},"headers":[{"level":2,"title":"JVM整体结构","slug":"jvm整体结构","link":"#jvm整体结构","children":[]},{"level":2,"title":"JVM的生命周期","slug":"jvm的生命周期","link":"#jvm的生命周期","children":[{"level":3,"title":"启动","slug":"启动","link":"#启动","children":[]},{"level":3,"title":"执行","slug":"执行","link":"#执行","children":[]},{"level":3,"title":"退出","slug":"退出","link":"#退出","children":[]}]},{"level":2,"title":"JVM发展历程","slug":"jvm发展历程","link":"#jvm发展历程","children":[{"level":3,"title":"Sun Classic VM","slug":"sun-classic-vm","link":"#sun-classic-vm","children":[]},{"level":3,"title":"Exact VM","slug":"exact-vm","link":"#exact-vm","children":[]},{"level":3,"title":"HotSpot VM","slug":"hotspot-vm","link":"#hotspot-vm","children":[]},{"level":3,"title":"BEA 的 JRockit","slug":"bea-的-jrockit","link":"#bea-的-jrockit","children":[]},{"level":3,"title":"IBM 的 J9","slug":"ibm-的-j9","link":"#ibm-的-j9","children":[]}]}],"git":{"createdTime":1664722755000,"updatedTime":1672590134000,"contributors":[{"name":"jayxiaohe","email":"495302067@qq.com","commits":1}]},"readingTime":{"minutes":4.18,"words":1253},"filePathRelative":"01java/40jvm/01.JVM简介.md","localizedDate":"2022年5月22日","autoDesc":true}');export{d as comp,m as data};
