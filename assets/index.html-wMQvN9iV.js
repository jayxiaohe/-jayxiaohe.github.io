import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,w as e,e as h,a as s,r as k,o as t}from"./app-BUJ2iQsf.js";const p={},d=h(`<h2 id="💬-描述" tabindex="-1"><a class="header-anchor" href="#💬-描述"><span>💬 描述</span></a></h2><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 <strong>示例 1:</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#393a34;--shiki-dark:#e1e4e8;--shiki-light-bg:#ffffff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes vitesse-light github-dark vp-code"><code><span class="line"><span>输入: [1,2,3,null,5,null,4]</span></span>
<span class="line"><span>输出: [1, 3, 4]</span></span>
<span class="line"><span>解释:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   1            &lt;---</span></span>
<span class="line"><span> /   \\</span></span>
<span class="line"><span>2     3         &lt;---</span></span>
<span class="line"><span> \\     \\</span></span>
<span class="line"><span>  5     4       &lt;---</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h2 id="📋-代码1-dfs" tabindex="-1"><a class="header-anchor" href="#📋-代码1-dfs"><span>📋 代码1- DFS</span></a></h2><p>按照 根结点 -&gt; 右子树 -&gt; 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#393a34;--shiki-dark:#e1e4e8;--shiki-light-bg:#ffffff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes vitesse-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> * Definition for a binary tree node.</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> * public class TreeNode {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> *     int val;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> *     TreeNode left;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> *     TreeNode right;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> *     TreeNode(int x) { val = x; }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> * }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">     List</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> res</span><span style="--shiki-light:#999999;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> ArrayList</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;"> rightSideView</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">TreeNode </span><span style="--shiki-light:#B07D48;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">        // 首次加入时，深度为0。</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">        dfs</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">root</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> res</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">TreeNode </span><span style="--shiki-light:#B07D48;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#FFAB70;"> depth</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">node </span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">        // 如果深度 == 结果集中的元素数。说明这是当前层的第一个元素。需要加到结果集中。否则不加。为什么呢？首先第一个进入dfs时，传入的深度为0，res长度也为0。这样可以把root加到res中。</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        接着深度</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">，考察右孩子。此时深度又等于res元素数，会把右孩子加入res。继续往下</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">...</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        若到某一层右孩子为null，会直接在上方返回，这样就会考虑左孩子。从而把左孩子加入集合。若左孩子也是null，会进行回溯，回溯到最近的、未考察过左孩子的节点，去考察它的左孩子（回溯时深度也会变小）。此时深度和res的长度是不相等的，这个左孩子不能加到res。就这样一路回溯。遇到合适的元素就会加到res。直到所有元素都考察一遍。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">        // 这里把深度和结果集的元素数结合了起来，这个思路是以前没想到的- - </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">depth </span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> res</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">())</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">            res</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">val</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">        // 准备考察下层元素，深度+1。</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        depth</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">        // 先考察右孩子。这样每次就能先判断右边的元素。</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">        dfs</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">right</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> depth</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">        dfs</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">left</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> depth</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><p><strong>复杂度： 时间和空间均为O(n) 。</strong><br></p><h2 id="📋-代码2-bfs" tabindex="-1"><a class="header-anchor" href="#📋-代码2-bfs"><span>📋 代码2- BFS</span></a></h2><p>对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#393a34;--shiki-dark:#e1e4e8;--shiki-light-bg:#ffffff;--shiki-dark-bg:#24292e;"><pre class="shiki shiki-themes vitesse-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> List</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;"> rightSideView</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">TreeNode </span><span style="--shiki-light:#B07D48;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        List</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> res</span><span style="--shiki-light:#999999;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> ArrayList</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">root </span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> res</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        Queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">TreeNode</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> queue</span><span style="--shiki-light:#999999;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> LinkedList</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">        queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">root</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#999999;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">())</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">            // 获取当前queue的长度，这也 代表着二叉树当前层元素的数量。</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">            size </span><span style="--shiki-light:#999999;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">            // 遍历当前层的元素。为什么用普通for循环？</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">            // 因为这样可以知道是否到达了当前层的最后一个元素。</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#999999;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> size</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">                // 把当前元素弹出，把它的孩子节点压入。先压左后压右，这样每层最右边的一个元素的值就是需要加到结果集中的。</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">                TreeNode</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> node</span><span style="--shiki-light:#999999;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;"> queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">poll</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">left</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#1E754F;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">                    queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">left</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">right</span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#1E754F;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">                    queue</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">right</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#6A737D;">                // 如果当前节点是当前层的最后一个节点，则把它的值加到结果集中。</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#AB5959;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">                    res</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">node</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#E1E4E8;">val</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#E1E4E8;"> res</span><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><p><strong>复杂度： 时间和空间均为O(n) 。</strong><br></p><h2 id="💡-思路" tabindex="-1"><a class="header-anchor" href="#💡-思路"><span>💡 思路</span></a></h2><p>已经写在上方代码注释中。有些之前没想到的思路。代码主要参考自<a href="https://leetcode-cn.com/u/sweetiee/" target="_blank" rel="noopener noreferrer">甜姨</a>。</p><br>`,17),r=s("a",{href:"https://leetcode-cn.com/problems/binary-tree-right-side-view/",class:"LinkCard",target:"_blank"},"LeetCode-199",-1),E=s("br",null,null,-1);function g(y,c){const i=k("center");return t(),n("div",null,[d,l(i,null,{default:e(()=>[r]),_:1}),E])}const A=a(p,[["render",g],["__file","index.html.vue"]]),u=JSON.parse('{"path":"/40algo/50treenode/50mid/lc199/","title":"LeetCode-199 二叉树的右视图","lang":"zh-CN","frontmatter":{"title":"LeetCode-199 二叉树的右视图","date":"2020-04-22T20:52:04.000Z","permalink":"/40algo/50treenode/50mid/lc199/","order":40,"icon":"leetcode","description":"💬 描述 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 📋 代码1- DFS 按照 根结点 -> 右子树 -> 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点。 复杂度： 时间和空间均为O(n) 。 📋 代码2- BFS 对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定...","head":[["meta",{"property":"og:url","content":"https://i.iyes.life/40algo/50treenode/50mid/lc199/"}],["meta",{"property":"og:site_name","content":"Mr.He"}],["meta",{"property":"og:title","content":"LeetCode-199 二叉树的右视图"}],["meta",{"property":"og:description","content":"💬 描述 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 📋 代码1- DFS 按照 根结点 -> 右子树 -> 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点。 复杂度： 时间和空间均为O(n) 。 📋 代码2- BFS 对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-18T06:12:12.000Z"}],["meta",{"property":"article:author","content":"Mr.He"}],["meta",{"property":"article:published_time","content":"2020-04-22T20:52:04.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-18T06:12:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LeetCode-199 二叉树的右视图\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-04-22T20:52:04.000Z\\",\\"dateModified\\":\\"2024-08-18T06:12:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.He\\",\\"url\\":\\"https://i.iyes.life\\"}]}"]]},"headers":[{"level":2,"title":"💬 描述","slug":"💬-描述","link":"#💬-描述","children":[]},{"level":2,"title":"📋 代码1- DFS","slug":"📋-代码1-dfs","link":"#📋-代码1-dfs","children":[]},{"level":2,"title":"📋 代码2- BFS","slug":"📋-代码2-bfs","link":"#📋-代码2-bfs","children":[]},{"level":2,"title":"💡 思路","slug":"💡-思路","link":"#💡-思路","children":[]}],"git":{"createdTime":1664722755000,"updatedTime":1723961532000,"contributors":[{"name":"jayxiaohe","email":"hept//github0712","commits":1}]},"readingTime":{"minutes":2.86,"words":857},"filePathRelative":"40algo/50treenode/50mid/40.leetcode199.md","localizedDate":"2020年4月23日","autoDesc":true}');export{A as comp,u as data};
