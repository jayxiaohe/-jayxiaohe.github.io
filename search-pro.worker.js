const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":1047,\"nextId\":1047,\"documentIds\":{\"0\":\"0\",\"1\":\"0#🏠-关于本站\",\"2\":\"0#微信\",\"3\":\"1\",\"4\":\"3\",\"5\":\"4\",\"6\":\"4#_1-快捷键\",\"7\":\"4#_1-1-自动导入-import\",\"8\":\"4#_1-2-快速换行\",\"9\":\"4#_2-操作\",\"10\":\"4#_2-1-快速判断变量是否等于null\",\"11\":\"4#_2-2-给代码创建书签\",\"12\":\"4#_2-3-idea如何显示编译后的类\",\"13\":\"4#_2-4-创建quick-list\",\"14\":\"4#_3-设置\",\"15\":\"4#_3-1-maven配置\",\"16\":\"4#_3-2-设置方法参数列表类型自动提示\",\"17\":\"4#_3-3-编码设置\",\"18\":\"4#_3-3-1-当前项目的设置\",\"19\":\"4#_3-3-2-新项目的默认设置\",\"20\":\"4#_3-4-问题-idea-2019-3-2-之后的版本无法递归导入maven问题。\",\"21\":\"4#_3-4-1-解决方案\",\"22\":\"4#_4-插件\",\"23\":\"4#_5-参考\",\"24\":\"4@0\",\"25\":\"4@1\",\"26\":\"5\",\"27\":\"5#快捷键\",\"28\":\"5#批量执行sql\",\"29\":\"5@0\",\"30\":\"5@1\",\"31\":\"6\",\"32\":\"6#查看哪个目录占用空间大\",\"33\":\"6@0\",\"34\":\"6@1\",\"35\":\"7\",\"36\":\"7#自用设置\",\"37\":\"7#通用\",\"38\":\"7#外观\",\"39\":\"7#图床\",\"40\":\"7#markdown\",\"41\":\"7#其他配置\",\"42\":\"7#快捷键\",\"43\":\"7#一-菜单栏\",\"44\":\"7#二-文件\",\"45\":\"7#三-编辑\",\"46\":\"7#四-段落\",\"47\":\"7#五-格式\",\"48\":\"7#六-视图\",\"49\":\"7#和谐\",\"50\":\"7@0\",\"51\":\"7@1\",\"52\":\"8\",\"53\":\"8#插件\",\"54\":\"8#图标\",\"55\":\"8#markdown增强语法\",\"56\":\"8@0\",\"57\":\"8@1\",\"58\":\"9\",\"59\":\"9#_1-maven介绍\",\"60\":\"9#_2-安装和配置\",\"61\":\"9#_2-1-settings配置修改\",\"62\":\"9#_2-2-环境变量配置\",\"63\":\"9#_2-3-验证\",\"64\":\"9#_3-基本概念\",\"65\":\"9#_3-1-maven中的坐标\",\"66\":\"9#_3-2-pom\",\"67\":\"9#_3-2-1-含义\",\"68\":\"9#_3-2-2-模型化思想模型化思想\",\"69\":\"9#_3-2-3-对应的配置文件\",\"70\":\"9#_3-2-4-pom-xml解读\",\"71\":\"9#_3-3-约定的目录结构\",\"72\":\"9#_4-执行-maven-的构建命令\",\"73\":\"9#_4-1-清理操作\",\"74\":\"9#_4-2-编译操作\",\"75\":\"9#_4-3-测试操作\",\"76\":\"9#_4-4-打包操作\",\"77\":\"9#_4-5-安装操作\",\"78\":\"9#_5-创建web工程\",\"79\":\"9#_6-依赖相关\",\"80\":\"9#_6-1-依赖范围-scope\",\"81\":\"9#_6-2-依赖的传递性\",\"82\":\"9#_6-3-依赖的排除\",\"83\":\"9#_6-3-1-配置方式\",\"84\":\"9#_7-maven工程间的继承\",\"85\":\"9#_7-1-概念-作用\",\"86\":\"9#_7-2-父子工程的pom-xml\",\"87\":\"9#_7-2-1-父工程的pom-xml\",\"88\":\"9#_7-2-2-子工程的pom-xml\",\"89\":\"9#_7-3-聚合和继承\",\"90\":\"9#_7-4-好处\",\"91\":\"9#_7-5-循环依赖问题\",\"92\":\"9#_8-idea中maven配置\",\"93\":\"9#_9-maven的生命周期\",\"94\":\"9#_9-1-三个生命周期\",\"95\":\"9#_9-2-特点\",\"96\":\"9#_10-插件和目标\",\"97\":\"9#_10-1-插件\",\"98\":\"9#_10-2-目标\",\"99\":\"9#_10-3-自定义打包的插件maven-assembly-plugin\",\"100\":\"9#_11-项目中遇到-用到过的插件\",\"101\":\"9#_11-1-maven-compiler-plugin\",\"102\":\"9#_11-2-maven-dependency-plugin\",\"103\":\"9#_11-3-maven-jar-plugin\",\"104\":\"9#_11-4-spring-boot-maven-plugin\",\"105\":\"9#_11-4-1-目标概述\",\"106\":\"9#_11-4-2-repackage目标-默认goal\",\"107\":\"9@0\",\"108\":\"9@1\",\"109\":\"10\",\"110\":\"10#diagrams-免费开源思维导图\",\"111\":\"10#explorerpatcher-win11菜单优化\",\"112\":\"10#xmind-zen\",\"113\":\"10#dev-sidecar\",\"114\":\"10#vive-资源管理器多标签页\",\"115\":\"10@0\",\"116\":\"10@1\",\"117\":\"11\",\"118\":\"11#推荐\",\"119\":\"11#文档\",\"120\":\"11#社区\",\"121\":\"11#社区互动\",\"122\":\"11#技巧\",\"123\":\"11#博客\",\"124\":\"11#电子书\",\"125\":\"11#优秀文章\",\"126\":\"11#视频\",\"127\":\"11#github\",\"128\":\"11#评论系统\",\"129\":\"11#前端小工具\",\"130\":\"11#代码编辑\",\"131\":\"11#emoji表情\",\"132\":\"11#图片工具\",\"133\":\"11#思维导图\",\"134\":\"11#css\",\"135\":\"11#cdn加速\",\"136\":\"11#网站托管\",\"137\":\"11#正则\",\"138\":\"11#其他\",\"139\":\"11#设计\",\"140\":\"11#图库\",\"141\":\"11#_3d\",\"142\":\"11#交互\",\"143\":\"11#有趣\",\"144\":\"11#生成器\",\"145\":\"11#元宇宙\",\"146\":\"11#教程\",\"147\":\"11#产品\",\"148\":\"11#实用\",\"149\":\"11#talk\",\"150\":\"11#算法\",\"151\":\"11#nginx\",\"152\":\"11#生活\",\"153\":\"11@0\",\"154\":\"11@1\",\"155\":\"12\",\"156\":\"12#react-ui-组件库\",\"157\":\"12#vue-ui组件库\",\"158\":\"12#常用效果组件\",\"159\":\"12#工具类\",\"160\":\"12#vue工具类\",\"161\":\"12#其他\",\"162\":\"12@0\",\"163\":\"12@1\",\"164\":\"14\",\"165\":\"15\",\"166\":\"15#数组\",\"167\":\"15#链表\",\"168\":\"15#栈\",\"169\":\"15#队列\",\"170\":\"15#递归\",\"171\":\"15#排序\",\"172\":\"15#二分查找\",\"173\":\"15#散列表\",\"174\":\"15#字符串\",\"175\":\"15#二叉树\",\"176\":\"15#堆\",\"177\":\"15#图\",\"178\":\"15#回溯\",\"179\":\"15#分治\",\"180\":\"15#动态规划\",\"181\":\"16\",\"182\":\"16#判断奇数偶数\",\"183\":\"16#_0和1交替替换\",\"184\":\"16#消除二进制表示中最后一个1\",\"185\":\"17\",\"186\":\"17#lc-219\",\"187\":\"17#lc-643\",\"188\":\"17#lc-1876\",\"189\":\"17#lc-1984\",\"190\":\"17#lc-1658\",\"191\":\"17@1\",\"192\":\"18\",\"193\":\"18#lc-855\",\"194\":\"18#lc-1801\",\"195\":\"18@1\",\"196\":\"19\",\"197\":\"19#力扣-easy\",\"198\":\"19#lc-1646\",\"199\":\"19#lc-1137-第-n-个泰波那契数\",\"200\":\"19#lc-70-爬楼梯\",\"201\":\"19#lc-118-杨辉三角\",\"202\":\"19#lc-121-买卖股票的最佳时机\",\"203\":\"19#lc-338-比特位计数\",\"204\":\"19#lcp-07-传递信息\",\"205\":\"19#lc-1749-任意子数组和的绝对值的最大值\",\"206\":\"19#背包问题\",\"207\":\"19#_01背包\",\"208\":\"19#参考\",\"209\":\"19@1\",\"210\":\"20\",\"211\":\"21\",\"212\":\"21#java基础面试题\",\"213\":\"23\",\"214\":\"23#容器概述\",\"215\":\"23#list-set-queue-map-四者的区别\",\"216\":\"23#如何选用集合\",\"217\":\"23#为什么要使用集合\",\"218\":\"23#集合框架底层数据结构总结\",\"219\":\"23#list\",\"220\":\"23#set\",\"221\":\"23#queue\",\"222\":\"23#map\",\"223\":\"23@0\",\"224\":\"23@1\",\"225\":\"24\",\"226\":\"24#常用的实现类\",\"227\":\"24#有了数组为什么还需要list集合\",\"228\":\"24#数组array和集合arraylist的区别\",\"229\":\"24#arraylist-和-linkedlist-的区别\",\"230\":\"24#arrayslist-为什么实现randomaccess接口\",\"231\":\"24#arraydeque-与-linkedlist-的区别\",\"232\":\"24#arraylist-的扩容机制\",\"233\":\"24#arrays-aslist-方法的作用-注意事项\",\"234\":\"24#将数组转换为集合-list\",\"235\":\"24#将集合-list-转换为数组\",\"236\":\"24@0\",\"237\":\"24@1\",\"238\":\"25\",\"239\":\"25#hashmap-和-hashtable-的区别\",\"240\":\"25#hashmap-和-hashset-区别\",\"241\":\"25#hashmap-和-treemap-区别\",\"242\":\"25#hashset-如何检查重复\",\"243\":\"25#hashmap-的底层实现\",\"244\":\"25#jdk1-8-之前\",\"245\":\"25#jdk1-8-之后\",\"246\":\"25#hashmap-的长度为什么是-2-的幂次方\",\"247\":\"25#hashmap-多线程操作导致死循环问题\",\"248\":\"25#hashmap-有哪几种常见的遍历方式\",\"249\":\"25#concurrenthashmap-和-hashtable-的区别\",\"250\":\"25#concurrenthashmap-线程安全的具体实现方式-底层具体实现\",\"251\":\"25#jdk1-7-上面有示意图\",\"252\":\"25#jdk1-8-上面有示意图\",\"253\":\"25#求大于等于指定数的最小的二次幂\",\"254\":\"25@0\",\"255\":\"25@1\",\"256\":\"26\",\"257\":\"26#排序操作\",\"258\":\"26#查找-替换操作\",\"259\":\"26#同步控制\",\"260\":\"26@0\",\"261\":\"26@1\",\"262\":\"28\",\"263\":\"29\",\"264\":\"29#什么是进程-线程\",\"265\":\"29#线程唤醒的方法\",\"266\":\"29#说下java线程的生命周期\",\"267\":\"29#上下文切换是什么\",\"268\":\"29#说说并发与并行的区别\",\"269\":\"29#什么是死锁-产生死锁的条件\",\"270\":\"29#开发中如何避免死锁呢\",\"271\":\"29#可重入锁\",\"272\":\"29#locksupport\",\"273\":\"29#sleep和wait的区别\",\"274\":\"29#使用线程池的好处\",\"275\":\"29#线程池的基本参数-线程池的拒绝策略\",\"276\":\"29#stringbuffer跟stringbuilder哪个线程安全-是怎么实现的\",\"277\":\"29#线程池从建立开始的任务调度机制-举例说明线程池调优\",\"278\":\"29#synchronize原理-偏向锁、自旋锁、轻量级锁、重量级锁都是啥\",\"279\":\"29#锁膨胀、锁降级\",\"280\":\"29#threadlocal使用会有什么问题\",\"281\":\"29#synchronize跟volatile的区别\",\"282\":\"29#synchronzed原理-和lock的区别\",\"283\":\"29#synchronized与reentrantlock的异同、底层原理\",\"284\":\"29#两者都是可重入锁\",\"285\":\"29#synchronized-依赖于-jvm-而-reentrantlock-依赖于-api\",\"286\":\"29#reentrantlock-比-synchronized-增加了一些高级功能\",\"287\":\"29#wait-跟notify-是否可以脱离synchronize使用\",\"288\":\"29#wait-跟notify-为什么是对象的方法\",\"289\":\"29#以reentrantlock为例。说下aqs的原理\",\"290\":\"29#公平锁的实现原理\",\"291\":\"29#怎么使用线程池的-有哪些获取方法\",\"292\":\"29#juc包下熟悉哪些类-分别描述原理\",\"293\":\"29#惊群效应\",\"294\":\"29#分布式唯一主键生成方案\",\"295\":\"29#synchronized保证有序性\",\"296\":\"29#锁升级锁降级\",\"297\":\"29#线程执行顺序-semaphore-join\",\"298\":\"29#微信抢红包方案\",\"299\":\"31\",\"300\":\"31#介绍下-java-内存区域-运行时数据区\",\"301\":\"31#程序计数器\",\"302\":\"31#java虚拟机栈\",\"303\":\"31#本地方法栈\",\"304\":\"31#堆\",\"305\":\"31#方法区\",\"306\":\"31#为什么要将永久代替换为元空间\",\"307\":\"31#运行时常量池-方法区的一部分\",\"308\":\"31#直接内存\",\"309\":\"31#java-对象的创建过程\",\"310\":\"31#step1-类加载检查\",\"311\":\"31#step2-分配内存\",\"312\":\"31#step3-初始化零值\",\"313\":\"31#step4-设置对象头\",\"314\":\"31#step5-执行-init-方法\",\"315\":\"31#对象的访问定位的两种方式-句柄和直接指针两种方式\",\"316\":\"31#string-类和常量池\",\"317\":\"31#常量池\",\"318\":\"31#string-intern-方法的含义\",\"319\":\"31#string-s1-new-string-abc-创建了几个对象\",\"320\":\"31#对象已经死亡\",\"321\":\"31#引用计数法\",\"322\":\"31#可达性分析算法\",\"323\":\"31#对象可以被回收-就代表一定会被回收吗\",\"324\":\"31#_4种引用类型\",\"325\":\"31#强引用-strongreference\",\"326\":\"31#软引用-softreference\",\"327\":\"31#弱引用-weakreference\",\"328\":\"31#虚引用-phantomreference\",\"329\":\"31#如何判断一个类是无用的类\",\"330\":\"31#垃圾收集算法\",\"331\":\"31#类加载器\",\"332\":\"31#双亲委派模型\",\"333\":\"31#双亲委派模型的好处\",\"334\":\"31#重要的jvm参数\",\"335\":\"31#设置内存大小\",\"336\":\"31#设置新生代内存大小\",\"337\":\"31#设置新生代和老年代内存的比值\",\"338\":\"31#设置方法区-永久代-元空间-大小\",\"339\":\"31#设置要使用的垃圾回收器\",\"340\":\"31#jdk-命令行工具\",\"341\":\"31#jdk-可视化分析工具\",\"342\":\"32\",\"343\":\"32#jvm整体结构\",\"344\":\"32#jvm的生命周期\",\"345\":\"32#启动\",\"346\":\"32#执行\",\"347\":\"32#退出\",\"348\":\"32#jvm发展历程\",\"349\":\"32#sun-classic-vm\",\"350\":\"32#exact-vm\",\"351\":\"32#hotspot-vm\",\"352\":\"32#bea-的-jrockit\",\"353\":\"32#ibm-的-j9\",\"354\":\"33\",\"355\":\"33#_1-执行引擎概述\",\"356\":\"33#_1-1-执行引擎的工作过程\",\"357\":\"33#_2-java-代码编译和执行过程\",\"358\":\"33#_2-1-问题-什么是解释器-lnterpreter-什么是-jit-编译器\",\"359\":\"33#_2-2-问题-为什么说-java-是半编译半解释型语音\",\"360\":\"33#_3-解释器\",\"361\":\"33#_3-1-解释器工作机制-或工作任务\",\"362\":\"33#_3-2-解释器分类\",\"363\":\"33#_3-3-现状\",\"364\":\"33#_4-jit-编译器\",\"365\":\"33#_4-1-java-代码的执行分类\",\"366\":\"33#_4-2-hotspot-jvm-的执行方式\",\"367\":\"33#_4-3-jit-编译器细节\",\"368\":\"33#_4-4-如何选择\",\"369\":\"33#_4-4-1-方法调用计数器\",\"370\":\"33#_4-4-2-回边计数器\",\"371\":\"33#_4-5-hotspot-vm-可以设置程序执行方式\",\"372\":\"33#_4-6-hotspot-vm-中-jit分类\",\"373\":\"34\",\"374\":\"34#内存结构概述\",\"375\":\"34#类的加载过程\",\"376\":\"34#step1-加载-loading\",\"377\":\"34#过程\",\"378\":\"34#加载-class-文件的方式\",\"379\":\"34#step2-链接-linking\",\"380\":\"34#step3-初始化-initialization\",\"381\":\"34#类加载器分类\",\"382\":\"34#_1-启动类加载器-引导类加载器-bootstrap-classloader\",\"383\":\"34#_2-扩展类加载器-extension-classloader\",\"384\":\"34#_3-应用程序类加载器-系统类加载器-appclassloader\",\"385\":\"34#_4-用户自定义类加载器\",\"386\":\"34#为什么需要自定义类加载器\",\"387\":\"34#如何自定义类加载器\",\"388\":\"34#classloader-的使用说明\",\"389\":\"34#获取-classloader-的途径\",\"390\":\"34#双亲委派机制\",\"391\":\"34#工作原理\",\"392\":\"34#沙箱安全机制\",\"393\":\"34#优势\",\"394\":\"34#其他\",\"395\":\"34#_1-jvm判断2个class对象是否为同一个类的两个必要条件\",\"396\":\"34#_2-对类加载器的引用\",\"397\":\"34#_3-类的主动使用和被动使用\",\"398\":\"35\",\"399\":\"35#pc-register-介绍\",\"400\":\"35#两个常见问题\",\"401\":\"35#_1-使用pc寄存器存储字节码指令地址的作用\",\"402\":\"35#_2-pc寄存器为什么被设定为线程私有\",\"403\":\"36\",\"404\":\"36#虚拟机栈概述\",\"405\":\"36#出现背景\",\"406\":\"36#虚拟机栈基本内容\",\"407\":\"36#java虚拟机栈是什么\",\"408\":\"36#栈的特点\",\"409\":\"36#栈中可能出现的异常\",\"410\":\"36#设置栈内存大小\",\"411\":\"36#栈的存储单位\",\"412\":\"36#栈中存储什么\",\"413\":\"36#栈运行原理\",\"414\":\"36#栈帧的内部结构\",\"415\":\"36#局部变量表-local-variables\",\"416\":\"36#操作数栈-operand-stack\",\"417\":\"36#动态链接-或指向运行时常量池的方法引用\",\"418\":\"36#方法的调用\",\"419\":\"36#静态链接-动态链接\",\"420\":\"36#早期绑定-晚期绑定\",\"421\":\"36#虚方法-非虚方法\",\"422\":\"36#方法重写的本质\",\"423\":\"36#虚方法表\",\"424\":\"36#方法返回地址\",\"425\":\"36#一些附加信息\",\"426\":\"36#栈的相关面试题\",\"427\":\"36#_1-举例栈溢出的情况-stackoverflowerror\",\"428\":\"36#_2-调整栈大小-就能保证不出现溢出吗\",\"429\":\"36#_3-分配的栈内存越大越好吗\",\"430\":\"36#_4-垃圾回收是否会涉及到虚拟机栈\",\"431\":\"36#_5-方法中定义-使用的局部变量是否线程安全\",\"432\":\"37\",\"433\":\"37#本地方法接口\",\"434\":\"37#什么是本地方法\",\"435\":\"37#为什么要使用-native-method\",\"436\":\"37#现状\",\"437\":\"37#本地方法栈-native-method-stack\",\"438\":\"38\",\"439\":\"38#_1-栈、堆、方法区的交互关系\",\"440\":\"38#_2-方法区的理解\",\"441\":\"38#_2-1-主要信息\",\"442\":\"38#_2-2-方法区的基本理解\",\"443\":\"38#_2-3-hotspot-中方法区的演进\",\"444\":\"38#jdk7及以前\",\"445\":\"38#jdk8\",\"446\":\"38#_3-设置方法区大小与oom\",\"447\":\"38#_3-1-jdk7及以前\",\"448\":\"38#_3-2-jdk8及以后\",\"449\":\"38#_3-3-如何查看当前permsize的值\",\"450\":\"38#_3-4-如何解决这些oom\",\"451\":\"38#_4-方法区的内部结构\",\"452\":\"38#_4-1-类型信息\",\"453\":\"38#_4-2-域-field-信息\",\"454\":\"38#_4-3-方法-method-信息\",\"455\":\"38#_4-4-non-final的类信息\",\"456\":\"38#_4-5-运行时常量池-vs-常量池\",\"457\":\"38#为什么需要常量池\",\"458\":\"38#常量池中有什么\",\"459\":\"38#_4-6-运行时常量池\",\"460\":\"38#_5-方法区的演进细节\",\"461\":\"38#_5-1-演进细节\",\"462\":\"38#_5-2-永久代为什么要被元空间替代\",\"463\":\"38#_5-3-stringtable-字符串常量池-为什么要调整\",\"464\":\"38#_6-方法区的垃圾回收\",\"465\":\"38#_7-总结-面试题\",\"466\":\"39\",\"467\":\"39#_1-对象的实例化\",\"468\":\"39#_1-1-创建对象的方式\",\"469\":\"39#_1-2-创建对象的步骤\",\"470\":\"39#_1-判断对象对应的类是否加载、链接、初始化\",\"471\":\"39#_2-为对象分配内存\",\"472\":\"39#_3-初始化分配到的空间\",\"473\":\"39#_4-设置对象的对象头\",\"474\":\"39#_5-执行-init-方法进行初始化\",\"475\":\"39#_2-对象的内存布局\",\"476\":\"39#_2-1-对象头-header\",\"477\":\"39#_2-2-实例数据-instance-data\",\"478\":\"39#_2-3-对齐填充-padding\",\"479\":\"39#_3-对象的访问定位\",\"480\":\"40\",\"481\":\"40#堆的核心概念\",\"482\":\"40#堆的核心概述\",\"483\":\"40#内存细分\",\"484\":\"40#设置堆内存大小与oom\",\"485\":\"40#设置\",\"486\":\"40#默认\",\"487\":\"40#如何查看设置的参数\",\"488\":\"40#年轻代与老年代\",\"489\":\"40#对象分配过程\",\"490\":\"40#概述\",\"491\":\"40#特殊情况\",\"492\":\"40#常用调优工具\",\"493\":\"40#minor-gc、major-gc、full-gc\",\"494\":\"40#_1-年轻代gc-minor-gc-触发机制\",\"495\":\"40#_2-老年代gc-major-gc-full-gc-触发机制\",\"496\":\"40#_3-full-gc-触发机制\",\"497\":\"40#堆空间分代思想\",\"498\":\"40#内存分配策略\",\"499\":\"40#为对象分配内存-tlab\",\"500\":\"40#什么是tlab\",\"501\":\"40#为什么有tlab-thread-local-allocation-buffer\",\"502\":\"40#tlab的其他说明\",\"503\":\"40#小结-堆空间的参数设置\",\"504\":\"40#handlepromotionfailure-参数说明\",\"505\":\"40#堆是分配对象的唯一选择吗\",\"506\":\"40#逃逸分析概述\",\"507\":\"40#逃逸分析-代码优化\",\"508\":\"40#_1-栈上分配\",\"509\":\"40#_2-同步省略-消除\",\"510\":\"40#_3-标量替换\",\"511\":\"40#逃逸分析-并不成熟\",\"512\":\"40#小结\",\"513\":\"40#参考链接-其他工具\",\"514\":\"41\",\"515\":\"41#_1-什么是垃圾\",\"516\":\"41#_2-为什么需要gc\",\"517\":\"41#_3-java-垃圾回收机制\",\"518\":\"41#_4-大厂面试题\",\"519\":\"41#_5-在java语言中-gc-roots包括哪些元素\",\"520\":\"41#_6-常见的垃圾收集算法\",\"521\":\"41#_6-1-标记-清除算法-mark-sweep\",\"522\":\"41#_6-2-复制算法-copying-『用于新生代』\",\"523\":\"41#_6-3-标记-压缩算法-mark-compact-『用于老年代』\",\"524\":\"41#_6-4-对比三种算法\",\"525\":\"41#_6-5-分代收集算法\",\"526\":\"41#_6-6-增量收集算法\",\"527\":\"41#_6-7-分区算法\",\"528\":\"41#_6-8-写到最后\",\"529\":\"41#_7-垃圾收集器\",\"530\":\"41#serial-串行收集器\",\"531\":\"41#parnew-收集器\",\"532\":\"41#parallel-scavenge-收集器-jdk1-8-默认的收集器\",\"533\":\"41#serial-old-收集器\",\"534\":\"41#cms-收集器-并发标记清除-不推荐\",\"535\":\"41#g1-收集器\",\"536\":\"41#zgc-收集器\",\"537\":\"41#jvm默认使用的收集器\",\"538\":\"41#shenandoah\",\"539\":\"41#收集器之间的搭配关系\",\"540\":\"41#_8-其他\",\"541\":\"42\",\"542\":\"43\",\"543\":\"44\",\"544\":\"44#流简介\",\"545\":\"44#流操作\",\"546\":\"44#流操作分类\",\"547\":\"44#使用流\",\"548\":\"44#筛选和切片\",\"549\":\"44#映射\",\"550\":\"44#查找和匹配\",\"551\":\"44#规约\",\"552\":\"44#数值流\",\"553\":\"44#构建流\",\"554\":\"45\",\"555\":\"45#前言\",\"556\":\"45#java8-常用日期类概述\",\"557\":\"45#instant类\",\"558\":\"45#duration类\",\"559\":\"45#period类\",\"560\":\"45#localdate类\",\"561\":\"45#localtime类\",\"562\":\"45#localdatetime类\",\"563\":\"45#year\",\"564\":\"45#yearmonth\",\"565\":\"45#monthday\",\"566\":\"45#month\",\"567\":\"45#其他相关类-接口\",\"568\":\"45#时间单位\",\"569\":\"45#temporaladjuster-调节器\",\"570\":\"45#其他\",\"571\":\"45#date转换为localdate\",\"572\":\"45#线程安全的日期解析与格式化工具\",\"573\":\"45#datetimeformatter\",\"574\":\"45#其他工具类\",\"575\":\"46\",\"576\":\"48\",\"577\":\"48#docker-ps-options\",\"578\":\"49\",\"579\":\"49#var-lib-docker-overlay2占用过大\",\"580\":\"51\",\"581\":\"51#常用操作\",\"582\":\"51#合并某个或某些提交到其他分支\",\"583\":\"51#方法1-使用-sourcetree【常用】\",\"584\":\"51#方法2-使用git命令\",\"585\":\"51#已提交的内容进行修改\",\"586\":\"51#常见问题\",\"587\":\"51#errno-10054\",\"588\":\"51#errno-443\",\"589\":\"53\",\"590\":\"53#参考内容\",\"591\":\"53#什么是spring框架-谈谈你对spring的理解\",\"592\":\"53#spring跟springmvc的区别\",\"593\":\"53#spring流程\",\"594\":\"53#什么是ioc-什么是aop\",\"595\":\"53#ioc\",\"596\":\"53#aop\",\"597\":\"53#ioc注入的方式\",\"598\":\"53#请解释-spring-bean-的自动装配\",\"599\":\"53#如何开启基于注解的自动装配-说一下这些注解\",\"600\":\"53#构造方法注入和设值注入有什么区别\",\"601\":\"53#使用-autowired注解自动装配的过程是怎样的\",\"602\":\"53#spring-aop和aspectj-aop有什么区别\",\"603\":\"53#spring-aop的实现原理\",\"604\":\"53#aop的常用术语及其含义\",\"605\":\"53#项目中如何进行aop配置\",\"606\":\"53#jdk动态代理和cglib代理有什么区别\",\"607\":\"53#动态代理跟静态代理的区别\",\"608\":\"53#反射的实现原理\",\"609\":\"53#spring自动注入类型\",\"610\":\"53#beanfactory和factorybean的区别\",\"611\":\"53#beanfactory和applicationcontext有什么区别\",\"612\":\"53#bean是什么\",\"613\":\"53#bean的加载过程\",\"614\":\"53#bean的生命周期\",\"615\":\"53#bean的作用范围\",\"616\":\"53#spring的单例实现原理\",\"617\":\"53#component-和-bean-的区别是什么\",\"618\":\"53#将一个类声明为-bean-的注解有哪些\",\"619\":\"53#bean-标签中可以定义哪些属性\",\"620\":\"53#不同作用域的bean相互依赖-有什么问题-如何处理\",\"621\":\"53#bean循环依赖问题-如何解决\",\"622\":\"53#为什么要三级缓存-二级不行吗\",\"623\":\"53#spring用到了哪些设计模式\",\"624\":\"53#第一种-简单工厂\",\"625\":\"53#第二种-工厂方法-factory-method\",\"626\":\"53#第三种-单例模式-singleton\",\"627\":\"53#第四种-适配器-adapter\",\"628\":\"53#第五种-包装器-decorator\",\"629\":\"53#第六种-代理-proxy\",\"630\":\"53#第七种-观察者-observer\",\"631\":\"53#第八种-策略-strategy\",\"632\":\"53#第九种-模板方法-template-method\",\"633\":\"53#spring事务的实现方式有几种\",\"634\":\"53#spring事务中的隔离级别有哪几种\",\"635\":\"53#spring事务的传播行为\",\"636\":\"53#spring事务失效的场景\",\"637\":\"53#transactional-rollbackfor-exception-class注解了解吗\",\"638\":\"53#spring框架中的单例beans是线程安全的么\",\"639\":\"53#spring应用销毁是在哪里\",\"640\":\"53#spring有哪些重要的扩展点\",\"641\":\"55\",\"642\":\"55#spring-mvc-运行流程\",\"643\":\"55#说说对spring-mvc的理解\",\"644\":\"55#springmvc的优点\",\"645\":\"55#什么是mvc模式\",\"646\":\"55#spring-mvc的主要组件\",\"647\":\"55#servlet原理\",\"648\":\"55#过滤器跟拦截器的区别\",\"649\":\"55#springmvc-中如何解决-get-post请求中文乱码问题\",\"650\":\"55#springmvc-如何做异常处理\",\"651\":\"55#springmvc-常用注解都有哪些\",\"652\":\"55#如何开启注解处理器和适配器\",\"653\":\"55#springmvc-的控制器是不是单例模式-如果是-有什么问题-怎么解决\",\"654\":\"55#springmvc-和struts2的区别有哪些\",\"655\":\"55#springmvc-中对于文件的上传有哪些需要注意\",\"656\":\"55#springmvc-中拦截器如何使用\",\"657\":\"56\",\"658\":\"56#springmvc\",\"659\":\"57\",\"660\":\"57#教程\",\"661\":\"57#文章\",\"662\":\"57#相关工具\",\"663\":\"58\",\"664\":\"58#什么是spring-boot-它主要有哪些优点\",\"665\":\"58#为什么要用spring-boot\",\"666\":\"58#spring-boot跟spring-cloud的区别\",\"667\":\"58#spring-boot与spring-mvc的区别\",\"668\":\"58#springboot如何修改端口号\",\"669\":\"58#springboot热部署的方式\",\"670\":\"58#方式一-spring-boot-devtools\",\"671\":\"58#方式二-spring-loaded\",\"672\":\"58#方式三-jrebel\",\"673\":\"58#spring-boot-中如何解决跨域问题\",\"674\":\"58#spring-boot的自动配置是如何实现的\",\"675\":\"58#conditional相关的注解\",\"676\":\"58#springboot-中怎么禁用某些自动配置特性\",\"677\":\"58#springboot的加载流程\",\"678\":\"58#springboot运行原理\",\"679\":\"58#spring-boot容器替换\",\"680\":\"58#spring-boot集成mybatis\",\"681\":\"58#springboot读取配置相关注解有\",\"682\":\"58#starters是什么\",\"683\":\"58#spring-boot的starter的执行原理\",\"684\":\"58#spring-boot自己实现starter\",\"685\":\"58#spring-boot-starter-parent-有什么用\",\"686\":\"58#spring-boot-打成的-jar-和普通的-jar-有什么区别\",\"687\":\"58#如何在-spring-boot-启动的时候运行一些特定的代码\",\"688\":\"59\",\"689\":\"59#springboot\",\"690\":\"60\",\"691\":\"60#rabbitmq的概念\",\"692\":\"60#四大核心概念\",\"693\":\"60#各个名词介绍\",\"694\":\"61\",\"695\":\"61#hello-rabbitmq\",\"696\":\"61#添加依赖\",\"697\":\"61#消息生产者\",\"698\":\"61#消息消费者\",\"699\":\"61#work-queues\",\"700\":\"61#轮询消费\",\"701\":\"61#轮询案例\",\"702\":\"61#web页面添加队列\",\"703\":\"62\",\"704\":\"62#消息应答\",\"705\":\"62#自动应答\",\"706\":\"62#手动消息应答的方法\",\"707\":\"62#消息自动重新入队\",\"708\":\"62#手动应答案例\",\"709\":\"62#效果演示\",\"710\":\"62#rabbitmq持久化\",\"711\":\"62#队列持久化\",\"712\":\"62#消息持久化\",\"713\":\"62#不公平分发\",\"714\":\"62#介绍\",\"715\":\"62#效果演示-1\",\"716\":\"62#预取值分发\",\"717\":\"62#介绍-1\",\"718\":\"62#效果演示-2\",\"719\":\"62#发布确认\",\"720\":\"62#发布确认逻辑\",\"721\":\"62#发布确认的策略\",\"722\":\"62#单个确认发布\",\"723\":\"62#批量确认发布\",\"724\":\"62#异步确认发布\",\"725\":\"62#应答和发布区别\",\"726\":\"63\",\"727\":\"63#exchanges\",\"728\":\"63#exchanges的类型\",\"729\":\"63#默认exchange\",\"730\":\"63#临时队列\",\"731\":\"63#绑定bindings\",\"732\":\"63#fanout-exchange\",\"733\":\"63#fanout介绍\",\"734\":\"63#fanout实战\",\"735\":\"63#direct-exchange\",\"736\":\"63#direct介绍\",\"737\":\"63#多重绑定\",\"738\":\"63#direct实战\",\"739\":\"63#topics-exchange\",\"740\":\"63#topic的介绍\",\"741\":\"63#topic匹配案例\",\"742\":\"63#topic实战\",\"743\":\"64\",\"744\":\"64#死信的概念\",\"745\":\"64#死信的来源\",\"746\":\"64#死信实战\",\"747\":\"64#消息ttl过期\",\"748\":\"64#死信最大长度\",\"749\":\"64#死信消息被拒\",\"750\":\"65\",\"751\":\"65#延迟队列介绍\",\"752\":\"65#ttl的两种设置\",\"753\":\"65#整合springboot\",\"754\":\"65#队列ttl\",\"755\":\"65#延时队列ttl优化\",\"756\":\"65#rabbitmq插件实现延迟队列\",\"757\":\"65#插件实战\",\"758\":\"65#总结\",\"759\":\"66\",\"760\":\"66#发布确认springboot版本\",\"761\":\"66#介绍\",\"762\":\"66#实战\",\"763\":\"66#回退消息\",\"764\":\"66#介绍-1\",\"765\":\"66#实战-1\",\"766\":\"66#备份交换机\",\"767\":\"66#介绍-2\",\"768\":\"66#实战-2\",\"769\":\"67\",\"770\":\"67#幂等性\",\"771\":\"67#概念\",\"772\":\"67#消息重复消费\",\"773\":\"67#解决思路\",\"774\":\"67#消费端的幂等性保障\",\"775\":\"67#优先级队列\",\"776\":\"67#使用场景\",\"777\":\"67#添加方法\",\"778\":\"67#实战\",\"779\":\"67#非springboot\",\"780\":\"67#整合springboot\",\"781\":\"67#惰性队列\",\"782\":\"67#使用场景-1\",\"783\":\"67#两种模式\",\"784\":\"67#内存开销对比\",\"785\":\"68\",\"786\":\"68#rabbitmq\",\"787\":\"69\",\"788\":\"69#websecurityconfigureradapter\",\"789\":\"69#requestmappinghandlermapping\",\"790\":\"69#自定义接口\",\"791\":\"69#anonymousaccess\",\"792\":\"69#anonymousgetmapping\",\"793\":\"70\",\"794\":\"70#springsecurity\",\"795\":\"71\",\"796\":\"72\",\"797\":\"72#cap理论\",\"798\":\"72#dubbo跟springcloud的区别\",\"799\":\"72#fegin调用service的时候是怎么样做到集成的负载均衡和熔断呢-自定义负载均衡\",\"800\":\"72#eureka跟zookeeper的区别\",\"801\":\"72#eureka的服务发现机制有啥缺点\",\"802\":\"72#参考文章\",\"803\":\"73\",\"804\":\"73#springboot\",\"805\":\"74\",\"806\":\"74#什么是mybatis\",\"807\":\"74#mybaits的优缺点\",\"808\":\"74#mybatis是如何将sql执行结果封装为目标对象并返回的-都有哪些映射形式\",\"809\":\"74#使用mybatis的mapper接口调用时有哪些要求\",\"810\":\"74#和-的区别是什么\",\"811\":\"74#xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签\",\"812\":\"74#mybatis-动态-sql-是做什么的-都有哪些动态-sql-动态-sql-的执行原理\",\"813\":\"74#mybatis的一级、二级缓存\",\"814\":\"74#模糊查询like语句该怎么写\",\"815\":\"74#如何获取自动生成的-主-键值\",\"816\":\"74#dao接口的工作原理\",\"817\":\"74#mybatis-是如何进行分页的-分页插件的原理是什么\",\"818\":\"74#简述-mybatis-的插件运行原理-以及如何编写一个插件。\",\"819\":\"74#在mapper中如何传递多个参数\",\"820\":\"74#一对一、一对多的关联查询\",\"821\":\"74#mybatis-是否支持延迟加载-如果支持-它的实现原理是什么\",\"822\":\"74#mybatis-的-xml-映射文件和-mybatis-内部数据结构之间的映射关系\",\"823\":\"74#为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里\",\"824\":\"74#参考\",\"825\":\"75\",\"826\":\"75#简介\",\"827\":\"75#特性\",\"828\":\"75#框架结构\",\"829\":\"75#使用配置\",\"830\":\"75#引入\",\"831\":\"75#配置数据源和日志\",\"832\":\"75#basemapper-t-接口\",\"833\":\"75#通用service\",\"834\":\"75#常用注解\",\"835\":\"75#table\",\"836\":\"75#tableid\",\"837\":\"75#tablefield\",\"838\":\"75#tablelogic\",\"839\":\"75#逻辑删除\",\"840\":\"75#实现逻辑删除\",\"841\":\"75#条件构造器和常用接口\",\"842\":\"75#wrapper介绍\",\"843\":\"75#querywrapper\",\"844\":\"75#组装查询条件\",\"845\":\"75#组装排序条件\",\"846\":\"75#组装删除条件\",\"847\":\"75#组装修改条件\",\"848\":\"75#修改更新的优先级\",\"849\":\"75#组装select子句\",\"850\":\"75#子查询\",\"851\":\"75#updatewrapper\",\"852\":\"75#condition\",\"853\":\"75#lambdaquerywrapper\",\"854\":\"75#lambdaupdatewrapper\",\"855\":\"75#插件\",\"856\":\"75#分页插件\",\"857\":\"75#添加配置类\",\"858\":\"75#测试\",\"859\":\"75#xml自定义分页\",\"860\":\"75#乐观锁\",\"861\":\"75#动态表名sql解析器\",\"862\":\"75#代码生成器\",\"863\":\"75#引入依赖\",\"864\":\"75#快速生成\",\"865\":\"75#多数据源\",\"866\":\"75#配置\",\"867\":\"75#mybatisx插件\",\"868\":\"76\",\"869\":\"76#mybatis\",\"870\":\"77\",\"871\":\"77#rpc\",\"872\":\"77#为什么要有rpc\",\"873\":\"77#什么是rpc\",\"874\":\"77#prc架构组件\",\"875\":\"77#rpc和soa、soap、rest的区别\",\"876\":\"77#rpc框架需要解决的问题\",\"877\":\"77#rpc的实现基础\",\"878\":\"77#rpc使用了哪些关键技术\",\"879\":\"77#主流rpc框架有哪些\",\"880\":\"77#dubbo\",\"881\":\"77#为什么要用dubbo\",\"882\":\"77#dubbo架构\",\"883\":\"77#dubbo分层架构\",\"884\":\"77#dubbo的使用场景有哪些\",\"885\":\"77#dubbo核心功能有哪些\",\"886\":\"77#dubbo和spring-cloud有什么关系\",\"887\":\"77#dubbo和spring-cloud有什么哪些区别\",\"888\":\"77#dubbo支持哪些协议-它们的优缺点有哪些\",\"889\":\"77#服务暴露的流程\",\"890\":\"77#服务引入的流程\",\"891\":\"77#服务调用的流程\",\"892\":\"77#知道什么是-spi-嘛\",\"893\":\"77#为什么-dubbo-不用-jdk-的-spi-而是要自己实现\",\"894\":\"77#dubbo-为什么默认用-javassist\",\"895\":\"77#🔴dubbo-异步转同步如何实现的\",\"896\":\"77#服务调用是阻塞的吗\",\"897\":\"77#dubbo有哪些注册中心\",\"898\":\"77#默认使用什么序列化框架-你知道的还有哪些\",\"899\":\"77#服务提供者能实现失效踢出是什么原理\",\"900\":\"77#服务上线怎么不影响旧版本\",\"901\":\"77#dubbo服务降级怎么做\",\"902\":\"77#dubbo-monitor实现原理\",\"903\":\"77#dubbo用到哪些设计模式\",\"904\":\"77#工厂模式\",\"905\":\"77#装饰器模式\",\"906\":\"77#观察者模式\",\"907\":\"77#动态代理模式\",\"908\":\"77#dubbo配置文件是如何加载到spring中的\",\"909\":\"77#dubbo-spi和java-spi区别\",\"910\":\"77#dubbo支持分布式事务吗\",\"911\":\"77#dubbo可以对结果进行缓存吗\",\"912\":\"77#dubbo-telnet命令能做什么\",\"913\":\"77#dubbo如何优雅停机\",\"914\":\"77#dubbo和dubbox之间的区别\",\"915\":\"77#dubbo的注册中心集群挂掉-发布者和订阅者之间还能通信么\",\"916\":\"77#dubbo集群提供了哪些负载均衡策略\",\"917\":\"77#dubbo的集群容错方案有哪些\",\"918\":\"77#dubbo超时设置有哪些方式\",\"919\":\"77#如果让你设计一个-rpc-框架-如何设计\",\"920\":\"77#dubbo使用过程中都遇到了些什么问题\",\"921\":\"77#参考\",\"922\":\"78\",\"923\":\"78#dubbo\",\"924\":\"79\",\"925\":\"79#📋-代码1-动态规划\",\"926\":\"79#💡-思路1-动态规划\",\"927\":\"79#💡-思路2-二分查找\",\"928\":\"80\",\"929\":\"80#💬-描述\",\"930\":\"80#💡-思路\",\"931\":\"80#📋-代码\",\"932\":\"81\",\"933\":\"81#💬-描述\",\"934\":\"81#📋-代码\",\"935\":\"81#💡-思路\",\"936\":\"82\",\"937\":\"82#💬-描述\",\"938\":\"82#📋-代码1-先排序后遍历\",\"939\":\"82#📋-代码2-先计数后遍历\",\"940\":\"82#💡-思路\",\"941\":\"83\",\"942\":\"83#🔗-链接\",\"943\":\"83#📋-代码1-dfs\",\"944\":\"83#📋-代码2-bfs\",\"945\":\"83#📋-代码3-dp\",\"946\":\"84\",\"947\":\"84#🔗-链接\",\"948\":\"84#📋-代码1-hash表\",\"949\":\"84#📋-代码2-状态压缩\",\"950\":\"85\",\"951\":\"85#算法-数组\",\"952\":\"86\",\"953\":\"86#💬-描述\",\"954\":\"86#📋-代码\",\"955\":\"86#💡-思路\",\"956\":\"86@1\",\"957\":\"87\",\"958\":\"87@1\",\"959\":\"88\",\"960\":\"88#算法-字符串\",\"961\":\"89\",\"962\":\"89#🔗-链接\",\"963\":\"89#📋-代码1\",\"964\":\"89#💡-思路\",\"965\":\"89#📋-代码2\",\"966\":\"90\",\"967\":\"90#💬-描述\",\"968\":\"90#📋-代码1-迭代\",\"969\":\"90#📋-代码2-递归\",\"970\":\"90#💡-思路\",\"971\":\"91\",\"972\":\"91#🔗-链接\",\"973\":\"91#📋-代码\",\"974\":\"91#💡-思路\",\"975\":\"91#🎃-缺点\",\"976\":\"92\",\"977\":\"92#算法-链表\",\"978\":\"93\",\"979\":\"93#算法-树\",\"980\":\"94\",\"981\":\"94#💬-描述\",\"982\":\"94#📋-代码1-bfs1-考虑每个水壶\",\"983\":\"94#📋-代码2-bfs2-只考虑水的总量-不关心它在哪个水壶\",\"984\":\"94#📋-代码3-最大公约数-执行最快\",\"985\":\"94#💡-思路\",\"986\":\"95\",\"987\":\"95#算法-其他类型\",\"988\":\"96\",\"989\":\"96#joiner\",\"990\":\"96#join-方法\",\"991\":\"96#appendto-方法\",\"992\":\"96#用javase-api实现join\",\"993\":\"96#join-map\",\"994\":\"96#其他\",\"995\":\"96#splitter\",\"996\":\"96#split-方法\",\"997\":\"96#preconditions-断言\",\"998\":\"96#基本用法\",\"999\":\"96@0\",\"1000\":\"96@1\",\"1001\":\"97\",\"1002\":\"98\",\"1003\":\"98#前置准备\",\"1004\":\"98#下载源码\",\"1005\":\"98#下载gradle构建工具\",\"1006\":\"98#修改distributionurl\",\"1007\":\"98#配置环境变量及仓库地址\",\"1008\":\"98#配置阿里云镜像\",\"1009\":\"98#修改spring源码内gradle的镜像地址\",\"1010\":\"98#编译compiletestjava模块\",\"1011\":\"98#导入项目到idea\",\"1012\":\"98#测试\",\"1013\":\"99\",\"1014\":\"99#spring源码解析\",\"1015\":\"100\",\"1016\":\"100#官方文档\",\"1017\":\"101\",\"1018\":\"101#💬-描述\",\"1019\":\"101#💡-思路\",\"1020\":\"101#📋-代码\",\"1021\":\"102\",\"1022\":\"102#📋-代码\",\"1023\":\"102#💡-思路\",\"1024\":\"103\",\"1025\":\"104\",\"1026\":\"104#n叉树-简单类型\",\"1027\":\"105\",\"1028\":\"105#💬-描述\",\"1029\":\"105#📋-代码1-递归\",\"1030\":\"105#📋-代码2-中序遍历\",\"1031\":\"105#💡-思路\",\"1032\":\"106\",\"1033\":\"106#💬-描述\",\"1034\":\"106#📋-代码1-dfs\",\"1035\":\"106#📋-代码2-bfs\",\"1036\":\"106#💡-思路\",\"1037\":\"107\",\"1038\":\"107#💬-描述\",\"1039\":\"107#💡-思路\",\"1040\":\"107#📋-代码\",\"1041\":\"108\",\"1042\":\"108#n叉树-中等难度类型\",\"1043\":\"109\",\"1044\":\"109#n叉树-hard类型\",\"1045\":\"110\",\"1046\":\"111\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,4],\"1\":[2,38],\"2\":[1],\"3\":[1,2],\"4\":[1,8],\"5\":[3],\"6\":[2,104],\"7\":[4,11],\"8\":[3,7],\"9\":[2],\"10\":[3,13],\"11\":[2,32],\"12\":[4,9],\"13\":[4,2],\"14\":[2,15],\"15\":[3,19],\"16\":[3,12],\"17\":[2,6],\"18\":[3,14],\"19\":[3,17],\"20\":[7],\"21\":[4,16],\"22\":[2,20],\"23\":[2,3],\"24\":[null,null,1],\"25\":[null,null,2],\"26\":[1],\"27\":[1,6],\"28\":[1,11],\"29\":[null,null,1],\"30\":[null,null,2],\"31\":[1],\"32\":[1,9],\"33\":[null,null,1],\"34\":[null,null,1],\"35\":[1,16],\"36\":[1],\"37\":[1,8],\"38\":[1,22],\"39\":[1,5],\"40\":[1,3],\"41\":[1,20],\"42\":[1,39],\"43\":[2,14],\"44\":[2,16],\"45\":[2,37],\"46\":[2,26],\"47\":[2,28],\"48\":[2,26],\"49\":[1,11],\"50\":[null,null,1],\"51\":[null,null,1],\"52\":[1,3],\"53\":[1,7],\"54\":[1,1],\"55\":[1,15],\"56\":[null,null,1],\"57\":[null,null,1],\"58\":[1],\"59\":[2,10],\"60\":[2,9],\"61\":[3,65],\"62\":[2,14],\"63\":[3,6],\"64\":[2],\"65\":[3,44],\"66\":[3],\"67\":[4,12],\"68\":[3,9],\"69\":[3,14],\"70\":[5,60],\"71\":[2,5],\"72\":[4,19],\"73\":[3,8],\"74\":[3,9],\"75\":[3,6],\"76\":[2,4],\"77\":[3,52],\"78\":[2,70],\"79\":[2],\"80\":[3,51],\"81\":[3,22],\"82\":[3,21],\"83\":[5,33],\"84\":[2],\"85\":[4,90],\"86\":[4],\"87\":[5,53],\"88\":[4,41],\"89\":[3,19],\"90\":[3,22],\"91\":[3,20],\"92\":[2,2],\"93\":[2],\"94\":[3,55],\"95\":[3,10],\"96\":[2],\"97\":[3,16],\"98\":[3,19],\"99\":[3,136],\"100\":[3],\"101\":[5,42],\"102\":[5],\"103\":[5,62],\"104\":[6,22],\"105\":[4,21],\"106\":[6,138],\"107\":[null,null,1],\"108\":[null,null,1],\"109\":[1,2],\"110\":[1,29],\"111\":[2,8],\"112\":[2,3],\"113\":[2,9],\"114\":[2,28],\"115\":[null,null,1],\"116\":[null,null,2],\"117\":[1,4],\"118\":[1,13],\"119\":[1,22],\"120\":[1,27],\"121\":[1,2],\"122\":[1,9],\"123\":[1,5],\"124\":[1,6],\"125\":[1,4],\"126\":[1,14],\"127\":[1,13],\"128\":[1,5],\"129\":[1,9],\"130\":[1,4],\"131\":[1,15],\"132\":[1,29],\"133\":[1,7],\"134\":[1,29],\"135\":[1,7],\"136\":[1,2],\"137\":[1,6],\"138\":[1,3],\"139\":[1,109],\"140\":[1,28],\"141\":[1,2],\"142\":[1,22],\"143\":[1,66],\"144\":[1,13],\"145\":[1,6],\"146\":[1,13],\"147\":[1,9],\"148\":[1,43],\"149\":[1,3],\"150\":[1,4],\"151\":[1,2],\"152\":[1,2],\"153\":[null,null,1],\"154\":[null,null,1],\"155\":[1,4],\"156\":[3,6],\"157\":[2,6],\"158\":[1,8],\"159\":[1,16],\"160\":[1,13],\"161\":[1,2],\"162\":[null,null,1],\"163\":[null,null,1],\"164\":[1,1],\"165\":[1,4],\"166\":[1,5],\"167\":[1,8],\"168\":[1,5],\"169\":[1,4],\"170\":[1,9],\"171\":[1,9],\"172\":[1,4],\"173\":[1,3],\"174\":[1,4],\"175\":[1,10],\"176\":[1,8],\"177\":[1,12],\"178\":[1,4],\"179\":[1,2],\"180\":[1,7],\"181\":[1,4],\"182\":[1,6],\"183\":[1,12],\"184\":[1,51],\"185\":[1,6],\"186\":[1,45],\"187\":[1,33],\"188\":[1,26],\"189\":[1,35],\"190\":[1,35],\"191\":[null,null,2],\"192\":[1,4],\"193\":[1,1],\"194\":[1,92],\"195\":[null,null,1],\"196\":[1,4],\"197\":[2],\"198\":[1,42],\"199\":[1,25],\"200\":[1,45],\"201\":[1,48],\"202\":[1,39],\"203\":[1,38],\"204\":[1,42],\"205\":[1,42],\"206\":[1,17],\"207\":[1,119],\"208\":[1,2],\"209\":[null,null,1],\"210\":[1,3],\"211\":[1],\"212\":[1,1],\"213\":[1,4],\"214\":[1,22],\"215\":[6,13],\"216\":[2,26],\"217\":[2,24],\"218\":[1],\"219\":[1,12],\"220\":[1,22],\"221\":[1,7],\"222\":[1,38],\"223\":[null,null,2],\"224\":[null,null,1],\"225\":[1,11],\"226\":[1,14],\"227\":[2,11],\"228\":[1,22],\"229\":[5,90],\"230\":[4,89],\"231\":[4,39],\"232\":[2,4],\"233\":[5,45],\"234\":[3,54],\"235\":[4,41],\"236\":[null,null,2],\"237\":[null,null,1],\"238\":[1,4],\"239\":[4,132],\"240\":[4,39],\"241\":[4,82],\"242\":[2,118],\"243\":[2],\"244\":[3,102],\"245\":[3,23],\"246\":[4,53],\"247\":[2,21],\"248\":[3,5],\"249\":[4,100],\"250\":[3],\"251\":[4,40],\"252\":[4,31],\"253\":[2,70],\"254\":[null,null,2],\"255\":[null,null,1],\"256\":[1,11],\"257\":[1,26],\"258\":[2,40],\"259\":[1,43],\"260\":[null,null,2],\"261\":[null,null,1],\"262\":[1,10],\"263\":[1],\"264\":[3,11],\"265\":[2,7],\"266\":[2,9],\"267\":[2,35],\"268\":[2,8],\"269\":[3,17],\"270\":[2,13],\"271\":[2,14],\"272\":[2],\"273\":[2,67],\"274\":[2,12],\"275\":[3,73],\"276\":[3,7],\"277\":[3,50],\"278\":[6,172],\"279\":[3,20],\"280\":[2,53],\"281\":[2,15],\"282\":[3,23],\"283\":[3],\"284\":[1,14],\"285\":[6,30],\"286\":[4,61],\"287\":[4],\"288\":[4,42],\"289\":[3,33],\"290\":[2,28],\"291\":[2,45],\"292\":[2,68],\"293\":[2,13],\"294\":[2],\"295\":[2],\"296\":[1],\"297\":[3],\"298\":[2,3],\"299\":[1],\"300\":[5,17],\"301\":[1,23],\"302\":[1,33],\"303\":[1,30],\"304\":[1,43],\"305\":[1,60],\"306\":[2,13],\"307\":[3,31],\"308\":[1,39],\"309\":[2,1],\"310\":[1,9],\"311\":[2,16],\"312\":[2,8],\"313\":[2,14],\"314\":[4,19],\"315\":[3,27],\"316\":[2],\"317\":[1,99],\"318\":[4,58],\"319\":[7,48],\"320\":[2],\"321\":[1,17],\"322\":[1,21],\"323\":[3,20],\"324\":[1,11],\"325\":[3,13],\"326\":[3,16],\"327\":[3,18],\"328\":[3,31],\"329\":[1,20],\"330\":[1,2],\"331\":[1,40],\"332\":[1,51],\"333\":[1,22],\"334\":[1],\"335\":[1,21],\"336\":[1,18],\"337\":[1,8],\"338\":[4,40],\"339\":[1,23],\"340\":[2,47],\"341\":[2,6],\"342\":[1],\"343\":[1,73],\"344\":[1],\"345\":[1,9],\"346\":[1,7],\"347\":[1,12],\"348\":[1],\"349\":[3,19],\"350\":[2,12],\"351\":[2,16],\"352\":[3,18],\"353\":[3,22],\"354\":[1],\"355\":[2,33],\"356\":[2,16],\"357\":[3,14],\"358\":[9,13],\"359\":[6,17],\"360\":[2,7],\"361\":[5,8],\"362\":[3,23],\"363\":[2,27],\"364\":[3],\"365\":[4,62],\"366\":[5,10],\"367\":[4,50],\"368\":[3,37],\"369\":[3,48],\"370\":[3,7],\"371\":[5,14],\"372\":[6,62],\"373\":[1],\"374\":[1,14],\"375\":[1,24],\"376\":[4],\"377\":[1,7],\"378\":[3,22],\"379\":[4,48],\"380\":[4,23],\"381\":[1,70],\"382\":[6,39],\"383\":[5,27],\"384\":[5,23],\"385\":[2],\"386\":[2,4],\"387\":[2,30],\"388\":[2,14],\"389\":[3,16],\"390\":[1,10],\"391\":[1,11],\"392\":[1,38],\"393\":[1,17],\"394\":[1],\"395\":[2,16],\"396\":[2,7],\"397\":[2,35],\"398\":[1],\"399\":[3,32],\"400\":[1],\"401\":[3,5],\"402\":[3,18],\"403\":[1],\"404\":[1],\"405\":[1,12],\"406\":[1],\"407\":[2,19],\"408\":[1,9],\"409\":[1,13],\"410\":[1,29],\"411\":[1],\"412\":[2,10],\"413\":[1,39],\"414\":[1,16],\"415\":[4,38],\"416\":[4,57],\"417\":[3,15],\"418\":[1],\"419\":[2,14],\"420\":[2,20],\"421\":[2,11],\"422\":[1,30],\"423\":[1,20],\"424\":[1,62],\"425\":[1,4],\"426\":[1],\"427\":[4,5],\"428\":[4,4],\"429\":[3,5],\"430\":[3,2],\"431\":[4,15],\"432\":[1],\"433\":[1],\"434\":[2,28],\"435\":[4,62],\"436\":[1,8],\"437\":[5,38],\"438\":[1],\"439\":[4,17],\"440\":[2,2],\"441\":[3,25],\"442\":[2,30],\"443\":[4],\"444\":[1,26],\"445\":[1,23],\"446\":[2,3],\"447\":[3,15],\"448\":[3,44],\"449\":[4,12],\"450\":[4,30],\"451\":[2,8],\"452\":[3,21],\"453\":[5,12],\"454\":[5,29],\"455\":[3,6],\"456\":[5,11],\"457\":[2,11],\"458\":[2,13],\"459\":[3,39],\"460\":[2],\"461\":[3,36],\"462\":[4,39],\"463\":[6,19],\"464\":[2,88],\"465\":[3,53],\"466\":[2],\"467\":[2,10],\"468\":[2,30],\"469\":[3],\"470\":[4,28],\"471\":[2,70],\"472\":[2,8],\"473\":[2,12],\"474\":[4,17],\"475\":[2],\"476\":[5,17],\"477\":[5,12],\"478\":[5,4],\"479\":[2,27],\"480\":[1],\"481\":[1],\"482\":[1,44],\"483\":[1,39],\"484\":[1],\"485\":[1,30],\"486\":[1,7],\"487\":[1,13],\"488\":[1,61],\"489\":[1],\"490\":[1,60],\"491\":[1],\"492\":[1,18],\"493\":[4,44],\"494\":[5,21],\"495\":[6,27],\"496\":[4,29],\"497\":[1,36],\"498\":[1,27],\"499\":[2],\"500\":[2,10],\"501\":[6,8],\"502\":[1,18],\"503\":[2,51],\"504\":[2,25],\"505\":[1,37],\"506\":[1,26],\"507\":[2,21],\"508\":[2,14],\"509\":[4,10],\"510\":[2,56],\"511\":[2,36],\"512\":[1,24],\"513\":[2,9],\"514\":[1],\"515\":[2,32],\"516\":[2,16],\"517\":[3,10],\"518\":[2,57],\"519\":[5,26],\"520\":[2,9],\"521\":[7,38],\"522\":[6,37],\"523\":[8,67],\"524\":[3,19],\"525\":[3,102],\"526\":[2,45],\"527\":[3,22],\"528\":[3,9],\"529\":[2,2],\"530\":[2,21],\"531\":[2,24],\"532\":[7,31],\"533\":[3,15],\"534\":[5,83],\"535\":[2,83],\"536\":[2,19],\"537\":[1,29],\"538\":[1,3],\"539\":[1,26],\"540\":[2,20],\"541\":[1,3],\"542\":[1,1],\"543\":[1],\"544\":[1,16],\"545\":[1],\"546\":[1,28],\"547\":[1,20],\"548\":[1,64],\"549\":[1,91],\"550\":[1,6],\"551\":[1],\"552\":[1],\"553\":[1],\"554\":[1],\"555\":[1,30],\"556\":[2],\"557\":[1,8],\"558\":[1,4],\"559\":[1,31],\"560\":[1,5],\"561\":[1,7],\"562\":[1,59],\"563\":[1],\"564\":[1],\"565\":[1,17],\"566\":[1,11],\"567\":[2],\"568\":[1,39],\"569\":[2,48],\"570\":[1],\"571\":[1,27],\"572\":[1],\"573\":[1,62],\"574\":[1,8],\"575\":[1,2],\"576\":[1],\"577\":[4,70],\"578\":[1],\"579\":[5,1],\"580\":[1],\"581\":[1],\"582\":[1,4],\"583\":[5,11],\"584\":[2,19],\"585\":[1,24],\"586\":[1],\"587\":[2,22],\"588\":[2,14],\"589\":[1],\"590\":[2,12],\"591\":[3,70],\"592\":[2,29],\"593\":[2],\"594\":[3,2],\"595\":[1,65],\"596\":[1,49],\"597\":[2,18],\"598\":[5,27],\"599\":[3,56],\"600\":[2,36],\"601\":[3,29],\"602\":[4,48],\"603\":[3,67],\"604\":[2,86],\"605\":[2,52],\"606\":[2,18],\"607\":[2,30],\"608\":[2,10],\"609\":[2,13],\"610\":[2,24],\"611\":[2,37],\"612\":[2,36],\"613\":[2,16],\"614\":[2,98],\"615\":[2,43],\"616\":[1,5],\"617\":[5,61],\"618\":[4,34],\"619\":[3,40],\"620\":[4,1],\"621\":[3,55],\"622\":[3,12],\"623\":[2],\"624\":[1,11],\"625\":[1,10],\"626\":[1,7],\"627\":[1,17],\"628\":[1,40],\"629\":[1,8],\"630\":[1,6],\"631\":[1,5],\"632\":[1,26],\"633\":[2,18],\"634\":[2,56],\"635\":[2,52],\"636\":[2,4],\"637\":[4,4],\"638\":[2,32],\"639\":[2],\"640\":[2],\"641\":[1],\"642\":[3,36],\"643\":[3,19],\"644\":[1,16],\"645\":[2,42],\"646\":[3,32],\"647\":[2],\"648\":[2,59],\"649\":[6,62],\"650\":[3,7],\"651\":[3,70],\"652\":[2,8],\"653\":[6,7],\"654\":[3,21],\"655\":[2,16],\"656\":[3,55],\"657\":[1],\"658\":[1],\"659\":[1],\"660\":[1,11],\"661\":[1,11],\"662\":[1,2],\"663\":[1],\"664\":[3,12],\"665\":[3,31],\"666\":[4,7],\"667\":[3,22],\"668\":[2,21],\"669\":[1,4],\"670\":[4,70],\"671\":[3,46],\"672\":[2,7],\"673\":[4,72],\"674\":[3,71],\"675\":[2,45],\"676\":[3,28],\"677\":[2,6],\"678\":[1,79],\"679\":[3,28],\"680\":[3,18],\"681\":[2,5],\"682\":[2,27],\"683\":[2,15],\"684\":[3,3],\"685\":[6,42],\"686\":[7,40],\"687\":[5,56],\"688\":[1],\"689\":[1],\"690\":[2,2],\"691\":[1,15],\"692\":[1,30],\"693\":[1,94],\"694\":[2],\"695\":[2,34],\"696\":[1,53],\"697\":[1,162],\"698\":[1,97],\"699\":[2,12],\"700\":[1,9],\"701\":[1,141],\"702\":[1,57],\"703\":[2],\"704\":[1,20],\"705\":[1,16],\"706\":[1,70],\"707\":[1,18],\"708\":[1,127],\"709\":[1,27],\"710\":[1,11],\"711\":[1,92],\"712\":[1,69],\"713\":[1],\"714\":[1,102],\"715\":[1,5],\"716\":[1],\"717\":[1,148],\"718\":[1,19],\"719\":[1,10],\"720\":[1,40],\"721\":[1,10],\"722\":[1,99],\"723\":[1,99],\"724\":[1,47],\"725\":[1,8],\"726\":[2],\"727\":[1,16],\"728\":[1,65],\"729\":[1,21],\"730\":[1,26],\"731\":[1,20],\"732\":[2],\"733\":[1,9],\"734\":[1,96],\"735\":[2,26],\"736\":[1,46],\"737\":[1,16],\"738\":[1,105],\"739\":[2],\"740\":[1,52],\"741\":[1,53],\"742\":[1,112],\"743\":[2],\"744\":[1,30],\"745\":[1,23],\"746\":[1,8],\"747\":[1,166],\"748\":[1,134],\"749\":[1,137],\"750\":[2],\"751\":[1,51],\"752\":[1,74],\"753\":[1,121],\"754\":[1,239],\"755\":[1,170],\"756\":[1,67],\"757\":[1,163],\"758\":[1,29],\"759\":[2,13],\"760\":[1,5],\"761\":[1,10],\"762\":[1,237],\"763\":[1],\"764\":[1,38],\"765\":[1,136],\"766\":[1],\"767\":[1,40],\"768\":[1,134],\"769\":[2],\"770\":[1],\"771\":[1,22],\"772\":[1,15],\"773\":[1,15],\"774\":[1,32],\"775\":[1],\"776\":[1,27],\"777\":[1,54],\"778\":[1,7],\"779\":[1,113],\"780\":[1,95],\"781\":[1],\"782\":[1,33],\"783\":[1,48],\"784\":[1,12],\"785\":[1],\"786\":[1],\"787\":[2,9],\"788\":[1,171],\"789\":[1,20],\"790\":[1],\"791\":[2,15],\"792\":[2,59],\"793\":[1],\"794\":[1],\"795\":[1,3],\"796\":[1],\"797\":[2,12],\"798\":[2,13],\"799\":[3],\"800\":[2,10],\"801\":[2],\"802\":[1,4],\"803\":[1],\"804\":[1],\"805\":[1],\"806\":[2,39],\"807\":[1,32],\"808\":[3,10],\"809\":[2,9],\"810\":[3,42],\"811\":[7,21],\"812\":[7,22],\"813\":[3,48],\"814\":[2,24],\"815\":[4,40],\"816\":[2,70],\"817\":[4,34],\"818\":[5,32],\"819\":[2,80],\"820\":[3,32],\"821\":[5,44],\"822\":[6,33],\"823\":[7,17],\"824\":[1,3],\"825\":[2],\"826\":[1,23],\"827\":[1,92],\"828\":[1],\"829\":[1],\"830\":[1,18],\"831\":[1,43],\"832\":[1,96],\"833\":[1,48],\"834\":[1],\"835\":[2,28],\"836\":[2,71],\"837\":[2,23],\"838\":[2],\"839\":[1,14],\"840\":[1,31],\"841\":[1],\"842\":[1,25],\"843\":[1,6],\"844\":[1,19],\"845\":[1,14],\"846\":[1,13],\"847\":[1,41],\"848\":[1,45],\"849\":[1,24],\"850\":[1,32],\"851\":[1,44],\"852\":[1,41],\"853\":[1,47],\"854\":[1,49],\"855\":[1],\"856\":[1,3],\"857\":[1,22],\"858\":[1,29],\"859\":[1,19],\"860\":[1,60],\"861\":[1,15],\"862\":[1],\"863\":[1,20],\"864\":[1,63],\"865\":[1,1],\"866\":[1,46],\"867\":[1,8],\"868\":[1],\"869\":[1],\"870\":[1,4],\"871\":[1],\"872\":[2,38],\"873\":[2,29],\"874\":[1,57],\"875\":[3,53],\"876\":[2,11],\"877\":[2,16],\"878\":[2,50],\"879\":[2,77],\"880\":[1],\"881\":[2,18],\"882\":[1,33],\"883\":[1,71],\"884\":[2,15],\"885\":[2,24],\"886\":[3,14],\"887\":[3,17],\"888\":[3,66],\"889\":[2,40],\"890\":[2,44],\"891\":[2,33],\"892\":[4,47],\"893\":[8,25],\"894\":[3,24],\"895\":[2],\"896\":[2,8],\"897\":[2,22],\"898\":[3,5],\"899\":[2,3],\"900\":[2,5],\"901\":[2,17],\"902\":[3,39],\"903\":[2,4],\"904\":[1,27],\"905\":[1,29],\"906\":[1,14],\"907\":[1,10],\"908\":[2,7],\"909\":[4,20],\"910\":[2,19],\"911\":[2,10],\"912\":[3,11],\"913\":[2,10],\"914\":[2,5],\"915\":[3,8],\"916\":[2,23],\"917\":[2,39],\"918\":[2,14],\"919\":[5,49],\"920\":[2,6],\"921\":[1,7],\"922\":[1],\"923\":[1],\"924\":[2],\"925\":[3,46],\"926\":[3,40],\"927\":[3,2],\"928\":[2],\"929\":[2,22],\"930\":[2,14],\"931\":[2,29],\"932\":[2],\"933\":[2,30],\"934\":[2,45],\"935\":[2,25],\"936\":[2],\"937\":[2,35],\"938\":[3,42],\"939\":[3,79],\"940\":[2,12],\"941\":[2],\"942\":[2,10],\"943\":[3,87],\"944\":[3,81],\"945\":[3,2],\"946\":[2],\"947\":[2,9],\"948\":[3,37],\"949\":[3,40],\"950\":[1],\"951\":[2,2],\"952\":[3],\"953\":[2,30],\"954\":[2,69],\"955\":[2,12],\"956\":[null,null,1],\"957\":[2,95],\"958\":[null,null,1],\"959\":[1],\"960\":[2,2],\"961\":[3],\"962\":[2,6],\"963\":[2,30],\"964\":[2,40],\"965\":[2,24],\"966\":[3],\"967\":[2,16],\"968\":[3,32],\"969\":[3,25],\"970\":[2,66],\"971\":[3],\"972\":[2,7],\"973\":[2,34],\"974\":[2,29],\"975\":[2,53],\"976\":[1],\"977\":[2,2],\"978\":[1],\"979\":[2,5],\"980\":[3],\"981\":[2,32],\"982\":[4,81],\"983\":[5,64],\"984\":[5,26],\"985\":[2,5],\"986\":[1],\"987\":[2,2],\"988\":[2,6],\"989\":[1,12],\"990\":[2,27],\"991\":[2,40],\"992\":[3,23],\"993\":[2,31],\"994\":[1,9],\"995\":[1,19],\"996\":[2,48],\"997\":[2,23],\"998\":[1,31],\"999\":[null,null,1],\"1000\":[null,null,2],\"1001\":[1,9],\"1002\":[1],\"1003\":[1,7],\"1004\":[1,22],\"1005\":[1,16],\"1006\":[1,21],\"1007\":[2,24],\"1008\":[2,26],\"1009\":[1,25],\"1010\":[1,12],\"1011\":[1,24],\"1012\":[1,9],\"1013\":[1],\"1014\":[1],\"1015\":[3],\"1016\":[1],\"1017\":[3],\"1018\":[2,27],\"1019\":[2,45],\"1020\":[2,22],\"1021\":[3],\"1022\":[2,25],\"1023\":[2,42],\"1024\":[1,134],\"1025\":[1],\"1026\":[2],\"1027\":[3],\"1028\":[2,23],\"1029\":[3,79],\"1030\":[3,47],\"1031\":[2,2],\"1032\":[3],\"1033\":[2,16],\"1034\":[3,83],\"1035\":[3,54],\"1036\":[2,4],\"1037\":[3],\"1038\":[2,57],\"1039\":[2,14],\"1040\":[2,29],\"1041\":[1],\"1042\":[2],\"1043\":[1],\"1044\":[2],\"1045\":[1,3],\"1046\":[1]},\"averageFieldLength\":[2.039847771148121,29.435997737601046,0.4082834860472566],\"storedFields\":{\"0\":{\"h\":\"关于\",\"t\":[\"🎈🎈🎈\",\"欢迎光临，很高兴遇见你！🤝\"]},\"1\":{\"h\":\"🏠 关于本站\",\"t\":[\"本站创建于2018年3月。 记录并总结一些面试题、算法笔记、项目总结及其他内容；也包含一些从网络收集的文章。\",\"从创建到现在，使用过 Hugo，hexo，docsify，Gridea，语雀 等工具。但因为种种原因，最终还是选择了 vuepress😊\",\"当前配置：\",\"系统：vuepress v2.x\",\"主题：hope v2.x\",\"编辑工具：typora 相关总结\",\"托管：netlify、vercel、Webify、github pages\",\"此博客所有内容的作用均为记录。内容来自个人总结及网络收集。如有错误、侵权可以联系我。谢谢！\"]},\"2\":{\"h\":\"微信\"},\"3\":{\"h\":\"介绍页\",\"t\":[\"将你的个人介绍和档案放置在此处。\"]},\"4\":{\"h\":\"Java\",\"t\":[\" 基础\",\" 容器\",\" 多线程\",\" JVM\",\" Java8\",\" hutool\",\" 缓存相关\"]},\"5\":{\"h\":\"IntelliJ IDEA 常用设置\"},\"6\":{\"h\":\"1. 快捷键\",\"t\":[\"由于刚入门时使用的是eclipse，刚切换到idea时都配置了eclipse的keymap。但当前和他人协作的过程中发现，大多数同时都使用的是默认的keymap，因此也切换到了默认的。在此进行总结。\",\"搜索\",\"shift shift：可以搜索内容、类、文件、git的注释等。但搜索内容时，似乎不能搜索中文。\",\"ctrl+F：在当前文件内搜索\",\"ctrl+shift+F：全局搜索内容\",\"大小写切换：ctrl+shift+U\",\"快速定位到问题行，继续按就切换到其它错误行：F2\",\"复制并粘贴当前行 - ctrl+d d = duplicate 复制\",\"格式化代码 - ctrl+alt+L\",\"代码重构：ctrl+shift+alt+T\",\"上下文操作/快捷修复 - alt+enter。改成了习惯的ctrl+1\",\"关闭当前标签页 - ctrl+F4\",\"​ 这个快捷键按起来不是很方便，改成了习惯的ctrl+W\",\"代码收尾 - ctrl+shift+enter\",\"​ 比如，输入System.out.println()，按ctrl+shift+enter即可自动补齐需要的分号。\",\"​ 输入if (s == null)，按ctrl+shift+enter即可自动补齐需要的前后括号。\",\"多光标 - `alt + shift\",\"选中代码/关键字后，按住alt + shift，再输入要替换的内容，即可完成批量替换。\",\"按住alt + shift，再点击不同的位置，即可在多个位置生成光标。这样可以批量插入注解、修饰符等内容。\",\"增加环绕代码 - ctrl + alt + T\",\"​ 给选中的代码块增加if/if-else/while/do-while/for/try-catch/synchronized等环绕代码。\",\"显示类结构，包含的属性、方法等 - alt+7\",\"方法见切换：`alt+up/down\",\"上下换行：ctrl+shift+up/down\",\"在上一个/下一个编辑点之间切换（回退/前进）：ctrl+alt+left/right\",\"快速生成当前类的子类/接口的实现类：选中接口/类名，按ctrl+1(alt+enter)，选择创建子类/实现类\",\"查看实现类/子类：ctrl+H\"]},\"7\":{\"h\":\"1.1. 自动导入(import)\",\"t\":[\"依次进入Settings -> Build, Execution... -> Build Tools -> Maven -> Importing，勾选这个选项：\",\"Import Maven projects automatically\"]},\"8\":{\"h\":\"1.2. 快速换行\",\"t\":[\"shift + Enter：换到下一行\",\"ctrl + Alt + Enter：换到上一行\"]},\"9\":{\"h\":\"2. 操作\"},\"10\":{\"h\":\"2.1. 快速判断变量是否等于null\",\"t\":[\"如果想则代码里判断变量rabbitTemplate是否非null，输入rabbitTemplate.nn并回车即可。\",\"变量名后输入『.』，可以发现除了可用的方法外，还有其他很多快捷功能。\",\"如：rabbitTemplate.sout+回车，会输入System.out.println(rabbitTemplate);\"]},\"11\":{\"h\":\"2.2. 给代码创建书签\",\"t\":[\"项目中会有一些重要的、需要经常改的代码，我们可以给其创建书签（bookmark），这样下次就能快速定位到了。\",\"添加书签：在需要收藏的代码前右击，选择Add Bookmark，即可创建成功。\",\"查看书签：依次点击View - Tool Windows - Bookmarks；或者使用快捷键Alt + 2。\",\"书签重命名：在书签视图下，右击添加了书签的代码，选择Rename Bookmark即可。\",\"添加助记符：\",\"方法1：在需要收藏的代码前右击，选择Add Mnemonic Bookmark，即可在创建书签的同时添加助记符。\",\"方法2：在书签视图下，右击添加了书签的代码，选择Assign Mnemonic即可。\",\"image-20220522225443294\"]},\"12\":{\"h\":\"2.3. IDEA如何显示编译后的类？\",\"t\":[\"点击IDEA左上角Project窗口右上角的齿轮，勾选 Tree Appearance -> Show Excluded Files即可。\"]},\"13\":{\"h\":\"2.4. 创建quick list\",\"t\":[\"todo...\"]},\"14\":{\"h\":\"3. 设置\",\"t\":[\"注意\",\"部分设置成功后，新建项目后该设置又会失效。这种设置需要在 File -> New Projects Setup -> Settings for New Projects 内设置。如maven、字符集编码等。\"]},\"15\":{\"h\":\"3.1. maven配置\",\"t\":[\"依次点击 File -> New Projects Setup -> Settings for New Projects，进入Build -> Build Tools -> Maven\",\"配置 Maven home path、settings file、Local repository\"]},\"16\":{\"h\":\"3.2. 设置方法参数列表类型自动提示\",\"t\":[\"File-Settings打开设置(或者ctrl +Alt+S)，进入Editor -> Code Completion\",\"Parameter Info下的三个选项都进行勾选\",\"image-20220526163354853\"]},\"17\":{\"h\":\"3.3. 编码设置\",\"t\":[\"在IDEA中，编码设置也是很重要的一个步骤，不合理的设置可能会导致文件在跨系统场景下乱码。\",\"设置分为两类：当前项目的设置、新项目的默认设置\"]},\"18\":{\"h\":\"3.3.1. 当前项目的设置\",\"t\":[\"点击 File -> Settings，在弹窗内选择 Editor -> File Encodings，\",\"如下图，这三个位置都需要改。使用最通用的设置：UTF-8。\",\"image-20220416142943301\"]},\"19\":{\"h\":\"3.3.2. 新项目的默认设置\",\"t\":[\"点击 File -> New Projects Setup -> Settings for New Projects，在弹窗内选择 Editor -> File Encodings，\",\"如上图，这三个位置都需要改。使用最通用的设置：UTF-8。\"]},\"20\":{\"h\":\"3.4. 问题： IDEA 2019.3.2+之后的版本无法递归导入maven问题。\"},\"21\":{\"h\":\"3.4.1. 解决方案\",\"t\":[\"使用快捷键：Ctrl+Shift+A\",\"找到：search recur\",\"把【Toggle Search For Maven Project Recursively】开关打开。如下图：\",\"image-20220416143653974\"]},\"22\":{\"h\":\"4. 插件\",\"t\":[\"mybatisX：mybatis插件，可以快速在接口方法和xml的sql之间跳转、根据JPA风格的方法名生成sql等功能。\",\"lombok：使用注解快速生成get/set/equals/toString等方法\",\"JRebel and XRebel：热启动\",\"PlantUML integration：展示类的UML图\",\"leetcode: 力扣插件，可以在idea里测试、提交力扣题目\"]},\"23\":{\"h\":\"5. 参考\",\"t\":[\"awesome-IntelliJ-IDEA\"]},\"24\":{\"c\":[\"工具\"]},\"25\":{\"c\":[\"IDEA\",\"软件\"]},\"26\":{\"h\":\"Navicat相关\"},\"27\":{\"h\":\"快捷键\",\"t\":[\"执行选中内容：Ctrl + Shift + R\",\" 待补充其他\"]},\"28\":{\"h\":\"批量执行sql\",\"t\":[\"typora 似乎没有批量执行sql的方法（暂未找到），但可以使用win的合并命令，先把sql合并，再执行。\",\"合并命令：\",\"type *.sql >> merge.sql\"]},\"29\":{\"c\":[\"工具\"]},\"30\":{\"c\":[\"Navicat\",\"软件\"]},\"31\":{\"h\":\"Linux相关\"},\"32\":{\"h\":\"查看哪个目录占用空间大\",\"t\":[\"先执行df -h 查看顶层的\",\"再进入想查看的目录，执行du -h -x --max-depth=1进一步查看。\"]},\"33\":{\"c\":[\"工具\"]},\"34\":{\"c\":[\"linux\"]},\"35\":{\"h\":\"typora相关\",\"t\":[\"注\",\"typora 默认的官网国内访问速度很慢，其实还有一个国内的中文站：https://typoraio.cn/\",\"主题：https://theme.typoraio.cn/\",\"快捷键文档：https://support.typoraio.cn/Shortcut-Keys/#change-shortcut-keys\"]},\"36\":{\"h\":\"自用设置\"},\"37\":{\"h\":\"通用\",\"t\":[\"启动选项： 重新打开上次使用的文件和目录\",\"保存 & 恢复： 勾选自动保存。\",\"更新： 去掉全部勾选\",\"高级设置： 去掉全部勾选\"]},\"38\":{\"h\":\"外观\",\"t\":[\"窗口样式： 一体化\",\"状态栏： 显示状态栏\",\"侧边栏： 勾选 “允许xxx”\",\"主题： 具体文件已打包放入阿里云：typora主题-themes.zip。当前使用的是Drake Hpt，是在Drake基础上改的。字号改为16px，英文字体JetBrains Mono, 中文字体HarmonyOS Sans SC。\"]},\"39\":{\"h\":\"图床\",\"t\":[\"阿里云OSS，配合 picgo 进行上传。\"]},\"40\":{\"h\":\"Markdown\",\"t\":[\"Markdown 扩展语法： 全部勾选\"]},\"41\":{\"h\":\"其他配置\",\"t\":[\"关闭拼写检查\",\"搜索替换。把默认的谷歌替换为百度。效果是在选中内容后的右键菜单内，会出现『百度一下🎉』菜单。如下图。\",\"// conf.user.json \\\"searchService\\\": [ [\\\"百度一下🎉\\\", \\\"https://baidu.com/s?ie=UTF-8&wd=%s\\\"] ],\"]},\"42\":{\"h\":\"快捷键\",\"t\":[\"除了系统自带的（在下方），还自定义了下面4个。\",\"// conf.user.json \\\"keyBinding\\\": { // for example: // \\\"Always on Top\\\": \\\"Ctrl+Shift+P\\\" // All other options are the menu items 'text label' displayed from each typora menu \\\"Code\\\": \\\"Ctrl+E\\\", \\\"Highlight\\\": \\\"Ctrl + Q\\\", \\\"Paste\\\": \\\"Ctrl+Shift+V\\\", \\\"Paste as Plain Text\\\": \\\"Ctrl+V\\\" },\"]},\"43\":{\"h\":\"一：菜单栏\",\"t\":[\"文件：alt+F\",\"编辑：alt+E\",\"段落：alt+P\",\"格式：alt+O\",\"视图：alt+V\",\"主题：alt+T\",\"帮助：alt+H\"]},\"44\":{\"h\":\"二：文件\",\"t\":[\"新建：Ctrl+N\",\"新建窗口：Ctrl+Shift+N\",\"打开：Ctrl+O\",\"快速打开：Ctrl+P\",\"保存：Ctrl+S\",\"另存为：Ctrl+Shift+S\",\"偏好：Ctrl+,\",\"关闭：Ctrl+W\"]},\"45\":{\"h\":\"三：编辑\",\"t\":[\"撤销：Ctrl+Z\",\"重做：Ctrl+Y\",\"剪切：Ctrl+X\",\"复制：Ctrl+C\",\"粘贴：Ctrl+V\",\"复制为MarkDown：Ctrl+Shift+C\",\"粘贴为纯文本：Ctrl+Shift+V\",\"全选：Ctrl+A\",\"选中当前行/句：Ctrl+L\",\"选中当前格式文本：Ctrl+E\",\"选中当前词：Ctrl+D\",\"跳转到文首：Ctrl+Home\",\"跳转到所选内容：Ctrl+J\",\"跳转到文末：Ctrl+End\",\"查找：Ctrl+F\",\"查找下一个：F3\",\"查找上一个：Shift+F3\",\"替换：Ctrl+H\"]},\"46\":{\"h\":\"四：段落\",\"t\":[\"标题：Ctrl+1/2/3/4/5\",\"段落：Ctrl+0\",\"增大标题级别：Ctrl+=\",\"减少标题级别：Ctrl+-\",\"表格：Ctrl+T\",\"代码块：Ctrl+Shift+K\",\"公式块：Ctrl+Shift+M\",\"引用：Ctrl+Shift+Q\",\"有序列表：Ctrl+Shift+[\",\"无序列表：Ctrl+Shift+]\",\"增加缩进：Ctrl+]\",\"减少缩进：Ctrl+[\"]},\"47\":{\"h\":\"五：格式\",\"t\":[\"标题加编号：https://github.com/lipengzhou/typora-theme-auto-numbering\",\"加粗：Ctrl+B\",\"斜体：Ctrl+I\",\"下划线：Ctrl+U\",\"代码：Ctrl+Shift+`\",\"删除线：Alt+Shift+5\",\"超链接：Ctrl+K\",\"清除样式：Ctrl+\\\\\",\"图片：Ctrl+Shift+I （不常用。直接粘贴图片即可）\"]},\"48\":{\"h\":\"六：视图\",\"t\":[\"显示隐藏侧边栏：Ctrl+Shift+L\",\"大纲视图：Ctrl+Shift+1\",\"文档列表视图：Ctrl+Shift+2\",\"文件树视图：Ctrl+Shift+3\",\"源代码模式：Ctrl+/\",\"专注模式：F8\",\"打字机模式：F9\",\"切换全屏：F11\",\"实际大小：Ctrl+Shift+0\",\"放大：Ctrl+Shift+=\",\"缩小：Ctrl+Shift+-\",\"应用内窗口切换：Ctrl+Tab\",\"打开DevTools：Shift+F12\"]},\"49\":{\"h\":\"和谐\",\"t\":[\"学习版安装包、主题已放入阿里云盘。名称为：20220715_typora_64bit_v1.3.8_setup.zip\"]},\"50\":{\"c\":[\"工具\"]},\"51\":{\"c\":[\"软件\"]},\"52\":{\"h\":\"博客常用资源\",\"t\":[\"提示\",\"此处记录一些编写博客时经常用到的资源。\"]},\"53\":{\"h\":\"插件\",\"t\":[\"https://moefyit.github.io/moefy-vuepress/\"]},\"54\":{\"h\":\"图标\",\"t\":[\"iconfont\"]},\"55\":{\"h\":\"Markdown增强语法\",\"t\":[\"Markdown增强\",\"Markdown Enhance Plugin - 演示\",\"Frontmatter配置\",\"标题批量添加序号：jetbrains插件 markdown-index\",\"把markdown文件复制到idea或其他jetbrains系的IDE内，右击，选择markdown index，即可添加成功。\"]},\"56\":{\"c\":[\"工具\"]},\"57\":{\"c\":[\"资源\"]},\"58\":{\"h\":\"maven笔记\"},\"59\":{\"h\":\"1. maven介绍\",\"t\":[\"官网：Maven\",\"下载地址：Download\",\"Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供构建和依赖管理支持的工具。\"]},\"60\":{\"h\":\"2. 安装和配置\",\"t\":[\"windows平台选择 apache-maven-x.x.x-bin.zip下载，下载后解压到不含中文、无空格的路径。\"]},\"61\":{\"h\":\"2.1. settings配置修改\",\"t\":[\"conf/settings.xml文件需要修改。主要修改点如下：\",\"<!-- 配置maven本地仓库的存放位置。默认在C盘。要从注释中拿出来。不需要建这个目录。要求目录中文无空格。 --> <localRepository>D:/0.devEnv/mavenRepository</localRepository> ... <!-- 配置阿里云提供的镜像仓库。也可替换为华为云、腾讯云等。 --> <mirrors> <mirror> <id>nexus-aliyun</id> <mirrorOf>central</mirrorOf> <name>Nexus aliyun</name> <url>https://maven.aliyun.com/repository/central</url> </mirror> </mirrors> ... <!-- 配置Maven工程的基础JDK版本 --> <profiles> <profile> <id>jdk-1.8</id> <activation> <activeByDefault>true</activeByDefault> <jdk>1.8</jdk> </activation> <properties> <maven.compiler.source>1.8</maven.compiler.source> <maven.compiler.target>1.8</maven.compiler.target> <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion> </properties> </profile> <profiles>\",\"阿里云的仓库地址已发生变更。很多教材还是使用的老地址。新旧地址的对应关系参考官网：https://maven.aliyun.com/repository/central\"]},\"62\":{\"h\":\"2.2. 环境变量配置\",\"t\":[\"添加环境变量 MAVEN_HOME，值为maven程序的地址（bin\\\\的上一级）。如D:\\\\0.devTools\\\\1.maven\\\\maven\",\"把%MAVEN_HOME%\\\\bin添加到path中。\"]},\"63\":{\"h\":\"2.3. 验证\",\"t\":[\"新开一个cmd窗口，执行mvn -v，如果能看到版本号，说明配置成功。\"]},\"64\":{\"h\":\"3. 基本概念\"},\"65\":{\"h\":\"3.1. maven中的坐标\",\"t\":[\"使用三个**『向量』在『Maven的仓库』中唯一的定位到一个『jar』**包。\",\"groupId：公司或组织的 id\",\"artifactId：一个项目或者是项目中的一个模块的 id。一般作为 Maven 工程的工程名。\",\"version：版本号，根据自己的需要设定 \",\"例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本\",\"例如：RELEASE 表示正式版本\",\"坐标：\",\" <groupId>javax.servlet</groupId> <artifactId>servlet-api</artifactId> <version>2.5</version>\",\"上面坐标对应的 jar 包在 Maven 本地仓库中的位置：\",\"Maven本地仓库根目录\\\\javax\\\\servlet\\\\servlet-api\\\\2.5\\\\servlet-api-2.5.jar\"]},\"66\":{\"h\":\"3.2. POM\"},\"67\":{\"h\":\"3.2.1. 含义\",\"t\":[\"POM：Project Object Model，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。\"]},\"68\":{\"h\":\"3.2.2. 模型化思想模型化思想\",\"t\":[\"POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。\"]},\"69\":{\"h\":\"3.2.3. 对应的配置文件\",\"t\":[\"POM 理念集中体现在 Maven 工程根目录下 pom.xml 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。\"]},\"70\":{\"h\":\"3.2.4. pom.xml解读\",\"t\":[\"<!-- 代表当前pom.xml采用的标签结构。从maven2开始就固定是4.0.0 --> <modelVersion>4.0.0</modelVersion> ... <!-- 当前工程的坐标信息 --> <groupId>com.bi</groupId> <artifactId>wms</artifactId> <version>1.24.0-SNAPSHOT</version> ... <!-- 当前工程的打包信息。 jar代表生成jar， war代表web工程， pom代表当前工程是用来管理其他工程的 --> <packaging>jar</packaging> ... <!-- 在maven中定义属性值。可指定依赖包的版本、java版本、字符集等等 --> <properties> <java.version>1.8</java.version> </properties> ... <!-- 配置依赖信息，可以包含多个 dependency 子标签 <scope>表示当前依赖的范围 --> <dependencies> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>3.5.1</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies>\"]},\"71\":{\"h\":\"3.3. 约定的目录结构\",\"t\":[\"./images\",\"另外还有一个 target 目录专门存放构建操作输出的结果。\"]},\"72\":{\"h\":\"4. 执行 Maven 的构建命令\",\"t\":[\"运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录。\",\"mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。\"]},\"73\":{\"h\":\"4.1. 清理操作\",\"t\":[\"mvn clean 清理操作。效果：删除 target 目录。\"]},\"74\":{\"h\":\"4.2. 编译操作\",\"t\":[\"主程序编译：mvn compile\",\"测试程序编译：mvn test-compile\",\"主体程序编译结果存放的目录：target/classes\",\"测试程序编译结果存放的目录：target/test-classes\"]},\"75\":{\"h\":\"4.3. 测试操作\",\"t\":[\"mvn test\",\"测试的报告存放的目录：target/surefire-reports\"]},\"76\":{\"h\":\"4.4. 打包操作\",\"t\":[\"mvn package\",\"打包的结果存放的目录：target\"]},\"77\":{\"h\":\"4.5. 安装操作\",\"t\":[\"mvn install\",\"安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。\",\"如下所示，坐标信息如下：\",\" <groupId>com.xxx.maven</groupId> <artifactId>pro01-maven-java</artifactId> <version>1.0-SNAPSHOT</version>\",\"在 Maven 仓库中生成的路径如下： D:\\\\0.devEnv\\\\mavenRepository\\\\com\\\\xxx\\\\maven\\\\pro01-maven-java\\\\1.0-SNAPSHOT\\\\pro01-maven-java-1.0-SNAPSHOT.jar\",\"另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库，和jar包在同一个目录内，如pro01-maven-java-1.0-SNAPSHOT.pom。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。\"]},\"78\":{\"h\":\"5. 创建web工程\",\"t\":[\"使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法。\",\"./images\",\"mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4\",\"参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。\",\"生成的pom.xml中，打包方式是war：<packaging>war</packaging>\",\"查看当前 Web 工程所依赖的 jar 包的列表：mvn dependency:list\",\"[INFO] The following files have been resolved: [INFO] org.hamcrest:hamcrest-core:jar:1.3:test [INFO] javax.servlet:javax.servlet-api:jar:3.1.0:provided [INFO] junit:junit:jar:4.12:test\",\"说明：javax.servlet:javax.servlet-api🫙3.1.0:provided 格式显示的是一个 jar 包的坐标信息。格式是：\",\"groupId : artifactId : 打包方式 : version : 依赖的范围\",\"以树形结构查看当前 Web 工程的依赖信息：mvn dependency:tree\"]},\"79\":{\"h\":\"6. 依赖相关\"},\"80\":{\"h\":\"6.1. 依赖范围<scope>\",\"t\":[\"标签的位置：dependencies/dependency/scope\",\"标签的可选值：compile/test/provided/system/runtime/import\",\"默认是compile\",\"compile、test、provided 对比：\",\"main目录（空间）\",\"test目录（空间）\",\"开发过程（时间）\",\"部署到服务器（时间）\",\"compile\",\"有效\",\"有效\",\"有效\",\"有效\",\"test\",\"无效\",\"有效\",\"有效\",\"无效\",\"provided\",\"有效\",\"有效\",\"有效\",\"无效\",\"compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。\",\"test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。\",\"provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。通过 provided 和 test 范围依赖的jar包不会放入war包。\"]},\"81\":{\"h\":\"6.2. 依赖的传递性\",\"t\":[\"在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。\",\"B 依赖 C 时使用 compile 范围：可以传递\",\"B 依赖 C 时使用 test 或 provided 范围：不能传递\",\"所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。\"]},\"82\":{\"h\":\"6.3. 依赖的排除\",\"t\":[\"当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 的 pom.xml 里，引入 B 的时候，把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。\"]},\"83\":{\"h\":\"6.3.1. 配置方式：\",\"t\":[\"如下所示，排除了pro01-maven-java内的commons-logging包。\",\"<dependency> <groupId>com.xxx.maven</groupId> <artifactId>pro01-maven-java</artifactId> <version>1.0-SNAPSHOT</version> <scope>compile</scope> <!-- 使用excludes标签配置依赖的排除 --> <exclusions> <!-- 在exclude标签中配置一个具体的排除 --> <exclusion> <!-- 指定要排除的依赖的坐标（不需要写version） --> <groupId>commons-logging</groupId> <artifactId>commons-logging</artifactId> </exclusion> </exclusions> </dependency>\"]},\"84\":{\"h\":\"7. Maven工程间的继承\"},\"85\":{\"h\":\"7.1. 概念 & 作用\",\"t\":[\"Maven工程之间，A 工程继承 B 工程时，称 B 工程为父工程，A 为子工程。\",\"本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。\",\"作用是，在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。\",\"它的背景是：\",\"对一个比较大型的项目进行了模块拆分。\",\"一个 project 下面，创建了很多个 module，每一个 module 都需要配置自己的依赖信息。\",\"它背后的需求是：\",\"在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。\",\"使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。\",\"使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。\",\"通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。\",\"比如，下方的代码使用了Spring的多个工程，使用时要求所有 Spring 自己的 jar 包版本必须一致。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。\",\"[INFO] +- org.springframework:spring-core:jar:4.0.0.RELEASE:compile [INFO] | \\\\- commons-logging:commons-logging:jar:1.1.1:compile [INFO] +- org.springframework:spring-beans:jar:4.0.0.RELEASE:compile [INFO] +- org.springframework:spring-context:jar:4.0.0.RELEASE:compile [INFO] +- org.springframework:spring-expression:jar:4.0.0.RELEASE:compile [INFO] +- org.springframework:spring-aop:jar:4.0.0.RELEASE:compile [INFO] | \\\\- aopalliance:aopalliance:jar:1.0:compile\",\"注意\",\"父工程的打包方式，要选择pom：<packaging>pom</packaging>。\",\"只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。\"]},\"86\":{\"h\":\"7.2. 父子工程的pom.xml\"},\"87\":{\"h\":\"7.2.1. 父工程的pom.xml\",\"t\":[\"<!-- 建了子module后，父工程的 pom.xml中会出现下面的标签 --> <modules> <module>pro04-maven-module</module> <module>pro05-maven-module</module> <module>pro06-maven-module</module> </modules> ... <!-- 使用dependencyManagement标签配置对依赖的管理 --> <!-- 被管理的依赖并没有真正被引入到工程 --> <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>4.0.0.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>4.0.0.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>4.0.0.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-expression</artifactId> <version>4.0.0.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-aop</artifactId> <version>4.0.0.RELEASE</version> </dependency> </dependencies> </dependencyManagement>\",\"提示\",\"上方代码中，每个坐标都要单独维护版本信息，修改起来比较麻烦。可以在<properties>内声明自定义属性统一管理，然后在<version>标签内引用。这样如果要修改版本，只需要修改一处即可。代码如下：\",\"<properties> <spring.version>4.0.0.RELEASE</spring-boot.version> </properties> <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>${spring.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>${spring.version}</version> </dependency> </dependencies> </dependencyManagement>\"]},\"88\":{\"h\":\"7.2.2. 子工程的pom.xml\",\"t\":[\"<!-- 子工程的pom文件内会出现 <parent> 标签，通过坐标，指向父工程 --> <parent> <groupId>com.hpt.maven</groupId> <artifactId>pro03-maven-parent</artifactId> <version>1.0-SNAPSHOT</version> </parent> ... <!-- 子工程的坐标 --> <!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --> <!-- <groupId>com.hpt.maven</groupId> --> <artifactId>pro04-maven-module</artifactId> <!-- <version>1.0-SNAPSHOT</version> --> ... <!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --> <!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --> <!-- 具体来说是由父工程的dependencyManagement来决定。 --> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-expression</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-aop</artifactId> </dependency> </dependencies>\"]},\"89\":{\"h\":\"7.3. 聚合和继承\",\"t\":[\"聚合和继承通常是结合使用的，但是其作用是不同的。\",\"继承和聚合，相互独立，二者没有关联； 通常是组合使用的。\",\"继承是在子项目中操作，使用 parent 标签，标记xx项目为父项目。\",\"聚合是在父项目(pom项目)中操作，使用 modules 标签，将xx项目标记为需要聚合的项目。\",\"聚合是将多个模块的工程汇聚到一起，而继承则是指明某个模块工程要继承另一个模块功能。\"]},\"90\":{\"h\":\"7.4. 好处\",\"t\":[\"一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。\",\"以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。\",\"配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。\"]},\"91\":{\"h\":\"7.5. 循环依赖问题\",\"t\":[\"如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：\",\"DANGER\",\"[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:\"]},\"92\":{\"h\":\"8. IDEA中maven配置\",\"t\":[\"参考 这里\"]},\"93\":{\"h\":\"9. Maven的生命周期\"},\"94\":{\"h\":\"9.1. 三个生命周期\",\"t\":[\"为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。\",\"生命周期名称\",\"作用\",\"各个环节\",\"Clean\",\"清理操作相关\",\"pre-clean clean post-clean\",\"Site\",\"生成站点相关\",\"pre-site site post-site deploy-site\",\"Default\",\"主要构建过程\",\"validategenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resources 复制并处理资源文件，至目标目录，准备打包。compile 编译项目 main 目录下的源代码。process-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resources 复制并处理资源文件，至目标测试目录。test-compile 编译测试源代码。process-test-classestest 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。prepare-packagepackage 接受编译好的代码，打包成可发布的格式，如JAR。pre-integration-testintegration-testpost-integration-testverifyinstall将包安装至本地仓库，以让其它项目依赖。deploy将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。\"]},\"95\":{\"h\":\"9.2. 特点\",\"t\":[\"前面三个生命周期彼此是独立的。\",\"在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。\",\"Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。\"]},\"96\":{\"h\":\"10. 插件和目标\"},\"97\":{\"h\":\"10.1. 插件\",\"t\":[\"Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。\",\"参考：maven插件官网\"]},\"98\":{\"h\":\"10.2. 目标\",\"t\":[\"一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。\",\"Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。\"]},\"99\":{\"h\":\"10.3. 自定义打包的插件\",\"t\":[\"当我们将项目打包时，希望将项目的说明文档、SQL 脚本文件、项目的配置文件、properties 文件等也打包，此时我们可以通过 Maven 提供的插件 maven-assembly-plugin 进行自定义打包。\",\"在pom.xml中配置插件依赖\",\"<build> <plugins> <plugin> <artifactId>maven-assembly-plugin</artifactId> <version>3.2.0</version> <executions> <execution> <id>make-zip</id> <phase>package</phase> <goals> <goal>single</goal> </goals> <configuration> <descriptors> <!-- 指定配置文件的路径，路径可变，例如：在resources 目录下则为：src/main/resources/assembly.xml --> <descriptor>src/main/resources/assembly.xml</descriptor> </descriptors> <archiverConfig> <encoding>utf-8</encoding> </archiverConfig> </configuration> </execution> </executions> </plugin> </plugins> </build>\",\"配置 assembly.xml\",\"<assembly> <!-- 打包文件名的标识符,在打包后的文件名称的后缀显示 --> <id>release</id> <formats> <!-- 这里设置打包的类型，例如 tar、zip 等 --> <format>zip</format> </formats> <includeBaseDirectory>false</includeBaseDirectory> <fileSets> <!-- 将 jar 包从项目所在的目录中的 target 目录取出来，放到 zip 包--> <fileSet> <directory>target</directory> <includes> <include>${project.artifactId}-${project.version}.jar</include> </includes> <outputDirectory>/${project.artifactId}</outputDirectory> </fileSet> <!-- 将 application.yml 从项目所在的目录中的 class 目录取出来，放到 zip 包--> <fileSet> <directory>${project.build.directory}/classes</directory> <includes> <include>application.yml</include> </includes> <outputDirectory>/${project.artifactId}</outputDirectory> </fileSet> <!-- 将 scripts 目录中所有文件取出，只排除 run 目录，放到 zip 包的 scripts 目录下--> <fileSet> <directory>scripts</directory> <includes> <include>**</include> </includes> <excludes> <exclude>run</exclude> </excludes> <outputDirectory>/${project.artifactId}/scripts</outputDirectory> </fileSet> <fileSet> <directory>./</directory> <includes> <include>readme.md</include> </includes> <outputDirectory>/${project.artifactId}</outputDirectory> </fileSet> </fileSets> </assembly>\",\"执行 mvn install，即可打包成功\"]},\"100\":{\"h\":\"11. 项目中遇到/用到过的插件\"},\"101\":{\"h\":\"11.1. maven-compiler-plugin\",\"t\":[\"官网\",\"maven编译插件。配置中可以指定编译时的java版本、编码。\",\"使用示例：\",\"<properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <java.version>1.8</java.version> </properties> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>2.3.2</version> <configuration> <source>${java.version}</source> <target>${java.version}</target> <encoding>${project.build.sourceEncoding}</encoding> </configuration> </plugin>\"]},\"102\":{\"h\":\"11.2. maven-dependency-plugin\"},\"103\":{\"h\":\"11.3. maven-jar-plugin\",\"t\":[\"官网\",\"maven官方插件，该插件提供了构建 jar 的功能。主要目标为：jar:jar\",\"遇到的用法，见下方spring-boot-maven-plugin插件中的示例。此次也只分析这3个属性，其他属性含义见官网。\",\"<addClasspath>：是否要在META-INF/MANIFEST.MF文件中创建Class-Path属性（描述依赖项列表）。默认值是false。\",\"<classpathPrefix>：addClasspath为true时才有意义，含义是指定第三方jar的路径前缀。默认值是“”。可以指定最终输出jar的META-INFO/MANIFEST文件中，Class-Path属性的前缀。如果想给最终的jar瘦身，即把第三方依赖从最终jar中移除，则这项必须写，用来指定jar的依赖路径的前缀。\",\"Class-Path: 依赖项列表，若存在多个依赖项时则采用空格分隔。依赖项路径为以JAR包路径为参考系的相对路径, 有个小细节就是, 如果自己生成这个文件,在引用了所有的以来后, 后面还有一个 '.'\",\"参考：META-INF/MANIFEST.MF文件详细说明\",\"<useUniqueVersions>： 是否使用唯一时间戳快照版本而不是 -SNAPSHOT 版本，默认值为true。如果为true会在使用时生成很多以时间戳结尾的jar，如果其他地方依赖了这个jar，使用时会报错。\",\"<manifest> <addClasspath>true</addClasspath> <classpathPrefix>lib/</classpathPrefix> <useUniqueVersions>false</useUniqueVersions> </manifest>\"]},\"104\":{\"h\":\"11.4. spring-boot-maven-plugin\",\"t\":[\"spring boot提供的maven打包插件，可打直接可运行的jar包或war包。官方文档地址\",\"使用2.2.1.RELEASE版本需要maven版本在2.0及以上，JDK在1.8及以上。\",\"一般对使用spring-boot-maven-plugin插件打出的可执行jar不建议作为jar给其他服务引用，因为可能出现访问可执行jar中的一些配置文件找不到的问题。如果想让构建出来的原始jar不被重新打包，可以对spring-boot-maven-plugin插件配置classifier属性，自定义一个可运行jar名称，这样该插件就不会对原始的jar重命名操作了。\"]},\"105\":{\"h\":\"11.4.1. 目标概述\",\"t\":[\"spring-boot:run：运行你的 Spring Boot 应用程序。\",\"spring-boot:repackage：把你的jar/war重新打包为可执行的jar/war包。\",\"spring-boot:start/stop：来管理 Spring Boot 应用程序的生命周期（即用于集成测试）。\",\"spring-boot:build-info：生成可供执行器使用的构建信息。\",\"此处只分析遇到的用的最多的目标：repackage。\"]},\"106\":{\"h\":\"11.4.2. repackage目标（默认goal）\",\"t\":[\"目标官网\",\"作用：重新打包现有的 JAR 和 WAR 存档，以便它们可以 使用 java -jar 从命令行执行。使用此目标后，默认情况下，maven自己先打的包会被加上.origin后缀。这是不可执行的jar，用来被其他项目引用。\",\"<configuration>用来对这个插件进行配置。在最下方的例子中，设置了主启动类，并引入了null，即最终包中不包含任何第三方依赖的jar。如果要排除某个jar，可以使用类似这样的方式：\",\"<excludes> <exclude> <groupId>com.foo</groupId> <artifactId>bar</artifactId> </exclude> </excludes>\",\"也可以使用<excludeGroupIds>com.foo</excludeGroupIds>，来排除这个group下的所有jar。\",\"<layout>ZIP</layout>：实现将/lib外置需要的配置。\",\"<outputDirectory>：指定该插件打的包最终会放到这个属性对应的路径下。如果未指定，默认路径是${project.build.directory}。\",\"<mainClass>：指定主启动类。如果没有指定，会查找包内第一个含有main()方法的类作为启动类。\",\"使用示例：\",\"下方的实例中使用了2个插件。maven-jar-plugin中指定了依赖的第三方jar要放到lib目录，spring-boot-maven-plugin插件中排除了第三方jar，并把最终输出的jar包放在了指定位置。这样会大大减少最终jar包的体积，实现jar包“瘦身”的效果。在我们的实际应用中，会去${boot-jar-output}目录下再重新打包成docker镜像。\",\"<!-- 基于maven-jar-plugin插件实现把依赖jar定义写入输出jar的META-INFO/MANIFEST文件；必须写在 spring-boot-maven-plugin 之前，才能确保下面的插件后执行 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jar-plugin</artifactId> <configuration> <archive> <manifest> <addClasspath>true</addClasspath> <classpathPrefix>lib/</classpathPrefix> <useUniqueVersions>false</useUniqueVersions> </manifest> </archive> </configuration> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <version>2.3.7.RELEASE</version> <configuration> <!-- 指定主启动类 --> <mainClass>com.cisai.tech.byqanalyseserver.ByqAnalyseServerApplication</mainClass> <includes> <!-- 不存在的include引用，相当于排除所有maven依赖jar，没有任何三方jar文件会打入最终输出的jar中。用来减少jar的体积。 --> <include> <groupId>null</groupId> <artifactId>null</artifactId> </include> </includes> <layout>ZIP</layout> <!-- 基于maven-jar-plugin输出微服务jar文件进行二次spring boot重新打包文件的输出目录 所有微服务构建输出jar文件统一输出到与lib同一个目录，便于共同引用同一个lib目录 --> <outputDirectory>${boot-jar-output}</outputDirectory> </configuration> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> </execution> </executions> </plugin>\"]},\"107\":{\"c\":[\"工具\"]},\"108\":{\"c\":[\"maven\"]},\"109\":{\"h\":\"工具资源\",\"t\":[\"此处记录一些用过的小工具。\"]},\"110\":{\"h\":\"\",\"t\":[\"与微软 VISIO 很类似，支持多种云盘存储，免费开源可自己搭建网站，支持携带版不用安装。\",\"官网：https://www.diagrams.net/\",\"开源地址：https://github.com/jgraph/drawio-desktop\",\"网页版地址：https://app.diagrams.net/\",\"下载地址：https://github.com/jgraph/drawio-desktop/releases\",\"office插件地址：https://appsource.microsoft.com/zh-CN/product/office/wa200000113\"]},\"111\":{\"h\":\"ExplorerPatcher - win11菜单优化\",\"t\":[\"原版GitHub地址：https://github.com/valinet/ExplorerPatcher\",\"第三方汉化版Github地址：https://github.com/ZetaSp/ExplorerPatcher\"]},\"112\":{\"h\":\"Xmind ZEN\",\"t\":[\"思维导图工具。学习版在云盘。\"]},\"113\":{\"h\":\"dev-sidecar\",\"t\":[\"可以改善github连接、下载缓慢的情况。\",\"官网：https://github.com/docmirror/dev-sidecar\"]},\"114\":{\"h\":\"vive - 资源管理器多标签页\",\"t\":[\"注意\",\"使用的操作系统版本为 win11-22H2；其他版本慎用。\",\"下载：https://github.com/thebookisclosed/ViVe\",\"配置：\",\"// 管理员身份运行 cmd cd xxxx\\\\ViVeTool-v0.3.1 vivetool /enable /id:37634385 vivetool /enable /id:39145991 vivetool /enable /id:36354489\",\"运行后重启电脑。\"]},\"115\":{\"c\":[\"工具\"]},\"116\":{\"c\":[\"资源\",\"软件\"]},\"117\":{\"h\":\"网站资源\",\"t\":[\"注意\",\"本文部分收集自网络，侵删。\"]},\"118\":{\"h\":\"推荐\",\"t\":[\"panjiachen by 花裤衩\",\"编程导航 by 程序员鱼皮\",\"编程自学之路 by 程序羊\",\"前端知识图谱+B站资源整合 by 技术胖\",\"大圣编程自学网 by 大圣\",\"开发者武器库\",\"工具大全\"]},\"119\":{\"h\":\"文档\",\"t\":[\"MDN | MDN-JS标准内置对象 Web技术权威文档\",\"DevDocs Web 开发技术文档，非常不错的学习手册！\",\"现代JavaScript教程 以最新标准为基准的JS教程\",\"ES5教程 阮一峰的JS教程\",\"ES6教程 阮一峰的ES6教程\",\"Bash 脚本教程 阮一峰编写\",\"ECMA ECMA官网\",\"菜鸟教程 涵盖多种语言的初级教程\",\"腾讯云开发者手册\"]},\"120\":{\"h\":\"社区\",\"t\":[\"Github 程序员同性交友社区\",\"掘金 一个帮助开发者成长的社区\",\"简书 有很多频道的创作社区\",\"思否 解决技术问题的社区\",\"stack overflow 同上，外网的\",\"InfoQ 促进软件开发及相关领域知识与创新的传播\",\"V2EX 创意工作者们的社区\",\"鱼塘热榜 划水网站，收集了很多网站，当天热门文章\",\"码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\"]},\"121\":{\"h\":\"社区互动\",\"t\":[\"gitter\",\"兔小巢\"]},\"122\":{\"h\":\"技巧\",\"t\":[\"Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\",\"百度指数 同上，但百度的数据仅限国内。\"]},\"123\":{\"h\":\"博客\",\"t\":[\"阮一峰的网络日志\",\"samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\"]},\"124\":{\"h\":\"电子书\",\"t\":[\"高教书苑 高等教育出版社的书籍，包含多种学科。\",\"SoBooks 免费的电子书资源网站\",\"Java程序员书单\"]},\"125\":{\"h\":\"优秀文章\",\"t\":[\"我做系统架构的一些原则 作者对系统架构的方法论总结\",\"灵活运用CSS开发技巧\",\"防御性CSS\"]},\"126\":{\"h\":\"视频\",\"t\":[\"bilibili B站，上面很多免费教学视频\",\"慕课网 实战视频教程\",\"妙味课堂 比较系统的前端入门视频教程\",\"中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\",\"egghead 质量还不错的短视频教程，外网\"]},\"127\":{\"h\":\"Github\",\"t\":[\"Repobeats 生成仓库的动态数据统计图\",\"github 短域名服务\",\"shields 徽章图标\",\"followers 全球排名\",\"star-history 展示一个项目 Stars 增长曲线\"]},\"128\":{\"h\":\"评论系统\",\"t\":[\"giscus 由 GitHub Discussions 驱动的评论系统\"]},\"129\":{\"h\":\"前端小工具\",\"t\":[\"Can I use 查看属性和方法的兼容性\",\"30 seconds of code 收集了许多有用的代码小片段\"]},\"130\":{\"h\":\"代码编辑\",\"t\":[\"codepen 在线代码编辑与演示\",\"codesandbox 内嵌VSCode的在线IDE\"]},\"131\":{\"h\":\"Emoji表情\",\"t\":[\"emoji表情\",\"emoji表情备忘录\",\"根据文本匹配emoji\",\"gitmoji 通过 emoji 表达 git 的操作内容\",\"在任意输入框快速打开emoji表情方法： Windows系统下按Win + . Mac系统下按Control + Command + 空格\"]},\"132\":{\"h\":\"图片工具\",\"t\":[\"tinypng图片压缩 压缩png很有用\",\"微图 浏览器端图片压缩，不会上传图片到服务器\",\"Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\",\"waifu2x 通过卷积网络放大图片\",\"vectormagic 转换矢量图\",\"vectorizer 真正的 png 转 svg 神器\",\"在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\",\"remove AI抠图\",\"backgroundremover 又一个抠图的\"]},\"133\":{\"h\":\"思维导图\",\"t\":[\"processon在线作图 流程图、思维导图、原型图等\",\"百度脑图 思维导图\",\"plectica 绘制知识图谱\"]},\"134\":{\"h\":\"CSS\",\"t\":[\"各种CSS生成器和JS代码片段\",\"CSS Tricks CSS技巧收集与演示\",\"CSS生成器\",\"CSS渐变生成器\",\"CSS3-Box Shadow(阴影)\",\"贝塞尔曲线生成器 \",\"花纹背景生成器\",\"花纹背景-pattern.css\",\"3D字体\",\"css-tricks css技巧文章\",\"You-need-to-know-css CSS的各种DEMO，很全\",\"animista CSS动画可视化工具，复制代码就能用\",\"navnav 各种炫酷的CSS动画组件\"]},\"135\":{\"h\":\"CDN加速\",\"t\":[\"jsDelivr 国外的一家优秀的公共 CDN 服务提供商\",\"unpkg cdn 服务\"]},\"136\":{\"h\":\"网站托管\",\"t\":[\"vercel 好用的网站托管服务\"]},\"137\":{\"h\":\"正则\",\"t\":[\"正则可视化\",\"iHateRegex 正则搜索，细节做得很好\",\"正则迷你书 学习正则的小手册\"]},\"138\":{\"h\":\"其他\",\"t\":[\"Linux命令手册\",\"carbon代码图片生成器 生成好看的代码图片\"]},\"139\":{\"h\":\"设计\",\"t\":[\"创造师导航\",\"设计师网址导航\",\"remove AI抠图，抠图算法很厉害\",\"Manypixels 插画\",\"Undraw 插画\",\"storytale 插画，种类丰富，包含3D插画\",\"uimovement 能从这个网站找到不少动画交互的灵感\",\"awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\",\"dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\",\"Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\",\"Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\",\"brandmark 另一个在线制作 logo 网站\",\"instant 又一个 logo 制作网站\",\"namecheap又一个 logo 制作网站\",\"logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\",\"coolors 帮你在线配色的网站 你能找到不少配色灵感\",\"colorhunt 另一个配色网站\",\"uigradients 渐变色网站\",\"designcap 在线海报设计\",\"Flat UI 色表 Flat UI 色表\",\"0to255 颜色梯度\",\"Ikonate 提供免费的图标 icons\",\"remixicon 又一个提供免费图标 icons\",\"feather 免费的 icons\",\"nord 北欧性冷淡风主题配色\",\"Unsplash 提供免费的高清图片\",\"Pexels 提供免费的高清图片\",\"colorkitty 从你的图片中提取配色\",\"design.youzan 有赞设计原则\",\"iconfont 阿里巴巴矢量图标库\",\"undraw 免费的矢量插画\",\"icomoon 矢量图标库\",\"cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\",\"CSS triangle generator 帮你快速用 css 做出三角形\",\"clippy 在线帮你使用 css clip-path 做出各种形状的图形\",\"Lorem Picsum 提供免费的占位图\",\"Canva 可画 生成插画、封面、海报、头像等\",\"404页 404页素材\",\"collectui 按功能组件分类的设计图\",\"smartmockups 产品模板生成工具\"]},\"140\":{\"h\":\"图库\",\"t\":[\"uigradients 渐变色生成工具\",\"freepik banner 图库\",\"觅元素一天免费下载十张 psd（免抠元素）\",\"搞定设计 可以抠图\",\"vectorizer 真正的 png 转 svg 神器\",\"站酷 国内优秀的设计作品展示\",\"花瓣\",\"虎克 ps 学习教程\",\"beTheme\",\"UI 中国\",\"wallhaven 壁纸网站-\"]},\"141\":{\"h\":\"3D\",\"t\":[\"sketchfab 3D模型\"]},\"142\":{\"h\":\"交互\",\"t\":[\"微交互 里面收集了市面上很多很好的微交互例子 值得学习\",\"Little Big Details 同上，一个国外微交互汇集网站\",\"cruip 登录页的各种页面设计，可以免费下载模板\",\"Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\",\"taiko-web 太鼓达人网页版 只能说很 6\"]},\"143\":{\"h\":\"有趣\",\"t\":[\"电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\",\"neocities 上面托管了很多有趣的网站\",\"奇趣网站收藏家 收藏了很多有趣的网站\",\"FC在线模拟器(小霸王游戏机) 童年回忆\",\"帮你百度一下 可以 点我测试一下-\",\"国际版 同帮我百度一下-点我测试一下-\",\"URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\",\"Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\",\"ggtalk 平时一直在听的一个技术博客\",\"awesome-comment 里面收集了很多有趣的代码注释\",\"text-img 都将图片转化为 ascii 用来写注释\",\"ascii video 使用ascii编码生成视频动画\",\"weird-fonts 将普通字母转化为 特殊 unicode\",\"snake 在地址栏里面玩贪吃蛇\",\"zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\",\"abbreviations 查看一个简写是什么意思的网站\",\"magi ai 搜索神器，超屌\",\"在线取名 解决取名难问题，超多名字生成\"]},\"144\":{\"h\":\"生成器\",\"t\":[\"卡通头像生成器 上传真人头像生成卡通头像\",\"artbreeder 动漫图生成真人图像\",\"声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\",\"诺基亚短信图片生成器\",\"到账语音生成器 支付宝到账1亿元\"]},\"145\":{\"h\":\"元宇宙\",\"t\":[\"符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\",\"沙盒\",\"梦境空间\",\"Decentraland\"]},\"146\":{\"h\":\"教程\",\"t\":[\"npx 教你怎么合理的使用 npx\",\"hacksplaining 网络安全学习网站\",\"mobile-web-best-practice 移动 web 最佳实践\",\"ZetCode 中文系列教程 一系列教程\"]},\"147\":{\"h\":\"产品\",\"t\":[\"Product Hunt 好产品推荐\",\"产品大牛 什么有很多完整的产品原型可以借鉴\",\"磨刀 快速出 ui 原型\"]},\"148\":{\"h\":\"实用\",\"t\":[\"webden 在线网页编辑器，轻便快捷\",\"browser-update 浏览器版本更新提示插件\",\"typeform 一个国外的在线调查问卷网站\",\"VideoFk VideoFk 视频在线解析下载\",\"全历史 历史内容聚合网站\",\"UzerMe 云端办公工具\",\"SoBooks 强大的电子书资源网站\",\"稿定设计 键式设计工具+智能抠图\",\"大力盘 百度网盘搜索\",\"ENFI 下载器 不限速下载器\",\"来画视频 像做 PPT 一样做短视频\",\"Arkie 海报制作工具\",\"优品 PPT\",\"比格 PPT\",\"高清免费图片\",\"高清免费图片 2\",\"shapedivider 生成波浪分隔线\",\"Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\"]},\"149\":{\"h\":\"Talk\",\"t\":[\"peerigon-talks 收集了不少有意思的 talks\"]},\"150\":{\"h\":\"算法\",\"t\":[\"leetcode 用 js 刷 leetcode\"]},\"151\":{\"h\":\"nginx\",\"t\":[\"nginx 可视化配置工具\"]},\"152\":{\"h\":\"生活\",\"t\":[\"Ventusky 风雨气温图\"]},\"153\":{\"c\":[\"工具\"]},\"154\":{\"c\":[\"网站\"]},\"155\":{\"h\":\"前端资源\",\"t\":[\"注意\",\"本文部分收集自网络，侵删。\"]},\"156\":{\"h\":\"React UI 组件库\",\"t\":[\"Ant Design\",\"React Bootstrap\",\"MATERIAL-UI\"]},\"157\":{\"h\":\"Vue UI组件库\",\"t\":[\"Element UI PC端\",\"Vant 移动端\",\"View UI\"]},\"158\":{\"h\":\"常用效果组件\",\"t\":[\"Animate.css 动画库\",\"Swiper 轮播组件\",\"mescroll 下拉刷新和上拉加载框架-基于原生JS\"]},\"159\":{\"h\":\"工具类\",\"t\":[\"Lodash.js\",\"Day.js 处理日期\",\"Timeago.js 相对时间，如N小时前\",\"Echarts 百度图表\",\"Meditor.md 开源在线 Markdown 编辑器\",\"validator.js 验证库\"]},\"160\":{\"h\":\"Vue工具类\",\"t\":[\"vue-draggable 基于Sortable.js实现的vue拖拽插件\",\"vue-qr 文本转二维码\",\"vue-cropper 图片裁剪插件\",\"vue-lazyload 懒加载\",\"vue-simple-upload 上传组件\"]},\"161\":{\"h\":\"其他\",\"t\":[\"H5带笔锋手写签名，支持PC端和移动端\"]},\"162\":{\"c\":[\"工具\"]},\"163\":{\"c\":[\"前端\"]},\"164\":{\"h\":\"框架\",\"t\":[\"框架相关的记录\"]},\"165\":{\"h\":\"数据结构和算法必知必会的50个代码实现\",\"t\":[\"以下内容中题目为转载，相关代码实现为本人实现or整理自网络。 部分之前总结过的题可以点击进入对应文章链接，没有总结的会在后续补充\"]},\"166\":{\"h\":\"数组\",\"t\":[\" 实现一个支持动态扩容的数组\",\" 实现一个大小固定的有序数组，支持动态增删改操作\",\" 实现两个有序数组合并为一个有序数组\"]},\"167\":{\"h\":\"链表\",\"t\":[\" 实现单链表、循环链表、双向链表，支持增删操作\",\"实现单链表反转\",\" 实现两个有序的链表合并为一个有序链表\",\" 实现求链表的中间结点\"]},\"168\":{\"h\":\"栈\",\"t\":[\" 用数组实现一个顺序栈\",\" 用链表实现一个链式栈\",\" 编程模拟实现一个浏览器的前进、后退功能\"]},\"169\":{\"h\":\"队列\",\"t\":[\" 用数组实现一个顺序队列\",\" 用链表实现一个链式队列\",\" 实现一个循环队列\"]},\"170\":{\"h\":\"递归\",\"t\":[\" 编程实现斐波那契数列求值f(n)=f(n-1)+f(n-2)\",\" 编程实现求阶乘n!\",\" 编程实现一组数据集合的全排列\"]},\"171\":{\"h\":\"排序\",\"t\":[\" 实现归并排序、快速排序、插入排序、冒泡排序、选择排序\",\" 编程实现O(n)时间复杂度内找到一组数据的第K大元素\"]},\"172\":{\"h\":\"二分查找\",\"t\":[\" 实现一个有序数组的二分查找算法\",\" 实现模糊二分查找算法（比如大于等于给定值的第一个元素）\"]},\"173\":{\"h\":\"散列表\",\"t\":[\" 实现一个基于链表法解决冲突问题的散列表\",\" 实现一个LRU缓存淘汰算法\"]},\"174\":{\"h\":\"字符串\",\"t\":[\" 实现一个字符集，只包含a～z这26个英文字母的Trie树\",\" 实现朴素的字符串匹配算法\"]},\"175\":{\"h\":\"二叉树\",\"t\":[\" 实现一个二叉查找树，并且支持插入、删除、查找操作\",\" 实现查找二叉查找树中某个节点的后继、前驱节点\",\" 实现二叉树前、中、后序以及按层遍历\"]},\"176\":{\"h\":\"堆\",\"t\":[\" 实现一个小顶堆、大顶堆、优先级队列\",\" 实现堆排序\",\" 利用优先级队列合并K个有序数组\",\" 求一组动态数据集合的最大Top K\"]},\"177\":{\"h\":\"图\",\"t\":[\" 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法\",\" 实现图的深度优先搜索、广度优先搜索\",\" 实现Dijkstra算法、A*算法\",\" 实现拓扑排序的Kahn算法、DFS算法\"]},\"178\":{\"h\":\"回溯\",\"t\":[\" 利用回溯算法求解八皇后问题\",\" 利用回溯算法求解0-1背包问题\"]},\"179\":{\"h\":\"分治\",\"t\":[\" 利用分治算法求一组数据的逆序对个数\"]},\"180\":{\"h\":\"动态规划\",\"t\":[\" 0-1背包问题\",\" 最小路径和\",\" 编程实现莱文斯坦最短编辑距离\",\" 编程实现查找两个字符串的最长公共子序列\",\" 编程实现一个数据序列的最长递增子序列\"]},\"181\":{\"h\":\"常用算法整理\",\"t\":[\"此处记录常用的算法，可以用在平时的解题中，提高解题效率。\"]},\"182\":{\"h\":\"判断奇数偶数\",\"t\":[\"判断n & 1的结果，如果是1，则n是奇数，否则是偶数。\"]},\"183\":{\"h\":\"0和1交替替换\",\"t\":[\"int i = 0; i ^= 1;\",\"应用：\",\"常用在部分奇偶变化、boolean类型的标志位持续变化的题目中。持续调用时，i会在0和1之间不断切换。\"]},\"184\":{\"h\":\"消除二进制表示中最后一个1\",\"t\":[\"n = n & (n - 1)\",\"如，n为 1001101 时，n - 1 = 1001100，二者相与赋值给n，结果为 1001100，最后一位的1被去掉了。\",\"再次计算，n-1 = 1001011，二者相与，结果为 1001000，最后一位的1被去掉了。\",\"应用：\",\"剑指 Offer 15. 二进制中1的个数：n不为0时持续进行上述计算，每计算一次sum+1。循环结束后，sum的值就是要求的结果。\",\"JDK中的实现，时间复杂度 `O(1)`\",\"// java.lang.Integer#bitCount public static int bitCount(int i) { // HD, Figure 5-2 i = i - ((i >>> 1) & 0x55555555); i = (i & 0x33333333) + ((i >>> 2) & 0x33333333); i = (i + (i >>> 4)) & 0x0f0f0f0f; i = i + (i >>> 8); i = i + (i >>> 16); return i & 0x3f; }\"]},\"185\":{\"h\":\"滑动窗口专题\",\"t\":[\"相关信息\",\"此处记录滑动窗口相关的题目，主要来自力扣。数据结构主要为数组、字符串。\"]},\"186\":{\"h\":\"\",\"t\":[\"使用set作为滑动窗口，通过下标判断窗口大小。\",\"遍历数组，使用set来保存遍历过的元素。通过set的大小，或遍历时的下班与k比较，来动态移除先前加进去的元素。如果添加失败，表示遇到了重复元素，返回true。遍历完成仍没有结束的，表示k范围内没有重复元素，返回false。\",\"public boolean containsNearbyDuplicate(int[] nums, int k) { Set<Integer> set = new HashSet<>(); int length = nums.length; for (int i = 0; i < length; i++) { if (i > k) { set.remove(nums[i-k-1]); } if (!set.add(nums[i])) { return true; } } return false; }\",\"时间 O(n)\",\"空间 O(k) set中的元素数，最多为k+1个。\"]},\"187\":{\"h\":\"\",\"t\":[\"求最大平均值，其实就是求子数组最大和。使用cur来记录窗口内元素的和，并使用max来记录不同下标处的和的最大值即可。\",\"易错点：max可以初始化为0，但在循环内，k之前的元素都要加起来才是第一个max的值。\",\"public double findMaxAverage(int[] nums, int k) { int max = 0, cur = 0; int n = nums.length; for (int i = 0; i < n; i++) { if (i >= k) { cur = cur - nums[i-k] + nums[i]; max = Math.max(max, cur); } else { cur += nums[i]; max = cur; } } return 1.0 * max / k; }\"]},\"188\":{\"h\":\"\",\"t\":[\"可以用滑动窗口，但是没必要。\",\"public int countGoodSubstrings(String s) { int sum = 0; int n = s.length(); char[] chars = s.toCharArray(); for (int i = 0; i <= n-3; i++) { if (chars[i] != chars[i+1] && chars[i]!= chars[i+2] && chars[i+1] != chars[i+2]) { sum++; } } return sum; }\"]},\"189\":{\"h\":\"\",\"t\":[\"可以先给学生分数排序，再构造一个大小为k的滑动窗口。从左到右遍历一次排序后的数组，找出每个窗口首位两端的分数差，最后找出所有窗口中分数差最小的值即可。\",\"public int minimumDifference(int[] nums, int k) { Arrays.sort(nums); int n = nums.length, ret = nums[k-1] - nums[0]; for (int i = k; i < n; i++) { ret = Math.min(ret, nums[i] - nums[i-k+1]); } return ret; }\",\"时间：O(nlogn)。n是数组长度，排序需要的时间为 O(nlogn)，后续遍历需要 O(n)\",\"空间：O(logn)，即排序需要的栈空间\"]},\"190\":{\"h\":\"\",\"t\":[\"和上面的滑动窗口不同，这道题需要计算的是数组两侧的数字和，即“窗口之外”的数。\",\"public int minimumDifference(int[] nums, int k) { Arrays.sort(nums); int n = nums.length, ret = nums[k-1] - nums[0]; for (int i = k; i < n; i++) { ret = Math.min(ret, nums[i] - nums[i-k+1]); } return ret; }\",\"时间：O(nlogn)。n是数组长度，排序需要的时间为 O(nlogn)，后续遍历需要 O(n)\",\"空间：O(logn)，即排序需要的栈空间\"]},\"191\":{\"c\":[\"滑动窗口\",\"哈希\"]},\"192\":{\"h\":\"优先队列专题\",\"t\":[\"相关信息\",\"此处记录优先级队列相关的题目，主要来自力扣。\"]},\"193\":{\"h\":\"\",\"t\":[\"todo\"]},\"194\":{\"h\":\"\",\"t\":[\"根据题意，创建2个优先队列，其比较规则相反。然后遍历orders。在循环中，先判断当前订单是否为采购类。\",\"如果是，则继续判断（while）：如果销售订单队列不为空，且其第一个元素的价格小于当前订单的价格，且当前订单的数量大于0，则进入while循环。\",\"循环内，先获取当前用户的数量和销售队列中第一个元素的数量的最小值，然后分别在数量上减去这个最小值。如果销售队列第一个元素的数量被减为0，则移除它。\",\"循环结束后判断，如果当前元素数量还大于0，则把它加入到采购队列中。\",\"外层orders的循环中，对销售类订单的循环和采购类类似。\",\"循环结束后，需要分别获取两个优先队列中，每个订单的数量之和。使用Java8的Stream简化代码。最后再对1000000007L取余后，返回结果。\",\"class Solution { Queue<int[]> buy = new PriorityQueue<>((a, b)-> b[0] - a[0]); Queue<int[]> sell = new PriorityQueue<>((a, b)-> a[0] - b[0]); public int getNumberOfBacklogOrders(int[][] orders) { for (int[] order : orders) { checkAndRemove(order); } return getSum(); } private int getSum() { return (int)((buy.stream().mapToLong(arr -> arr[1]).sum() + sell.stream().mapToLong(arr -> arr[1]).sum()) % (1000000007L)); } /** * 检查对应的队列中，是否有需要消除的元素。 * @param cur */ private void checkAndRemove(int[] cur) { if (cur[2] == 0) { // 当前是采购订单，查询销售订单列表。 while (!sell.isEmpty() && sell.peek()[0] <= cur[0] && cur[1] > 0) { int min = Math.min(sell.peek()[1], cur[1]); cur[1] -= min; sell.peek()[1] -= min; if (sell.peek()[1] == 0) { sell.remove(); } } if (cur[1] > 0) { buy.add(cur); } } else { while (!buy.isEmpty() && buy.peek()[0] >= cur[0] && cur[1] > 0) { int min = Math.min(buy.peek()[1], cur[1]); cur[1] -= min; buy.peek()[1] -= min; if (buy.peek()[1] == 0) { buy.remove(); } } if (cur[1] > 0) { sell.add(cur); } } } }\",\"时间复杂度：O(nlog⁡n)，其中n是数组orders的长度。需要遍历数组orders一次，对于每个元素处理优先队列的时间是O(log⁡n)，共需要O(log⁡n)的时间，遍历结束之后计算剩余的积压订单总数需要O(log⁡n)的时间。\",\"空间复杂度：O(n)，其中n是数组orders的长度。优先队列需要O(n)的空间。\"]},\"195\":{\"c\":[\"优先队列\"]},\"196\":{\"h\":\"动态规划专题\",\"t\":[\"相关信息\",\"此处记录动态规划相关的题目，主要来自力扣。\"]},\"197\":{\"h\":\"力扣-Easy\"},\"198\":{\"h\":\"\",\"t\":[\"数据范围为0-100，直接使用递推公式模拟即可。\",\"由题目可得出：最大值肯定是在奇数位上。为了便于计算，如果n是奇数则n+1(变成偶数)，多加了一个偶数位，答案不受影响。\",\"这样处理后，for循环就可以只循环一半。\",\"public int getMaximumGenerated(int n) { if (n < 2) return n; n += (n&1); int[] ints = new int[n+1]; ints[1] = 1; int tmp = 0, max = 1, half = n>>1; for (int i = 1; i < half; i++) { ints[i<<1] = ints[i]; ints[(i<<1)+1] = ints[i] + ints[i+1]; } return Arrays.stream(ints).max().getAsInt(); }\"]},\"199\":{\"h\":\"\",\"t\":[\"直接模拟。时间复杂度为n，空间复杂度为1。\",\"public int tribonacci(int n) { if (n == 0) return 0; if (n < 3) return 1; int p1 = 0, p2 = 1, p3 = 1; int cur = 0; for (int i = 3; i <= n; i++) { cur = p1 + p2 + p3; p1 = p2; p2 = p3; p3 = cur; } return cur; }\"]},\"200\":{\"h\":\"\",\"t\":[\"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\",\"每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\",\"定义一个长度为n的int数组dp，dp[i]表示走到第i层时的方法数，那么，dp[i] = dp[i-1] + dp[i-2]。也就是说，到达第i层，只能从i-1或i-2层。那么其方法数就是后面这两个方法数之和。\",\"根据题意可以得知，dp[0] = 1, dp[1] = 1。后面的值的就可以通过公式得到。\",\"优化：由于dp[i] 只和 dp[i-1]、dp[i-2]相关，可以不用数组，使用有限的几个变量即可。\",\"public int climbStairs(int n) { if (n <2) return 1; int p0 = 1, p1 = 1, p2 = 2; for (int i = 2; i < n; i++) { p2 = p0 + p1; p0 = p1; p1 = p2; } return p0 + p1; }\"]},\"201\":{\"h\":\"\",\"t\":[\"由题意可易得，从第三行开始，除了开始和末尾的位置上的元素，其余位置上的元素都是由上方的元素以及上方左侧的元素相加得到的，此时就很容易的到从第三行开始状态转移方程为dp[i][j] = dp[i-1][j] + dp[i-1][j-1]。再判断下边界条件即可。\",\"public List<List<Integer>> generate(int numRows) { List<List<Integer>> out = new LinkedList<>(); out.add(Arrays.asList(1)); if (numRows == 1) return out; out.add(Arrays.asList(1,1)); int tmp; for (int i = 3; i <= numRows; i++) { tmp = 0; List<Integer> in = new ArrayList<>(3); in.add(1); List<Integer> pre = out.get(i - 2); // 第i行，需要使用上一行列表的除了最后一个的数。由于下标是从0开始，而行号从1开始，因此上行使用out.get(i - 2)。 for (int j = 0; j < pre.size()-1; j++) { in.add(pre.get(tmp) + pre.get(++tmp)); } in.add(1); out.add(in); } return out; }\"]},\"202\":{\"h\":\"\",\"t\":[\"由题意可易得，从第2个元素开始，我们都需要找到之前元素中的最小值，且这个值必须小于当前值。使用dp数组来表示对于第i位元素，前面的元素中的最小值。\",\"public int maxProfit(int[] prices) { int len = prices.length; int[] dp = new int[len]; if (len < 2) { return 0; } dp[0] = prices[0]; dp[1] = prices[0]; int max = Math.max(0, prices[1] - prices[0]); for (int i = 2; i < len; i++) { dp[i] = Math.min(prices[i-1], dp[i-1]); max = Math.max(max , prices[i] - dp[i]); } return max; }\",\"进一步优化，使用单个变量代替dp数组：\",\"public int maxProfit(int[] prices) { int len = prices.length; if (len < 2) { return 0; } int minValue = Math.min(prices[0], prices[1]); int max = Math.max(0, prices[1] - prices[0]); for (int i = 2; i < len; i++) { minValue = Math.min(prices[i-1], minValue); max = Math.max(max , prices[i] - minValue); } return max; }\",\"还可以进一步优化，如下所示：\",\"public int maxProfit(int[] prices) { int min = Integer.MAX_VALUE; int max = 0;//最大利润 for (int i = 0; i < prices.length; i++) { if(prices[i] < min){ min = prices[i]; }else if(prices[i] - min > max){ max = prices[i] - min; } } return max; }\"]},\"203\":{\"h\":\"\",\"t\":[\"经过分析，可以得知：\",\"奇数i的二进制表示中的1，等于前面那个数的二进制表示中的1的个数+1。\",\"偶数，等于其除以2的数的二进制表示中的1的个数。\",\"public int[] countBits(int n) { int[] dp = new int[n+1]; dp[0] = 0; int flag = 0; for (int i = 1; i <= n; i++, flag ^=1) { if (flag == 0) { dp[i] = dp[i-1] + 1; } else { dp[i] = dp[i>>1]; } } return dp; }\",\"可以进行优化。我们可以得知，i为奇数时，dp[i] = dp[i-1] + 1; 其中 i-1 为偶数，那么 dp[i-1] 就等于 dp[i>>1]。\",\"优化后代码如下.flag的值会在0和1之间切换。\",\"public int[] countBits(int n) { int[] dp = new int[n+1]; dp[0] = 0; int flag = 1; for (int i = 1; i <= n; i++, flag ^=1) { dp[i] = dp[i>>1] + flag; } return dp; }\"]},\"204\":{\"h\":\"\",\"t\":[\"个人认为，这道题使用动态规划解法时，应该属于mid难度。\",\"定义动态规划的状态 dp[i][j]为经过 i 轮传递到编号 j 的玩家的方案数，可知 dp[0][0]= 1。\",\"对于传信息的关系 [src, dst]，如果第 i 轮传递到编号 src 的玩家，则第 i + 1 轮可以从编号 src 的玩家传递到编号 dst 的玩家。因此在计算 dp[i+1][dst]时，需要考虑可以传递到dst的所有玩家，即下方代码处应使用累加的方式计算。\",\"public int numWays(int n, int[][] relation, int k) { int[][] dp = new int[k + 1][n]; dp[0][0] = 1; for (int i = 0; i < k; i++) { for (int[] edge : relation) { int src = edge[0], dst = edge[1]; dp[i + 1][dst] += dp[i][src]; } } return dp[k][n - 1]; }\"]},\"205\":{\"h\":\"\",\"t\":[\"个人认为，这道题使用动态规划解法时，应该属于mid难度。\",\"定义动态规划的状态 dp[i][j]为经过 i 轮传递到编号 j 的玩家的方案数，可知 dp[0][0]= 1。\",\"对于传信息的关系 [src, dst]，如果第 i 轮传递到编号 src 的玩家，则第 i + 1 轮可以从编号 src 的玩家传递到编号 dst 的玩家。因此在计算 dp[i+1][dst]时，需要考虑可以传递到dst的所有玩家，即下方代码处应使用累加的方式计算。\",\"public int numWays(int n, int[][] relation, int k) { int[][] dp = new int[k + 1][n]; dp[0][0] = 1; for (int i = 0; i < k; i++) { for (int[] edge : relation) { int src = edge[0], dst = edge[1]; dp[i + 1][dst] += dp[i][src]; } } return dp[k][n - 1]; }\"]},\"206\":{\"h\":\"背包问题\",\"t\":[\"相关信息\",\"如果按照常见的「背包问题」的题型来抽象模型的话，「背包问题」大概是对应这样的一类问题：\",\"泛指一类「给定价值与成本」，同时「限定决策规则」，在这样的条件下，如何实现价值最大化的问题。\",\"参考资料：\",\"宫水三叶的刷题笔记#背包问题\",\"背包九讲（待bu'c）\"]},\"207\":{\"h\":\"01背包\",\"t\":[\"有 N 件物品和一个容量是 V 的背包。每件物品有且只有一件。\",\"第 i 件物品的体积是 v[i]，价值是w[i]。\",\"求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\",\"示例 1：\",\"输入: N = 3, V = 4, v = [4,2,3], w = [4,2,3] 输出: 4 解释: 只选第一件物品，可使价值最大。\",\"示例 2：\",\"输入: N = 3, V = 5, v = [4,2,3], w = [4,2,3] 输出: 5 解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。\",\"根据变化参数和返回值，可以抽象出我们的 dp 数组：一个二维数组，其中一维代表「当前枚举到哪件物品」，另外一维代表「现在已使用的容量」，数组装的是「最大价值」。\",\"我们只需要考虑第 i 件物品如何选择即可，对于第 i 件物品，我们有「选」和「不选」两种决策。如果不选，其实就是dp[i-1][c]，等于我们只考虑前 i-1 件物品，当前容量为 c 的情况下的最大价值；如果选，表示新消耗了v[i]的容量，获得了w[i]的价值，那前 i-1 件物品可用的容量就成了c-v[i]。即最大价值为：dp[i-1][c-v[i]]+w[i]。选第 i 件物品的前提是，当前剩余的背包容量>=物品体积。\",\"在「选」和「不选」之间取最大值，就是我们「考虑前 i 件物品，使用容量不超过 C」的条件下的「背包最大价值」。\",\"即可得「状态转移方程」为： $$ dp[i][c] = max(dp[i-1][c], dp[i-1][c-v[i]] + w[i]) $$ 代码：\",\"public int maxValue(int N, int C, int[] v, int[] w) { int[][] dp = new int[N][C+1]; // 先处理「考虑第一件物品」的情况。i为使用的空间，如果其>=第一件物品需要的容量，当前最大价值就为w[0]，否则表示当前不装，最大价值为0。 for (int i = 0; i <= C; i++) { dp[0][i] = i >= v[0] ? w[0] : 0; } // 再处理「考虑其余物品」的情况。i代表当前物品，j代表当前可以使用的容量，即剩余容量。 for (int i = 1; i < N; i++) { for (int j = 0; j <= C; j++) { // 不选该物品时的总价值 int n = dp[i-1][j]; // 选择该物品时的总价值，前提「剩余容量」大于等于「物品体积」 int y = j >= v[i] ? dp[i-1][j-v[i]] + w[i] : n; dp[i][j] = Math.max(n, y); } } return dp[N-1][C]; }\"]},\"208\":{\"h\":\"参考\",\"t\":[\"宫水三叶的刷题笔记#动态规划\"]},\"209\":{\"c\":[\"动态规划\"]},\"210\":{\"h\":\"算法\",\"t\":[\"一些算法题记录，主要来自力扣。\"]},\"211\":{\"h\":\"Java基础面试题\"},\"212\":{\"h\":\"Java基础面试题\",\"t\":[\"待补充\"]},\"213\":{\"h\":\"容器概述\",\"t\":[\"注意\",\"本文部分内容来自网络。侵删。\"]},\"214\":{\"h\":\"容器概述\",\"t\":[\"Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。主要接口和实现类如下图所示。\",\"20220327132758\",\"图中只列举了主要的继承派生关系，并没有列举所有关系。\"]},\"215\":{\"h\":\"List, Set, Queue, Map 四者的区别？\",\"t\":[\"List存储的元素是有序的、可重复的。\",\"Set存储的元素是无序的、不可重复的。\",\"Queue按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\",\"Map使用键值对（key-value）存储。key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\"]},\"216\":{\"h\":\"如何选用集合？\",\"t\":[\"主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。\",\"当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。\"]},\"217\":{\"h\":\"为什么要使用集合？\",\"t\":[\"当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。\",\"数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。\"]},\"218\":{\"h\":\"集合框架底层数据结构总结\"},\"219\":{\"h\":\"\",\"t\":[\"Arraylist： Object[] 数组\",\"Vector：Object[] 数组\",\"LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)\"]},\"220\":{\"h\":\"Set\",\"t\":[\"HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素\",\"LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于LinkedHashMap， 其内部是基于 HashMap 实现\",\"TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)\"]},\"221\":{\"h\":\"Queue\",\"t\":[\"PriorityQueue: Object[] 数组来实现二叉堆\",\"ArrayQueue: Object[] 数组 + 双指针\"]},\"222\":{\"h\":\"Map\",\"t\":[\"HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\",\"LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》\",\"Hashtable： 数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的\",\"TreeMap： 红黑树（自平衡的排序二叉树）\"]},\"223\":{\"c\":[\"学习笔记\",\"Java容器\"]},\"224\":{\"c\":[\"基础\"]},\"225\":{\"h\":\"List\",\"t\":[\"List是一个有序的、可重复的集合，扩展Collection接口的接口，在java.util包下，提供增删改查数据的基本功能，且可以通过索引来插入替换和删除集合元素的方法。\",\"集合的出现就是为了持有对象，集合中可以存储任意类型的对象，而且长度可变。\"]},\"226\":{\"h\":\"常用的实现类\",\"t\":[\"ArrayList\",\"底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素\",\"LinkedList\",\"底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素\",\"Vector\",\"底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素\"]},\"227\":{\"h\":\"有了数组为什么还需要List集合？\",\"t\":[\"数组长度是固定的，在日常编程中可能经常不确定会有多少个对象。如果使用数组那么一旦数量超过了数组的长度就将发生异常：java.lang.ArrayIndexOutOfBoundsException（这个异常表示数组下标越界）。集合的出现就是为了持有对象，集合中可以存储任意类型的对象,而且长度可变。\"]},\"228\":{\"h\":\"数组Array和集合ArrayList的区别\",\"t\":[\"数组Array\",\"数组在内存中是连续存储的，所以它的索引速度是非常的快，而且赋值与修改元素也很简单\",\"声明数组的时候，必须同时指明数组的长度，数组的长度过长，会造成内存浪费，数组和长度过短，会造成数据溢出的错误。\",\"数组只能存放类型一样的数据（基本类型/引用类型）\",\"集合List（ArrayList)\",\"容量可动态增长；但牺牲效率\",\"ArrayList内部封装了一个Object类型的数组\",\"可以将 ArrayList想象成一种“会自动扩增容量的Array”\"]},\"229\":{\"h\":\"Arraylist 和 LinkedList 的区别?\",\"t\":[\"是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\",\"底层数据结构：Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\",\"插入和删除是否受元素位置的影响：\",\"ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\",\"LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。\",\"是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\",\"内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\",\"双向链表： 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。\",\"双向循环链表： 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。\",\"参考：看图轻松理解数据结构与算法系列(双向链表)\"]},\"230\":{\"h\":\"ArraysList 为什么实现 接口？\",\"t\":[\"public interface RandomAccess { }\",\"RandomAccess的源码如上，什么都没有定义。所以它只是一个标识。阅读接口的注释，不难发现，这个接口的实现类具有随机访问功能。注释的翻译如下（百度机翻）\",\"RandomAccess 接口的注释\",\"列表实现所使用的标记接口，用于指示它们支持快速（通常为常数时间）随机访问。该接口的主要目的是允许通用算法在应用于随机或顺序访问列表时改变其行为，以提供良好的性能。\",\"操作随机访问列表（如ArrayList）的最佳算法在应用于顺序访问列表（如LinkedList）时会产生二次行为。鼓励通用列表算法在应用算法之前检查给定列表是否是该接口的实例，如果将该算法应用于顺序访问列表，该算法将提供较差的性能，并在必要时改变其行为，以保证可接受的性能。\",\"人们认识到，随机存取和顺序存取之间的区别往往是模糊的。例如，一些列表实现提供了渐近线性的访问时间，如果它们在实践中获得了巨大但恒定的访问时间。这样的列表实现通常应该实现这个接口。根据经验，如果对于类的典型实例，该循环： for (int i=0, n=list.size(); i < n; i++) list.get(i);\",\"运行速度比下面这个循环快： for (Iterator i=list.iterator(); i.hasNext(); ) i.next();\",\"在很多源码中，我们都能看到使用RandomAccess的例子。比如Collections#binarySearch()方法。\",\"如果要搜索的list实现类实现了RandomAccess，则调用indexedBinarySearch，否则调用iteratorBinarySearch。在前者使用list.get(index)来获取元素，而后者使用list.listIterator()的方式来遍历获取元素。前者效率是要高一些的。\",\"public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) { if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); }\"]},\"231\":{\"h\":\"ArrayDeque 与 LinkedList 的区别\",\"t\":[\"ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？\",\"ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。\",\"ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。\",\"ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。\",\"ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。\",\"从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。\"]},\"232\":{\"h\":\"ArrayList 的扩容机制\",\"t\":[\"参考这里\",\"默认长度为10，扩容时扩一半。\"]},\"233\":{\"h\":\"Arrays.asList()方法的作用？注意事项？\",\"t\":[\"这个方法可以把数组转为list，适用于对象型数据的数组。有以下注意事项：\",\"Arrays.asList()是泛型方法，传递的数组必须是对象数组，而不是基本类型。\",\" int[] myArray = {1, 2, 3}; List myList = Arrays.asList(myArray); System.out.println(myList.size());//1 System.out.println(myList.get(0));//数组地址值 System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException int[] array = (int[]) myList.get(0); System.out.println(array[0]);//1\",\"当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。\",\"可以使用包装类型数组就可以解决这个问题：Integer[] myArray = {1, 2, 3};\",\"该方法返回的ArrayList全限定名是java.util.Arrays.ArrayList。这个类继承了AbstractList，长度是不可改变的，也没有重写add()、remove()、clear()等方法。因此调用这些方法时会报错。\"]},\"234\":{\"h\":\"将数组转换为集合（List）？\",\"t\":[\"手动实现\",\"//JDK1.5+ static <T> List<T> arrayToList(final T[] array) { final List<T> l = new ArrayList<T>(array.length); for (final T s : array) { l.add(s); } return l; } Integer [] myArray = { 1, 2, 3 }; System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList\",\"较简单的方法\",\"List list = new ArrayList<>(Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\"))\",\"使用Java8的stream(推荐)\",\"Integer [] myArray = { 1, 2, 3 }; List myList = Arrays.stream(myArray).collect(Collectors.toList()); //基本类型也可以实现转换（依赖boxed的装箱操作） int [] myArray2 = { 1, 2, 3 }; List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());\"]},\"235\":{\"h\":\"将集合（List）转换为数组？\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。\",\"toArray(T[] array) 方法的参数是一个泛型数组，如果 toArray 方法中没有传递任何参数的话返回的是 Object类 型数组。\",\"String [] s= new String[]{ \\\"dog\\\", \\\"lazy\\\", \\\"a\\\", \\\"over\\\", \\\"jumps\\\", \\\"fox\\\", \\\"brown\\\", \\\"quick\\\", \\\"A\\\" }; List<String> list = Arrays.asList(s); Collections.reverse(list); //没有指定类型的话会报错 s=list.toArray(new String[0]);\"]},\"236\":{\"c\":[\"学习笔记\",\"Java容器\"]},\"237\":{\"c\":[\"基础\"]},\"238\":{\"h\":\"Map\",\"t\":[\"相关参考文章🍉\",\"红黑树深入剖析及Java实现\",\"以下内容出自JavaGuide。\"]},\"239\":{\"h\":\"HashMap 和 Hashtable 的区别\",\"t\":[\"线程是否安全：HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\",\"效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；\",\"对 Null key 和 Null value 的支持：HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。\",\"初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。\",\"底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\",\"HashMap 中带有初始容量的构造函数：\",\" public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); }\",\"下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。\",\" /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }\"]},\"240\":{\"h\":\"HashMap 和 HashSet 区别\",\"t\":[\"如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。\",\"HashMap\",\"HashSet\",\"实现了 Map 接口\",\"实现 Set 接口\",\"存储键值对\",\"仅存储对象\",\"调用 put()向 map 中添加元素\",\"调用 add()方法向 Set 中添加元素\",\"HashMap 使用键（Key）计算 hashcode\",\"HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性\"]},\"241\":{\"h\":\"HashMap 和 TreeMap 区别\",\"t\":[\"TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。\",\"实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。\",\"实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：\",\"/** * @author shuang.kou * @createTime 2020年06月15日 17:02:00 */ public class Person { private Integer age; public Person(Integer age) { this.age = age; } public Integer getAge() { return age; } public static void main(String[] args) { TreeMap<Person, String> treeMap = new TreeMap<>(new Comparator<Person>() { @Override public int compare(Person person1, Person person2) { int num = person1.getAge() - person2.getAge(); return Integer.compare(num, 0); } }); treeMap.put(new Person(3), \\\"person1\\\"); treeMap.put(new Person(18), \\\"person2\\\"); treeMap.put(new Person(35), \\\"person3\\\"); treeMap.put(new Person(16), \\\"person4\\\"); treeMap.entrySet().stream().forEach(personStringEntry -> { System.out.println(personStringEntry.getValue()); }); } }\",\"输出:\",\"person1 person4 person2 person3\",\"可以看出，TreeMap 中的元素已经是按照 Person 的 age 字段的升序来排列了。\",\"上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：\",\"TreeMap<Person, String> treeMap = new TreeMap<>((person1, person2) -> { int num = person1.getAge() - person2.getAge(); return Integer.compare(num, 0); });\",\"综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。\"]},\"242\":{\"h\":\"HashSet 如何检查重复\",\"t\":[\"以下内容摘自我的 Java 启蒙书《Head first java》第二版：\",\"当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。\",\"在openjdk8中，HashSet的add()方法只是简单的调用了HashMap的put()方法，并且判断了一下返回值以确保是否有重复元素。直接看一下HashSet中的源码：\",\"// Returns: true if this set did not already contain the specified element // 返回值：当set中没有包含add的元素时返回真 public boolean add(E e) { return map.put(e, PRESENT)==null; }\",\"而在HashMap的putVal()方法中也能看到如下说明：\",\"// Returns : previous value, or null if none // 返回值：如果插入位置没有元素返回null，否则返回上一个元素 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { ... }\",\"也就是说，在openjdk8中，实际上无论HashSet中是否已经存在了某元素，HashSet都会直接插入，只是会在add()方法的返回值处告诉我们插入前是否存在相同元素。\",\"hashCode()与 equals() 的相关规定：\",\"如果两个对象相等，则 hashcode 一定也是相同的\",\"两个对象相等,对两个 equals() 方法返回 true\",\"两个对象有相同的 hashcode 值，它们也不一定是相等的\",\"综上，equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖\",\"hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\",\"==与 equals 的区别\",\"对于基本类型来说，== 比较的是值是否相等；\",\"对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；\",\"对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。\"]},\"243\":{\"h\":\"HashMap 的底层实现\"},\"244\":{\"h\":\"JDK1.8 之前\",\"t\":[\"JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\",\"所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\",\"JDK 1.8 HashMap 的 hash 方法源码:\",\"JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\",\" static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }\",\"对比一下 JDK1.7 的 HashMap 的 hash 方法源码.\",\"static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); }\",\"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\",\"所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\",\"[此处需要补充图片：jdk1.8之前的内部结构-HashMap.png]\"]},\"245\":{\"h\":\"JDK1.8 之后\",\"t\":[\"相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\",\"TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\"]},\"246\":{\"h\":\"HashMap 的长度为什么是 2 的幂次方\",\"t\":[\"为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) & hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。\",\"这个算法应该如何设计呢？\",\"我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。\"]},\"247\":{\"h\":\"HashMap 多线程操作导致死循环问题\",\"t\":[\"主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。\",\"详情请查看：https://coolshell.cn/articles/9606.html\"]},\"248\":{\"h\":\"HashMap 有哪几种常见的遍历方式?\",\"t\":[\"HashMap 的 7 种遍历方式与性能分析！\"]},\"249\":{\"h\":\"ConcurrentHashMap 和 Hashtable 的区别\",\"t\":[\"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\",\"底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\",\"实现线程安全的方式（重要）：\",\"① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\",\"② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\",\"两者的对比图：\",\"Hashtable:\",\"Hashtable全表锁\",\"https://www.cnblogs.com/chengxiao/p/6842045.html>\",\"JDK1.7 的 ConcurrentHashMap：\",\"JDK1.7的ConcurrentHashMap\",\"https://www.cnblogs.com/chengxiao/p/6842045.html>\",\"JDK1.8 的 ConcurrentHashMap：\",\"Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）\",\"JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。\"]},\"250\":{\"h\":\"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现\"},\"251\":{\"h\":\"JDK1.7（上面有示意图）\",\"t\":[\"首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\",\"ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。\",\"Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。\",\"static class Segment<K,V> extends ReentrantLock implements Serializable { }\",\"一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。\"]},\"252\":{\"h\":\"JDK1.8 （上面有示意图）\",\"t\":[\"ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）\",\"synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。\"]},\"253\":{\"h\":\"求大于等于指定数的最小的二次幂？\",\"t\":[\"HashMap的tableSizeFor方法能衍生出来一个很有意思的问题。该方法内容如下：\",\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }\",\"我们假设 cap = 321，那么n = 320，二进制表达为：0001 0100 0000\",\"n |= n >>> 1：n>>>1意思是无符号右移1位，结果为 1010 0000。与运算后结果：0001 1110 0000\",\"n |= n >>> 2：n>>>2意思是无符号右移2位，结果为 0111 1000。与运算后结果：0001 1111 1000\",\"n |= n >>> 4：n>>>4意思是无符号右移4位，结果为 0001 1111。与运算后结果：0001 1111 1111\",\"n |= n >>> 8：n>>>8意思是无符号右移8位，结果为 0000 0001。与运算后结果：0001 1111 1111\",\"n |= n >>> 16：n>>>8意思是无符号右移16位，结果为 0000 0000。与运算后结果：0001 1111 1111\",\"最终结果为：0001 1111 1111，10进制表示为511。最终结果+1，为512。即表示最终结果。\",\"可以看到，算法里位运算的作用，是把原始数据里的1，复制到每个低位上。最后再加1，整个二进制就只包含1个1，即等于二次幂。\",\"那开始为什么要先减1呢？如果给的元素数据就是二次幂，如1024，不减1就会得到2048：\",\"0100 0000 0000 -> 0110 0000 0000 -> 0111 1000 0000 -> 0111 1111 1000 -> 0111 1111 1111 -> 0111 1111 1111 -> 1000 0000 0000，结果为2048。\",\"这个方法原本是确定HashMap内部数值的长度的，如果恰好给了一个二次幂，那就需要返回其本身。因此算法这样设计。\",\"那为什么要分别进行1,2,4,8,16次无符号右移呢？这样恰好能覆盖int的最大值。\"]},\"254\":{\"c\":[\"学习笔记\",\"Java容器\"]},\"255\":{\"c\":[\"基础\"]},\"256\":{\"h\":\"Collections工具类\",\"t\":[\"Collections 工具类常用方法：\",\"排序\",\"查找,替换操作\",\"同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)\"]},\"257\":{\"h\":\"排序操作\",\"t\":[\"void reverse(List list)//反转 void shuffle(List list)//随机排序 void sort(List list)//按自然排序的升序排序 void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑 void swap(List list, int i , int j)//交换两个索引位置的元素 void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面\"]},\"258\":{\"h\":\"查找,替换操作\",\"t\":[\"int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的 int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll) int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素 int frequency(Collection c, Object o)//统计元素出现次数 int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target) boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素\"]},\"259\":{\"h\":\"同步控制\",\"t\":[\"Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。\",\"我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。\",\"最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。\",\"方法如下：\",\"synchronizedCollection(Collection<T> c) //返回指定 collection 支持的同步（线程安全的）collection。 synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。 synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。 synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。\"]},\"260\":{\"c\":[\"学习笔记\",\"Java容器\"]},\"261\":{\"c\":[\"collections\"]},\"262\":{\"h\":\"多线程概述\",\"t\":[\"以下列出的文章均来自网络。全是干货。面试必备🎉🎉🎉\",\"List🍉\",\"美团技术团队 - 不可不说的Java“锁”事\",\"美团技术团队 - 从ReentrantLock的实现看AQS的原理及应用\",\"美团技术团队 - Java类文章\"]},\"263\":{\"h\":\"多线程面试题\"},\"264\":{\"h\":\"什么是进程，线程？\",\"t\":[\"进程是指在系统中正在运行的一个应用程序；线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元。 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。可以理解成是在进程中独立运行的子任务。\"]},\"265\":{\"h\":\"线程唤醒的方法？\",\"t\":[\"Object的wait, notify\",\"JUC下，Condition的await, signal\",\"LockSupport类。\"]},\"266\":{\"h\":\"说下Java线程的生命周期？\",\"t\":[\"1\",\"图中 runnable 到 wait 状态的转换中，join实际上是Thread类的方法，但这里写成了Object。\"]},\"267\":{\"h\":\"上下文切换是什么？\",\"t\":[\"线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。\",\"主动让出 CPU，比如调用了 sleep(), wait() 等。\",\"时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。\",\"调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\",\"被终止或结束运行\",\"这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\",\"上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\"]},\"268\":{\"h\":\"说说并发与并行的区别?\",\"t\":[\"并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；\",\"并行： 单位时间内，多个任务同时执行。\"]},\"269\":{\"h\":\"什么是死锁？产生死锁的条件？\",\"t\":[\"所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 产生死锁的必要条件：\",\"互斥条件：该资源任意一个时刻只由一个线程占用。\",\"请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\",\"不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\",\"循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\"]},\"270\":{\"h\":\"开发中如何避免死锁呢？\",\"t\":[\"破坏请求与保持条件 ：一次性申请所有的资源。\",\"破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\",\"破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\",\"参考：Java多线程 开发中避免死锁的八种方法\"]},\"271\":{\"h\":\"可重入锁？\",\"t\":[\"“可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。\"]},\"272\":{\"h\":\"LockSupport？\"},\"273\":{\"h\":\"Sleep和wait的区别？\",\"t\":[\"sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法。例如，当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。并且可以调用notify()方法或者notifyAll()方法通知正在等待的其他线程。notify()方法仅唤醒一个线程（等待队列中的第一个线程）并允许他去获得锁。notifyAll()方法唤醒所有等待这个对象的线程并允许他们去竞争获得锁。具体区别如下：\",\"原理不同。sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，他会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动苏醒。例如，当线程执行报时功能时，每一秒钟打印出一个时间，那么此时就需要在打印方法前面加一个sleep()方法，以便让自己每隔一秒执行一次，该过程如同闹钟一样。而wait()方法是object类的方法，用于线程间通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程调用notify()方法或者notifyAll()时才醒来，不过开发人员也可以给他指定一个时间，自动醒来。\",\"对锁的处理机制不同。由于sleep()方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通信，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。\",\"使用区域不同。wait()方法必须放在同步控制方法和同步代码块中使用，sleep()方法则可以放在任何地方使用。sleep()方法必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用他的interrupt()，产生InterruptedException。由于sleep不会释放锁标志，容易导致死锁问题的发生，因此一般情况下，推荐使用wait()方法。\"]},\"274\":{\"h\":\"使用线程池的好处？\",\"t\":[\"降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\",\"提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\",\"提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\"]},\"275\":{\"h\":\"线程池的基本参数？线程池的拒绝策略？\",\"t\":[\"corePoolSize（核心线程数量） 向线程池提交一个任务，此时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）\",\"maximumPoolSize（最大线程数量） 线程池所允许的最大同时可执行线程数量。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。\",\"keepAliveTime（线程存活保持时间） 当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。\",\"TimeUnit: 存活时间单位\",\"workQueue（任务队列） 用于传输和保存等待执行任务的阻塞队列。\",\"threadFactory（线程工厂） 用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。\",\"handler（线程饱和策略）\",\"队列满，并且线程达到最大线程数量的时候，对新任务的拒绝策略\",\"拒绝策略共有4种，也是 RejectedExecutionHandler 接口的4个实现类（前3种都会导致有任务丢弃）：\",\"ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。\",\"hreadPoolExecutor.DiscardPolicy: 丢弃任务，但是不抛出异常。\",\"ThreadPoolExecutor.DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新提交被拒绝的任务。\",\"ThreadPoolExecutor.CallerRunsPolicy: 由调用线程（提交任务的线程）处理该任务。\"]},\"276\":{\"h\":\"StringBuffer跟StringBuilder哪个线程安全？是怎么实现的？\",\"t\":[\"StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\"]},\"277\":{\"h\":\"线程池从建立开始的任务调度机制？举例说明线程池调优？\",\"t\":[\"线程池的工作过程如下：\",\"线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。\",\"当调用 execute() 方法添加一个任务时，线程池会做如下判断：\",\"如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\",\"如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\",\"如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\",\"如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。\",\"当一个线程完成任务时，它会从队列中取下一个任务来执行。\",\"当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\",\"一般需要根据任务的类型来配置线程池大小：\",\"如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1。\",\"如果是IO密集型任务，参考值可以设置为2*NCPU。\",\"当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。\"]},\"278\":{\"h\":\"Synchronize原理？偏向锁、自旋锁、轻量级锁、重量级锁都是啥？\",\"t\":[\"参考：\",\"深入理解Java并发之synchronized实现原理\",\"Java锁与线程的那些事 - 有赞\",\"Java6及以上版本对synchronized的优化\",\"synchronized原理\",\"Java 虚拟机中的同步基于Monitor对象实现。同步代码块是显式同步，有明确的 monitorenter 和 monitorexit 指令；同步方法是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。\",\"一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成。其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等。除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：锁状态、偏向锁(Java6)、轻量级锁(Java6)、重量级锁等。\",\"缺点：Java 6 以前，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。\",\"Java 6 之后\",\"庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\",\"偏向锁:\",\"Java6之后加入的新锁，是对锁操作的优化手段。在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。\",\"偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。\",\"但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失。偏向锁失败后，会升级为轻量级锁。\",\"轻量级锁:\",\"倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是对绝大部分的锁，在整个同步周期内都不存在竞争，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。\",\"自旋锁:\",\"轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。\",\"自适应自旋锁:\",\"自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：\",\"如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。\",\"相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。\",\"自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。\",\"重量级锁:\",\"内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。\",\"锁消除:\",\"消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。\"]},\"279\":{\"h\":\"锁膨胀、锁降级？\",\"t\":[\"锁膨胀为偏向锁 > 轻量级锁 > 重量级锁的过程。具体见上一条。\",\"大部分资料中说JVM不支持锁降级。但这篇文档说明可以：https://www.jianshu.com/p/9932047a89be。\",\"大部分资料中说的锁降级发生在读写锁ReentrantReadWriteLock中，是写锁降级读锁的过程。锁降级的本质是释放掉独占锁，使其他线程可以获取到读锁，提高并发，而当前线程持有读锁来保证数据的可见性。\"]},\"280\":{\"h\":\"ThreadLocal使用会有什么问题？\",\"t\":[\"存在内存泄漏问题。\",\"内存泄漏：\",\"存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。\",\"产生原因：\",\"ThreadLocal自身并不储存值，而是作为一个key来让线程从ThreadLocal获取value。Entry是中的key是弱引用，所以jvm在垃圾回收时如果外部没有强引用来引用它，ThreadLocal必然会被回收。但是，作为ThreadLocalMap的key，ThreadLocal被回收后，ThreadLocalMap就会存在null，但value不为null的Entry。若当前线程一直不结束，可能是作为线程池中的一员，线程结束后不被销毁，或者分配（当前线程又创建了ThreadLocal对象）使用了又不再调用get/set方法，就可能引发内存泄漏。其次，就算线程结束了，操作系统在回收线程或进程的时候不是一定杀死线程或进程的，在繁忙的时候，只会清除线程或进程数据的操作，重复使用线程或进程（线程id可能不变导致内存泄漏）。因此，key弱引用并不是导致内存泄漏的原因，而是因为ThreadLocalMap的生命周期与当前线程一样长，并且没有手动删除对应key。\",\"解决:\",\"在使用完ThreadLocal时，及时调用它的的remove方法清除数据。\",\"ThreadLocal在预防内存泄漏方面，做了哪些努力？\",\"在ThreadLocal中，进行get，set操作的时候会清除Map里所有key为null的value。\"]},\"281\":{\"h\":\"Synchronize跟Volatile的区别？\",\"t\":[\"volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\"]},\"282\":{\"h\":\"Synchronzed原理？和Lock的区别？\",\"t\":[\"Synchronzed是java关键字基于JVM层面；Lock指具体的类（ReentrantLock）\",\"Synchronzed会自动释放锁；Lock需要手动释放锁\",\"Synchronzed是非公平锁；Lock默认是非公平锁，但可以根据构造参数指定为公平锁\",\"Synchronzed不可中断，除非异常或成功执行结束；Lock可中断设置超时tryLock（timeout,unit）或lockInterruptibly()放代码块里，调用interrupt()方法中断。\",\"Synchronzed不能唤醒指定线程;Lock可以唤醒指定线程(Condition)；lock.newCondition()\"]},\"283\":{\"h\":\"synchronized与reentrantlock的异同、底层原理？\"},\"284\":{\"h\":\"两者都是可重入锁\",\"t\":[\"“可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。\"]},\"285\":{\"h\":\"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API\",\"t\":[\"synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。\"]},\"286\":{\"h\":\"ReentrantLock 比 synchronized 增加了一些高级功能\",\"t\":[\"相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：\",\"等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\",\"可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。\",\"可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。\",\"Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。\"]},\"287\":{\"h\":\"wait()跟notify()是否可以脱离synchronize使用？\"},\"288\":{\"h\":\"wait()跟notify()为什么是对象的方法？\",\"t\":[\"调用wait(), notify()或notifyAll()的时候，必须先获得锁，且状态变量须由该锁保护，而固有锁对象与固有条件队列对象又是同一个对象。也就是说，要在某个对象上执行wait，notify，先必须锁定该对象，而对应的状态变量也是由该对象锁保护的。\",\"原因一：Java中，任何对象都可以作为锁，既然wait是放弃对象锁，当然就要把wait定义在这个对象所属的类中。更通用一些，由于所有类都继承于Object，我们完全可以把wait方法定义在Object类中，这样，当我们定义一个新类，并需要以它的一个对象作为锁时，不需要我们再重新定义wait方法的实现，而是直接调用父类的wait(也就是Object的wait)，此处，用到了Java的继承。\",\"原因二：有的人会说，既然是线程放弃对象锁，那也可以把wait定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。\"]},\"289\":{\"h\":\"以ReentrantLock为例。说下AQS的原理？\",\"t\":[\"AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\",\"CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。\",\"美团-从ReentrantLock的实现看AQS的原理及应用\",\"https://blog.csdn.net/lldouble/article/details/80940110\"]},\"290\":{\"h\":\"公平锁的实现原理？\",\"t\":[\"非公平锁：不管等待顺序，每个线程获取锁的概率都是相等的，优点是提高了响应速度，不用把大量时间花费在线程调度上，而是花费在执行代码上。\",\"实现方式：首先获取到当前线程，判断当前锁的状态是否为0，如果是，说明当前锁没有被其他线程占有，则利用CAS操作将锁的状态从0置为1成功后，将锁的持有者置为当前线程。\",\"公平锁：按照线程等待顺序获取锁，一般将获取锁失败的线程放入等待队列中，每次从FIFO队列的队头取出线程获取锁。这种方式会造成性能低下，大量的时间花费在线程调度上。\",\"实现方式：在非公平锁的实现上，加了一层判断hasQueuedPredecessors()，该方法的大概意思是判断是否有线程等待的时间比当前线程等待时间还要久，如果有返回true，则当前线程获取锁失败，如果没有返回false，当前线程获取到锁，也就是判断当前线程是否是等待队列的队头元素。\"]},\"291\":{\"h\":\"怎么使用线程池的，有哪些获取方法\",\"t\":[\"Executors.newFixedThreadPool(int i)：创建一个拥有 i 个线程的线程池\",\"执行长期的任务，性能好很多\",\"创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待\",\"Executors.newSingleThreadExecutor()：创建一个只有1个线程的 单线程池\",\"一个任务一个任务执行的场景\",\"创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行\",\"Executors.newCacheThreadPool()：创建一个可扩容的线程池\",\"执行很多短期异步的小程序或者负载教轻的服务器\",\"创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程\",\"Executors.newScheduledThreadPool()： 可以设定从该线程池中获得线程的最小间隔时间\",\"new ThreadPoolExecutor() 这也是阿里Java开发手册中推荐的写法。\",\"这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\",\"Executors返回的线程池对象的弊端如下：\",\"FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。\",\"CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。\",\"美团-Java线程池实现原理及其在美团业务中的实践\"]},\"292\":{\"h\":\"juc包下熟悉哪些类？分别描述原理\",\"t\":[\"CountDownLatch 这个类是一个同步计数器，主要用于线程间的控制，当CountDownLatch的count计数>0时，await()会造成阻塞，直到count变为0，await()结束阻塞。如果我想让其他线程执行完指定程序，其他所有程序都执行结束后我再执行，这时可以用CountDownLatch。但计数无法被重置，如果需要重置计数，请考虑使用 CyclicBarrier 。\",\"CyclicBarrier 循环屏障。它可以协同多个线程，让多个线程在这个屏障前等到，直到所有线程都到达了这个屏障时，再一起执行后面的操作。假如每个线程各有一个await，任何一个线程运行到await方法时就阻塞，直到最后一个线程运行到await时才同时返回。和之前的CountDownLatch相比，它只有await方法，而CountDownLatch是使用countDown()方法将计数器减到0，它创建的参数就是countDown的数量；CyclicBarrier创建时的int参数是await的数量。\",\"Semaphore 该类用于控制信号量的个数，构造时传入个数。Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。方法：acquire(), release()。\",\"Exchanger 这个类用于交换数据，只能用于两个线程。当一个线程运行到exchange()方法时会阻塞，另一个线程运行到exchange()时，二者交换数据，然后执行后面的程序。\",\"ReentrantLock\",\"ConcurrentHashMap concurrenthashmap原理，1.7/1.8区别\",\"CopyonWriteArrayList\",\"copyonwriteArrayList 原理和存在的问题\"]},\"293\":{\"h\":\"惊群效应？\",\"t\":[\"https://blog.csdn.net/second60/article/details/81252106https://www.zhihu.com/question/22756773\"]},\"294\":{\"h\":\"分布式唯一主键生成方案？\"},\"295\":{\"h\":\"synchronized保证有序性？\"},\"296\":{\"h\":\"锁升级锁降级\"},\"297\":{\"h\":\"线程执行顺序，Semaphore，join\"},\"298\":{\"h\":\"微信抢红包方案？\",\"t\":[\"无锁机制，将一批请求放进消息队列中，串行化消费\"]},\"299\":{\"h\":\"JVM面试题\"},\"300\":{\"h\":\"介绍下 Java 内存区域（运行时数据区）\",\"t\":[\"JDK 1.8 和之前的版本略有不同。\",\"1\",\"线程私有的：\",\"程序计数器\",\"虚拟机栈\",\"本地方法栈\",\"线程共享的：\",\"堆\",\"方法区（1.8之前hotspot的实现方式是永久代。之后是元空间，使用的是直接内存）\",\"直接内存 （非运行时数据区的一部分）\"]},\"301\":{\"h\":\"程序计数器\",\"t\":[\"程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\",\"另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\",\"程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\",\"具体内容见 这里\"]},\"302\":{\"h\":\"Java虚拟机栈\",\"t\":[\"Java 虚拟机栈是由一个个栈帧组成。与程序计数器一样，也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。\",\"Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\",\"Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。\",\"StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\",\"OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\"]},\"303\":{\"h\":\"本地方法栈\",\"t\":[\"和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\",\"本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\",\"方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\",\"在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。\"]},\"304\":{\"h\":\"堆\",\"t\":[\"Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\",\"Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。\",\"在 JDK 8 版本之前，堆内存被通常分为下面三部分：\",\"新生代(Young Generation)（Eden S0 S1。8:1:1）\",\"老年代(Old Generation)\",\"永久代(Permanent Generation)（永久代可以不考虑。把它看作方法区的具体实现。）\",\"堆这里最容易出现的就是 OutOfMemoryError 错误\"]},\"305\":{\"h\":\"方法区\",\"t\":[\"用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的。\",\"虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\",\"注\",\"方法区相当于 『接口』，永久代和元空间则是1.7和1.8版本对它的『实现』。\",\"方法区是 Java 虚拟机规范中的定义，永久代是 HotSpot 的概念。其他的虚拟机实现并没有永久代这一说法。\",\"垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。\",\"常用参数：\",\"// 1.7 -XX:PermSize=N //方法区 (永久代) 初始大小 -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen // 1.8。 -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小\",\"与永久代不同，如果不指定Metaspace大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\"]},\"306\":{\"h\":\"为什么要将永久代替换为元空间？\",\"t\":[\"主要原因：\",\"永久代有固定大小的限制，但有时很难确定。动态加载的类过多，容易产生Perm区的OOM。\",\"对永久代进行调优是很困难的。\",\"在JDK8合并 HotSpot 和 JRockit。要考虑JRockit客户不配置永久代的习惯。\",\"具体见 这里\"]},\"307\":{\"h\":\"运行时常量池（方法区的一部分）\",\"t\":[\"Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）\",\"会受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\",\"JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代\",\"JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\",\"JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)\"]},\"308\":{\"h\":\"直接内存\",\"t\":[\"直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。\",\"JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。\",\"本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\"]},\"309\":{\"h\":\"Java 对象的创建过程\",\"t\":[\"img\"]},\"310\":{\"h\":\"\",\"t\":[\"虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\"]},\"311\":{\"h\":\"Step2:分配内存\",\"t\":[\"在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\"]},\"312\":{\"h\":\"Step3:初始化零值\",\"t\":[\"内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\"]},\"313\":{\"h\":\"Step4:设置对象头\",\"t\":[\"初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\"]},\"314\":{\"h\":\"Step5:执行 init 方法\",\"t\":[\"在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\",\"具体见 这里\"]},\"315\":{\"h\":\"对象的访问定位的两种方式（句柄和直接指针两种方式）\",\"t\":[\"建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：\",\"句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\",\"直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。\",\"这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\"]},\"316\":{\"h\":\"String 类和常量池\"},\"317\":{\"h\":\"常量池\",\"t\":[\"字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\",\"对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。\",\"字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。称为常量折叠(Constant Folding)\",\"JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。\",\"String str1 = \\\"str\\\"; String str2 = \\\"ing\\\"; String str3 = \\\"str\\\" + \\\"ing\\\";//常量池中的对象 String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = \\\"string\\\";//常量池中的对象 System.out.println(str3 == str4);//false System.out.println(str3 == str5);//true System.out.println(str4 == str5);//false\",\"上方代码中，str1、str2、str3都会被放入常量池，属于字符串常量池中的对象。其中，对于 String str3 = \\\"str\\\" + \\\"ing\\\"; 编译器会优化成 String str3 = \\\"string\\\"; ，因为str3是编译器在程序编译期就可以确定值的常量。\",\"而对于str4，属于对象引用之间以“+”的方式拼接，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。上方str4的定义等于：\",\"String str4 = new StringBuilder().append(str1).append(str2).toString();\",\"因此，str4 并不是字符串常量池中存在的对象，属于堆上的新对象。\",\"特殊情况1：\",\"被 final 关键字修改之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。如下方代码中的 d。虽然也是以“+”拼接对象引用，但这两个引用是final修饰的，编译器就能确认值。因此d也会被放入常量池，或从常量池中查找。因此c == d。\",\"final String str1 = \\\"str\\\"; final String str2 = \\\"ing\\\"; // 下面两个表达式其实是等价的 String c = \\\"str\\\" + \\\"ing\\\";// 常量池中的对象 String d = str1 + str2; // 常量池中的对象 System.out.println(c == d);// true\",\"特殊情况2：\",\"下方代码中str2虽然也用final修饰了，但它的值来自后面的方法，编译器不能确定。因此不能优化。因此d不能优化，c == d 返回false。\",\"final String str1 = \\\"str\\\"; final String str2 = getStr(); String c = \\\"str\\\" + \\\"ing\\\";// 常量池中的对象 String d = str1 + str2; // 在堆上创建的新的对象 System.out.println(c == d);// false public static String getStr() { return \\\"ing\\\"; }\",\"另一个例子\",\"String str1 = \\\"abcd\\\"; // 从字符串常量池中拿对象 String str2 = new String(\\\"abcd\\\"); // 直接在堆内存空间创建一个新的对象 String str3 = new String(\\\"abcd\\\"); // 直接在堆内存空间创建一个新的对象 System.out.println(str1==str2); // false System.out.println(str2==str3); // false\"]},\"318\":{\"h\":\"String.intern()方法的含义？\",\"t\":[\"String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中，减少不必要的内存开销。\",\"String s1 = \\\"Javatpoint\\\"; String s2 = s1.intern(); String s3 = new String(\\\"Javatpoint\\\"); String s4 = s3.intern(); System.out.println(s1==s2); // True System.out.println(s1==s3); // False。s3会直接创建新对象 System.out.println(s1==s4); // True。s3.intern()返回的是常量池中这个串的引用，也就是s1 System.out.println(s2==s3); // False。s2来自常量池，s3来自堆 System.out.println(s2==s4); // True。都来自常量池 System.out.println(s3==s4); // False。s3来自堆，s4来自常量池\",\"总结：我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 String 对象（ String s1 = \\\"java\\\" ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。\"]},\"319\":{\"h\":\"String s1 = new String(\\\"abc\\\") 创建了几个对象？\",\"t\":[\"会创建 1 或 2 个字符串：\",\"如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。\",\"如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。\",\"问题：\",\"String s1 = new String(\\\"ja\\\").concat(\\\"va\\\"); System.out.println(s1 == s1.intern()); String s2 = new String(\\\"te\\\").concat(\\\"st\\\"); System.out.println(s2 == s2.intern());\",\"上方代码执行的结果是false；true。\",\"jvm加载的过程中，会在常量池内创建一个“java”字符串。因此，s1.intern()返回的就是加载过程中创建的那个常量池中的字符串，而s1指向堆。二者不一致，返回false。\",\"而s2.intern()执行时，发现常量池里没有“test”字符串，因此会把堆中s2对象的引用放在常量池中。这正好和s2的引用一致。因此返回true。\"]},\"320\":{\"h\":\"对象已经死亡？\"},\"321\":{\"h\":\"引用计数法\",\"t\":[\"给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。\",\"这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 相互引用的对象，它们的引用计数器都不为 0，永远无法回收。\"]},\"322\":{\"h\":\"可达性分析算法\",\"t\":[\"通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\",\"哪些对象可以作为 GC Roots 呢？\",\"虚拟机栈(栈帧中的本地变量表)中引用的对象\",\"本地方法栈(Native 方法)中引用的对象\",\"方法区中类静态属性引用的对象\",\"方法区中常量引用的对象\",\"所有被同步锁持有的对象\"]},\"323\":{\"h\":\"对象可以被回收，就代表一定会被回收吗？\",\"t\":[\"即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\",\"被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\"]},\"324\":{\"h\":\"4种引用类型\",\"t\":[\"JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\"]},\"325\":{\"h\":\"强引用（StrongReference）\",\"t\":[\"以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\"]},\"326\":{\"h\":\"软引用（SoftReference）\",\"t\":[\"如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\",\"软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\"]},\"327\":{\"h\":\"弱引用（WeakReference）\",\"t\":[\"如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\",\"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\"]},\"328\":{\"h\":\"虚引用（PhantomReference）\",\"t\":[\"\\\"虚引用\\\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\",\"虚引用主要用来跟踪对象被垃圾回收的活动。\",\"虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\",\"在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\"]},\"329\":{\"h\":\"如何判断一个类是无用的类\",\"t\":[\"该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\"]},\"330\":{\"h\":\"垃圾收集算法\",\"t\":[\"具体见 这里\"]},\"331\":{\"h\":\"类加载器\",\"t\":[\"JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：\",\"BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。\",\"ExtensionClassLoader(扩展类加载器) ：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。\",\"AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。\"]},\"332\":{\"h\":\"双亲委派模型\",\"t\":[\"每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。\",\"public class ClassLoaderDemo { public static void main(String[] args) { System.out.println(ClassLoaderDemo.class.getClassLoader()); System.out.println(ClassLoaderDemo.class.getClassLoader().getParent()); System.out.println(ClassLoaderDemo.class.getClassLoader().getParent().getParent()); } }\",\"结果：\",\"sun.misc.Launcher$AppClassLoader@18b4aac2 sun.misc.Launcher$ExtClassLoader@1b6d3586 null\",\"AppClassLoader的父类加载器为ExtClassLoader， ExtClassLoader的父类加载器为 null，null 并不代表ExtClassLoader没有父类加载器，而是 BootstrapClassLoader 。因为**BootstrapClassLoader**不是java实现的，所以在java代码里获取不到。\"]},\"333\":{\"h\":\"双亲委派模型的好处\",\"t\":[\"双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。\"]},\"334\":{\"h\":\"重要的JVM参数\"},\"335\":{\"h\":\"设置内存大小\",\"t\":[\"-Xms<heap size>[unit] -Xmx<heap size>[unit]\",\"heap size 表示要初始化内存的具体大小。\",\"unit 表示要初始化内存的单位。单位为***“ g”*** (GB) 、“ m”（MB）、“ k”（KB）。\",\"如，-Xms2G -Xmx5G，表示最小2GB，最大5GB的堆内存。\"]},\"336\":{\"h\":\"设置新生代内存大小\",\"t\":[\"-XX:NewSize=<young size>[unit] -XX:MaxNewSize=<young size>[unit]\",\"上面的代码可以指定新生代内存(Young Ceneration)大小\",\"如-XX:NewSize=256m -XX:MaxNewSize=1024m表示新生代最小256m，最大 1024m的内存。\",\"也可以使用-Xmn256m ，表示为新生代分配256m的内存。\"]},\"337\":{\"h\":\"设置新生代和老年代内存的比值\",\"t\":[\"-XX:NewRatio=1\",\"上方代码用来设置新生代和老年代内存的比值。值为1表示新生代与老年代所占比值为1：1，新生代占整个堆栈的 1/2。\"]},\"338\":{\"h\":\"设置方法区（永久代/元空间）大小\",\"t\":[\"-XX:PermSize=N //1.7 方法区 (永久代) 初始大小 -XX:MaxPermSize=N //1.7 方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen\",\"上方代码为JDK 1.8 之前永久代还没被彻底移除的时候，用这些参数来调节方法区大小。\",\"-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\",\"JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。通过上方参数设置。\"]},\"339\":{\"h\":\"设置要使用的垃圾回收器\",\"t\":[\"-XX:+UseSerialGC // 串行垃圾收集器 -XX:+UseParallelGC // 并行垃圾收集器 -XX:+UseParNewGC // CMS垃圾收集器。jdk9被deprecated，在jdk14被正式从jdk中删除 -XX:+UseG1GC // G1垃圾收集器\",\"jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）\",\"jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）\",\"jdk1.9 默认垃圾收集器G1\"]},\"340\":{\"h\":\"JDK 命令行工具\",\"t\":[\"jps (JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；\",\"jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;\",\"jinfo (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;\",\"jmap (Memory Map for Java) : 生成堆转储快照;\",\"jhat (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;\",\"jstack (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合\"]},\"341\":{\"h\":\"JDK 可视化分析工具\",\"t\":[\"JConsole:Java 监视与管理控制台\",\"Visual VM:多合一故障处理工具\"]},\"342\":{\"h\":\"JVM简介\"},\"343\":{\"h\":\"JVM整体结构\",\"t\":[\"1595048291864-59d04e29-0e91-4b7d-a756-1b4505979a17\",\"方法区和堆区是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。\",\"Java栈又叫做jvm虚拟机栈\",\"方法区（永久代）在jdk8以后又叫做元空间Metaspace\",\"方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT编译器，英文写作Just-In-Time Compiler）编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\",\"在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代\",\"在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代\",\"在JDK1.8之后JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域\",\"java代码执行流程：\",\"java程序 ->（编译javac）-> 字节码文件.class -> 类装载子系统化身为反射类Class -> 运行时数据区 -> （解释执行）-> 操作系统（Win，Linux，Mac JVM）\",\"提示\",\"运行时环境，和JDK中的 Runtime 类对应。这个类也是单例的。\"]},\"344\":{\"h\":\"JVM的生命周期\"},\"345\":{\"h\":\"启动\",\"t\":[\"Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。\"]},\"346\":{\"h\":\"执行\",\"t\":[\"一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。\",\"程序开始执行时他才运行，程序结束时他就停止。\",\"执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。\"]},\"347\":{\"h\":\"退出\",\"t\":[\"有以下几种情况：\",\"程序正常执行结束\",\"程序异常或错误而异常终止\",\"操作系统错误导致终止\",\"某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作\",\"除此之外，JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况\"]},\"348\":{\"h\":\"JVM发展历程\"},\"349\":{\"h\":\"Sun Classic VM\",\"t\":[\"第一款商用Java虚拟机，JDK1.4时被淘汰\",\"只提供了解释器，效率较差。如果需要JIT编译器（及时编译器），就要进行外挂。但二者不能协同工作\",\"JIT会把热点代码（执行次数较多的）编译成本地机器指令，并缓存起来。提升了效率\",\"JIT的缺点：如果把所有代码都编译成本地机器指令，会导致暂停时间太长，导致卡顿\",\"现在hotspot内置了此虚拟机\"]},\"350\":{\"h\":\"Exact VM\",\"t\":[\"jdk1.2时由sun提供\",\"Exact menory management: 准确式内存管理——虚拟机可以知道内存中某个位置的数据具体是什么类型\",\"具有热点探测、编译器与解释器混合工作模式\",\"只在Solaris平台短暂使用，其他平台上还是classic vm\"]},\"351\":{\"h\":\"HotSpot VM\",\"t\":[\"1997年由sun收购而来。JDK1.3时，成为默认虚拟机\",\"Sun/Oracle JDK 和 OpenJDK的默认虚拟机\",\"名字中的 hotspot 指的是它的热点代码探测技术\",\"通过计数器找到最具编译价值的代码。触发即时编译或栈上替换\",\"通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡\"]},\"352\":{\"h\":\"BEA 的 JRockit\",\"t\":[\"专注于服务器端应用。它可以不太关注程序启动速度，因此JRock内部不包含解析器实现，全部代码都靠即时编译器编译后执行\",\"JRockit JVM是世界上最快的JVM\",\"优势：全面的Java运行时解决方案组合\",\"2008年，BEA被Oracle收购。Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 跹的优秀特性。\"]},\"353\":{\"h\":\"IBM 的 J9\",\"t\":[\"全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9\",\"市场定位与 HotSpott 接近，服务器端、桌而应用、嵌入式等多用途 VM\",\"广泛用于IBM的各种Java产品。\",\"目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机\"]},\"354\":{\"h\":\"执行引擎\"},\"355\":{\"h\":\"1. 执行引擎概述\",\"t\":[\"执行引擎是 Java 虚拟机核心的组成部分之一。\",\"“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。\",\"JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。\",\"那么，如果想要让一个 Java 程序运行起来，执行引擎(Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。\"]},\"356\":{\"h\":\"1.1 执行引擎的工作过程\",\"t\":[\"执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于pc寄存器。\",\"每当执行完一项指令操作后，pc寄存器就会更新下一条需要被执行的指令地址。\",\"当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。\",\"从外观上来看，所有的 Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。\"]},\"357\":{\"h\":\"2. Java 代码编译和执行过程\",\"t\":[\"上图中，绿色部分为解释执行过程，蓝色为编译执行的过程。大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。\",\"橙色部分由 javac 完成编译，属于前端编译。最终会形成线性字节码执行流。这部分和 JVM 是无关的。\"]},\"358\":{\"h\":\"2.1 问题：什么是解释器（lnterpreter)，什么是 JIT 编译器？\",\"t\":[\"解释器: 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\",\"JIT(Just In Time Compiler)编译器： 就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。\"]},\"359\":{\"h\":\"2.2 问题：为什么说 Java 是半编译半解释型语音？\",\"t\":[\"JDK 1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。\",\"现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。\"]},\"360\":{\"h\":\"3. 解释器\",\"t\":[\"JVM 设计者们的初衷仅仅只是单纯地为了满足 Java 程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释宇节码执行程序的想法。\"]},\"361\":{\"h\":\"3.1 解释器工作机制（或工作任务）\",\"t\":[\"解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。\",\"当一条字节码指令被解释执行完成后，接着再根据pc寄存器中记录的下一条需要被执行的字节码指令执行解释操作。\"]},\"362\":{\"h\":\"3.2 解释器分类\",\"t\":[\"在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。\",\"字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。\",\"而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 \",\"在 HotSpot VM 中，解释器主要由 Interpreter 模块和 code 模块构成。Interpreter 模块：实现了解释器的核心功能。code 模块：用于管理 HotSpot 在运行时生成的本地机器指令。\"]},\"363\":{\"h\":\"3.3 现状\",\"t\":[\"由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，基于解释器执行己经沦落为低效的代名词，并且时常被一些 C/C++ 程序员所调侃。\",\"为了解决这个问題，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可。这种方式可以使执行效率大幅度提升。\",\"不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。\"]},\"364\":{\"h\":\"4. JIT 编译器\"},\"365\":{\"h\":\"4.1 Java 代码的执行分类\",\"t\":[\"第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行\",\"第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术(JIT)将方法编译成机器码后再执行\",\"HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。\",\"在今天，Java 程序的运行性能早己脱胎换骨，己经达到了可以和 C/C++ 程序一较高下的地步。\",\"既然 Hotspot 已经内置了 JIT 编译器，为什么还需要使用解释器拖累性能呢？\",\"当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码 后，执行效率高。 所以，尽管 JRockit 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。\"]},\"366\":{\"h\":\"4.2 HotSpot JVM 的执行方式\",\"t\":[\"当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不心要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。\"]},\"367\":{\"h\":\"4.3 JIT 编译器细节\",\"t\":[\"Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把 java 文件转变成 class 文件的过程；\",\"也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time CompiIer)把字节码转变成机器码的过程。\",\"还可能是指使用静态提前编译器(AOT 编译器，Ahead Of Time Compiler)直接把 java 文件编译成本地机器代码的过程。\",\"前端编译器： Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。 JIT编译器：HotSpot VM 的 CI、C2 编译器。 AOT编译器：GNU Compiler for the Java (GCJ)、Excelsior JET。\"]},\"368\":{\"h\":\"4.4 如何选择？\",\"t\":[\"当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为==“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化==，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。\",\"一个被多次调用的方法，或者是一个方注体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR(On Stack Rep1acement）編译。\",\"一个方法宄竟要被调用多少次，或者一个循环体宄竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。\",\"目前Hotspot VM所采用的热点探测方式是基于计数器的热点探测。\",\"采用基于计数器的热点探测，Hotspot将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器(lnvocation Counter)和回边计数器(Back Edge Counter）\",\"方法调用计数器用于统计方法的调用次数\",\"回边计数器则用于统计循环体执行的循环次数\"]},\"369\":{\"h\":\"4.4.1 方法调用计数器\",\"t\":[\"这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在server模式下是10000次。超过这个阈值，就会触发JIT编译。\",\"这个阈值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。\",\"当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在己被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法计数器的阈值。如果己超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。\",\"热度衰减\",\"如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(Counter Decay)，而这段时间就称为此方法统计的半衰周期(counter Half Life Time)。\",\"进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关热度衰减，让方法计数器统计方注调用的绝对次数，这样，只要系统运行时间足够长，纶大部分方法都会被编译成本地代码。 另外，可以使用 -XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。\"]},\"370\":{\"h\":\"4.4.2 回边计数器\",\"t\":[\"它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（BackEdge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。\"]},\"371\":{\"h\":\"4.5 HotSpot VM 可以设置程序执行方式\",\"t\":[\"缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为JVM指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行：如下所示：\",\"-Xint：完全采用解释器模式执行程序 -Xcomp: 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行 -Xmixed: 采用解释器+即时编译器的混合模式共同执行程序\"]},\"372\":{\"h\":\"4.6 HotSpot VM 中 JIT分类\",\"t\":[\"hotspot jvm 内置了两个jit编译器，分别是client compiler（C1编译器）和server compiler（C2编译器），可通过下列指令显式指定使用哪种即时编译器\",\"-client 指定java虚拟机运行在client模式下，并使用C1编译器。C1编译器会堆字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。\",\"-server 指定java虚拟机运行在server模式下，并使用C2编译器。C2进行较长时间的优化，以及激进优化。但优化的代码执行效率更高。\",\"C1主要有方法内联，去虚拟化冗余消除\",\"方法内联：将引用函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程\",\"去虚拟化：对唯一的实现类进行内联\",\"冗余消除：在运行期间，把一些不会运行的代码折叠掉\",\"C2的优化主要是在全局层面，逃逸分析是优化的基础，基于逃逸分析在C2上有如下几种优化\",\"标量替换：用标量值替换聚合对象的属性值\",\"栈上分配：对于未逃逸的对象分配对象在栈而不是堆\",\"同步消除：清除同步操作，通常指synchronized\",\"分层编译策略： 程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。 当显式指定了-server 时，默认开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。\",\"总结：\",\"一般来讲，JIT 编译出来的机器码性能比解释器高。\",\"C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。\"]},\"373\":{\"h\":\"类加载子系统\"},\"374\":{\"h\":\"内存结构概述\",\"t\":[\"tips\",\"方法区：只有 HotSpot VM 才有。jdk7之前称为永久代，jdk7之后称为元空间。\",\"方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代/元空间就是HotSpot VM对虚拟机规范中方法区的一种实现方式。\"]},\"375\":{\"h\":\"类的加载过程\",\"t\":[\"类加载器系统负责从文件系统或者网络中加载 Class 文件，class文件在文件开头有特定的文件标识\",\"ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由执行引擎（Execution Engine）决定\",\"加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）\",\"tips\",\"类的加载过程分为3个环节：加载、链接、初始化\"]},\"376\":{\"h\":\"step1：加载（Loading）\"},\"377\":{\"h\":\"过程\",\"t\":[\"通过一个类的全限定名获取定义此类的二进制字节流\",\"将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\",\"在内存中生成一个代表这个类的 java.langClass 对象，作为方法区这个类的各种数据的访问入口\"]},\"378\":{\"h\":\"加载 .class 文件的方式\",\"t\":[\"从本地系统中直接加载\",\"通过网络获取，典型场景：webApplet\",\"从 zip 压缩包中读取，成为日后jar、war格式的基础\",\"运行时计算生成，使用最多的是：动态代理技术\",\"由其他文件生成，典型场景：JSP应用\",\"从专有数据库中提取 .class 文件，比较少见\",\"从加密文件中获取，典型的防 Class 文件被反编译的保护措施\"]},\"379\":{\"h\":\"step2：链接（Linking）\",\"t\":[\"主要分为 3 部分：验证、准备、解析\",\"验证 \",\"目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全\",\"主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证\",\"准备 \",\"为类变量分配内存并且设置该类变量的默认初始值，即零值\",\"这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化\",\"这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中\",\"解析 \",\"将常量池内的符号引用转换为直接引用的过程\",\"事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行\",\"符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄\",\"解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等\"]},\"380\":{\"h\":\"step3：初始化（Initialization）\",\"t\":[\"初始化阶段就是执行类构造器方法<clinit>()的过程\",\"这个方法不需要定义，是 javac 编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来。如果没有静态变量的赋值以及没有静态代码块，就不会有<clinit>()方法\",\"构造器方法中指令按语句在源文件中出现的顺序执行\",\"<cinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>() ）\",\"若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕\",\"虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。即一个类只需被clinit一次，之后该类的内部信息就被存储在方法区\"]},\"381\":{\"h\":\"类加载器分类\",\"t\":[\"JVM 支持两种类型的类加载器，分别为引导类加载器（Bootstrap CIassLoader）和自定义类加载器（User-Defined CIassLoader）。\",\"从概念上来讲，自定义类加载器一般指的是程序中开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器，包括 Extension Class Loader、System Class Loader。\",\"无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：\",\"1595094774889-fbc2624a-ce0c-458e-85a2-ae4b5cee3179\",\"提示\",\"注意上图中的加载器划分关系为包含关系，并不是继承关系。 用户自定义的类是由系统类加载器加载的。即 AppClassLoader。 String 类等核心类库是由引导类加载器加载的。即由 BootStrap Class Loader 加载。在代码中尝试获取这个类加载器时，会返回 null。\",\"//获取系统类加载器 -> sun.misc.Launcher$AppClassLoader@659e0bfd ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取其上层：扩展类加载器 -> sun.misc.Launcher$ExtClassLoader@6d06d69c ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader); //获取其上层：bootstrapClassLoader：null ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader); //对于用户定义的类来说，默认使用系统类加载器加载 -> sun.misc.Launcher$AppClassLoader@659e0bfd ClassLoader classLoader= ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); // String 类的加载器为 bootstrapClassLoader。打印为 null。 System.out.println(String.class.getClassLoader());\"]},\"382\":{\"h\":\"1. 启动类加载器（引导类加载器，Bootstrap ClassLoader）\",\"t\":[\"这个类加载使用 c/c++ 语言实现的，嵌套在 JVM 内部。\",\"它用来加载 Java 的核心库（JAVA_HOME/jre/1ib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类。\",\"并不继承自 java.Iang.ClassLoader（不是用java实现的），没有父加载器。\",\"加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\",\"出于安全考虑，Bootstrap 启动类加载器只加载包名为java、javax、sun 等开头的类。\"]},\"383\":{\"h\":\"2. 扩展类加载器（Extension ClassLoader）\",\"t\":[\"Java语音编写，由 sun.misc.Launcher$ExtClassLoader 实现\",\"派生于 ClassLoader 类\",\"父类加载器为启动类加载器\",\"从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载\"]},\"384\":{\"h\":\"3. 应用程序类加载器（系统类加载器，AppClassLoader）\",\"t\":[\"java 语音编写，由 sun.misc.Launcher$AppClassLoader 实现\",\"派生于 ClassLoader 类\",\"父类加载器为扩展类加载器\",\"它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库\",\"该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载\",\"通过 ClassLoader#getsystemClassLoader() 方法可以获取到该类加载器\"]},\"385\":{\"h\":\"4. 用户自定义类加载器\"},\"386\":{\"h\":\"为什么需要自定义类加载器？\",\"t\":[\"隔离加载类\",\"修改类加载的方式\",\"扩展加载源\",\"防止源码泄漏\"]},\"387\":{\"h\":\"如何自定义类加载器？\",\"t\":[\"开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求\",\"在 JDKI.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDKI.2 之后己不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中\",\"在编与自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁\"]},\"388\":{\"h\":\"ClassLoader 的使用说明\",\"t\":[\"提示\",\"ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器） 该类全限定名：java.lang.ClassLoader\",\"1595518477978-03c1006e-809c-47ae-ad0a-61fcdc9220af\"]},\"389\":{\"h\":\"获取 ClassLoader 的途径\",\"t\":[\"this.getClass.getClassLoader(); // 使用当前类的ClassLoader Thread.currentThread().getContextClassLoader(); // 使用当前线程的ClassLoader ClassLoader.getSystemClassLoader(); // 使用系统ClassLoader，即系统的入口点所使用的ClassLoader DriverManager.getCallerClassLoader() // 获取调用者的 ClassLoader。如本地方法调用\"]},\"390\":{\"h\":\"双亲委派机制\",\"t\":[\"注\",\"Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的 class 文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\"]},\"391\":{\"h\":\"工作原理\",\"t\":[\"如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行\",\"如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器\",\"如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载\"]},\"392\":{\"h\":\"沙箱安全机制\",\"t\":[\"package java.lang; public class String { public static void main(String[] args) { System.out.println(\\\"测试自定义java.lang.String类！\\\"); } } /** 执行结果： 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args) 否则 JavaFX 应用程序类必须扩展javafx.application.Application **/\",\"自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件 (rt.jar包中java\\\\lang\\\\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\"]},\"393\":{\"h\":\"优势\",\"t\":[\"避免类的重复加载\",\"保护程序安全，防止核心 API 被随意篡改。如： \",\"自定义类：java.lang.String\",\"自定义类：java.lang.Test (java开头的包名，会被引导类加载器加载。如果该类下有main方法，试图执行时会报错：java.lang.SecurityException)\"]},\"394\":{\"h\":\"其他\"},\"395\":{\"h\":\"1. JVM判断2个class对象是否为同一个类的两个必要条件\",\"t\":[\"类的完整类名必须一致，包括包名\",\"加载这个类的 ClassLoader（指ClassLoader实例对象）必须相同 :::tips 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的CIassLoader实例对象不同，那么这两个类对象也是不相等的。\"]},\"396\":{\"h\":\"2. 对类加载器的引用\",\"t\":[\"JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。\"]},\"397\":{\"h\":\"3. 类的主动使用和被动使用\",\"t\":[\"Java 程序对类的使用方式分为：主动使用和被动使用 主动使用，又分为七种情况：\",\"创建类的实例\",\"访问某个类或接口的静态变量，或者对该静态变量賦值\",\"调用类的静态方法\",\"反射（比如：Class.forName(\\\"com.hpt.Test\\\")）\",\"初始化一个类的子类\",\"Java 虚拟机启动时被标明为启动类的类\",\"JDK7 开始提供的动态语言支持： \",\"java.lang.invoke.MethodHandle 实例的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类未初始化，则初始化\",\"除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。\"]},\"398\":{\"h\":\"程序计数器\"},\"399\":{\"h\":\"PC Register 介绍\",\"t\":[\"JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。\",\"作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。\",\"它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\",\"在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\",\"任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。或者，如果是在执行native方法，则是未指定值(undefned)\",\"它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\",\"字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\",\"它是唯一一个在Java虚拟机规范中没有规定任何 OutMemoryError 情况的区域。\"]},\"400\":{\"h\":\"两个常见问题\"},\"401\":{\"h\":\"1. 使用PC寄存器存储字节码指令地址的作用？\",\"t\":[\"因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\"]},\"402\":{\"h\":\"2. PC寄存器为什么被设定为线程私有？\",\"t\":[\"所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\",\"由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\"]},\"403\":{\"h\":\"虚拟机栈\"},\"404\":{\"h\":\"虚拟机栈概述\"},\"405\":{\"h\":\"出现背景\",\"t\":[\"由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要史多的指令。 栈是运行时的单位，而堆是存储的单位。\"]},\"406\":{\"h\":\"虚拟机栈基本内容\"},\"407\":{\"h\":\"Java虚拟机栈是什么？\",\"t\":[\"Java虚拟机栈（Java Virtual Machine Stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧 (Stack Frame)，对应着一次次的Java方法调用。是线程私有的。生命周期和线程一致。作用是主管Java程序的运行。它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。\"]},\"408\":{\"h\":\"栈的特点\",\"t\":[\"栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\",\"JVM直接对Java栈的操作只有两个： \",\"每个方法执行，伴随着进栈（入栈、压栈）\",\"执行结束后的出栈工作\",\"对于栈来说不存在垃圾回收问题\"]},\"409\":{\"h\":\"栈中可能出现的异常\",\"t\":[\"Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。\",\"如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。\",\"如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。\"]},\"410\":{\"h\":\"设置栈内存大小\",\"t\":[\"使用参数 -Xss 设置线程的最大栈空间。栈的大小直接决定了函数调用的最大可达深度。 默认单位是 bytes。可以在数字后面加具体单位。默认大小如下：\",\"Linux/x64 (64-bit): 1024 KB\",\"macOS (64-bit): 1024 KB\",\"Oracle Solaris/x64 (64-bit): 1024 KB\",\"Windows: The default value depends on virtual memory\",\"设置示例：\",\"-Xss1m -Xss1024k -Xss1048576\"]},\"411\":{\"h\":\"栈的存储单位\"},\"412\":{\"h\":\"栈中存储什么？\",\"t\":[\"每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。\"]},\"413\":{\"h\":\"栈运行原理\",\"t\":[\"JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。\",\"在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧(current Frame)，与当前栈帧相对应的方法就是当前方法(current Method)，定义这个方法的类就是当前类(current Class)。\",\"执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\",\"如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。\",\"不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧\",\"如果当前方法去调了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。\",\"Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。\"]},\"414\":{\"h\":\"栈帧的内部结构\",\"t\":[\"局部变量表(Local variables)\",\"操作数栈(operand stack)（或表达式栈）\",\"动态链接(Dynamic Linking)（或指向运行时常量池的方法引用）\",\"方法返回地址(Return Address）（或方法正常退出或者异常退出的定义）\",\"一些附加信息\"]},\"415\":{\"h\":\"局部变量表（Local Variables）\",\"t\":[\"局部变量表也被称之为局部变量数组或本地变量表\",\"定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用(reference)，以及returnAddress类型。\",\"由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。\",\"局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。\",\"方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\",\"局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。\",\"在栈帧中，与性能调优关系最密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。\",\"局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。\"]},\"416\":{\"h\":\"操作数栈（Operand Stack）\",\"t\":[\"操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。是用数组实现的。但不能通过索引访问。\",\"操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。\",\"每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值。\",\"栈中的任何一个元素都是可以任意的Java数据类型。 \",\"32bit 的类型占用一个栈单位深度\",\"64bit 的类型占用两个栈单位深度\",\"操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。\",\"每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈（Expression Stack）。\",\"操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)\",\"某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，指向复制、交换、求和等操作。\",\"如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条需要执行的字节码指令。\",\"操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。\",\"另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。\"]},\"417\":{\"h\":\"动态链接（或指向运行时常量池的方法引用）\",\"t\":[\"每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如invokedynamic指令\",\"在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\"]},\"418\":{\"h\":\"方法的调用\"},\"419\":{\"h\":\"静态链接/动态链接\",\"t\":[\"在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。\",\"静态链接：\",\"当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。\",\"动态链接：\",\"如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。\"]},\"420\":{\"h\":\"早期绑定/晚期绑定\",\"t\":[\"对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。\",\"早期绑定\",\"早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。\",\"晚期绑定\",\"如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。\"]},\"421\":{\"h\":\"虚方法/非虚方法\",\"t\":[\"如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。\",\"静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。\",\"其他方法称为虚方法。\",\"参考: invokedynamic\"]},\"422\":{\"h\":\"方法重写的本质\",\"t\":[\"找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。\",\"如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。\",\"否则，按照继承关系从下往上依次对 C 的各个父类进行第2步的搜索和验证过程。\",\"如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodEtror异常。\",\"注\",\"IllegalAccessError 介绍： 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。\"]},\"423\":{\"h\":\"虚方法表\",\"t\":[\"在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表(virtual method table)（非虚方法不会出现在表中）来实现。使用索引表来代替查找。\",\"每个类中都有一个虚方法表，表中存放着各个方法的实际入囗。\",\"虚方法表什么时候被创建？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。\"]},\"424\":{\"h\":\"方法返回地址\",\"t\":[\"存放调用该方法的pc寄存器的值。\",\"一个方法的结束，有两种方式： \",\"正常执行完成\",\"出现未处理的异常，非正常退出\",\"无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\",\"本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。\",\"正常完成出口和异常完成出口的区别：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。\",\"当一个方法开始执行后，只有两种方式可以退出这个方法：\",\"执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者，简称正常完成出口。 \",\"一个方法在正常调用完成之后需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。\",\"在字节码指令中，返回指令包含 ireturn（当返回值是boolean、byte、char、short 和 int类型时使用）、lreturn、freturn、dreturn以及 areturn，另外还有一个return指令供声明为 void 的方法、实例初始化方法、类和接囗的初始化方法使用。\",\"在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。方法执行过程抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。\"]},\"425\":{\"h\":\"一些附加信息\",\"t\":[\"栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。\"]},\"426\":{\"h\":\"栈的相关面试题\"},\"427\":{\"h\":\"1. 举例栈溢出的情况？（StackOverflowError）\",\"t\":[\"通过 -Xss 设置。参考之前的内容。\"]},\"428\":{\"h\":\"2. 调整栈大小，就能保证不出现溢出吗？\",\"t\":[\"不能。如递归不写退出条件时，还是会出现溢出。\"]},\"429\":{\"h\":\"3. 分配的栈内存越大越好吗？\",\"t\":[\"不是，内存总量确定的情况下，栈内存分配过大，会影响其他内存结构的正常使用。\"]},\"430\":{\"h\":\"4. 垃圾回收是否会涉及到虚拟机栈？\",\"t\":[\"不会。\"]},\"431\":{\"h\":\"5. 方法中定义/使用的局部变量是否线程安全？\",\"t\":[\"具体问题具体分析。\",\"在方法内定义 StringBuilder sb = new StringBuilder(); 并在后续对其进行 append操作，是线程安全的。\",\"如果对方法入参中的 StringBuilder 进行 append，不安全。因为这个入参有可能被多个线程调用。\"]},\"432\":{\"h\":\"本地方法接口与本地方法栈\"},\"433\":{\"h\":\"本地方法接口\"},\"434\":{\"h\":\"什么是本地方法？\",\"t\":[\"简单地讲， 一个 NativeMethod 就是一个Java调用非Java代码的接囗 。\",\"一个NativeMethod是这样一个Java方注：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在c++中，你可以用extern \\\"C\\\" 告知C++编译器去调用一个C的函数。 在定义一个native method时，并不提供实现体（有些像定义一个Java 接口。因为其实现体是由非java语言在外面实现的。 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。\",\"native 可以与其他所有的Java标识符连用，但 abstract 除外。\"]},\"435\":{\"h\":\"为什么要使用 Native Method？\",\"t\":[\"Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\",\"与Java环境外交互：\",\"有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。\",\"与操作系统交互：\",\"JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依于一些底层系統的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也要使用本地方法。\",\"Sun's Java：\",\"sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority() 方法是用Java实现的，但是它实现调用的是该类里的本地方法 setPriority0() 。这个本地方法是用C实现的，并被植入JVM内部，在Winaows95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现，由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library，即dll)提供，然后被JVM调用。\"]},\"436\":{\"h\":\"现状\",\"t\":[\"目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中己经比较少见。因为现在的异构领域间的通信很发达，比如可以使用socket通信，也可以使用webservice等等。\"]},\"437\":{\"h\":\"本地方法栈（Native Method Stack）\",\"t\":[\"Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。\",\"本地方法栈也是线程私有的。\",\"允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） \",\"如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。\",\"如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。\",\"本地方法是使用C语言实现的。它的具体做法是NatIve Method Stack中（hotspot场景下，是在虚拟机栈中。因为它们是合一的）登记native方法，在Execution Engine 执行时加载本地方法库。\",\"当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 \",\"本地方法可通过本地方法接囗来访问虚拟机内部的运行时数据区。\",\"它甚至可以直接使用本地处理器中的寄存器。\",\"直接从本地内存的堆中分配任意数量的内存。\",\"并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。\",\"在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。\"]},\"438\":{\"h\":\"方法区\"},\"439\":{\"h\":\"1. 栈、堆、方法区的交互关系\",\"t\":[\"运行时数据区结构\",\"从线程共享与否的角度来看（图中元空间就是jdk7以后方法区的实现）\",\"栈、堆、方法区的交互关系\",\"Person person = new Person();\",\"上行代码中，Person为类信息，存放在方法区；person为变量，存放在java栈中；new Person()创建的对象存放在堆中。\"]},\"440\":{\"h\":\"2. 方法区的理解\",\"t\":[\"官网中的相关介绍：点击这里\"]},\"441\":{\"h\":\"2.1 主要信息\",\"t\":[\"被所有jvm线程共享。\",\"它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化、接口初始化中使用的特殊方法。\",\"方法区是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能选择不进行垃圾收集或压缩。此规范不要求方法区域的位置或用于管理已编译代码的策略。\",\"方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，并且可以在不需要更大的方法区域时收缩。\",\"对于 HotSpotJVM，方法区还有一个别名叫Non-Heap（非堆）。目的就是要和堆分开。\",\"方法区可以看作是一块独立于Java堆的内存空间。方法区域的内存不需要是连续的。\",\"如果方法区域中的内存无法用于满足分配请求，Java虚拟机将抛出OutOfMemoryError。\"]},\"442\":{\"h\":\"2.2 方法区的基本理解\",\"t\":[\"方法区（MethodArea）与 Java 堆一样，是各个线程共享的内存区域。\",\"方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。\",\"方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。\",\"方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGenspace（1.7） 或者 java.lang.OutOfMemoryError：Metaspace（1.8）。\",\"关闭 JVM 就会释放这个区域的内存。\"]},\"443\":{\"h\":\"2.3 Hotspot 中方法区的演进\"},\"444\":{\"h\":\"jdk7及以前\",\"t\":[\"在jdk7及以前，习惯上把方法区称为永久代。jdk8 开始，使用元空间取代了永久代。\",\"本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JROCkit/ IBM J9 中不存在永久代的概念。\",\"现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过 -XX:MaxPermSize 上限）\"]},\"445\":{\"h\":\"jdk8\",\"t\":[\"完全废弃了永久代的概念，改用与 BEA JROCkit/ IBM J9 一样在本地内存中实现的元空间来代替。\",\"元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。\",\"永久代、元空间二者并不只是名字变了，内部结构也调整了。\",\"根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。\"]},\"446\":{\"h\":\"3. 设置方法区大小与OOM\",\"t\":[\"方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。\"]},\"447\":{\"h\":\"3.1 jdk7及以前\",\"t\":[\"通过 -XX:permSize 来设置永久代初始分配空间。默认值是20.75M\",\"通过-XX:MaxPermSize 来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M\",\"当JVM加载的类信息容量超过了这个值，会报异常java.lang.OutOfMemoryError: PermGenspace\"]},\"448\":{\"h\":\"3.2 jdk8及以后\",\"t\":[\"元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。\",\"默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。\",\"与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常 OutOfMemoryError：Metaspace\",\"-XX:MetaspaceSize：设置初始的元空间大小：对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。\",\"如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。\"]},\"449\":{\"h\":\"3.3 如何查看当前 的值？\",\"t\":[\"可先通过 jps获取当前进程的进程号，1.7版本使用 jinfo -flag PermSize pid 查看；1.8及以后的版本使用 jinfo -flag MetaspaceSize pid 查看。\"]},\"450\":{\"h\":\"3.4 如何解决这些OOM？\",\"t\":[\"要解决OOM异常或heapspace的异常，一般的手段是首先通过内存映像分析工具出来的堆转储快照进行分析，重点是确认（如Eclipse Memory Analyzer)对dump内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak)还是内存溢出（Memory Overflow)。\",\"如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。\",\"如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。\"]},\"451\":{\"h\":\"4. 方法区的内部结构\",\"t\":[\"方法区用于存储己被虚拟机加载的类型信息、常量(运行时常量池)、静态变量、即时编译器(JIT)编译后的代码缓存等。\"]},\"452\":{\"h\":\"4.1 类型信息\",\"t\":[\"对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：\",\"这个类型的完整有效名称（全名：包名．类名）\",\"这个类型直接父类的完整有效名（对于interface或是java.1ang.Object，都没有父类）\",\"这个类型的修饰符(public,abstract,final的某个子集）\",\"这个类型直接接口的一个有序列表\",\"类的加载器\"]},\"453\":{\"h\":\"4.2 域(field)信息\",\"t\":[\"JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。\",\"域的相关信息包括：域名称、域类型、域修饰符(private, protected, static, final, volatile, transient的某个子集）\"]},\"454\":{\"h\":\"4.3 方法(method)信息\",\"t\":[\"JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序。\",\"方法名称\",\"方法的返回类型（或void)\",\"方法参数的数量和类型（按顺序）\",\"方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)\",\"方法的字节码(bytecodes)、操作数栈、局部变量表及大小( abstract 和 native 方法除外)\",\"异常表(abstract 和 native 方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。\"]},\"455\":{\"h\":\"4.4 non-final的类信息\",\"t\":[\"静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。\",\"类变量被类的所有实例共享，即使没有类实例时你也可以访问它。\"]},\"456\":{\"h\":\"4.5 运行时常量池 vs 常量池\",\"t\":[\"方法区，内部包含了运行时常量池。\",\"字节码文件，内部包含了常量池。\",\"要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区。\",\"要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。\"]},\"457\":{\"h\":\"为什么需要常量池？\",\"t\":[\"一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。\"]},\"458\":{\"h\":\"常量池中有什么？\",\"t\":[\"几种在常量池内存储的数据类型包括：\",\"数量值\",\"字符串值\",\"类引用\",\"字段引用\",\"方法引用\",\"常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。\"]},\"459\":{\"h\":\"4.6 运行时常量池\",\"t\":[\"运行时常量池(Runtime Constant Pool）是方法区的一部分。\",\"常量池表（constant Pool Tab1e)是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\",\"运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。\",\"JVM 为每个己加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。\",\"运行时常量池中包含多种不同的常量，包括编译期就己经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\",\"运行时常量池类似于传统编程语言中的符号表（symbol table)，但是它所包含的数据却比符号表要更加丰富一些。\",\"当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛 outofMemoryError 异常。\",\"运行时常量池相对于 Class 文件常量池的另一重要特征是：具各动态性。\"]},\"460\":{\"h\":\"5. 方法区的演进细节\"},\"461\":{\"h\":\"5.1 演进细节\",\"t\":[\"首先明确：只有 Hotspot 才有永久代。 BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受 Java虚拟机规范管束，并不要求统一。\",\"Hotspot 中方法区的变化\",\"jdk 1.6及之前 有永久代(permanent generation），静态变量存放在永久代上 \",\"jdk 1.7 有永久代，但己经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 \",\"jdk 1.8及之后 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆 \"]},\"462\":{\"h\":\"5.2 永久代为什么要被元空间替代？\",\"t\":[\"官网描述-JEP122\",\"动机：这是JRockit和 Hotspot 融合工作的一部分。JRockit客户不需要配置永久代（因为 JRockit 没有永久代），并且习惯于不配置永久代。\",\"由于类的元数据分配在本地内存中，元空间最大可分配空间就是系统可用内存空间。 这项改动是很有必要的，原因有：\",\"为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生 Perm区的OOM。比如某个实际 web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误 java.lang.OutOfMemoryError: PermGen。 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\",\"对永久代进行调优是很困难的。\"]},\"463\":{\"h\":\"5.3 StringTable (字符串常量池)为什么要调整？\",\"t\":[\"jdk7中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。\"]},\"464\":{\"h\":\"6. 方法区的垃圾回收\",\"t\":[\"有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 ZGC 收集器就不支持类卸载）。\",\"一般来说==这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。==但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。\",\"方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。\",\"先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量： \",\"类和接口的全限定名\",\"字段的名称和描述符\",\"方法的名称和描述符\",\"Hotspot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\",\"回收废弃常量与回收 Java 堆中的对象非常类似。\",\"判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了。需要同时满足下面三个条件： \",\"该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。\",\"加载该类的类加载器己经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，Hotsppt 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceC1ass-Loading、-XX:+TraceC1assUnLoading 查看类加载和卸载信息。\",\"在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。\"]},\"465\":{\"h\":\"7. 总结 & 面试题\",\"t\":[\"百度 三面：说一下 JVM 内存模型吧，有哪些区？分别干什么的？\",\"蚂蚁金服 Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布／内存结构？栈和堆的区别？堆的结构？为什么两个 survor 区？ 二面：Eden 和 survivor 的比例分配？\",\"小米 jvm 内存分区，为什么要有新生代和老年代\",\"字节跳动 二面：Java 的内存分区 二面：讲讲jvm运行时数据库区 什么时候对象会进入老年代？\",\"京东 JVM 的内存结构，Eden 和 survivor比例 JVM 内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为 Eden 和 survor。\",\"天猫 一面：JVM 内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8 做了什么修改。\",\"拼多多 JVM 存分哪几个区，每个区的作用是什么？\",\"美团 java 内存分配 jvm 的永久代中会发生垃圾回收吗？ 一面：jvm 内存分区，为什么要有新生代和老年代？\"]},\"466\":{\"h\":\"对象的实例化、内存布局与访问定位\"},\"467\":{\"h\":\"1. 对象的实例化\",\"t\":[\"大厂面试题\",\"美团： 对象在 JVM 中是怎么存储的？ 对象头信息里面有哪些东西？\",\"蚂蚁金服： 二面：java 对象头里有什么\"]},\"468\":{\"h\":\"1.1 创建对象的方式\",\"t\":[\"new 有两种变形：Xxx的静态方法；XxxBuilder/XxxFactory 的静态方法。\",\"newInstance() 是反射的方式，只能调用无参构造器，权限必须是 public。\",\"Constructor 的 newInstance(Xxx)也是反射的方式，可调用无参/有参构造器，权限没有要求\",\"clone 要求当前类实现 Cloneable 接口，实现 clone() 方法。不调用构造器。\",\"反序列化 可从文件、网络获取一个对象的二进制流。\",\"第三方库。\"]},\"469\":{\"h\":\"1.2 创建对象的步骤\"},\"470\":{\"h\":\"1. 判断对象对应的类是否加载、链接、初始化\",\"t\":[\"虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在Mataspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否己经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 Key 进行查找对应的.class文件。如果没有找到文件，则抛出 ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的 Class 类对象。\"]},\"471\":{\"h\":\"2. 为对象分配内存\",\"t\":[\"首先计算对象占用窒间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。\",\"如果内存规整，使用指针碰撞\",\"如果内存是规整的，那么虚拟机将采用的是指针碰撞法（BumpThePointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 ser1、parNew 这种基于压缩算法的，虚拟机采用这种分配方式。\",\"一般使用带有compact（整理）过程的收集器时，使用指针碰撞。\",\"如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配\",\"如果内存不是规整的，己使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为空闲列表（FreeList）\",\"选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\",\"处理并发安全问题\",\"在分配内存空间时，另外一个问題是及时保证 new 对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题。\",\"CAS（Compare And Swap）失败重试、区域加锁：保证指针更新操作的原子性。\",\"TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB，ThreadLocal Allocation Buffer）虚拟机是否使用 TLAB，可以通过 -XX:+/-UseTLAB 参数来设定。\"]},\"472\":{\"h\":\"3. 初始化分配到的空间\",\"t\":[\"内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在 Javaa 代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。\"]},\"473\":{\"h\":\"4. 设置对象的对象头\",\"t\":[\"将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。\"]},\"474\":{\"h\":\"5. 执行 init 方法进行初始化\",\"t\":[\"在 Java 程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。\"]},\"475\":{\"h\":\"2. 对象的内存布局\"},\"476\":{\"h\":\"2.1 对象头（Header）\",\"t\":[\"包含两部分：\",\"运行时元数据（Mark Word）： 哈希值（hashcode），GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳\",\"类型指针： 指向类元数据InstanceClass，确定该对象所属的类型。\",\"如果是数组，还需要记录数组的长度！\"]},\"477\":{\"h\":\"2.2 实例数据（Instance Data）\",\"t\":[\"它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）\",\"规则：\",\"相同宽度的字段总是被分配在一起\",\"父类中定义的变量会出现在子类之前\",\"如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙\"]},\"478\":{\"h\":\"2.3 对齐填充（Padding）\",\"t\":[\"不是必须的，也没特别含义，仅仅起到占位符的作用。\"]},\"479\":{\"h\":\"3. 对象的访问定位\",\"t\":[\"JVM 是如何涌过栈帧中的对象引用访问到其内部的对象实例的呢？定位，通过栈上 reference 访问\",\"对象访问方式主要有两种\",\"句柄访问：在堆空间开一片区域，称为句柄池，存放到对象实例数据/类型数据的指针。栈中变量指向句柄。\",\"优点：堆中对象被移动时，只会改变句柄处记录的值，无需改变栈中存放的句柄地址。（垃圾回收时对象会移动）\",\"缺点：需要额外空间，访问效率低。\",\"直接指针（Hotspot采用）：栈中的变量直接指向堆中的对象。\",\"优点：访问效率高。\",\"缺点：对象移动时需要修改栈中存放的对象地址。\"]},\"480\":{\"h\":\"堆\"},\"481\":{\"h\":\"堆的核心概念\"},\"482\":{\"h\":\"堆的核心概述\",\"t\":[\"堆是线程共享的，和方法区（Runtime）一样。它们是进程私有的，线程共享的。\",\"一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\",\"Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM 管理的最大一块内存空间。堆内存的大小是可以调节的。\",\"《Java虚拟机规范》规定，堆可以处于物理上不连续 的内存空间中，但在逻辑上它应该被视为连续的 。\",\"所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local AIIocation Buffer, TLAB)。\",\"《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（\\\"几乎\\\"所有的对象实例都在这里(堆)分配内存。一一从实际使用角度看的）。\",\"数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。\",\"在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。\",\"堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。\"]},\"483\":{\"h\":\"内存细分\",\"t\":[\"现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：\",\"Java7 及之前堆内存锣辑上分为三部分：新生代+老年代+永久区 \",\"Young Generation Space 新生代 Young/New。又被划分为Eden区和Survivor区。\",\"Tenure generation space 老年代 Old/Tenure\",\"Permanent Space 永久区 Perm\",\"Java8 及之后堆内存逻辑上分为三部分：新生代+老年代+元空间 \",\"Young Generation Space 新生代 Young/New。又被划分为Eden区和Survivor区。\",\"Tenure generation space 老年代 Old/Tenure\",\"MetaSpace 元空间 Meta\",\"JDK 1.7 堆空间内部结构\",\"1596950825906-aafafd72-7bac-456a-8c02-14dc4f801513\",\"其中，永久代可以不考虑。把它看作方法区的具体实现。\"]},\"484\":{\"h\":\"设置堆内存大小与OOM\"},\"485\":{\"h\":\"设置\",\"t\":[\"Java 堆区用于存储Java对象实例，那么堆的大小在启动时就己经设定好了，可以通过选项-Xmx 和 -Xms 来进行设置。 \",\"-Xms 用于表示堆区的起始内存，等价于 -XX:InitialHeapSize\",\"-Xmx 则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize\",\"一旦堆区中的内存大小超过 -Xmx 所指定的最大内存时，将会抛出 OutOfMemoryError 异常。\",\"通常会将-Xmx 和 -Xms 两个参数配置相同的值。其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。\",\"-Xmx 和 -Xms 两个参数配置的值包含堆空间中的新生代 + 老年代。不包含 永久代/元空间。\"]},\"486\":{\"h\":\"默认\",\"t\":[\"默认情况下，初始内存大小：物理电脑内存大小／64；最大内存大小：物理电脑内存大小 / 4。\"]},\"487\":{\"h\":\"如何查看设置的参数\",\"t\":[\"方式1：jps 获取进程id；jstat -gc 进程id \",\"方式2：-XX:+PrintGCDetails 如上两图，查看的方式不同，但结果是一致的。\"]},\"488\":{\"h\":\"年轻代与老年代\",\"t\":[\"存储在堆中的Java对象可以被划分为两类。 \",\"一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\",\"另外一类对象的生命周期非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。\",\"Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代(OldGen)\",\"其中年轻代又可以划分为 Eden 空间、survivor0 空间和 survivor1（有时也叫做from区、to区）\",\"配置新生代与老年代在堆结构的占比(一般不会修改) \",\"默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3\",\"可以改为-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\",\"在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1。可以通过选项 -XX:SurvivorRatio 调整这个空间比例。比如-XX：SurvivorRatio=8\",\"几乎所有的Java对象都是在Eden区被new出来的。\",\"绝大部分的Java对象的销毁都在新生代进行了。\",\"IBM公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。\",\"可以使用选项-Xmn设置新生代最大内存大小。这个参数一般使用默认值就可以了。\",\"虽然新生代中 Eden 和 S0、S1 的比例默认是8:1:1，但实际可能并不是这样。存在自适应的内存分配策略。但如果显示地使用 —XX：SurvivorRatio=8 来指定比例，则这个比例必然成立。\"]},\"489\":{\"h\":\"对象分配过程\"},\"490\":{\"h\":\"概述\",\"t\":[\"为新对象分配内存是一件非常严谨和复杂的任务，Java的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。\",\"new 的对象先放Eden区。此区有大小限制。\",\"当Eden的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收(YGC/Minor GC)，将Eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden区。\",\"然后将Eden中的剩余对象移动到 survivor0 区。\",\"如果再次触发垃圾回收，此时上次幸存下来的对象放到 survivor0 区的，如果没有回收，就会放到 survivor1 区。\",\"如果再次经历垃圾回收，此时会重新放回 survivor0 区，接着再去 survivor1 区。\",\"啥时候能去养老区（老年代）呢？可以设置次数。默认是15次。\",\"可以设置参数：-XX:MaxTenuringThreshold=<N> 设置对象转移到老年代的年龄。\",\"在养老区，相对悠闲。当养老区内存不足时，再次触发GC（MajorGC），进行养老区的内存清理。\",\"若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生OOM异常。\",\"针对幸存者S0，S1 区的总结：复制之后有交换，谁空谁就是to，另一个就是from。\",\"关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。\"]},\"491\":{\"h\":\"特殊情况\"},\"492\":{\"h\":\"常用调优工具\",\"t\":[\"JDK命令行（jinfo, jstat, javap, jmap...）\",\"EcIipse:Memory Analyzer Tool\",\"Jconsole\",\"VisualVM\",\"Jprofiler\",\"Java Flight Recorder\",\"GCViewer\",\"GC Easy\"]},\"493\":{\"h\":\"Minor GC、Major GC、Full GC\",\"t\":[\"JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代、方法区）一起回收的，大部分时候回收的都是指新生代。针对 HotSpot VM 的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）\",\"部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： \",\"新生代收集(Minor GC / Young GC)：只是新生代的垃圾收集\",\"老年代收集(Major GC / Old GC）：只是老年代的垃圾收集。\",\"混合收集（Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为。\",\"整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。\",\"目前，只有CMS GC会有单独收集老年代的行为。\",\"注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。\"]},\"494\":{\"h\":\"1. 年轻代GC(Minor GC)触发机制\",\"t\":[\"当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden满，survivor满不会引发GC（每次Minor GC会清理年轻代的内存）。\",\"因为Java对象大多都具备朝生夕灭的特性，所以 Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\",\"Minor GC会引发STW。暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。\",\"survivor0、survivor1的GC是被动的。触发的条件是Eden满。\"]},\"495\":{\"h\":\"2. 老年代GC(Major GC / Full GC)触发机制\",\"t\":[\"指发生在老年代的GC，对象从老年代消失时，我们说 Major GC 或 Full GC 发生了。\",\"出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在parallel Scavenge 收集器的收集策略里就有直接进行Major的策略选择过程）。也就是在老年代空间不足时，会先尝试触发MinorGC。如果之后空间还不足，则触发Major GC。\",\"MajorGC 的速度一般会比 MinorGC 慢10倍以上，STW的时间更长。\",\"如果MajorGC后，内存还不足，就报OOM了。\"]},\"496\":{\"h\":\"3. Full GC 触发机制\",\"t\":[\"触发Full执行的情况有如下五种：\",\"调用system.gc()时，系统建议执行FullGC，但是不必然执行\",\"老年代空间不足\",\"方法区空间不足\",\"通过Minor GC 后进入老年代的平均大小大于老年代的可用内存\",\"由Eden区、survivor space0（From Space)区向 survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\",\"说明：full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。\"]},\"497\":{\"h\":\"堆空间分代思想\",\"t\":[\"为什么需要java堆分代？不分代就不能正常工作了吗？\",\"经研究，不同对象的生命周期不同。70% ~ 99%的对象是临时对象。\",\"新生代：有Eden、两块大小相同的survivor（又称为from/to, s0/s1）构成，to 总为空。\",\"老年代：存放新生代中经历多次 GC 仍然存活的对象。\",\"其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\"]},\"498\":{\"h\":\"内存分配策略\",\"t\":[\"如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。\",\"对象晋升老年代的年龄阈值，可以通过选项-XX：MaxTenuringThreshold来设置。\",\"针对不同年龄段的对象分配原则如下所示：\",\"优先分配到Eden\",\"大对象直接分配到老年代（尽量避免程序中出现过多的大对象）\",\"长期存活的对象分配到老年代\",\"动态对象年龄判断 \",\"如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\",\"仝间分配担保：—XX：HandlePromotionFailure\"]},\"499\":{\"h\":\"为对象分配内存：TLAB\"},\"500\":{\"h\":\"什么是TLAB?\",\"t\":[\"从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。\",\"多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配筻略。\",\"所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\"]},\"501\":{\"h\":\"为什么有TLAB（Thread Local Allocation Buffer）?\",\"t\":[\"堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\",\"由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\",\"为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\"]},\"502\":{\"h\":\"TLAB的其他说明\",\"t\":[\"尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将其作为内存分配的首选。\",\"在程序中，开发人员可以通过选项--XX:+UseTLAB 设置是否开启TLAB空间(默认是开启的)\",\"默认情况下，TLAB空间的内存非常小，仅占整个Eden空间的1%，当然我们可以通过选项-XX:TLABwasteTargetPercent 设置TLAB空间所占用Eden空间的百分比大小。\",\"一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。\"]},\"503\":{\"h\":\"小结：堆空间的参数设置\",\"t\":[\"-XX:+PrintFlagsInitial: 查看所有的参数的默认初始值\",\"-XX:+PrintFlagsFinal: 查看所有的参数的最终值（可能会存在修改，不再是初始值） 具体查看某个参数值的指令： \",\"jps: 查看当前运行中的进程\",\"jinfo -flag 参数名 进程id\",\"-Xms: 初始堆空间内存（默认为物理内存的1/64）\",\"-Xmx: 最大堆空间内存（默认为物理内存的1/4）\",\"-Xmn: 设置新生代的大小。（初始值及最大值）\",\"-XX:NewRatio: 配置新生代与老年代在堆结构的占比（默认是2。新生代1/3，老年代2/3）\",\"-XX:survivorRatio：设新生代中Eden和S0/S1空间的比例（默认是8）\",\"-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄 \",\"最大值是15。parallel收集器的默认值是15，CMS收集器的默认值是6。\",\"-XX:+printGCDetails：输出详细的GC处理日志 \",\"打印gc简要信息：① -XX:PrintGC ② -verbose:gc 二者打印的结果相同\",\"-XX:HandlePromotionFailure: 是否设置空间分配担保\"]},\"504\":{\"h\":\"HandlePromotionFailure 参数说明\",\"t\":[\"在发生MinorGC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。\",\"如果大于，则此次MinorGC是安全的\",\"如果小于，则虚拟机会查看-XX:HandlePromotionFailure 设置值是否允许担保失败。 \",\"如果HandlePromotionFailure=true,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 \",\"如果大于，则尝试进行一次MinorGC，但这次MinorGC依然是有风险的。\",\"如果小于，则改为进行一次FullGC。\",\"如果HandlePromotionFailure=false，则改为进行一次FullGC。\",\"在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionrailure参数，但是在代码中己经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行MinorGC，否则将进行FullGC。\"]},\"505\":{\"h\":\"堆是分配对象的唯一选择吗\",\"t\":[\"在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述： 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\",\"在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是“如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。”这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\",\"此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。\",\"只有在Server模式下才可以启用逃逸分析。可通过java -version查看\"]},\"506\":{\"h\":\"逃逸分析概述\",\"t\":[\"如何将堆上的对象分配到栈，需要使用逃逸分析手段。\",\"这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。\",\"通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。\",\"逃逸分析的基本行为就是分析对象动态作用域： \",\"当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。\",\"当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。\",\"在JDK6u23版本之后，HotSpot中默认就己经开启了逃逸分析。如果使用的是较早的版本，开发人员则可以通过：\",\"选项-XX:+DoEscapeAnalysis显式开启逃逸分析\",\"选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。\",\"结论\",\"开发中能使用局部变量的，就不要使用在方法外定义。\"]},\"507\":{\"h\":\"逃逸分析：代码优化\",\"t\":[\"使用逃逸分析，编译器可以对代码做如下优化：\",\"栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。\",\"同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。\",\"分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器(对Java而言，就是栈)中。\"]},\"508\":{\"h\":\"1. 栈上分配\",\"t\":[\"JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。\",\"常见的栈上分配的场景：给成员变量赋值、方法返回值、实例引用传递。\"]},\"509\":{\"h\":\"2. 同步省略（消除）\",\"t\":[\"线程同步的佧价是相当高的，同步的后果是降低并发性和性能。\",\"在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。\"]},\"510\":{\"h\":\"3. 标量替换\",\"t\":[\"标量(Scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。\",\"相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\",\"在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。\",\"public class Test { public static void main(String[] args) { alloc(); } private static void alloc() { Point point = new Point(1,2); System.out.println(\\\"x = \\\" + point.x + \\\", y = \\\" + point.y); } static class Point { private int x; private int y; public Point(int x, int y) { x = x; y = y; } } }\",\"上面的alloc()方法，经过标量替换后，会变成\",\"private static void alloc() { int x = 1; int y = 2; System.out.println(\\\"x = \\\" + x + \\\", y = \\\" + y); }\",\"有什么好处？可以大大减少堆内存的占用。因为不用创建对象了，也就不用分配内存了。\",\"标量替换为栈上分配提供了很好的基础。\",\"参数-XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。\",\"但这不能说明把对象分配在了栈上。这种情况没有创建对象。\"]},\"511\":{\"h\":\"逃逸分析：并不成熟\",\"t\":[\"关于逃逸分析的论文在1999年就己经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。\",\"其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。\",\"一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\",\"虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。\",\"注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里己经说明，所以可以明确所有的对象实例都是创建在堆上。\",\"目前很多书籍还是基于JDK7以前的版本，JDK己经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代己经被元数据区取代。但是，intern字符串的缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。\"]},\"512\":{\"h\":\"小结\",\"t\":[\"年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\",\"老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。\",\"当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率大大低于年轻代。\"]},\"513\":{\"h\":\"参考链接/其他工具\",\"t\":[\"1. JVM参数-Oracle官网\",\"2. arthas - 阿里开源的Java诊断工具\",\"3. Escape Analysis\"]},\"514\":{\"h\":\"垃圾回收概述\"},\"515\":{\"h\":\"1. 什么是垃圾\",\"t\":[\"三个经典问题：\",\"哪些内存需要回收？\",\"什么时候回收？\",\"如何回收？\",\"垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.\",\"如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。\"]},\"516\":{\"h\":\"2. 为什么需要GC\",\"t\":[\"对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫\",\"除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。\",\"随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。\"]},\"517\":{\"h\":\"3. Java 垃圾回收机制\",\"t\":[\"自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低了内存泄漏和内存溢出的风险。 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。\",\"缺点：弱化java开发任意在程序出现内存溢出时定位问题和解决问题的能力。\",\"参考：oracle官网对垃圾回收的描述\"]},\"518\":{\"h\":\"4. 大厂面试题\",\"t\":[\"蚂蚁金服： 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1 一面：GC算法有哪些，目前的JDK版本采用什么回收算法 一面：GI回收器讲下回收过程 GC是什么？为什么要有GC？ 一面：GC的两种判定方法？CMS收集器与G1收集器的特点。\",\"百度： 说一下GC算法，分代回收说下 垃圾收集策略和算法\",\"天猫： 一面：jvm GC原理，怎么回收内存 一面：CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？\",\"滴滴： 一面．java的垃圾回收器都有哪些，说下gl的应用场景，平时你是如何搭配使用垃圾回收器的。\",\"京东： 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 垃圾回收算法的实现原理：\",\"阿里： 讲一下垃圾回收算法： 什么情况下触发垃圾回收？ 如何选择合适的垃圾收集算法？\",\"字节跳动： 常见的垃圾回收器算法有哪些，各有什么优劣？ System．gc()和runtime.gc()会做什么事情？ 一面：JavaGC机制？GCRoots有哪些？ 二面．Java对象的回收方式，回收算法： CMS和G1了解么，CMS解决什么问题，说一下回收的过程。 CMS回收停顿了几次，为什么要停顿两次。\"]},\"519\":{\"h\":\"5. 在Java语言中，GC Roots包括哪些元素？\",\"t\":[\"虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。\",\"本地方法栈内JNI（通常说的本地方法）引用的对象\",\"方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量\",\"方法区中常量引用的对象。比如：字符串常量池(String Table)里的引用\",\"所有被同步锁synchronized持有的对象\",\"Java虚拟机内部的引用：基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。\",\"反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。\"]},\"520\":{\"h\":\"6. 常见的垃圾收集算法\",\"t\":[\"标记-清除算法（Mark-Sweep）\",\"复制算法（Copying）\",\"标记-压缩算法（Mark-Compact）\"]},\"521\":{\"h\":\"6.1 标记-清除算法（Mark-Sweep）\",\"t\":[\"当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。\",\"标记：收集器从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。\",\"清除：收集器对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。\",\"缺点：\",\"效率不高（在进行GC的时候，需要停止整个应用程序，导致用户体验差）\",\"空间碎片（这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表）\",\"注意：何为清除？\",\"这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。即直接覆盖。\"]},\"522\":{\"h\":\"6.2 复制算法（Copying）『用于新生代』\",\"t\":[\"核心思想： 将内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\",\"优点：\",\"效率高（没有标记和清除过程，实现简单，运行高效）\",\"没有碎片（复制过去以后保证空间的连续性，不会出现“碎片”问题）\",\"缺点：\",\"需要两倍的内存空间。\",\"对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。\",\"特别的： 如果系统中的垃圾对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。\",\"应用场景： 在新生代，对常规应用的垃圾回收，一次通常可以回收70%~99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。\"]},\"523\":{\"h\":\"6.3 标记-压缩算法（Mark-Compact）『用于老年代』\",\"t\":[\"背景： 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。 标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩(Mark-Compact)算法由此诞生。\",\"执行过程： 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 之后，清理边界外所有的空间。\",\"标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-sweep-Compact)算法。 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。\",\"优点：\",\"无内存碎片（消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可）\",\"空间使用率高（消除了复制算法当中，内存减半的高额代价）\",\"缺点：\",\"从效率上来说，标记-整理算法要低于复制算法。\",\"移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。 移动过程中，需要全程暂停用户应用程序。即 STW。\"]},\"524\":{\"h\":\"6.4 对比三种算法\",\"t\":[\"标记清除\",\"标记压缩\",\"复制\",\"速率\",\"中等\",\"最慢\",\"最快\",\"空间开销\",\"少（但会堆积碎片）\",\"少（不堆积碎片）\",\"通常需要活对象的2倍空间（不堆积碎片）\",\"移动对象\",\"否\",\"是\",\"是\",\"我们可以看到，没有最好的算法，只有最合适的算法。\"]},\"525\":{\"h\":\"6.5 分代收集算法\",\"t\":[\"前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。\",\"分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\",\"在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。\",\"目前几乎所有的垃圾回收器都采用分代收集算法执行垃圾回收的\",\"在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。\",\"年轻代（Young Gen）：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。\",\"这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot 中的两个 Survivor 的设计得到缓解。\",\"老年代（Tenured Gen）：区域较大，对象生命周期长、存活率高，回收不频繁。\",\"这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。\",\"标记（Mark） 阶段的开销与存活对象的数量成正比。\",\"清除（Sweep） 阶段的开销与所管理区域的大小成正相关。\",\"压缩（Compact） 阶段的开销与存活对象的数据成正比。\",\"以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。\",\"分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代\"]},\"526\":{\"h\":\"6.6 增量收集算法\",\"t\":[\"概述\",\"上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World（STW） 的状态。在这种状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。\",\"基本思想\",\"如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\",\"总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。\",\"缺点\",\"使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。\"]},\"527\":{\"h\":\"6.7 分区算法\",\"t\":[\"一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。\",\"分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。\"]},\"528\":{\"h\":\"6.8 写到最后\",\"t\":[\"注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。\"]},\"529\":{\"h\":\"7. 垃圾收集器\",\"t\":[\"垃圾收集器是垃圾回收算法的具体实现。\"]},\"530\":{\"h\":\"Serial 串行收集器\",\"t\":[\"Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \\\"Stop The World\\\" ），直到它收集结束。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"优点：简单高效，没有线程交互的开销。\"]},\"531\":{\"h\":\"ParNew 收集器\",\"t\":[\"ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\"]},\"532\":{\"h\":\"Parallel Scavenge 收集器（ JDK1.8 默认的收集器）\",\"t\":[\"Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。\",\"区别是：Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。\",\"JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能\"]},\"533\":{\"h\":\"Serial Old 收集器\",\"t\":[\"Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\"]},\"534\":{\"h\":\"CMS 收集器（并发标记清除，不推荐）\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\",\"从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种『标记-清除』 算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\",\"初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\",\"并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\",\"并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\",\"优点：\",\"并发收集、低停顿\",\"缺点：\",\"对 CPU 资源敏感\",\"无法处理浮动垃圾\",\"使用的『标记-清除』算法会导致收集结束时会有大量空间碎片产生。最后还是需要Serial Old来清理碎片\",\"【新增】只针对老年代，和Parallel Scavenge不兼容，只能和ParNew配合使用。\",\"以上缺点，造成的结果就是ParNew + CMS + Serial Old的组合工作起来其实并不稳定。为了得到CMS那一点好处，需要付出很多的代价（包括JVM调参）。所以作为默认GC（jdk1.7, 1.8），采用Parallel Scavenge/Parallel Old这种省心又省力方案完全合理。\",\"在 JEP363中，CMS已被移除。\"]},\"535\":{\"h\":\"G1 收集器\",\"t\":[\"G1 (Garbage-First) 是一款面向服务器的垃圾收集器。主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.\",\"被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：\",\"并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\",\"分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\",\"空间整合：与 CMS 的『标记-清理』算法不同，G1 从整体来看是基于『标记-整理』算法实现的收集器；从局部上来看是基于『标记-复制』算法实现的。\",\"可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\",\"G1 收集器的运作大致分为以下几个步骤：\",\"初始标记\",\"并发标记\",\"最终标记\",\"筛选回收\",\"G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\"]},\"536\":{\"h\":\"ZGC 收集器\",\"t\":[\"与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。\",\"在 ZGC 中出现 Stop The World 的情况会更少！\"]},\"537\":{\"h\":\"JVM默认使用的收集器\",\"t\":[\"jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代），吞吐量优先。\",\"jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代），吞吐量优先。\",\"jdk1.9 默认垃圾收集器G1\",\"java -XX:+PrintCommandLineFlags -version ：可查看默认设置收集器类型\",\"java -XX:+PrintGCDetails：可通过打印的GC日志的新生代、老年代名称判断。在1.8环境下，这个命令执行后会出现PSYoungGen、ParOldGen字样，表示使用的是默认收集器。\",\"目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。\"]},\"538\":{\"h\":\"Shenandoah\",\"t\":[\"待补充。\",\"todo...\"]},\"539\":{\"h\":\"收集器之间的搭配关系\",\"t\":[\"image-20220525105153278\",\"新生代（复制算法）\",\"老年代\",\"Serial （串行，速度优先）\",\"Serial Old （串行，标记整理，速度优先）\",\"ParNew（Serial 的多线程版本，串行，速度优先）\",\"CMS（并发，标记清除，可搭配Serial Old，速度优先）\",\"Parallel Scavenge （并行，吞吐量优先）\",\"1. Parallel Old （并行，吞吐量优先）2. Serial Old（串行）（标记整理）\",\"新生代 + 老年代\",\"G1（并发，标记整理 + 复制。速度优先）\"]},\"540\":{\"h\":\"8. 其他\",\"t\":[\"MAT: eclipse发布的内存分析工具\",\"JProfiler: GC Roots溯源，分析OOM等\",\"知乎 - 为什么 JDK 8 默认使用 Parallel Scavenge 收集器？\",\"知乎 - JVM默认老年代回收是 PSMarkSweep(Serial-Old) 还是Parallel Old？\"]},\"541\":{\"h\":\"JVM\",\"t\":[\"JVM的相关知识。大部分来自尚硅谷宋红康老师的课程。\"]},\"542\":{\"h\":\"lambda\",\"t\":[\"待补充\"]},\"543\":{\"h\":\"流\"},\"544\":{\"h\":\"流简介\",\"t\":[\"流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。简短的定义就是“从支持数据处理操作的源生成的元素序列”。\",\"流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。\"]},\"545\":{\"h\":\"流操作\"},\"546\":{\"h\":\"流操作分类\",\"t\":[\"对流的操作可以分为两类：中间操作、终端操作。如下方代码所示，filter, map, limit 方法的返回值都是流，可以连成一条流水线，它们就是中间操作。collect 触发流水线执行并关闭，它就是终端操作。\",\"可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。\",\"List<String> names = menu.stream() .filter(d -> d.getCalories() > 300) // 中间操作 .map(Dish::getName) // 中间操作 .limit(3) // 中间操作 .collect(toList()); // 终端操作\"]},\"547\":{\"h\":\"使用流\",\"t\":[\"流的使用一般包括三件事：\",\"一个数据源（如集合）来执行一个查询；\",\"一个中间操作链，形成一条流的流水线；\",\"一个终端操作，执行流水线，并能生成结果。\",\"常见的中间操作有：filter，map, limit, sorted, distinct。常见的终端操作有：forEach, count, collect。\"]},\"548\":{\"h\":\"筛选和切片\",\"t\":[\"用谓词切片。\",\"如下方的filter()方法。接收一个返回boolean值的函数作为参数，并返回一个包含了符合该条件的元素的流。\",\"List<Dish> vegetarianMenu = menu.stream() .filter(Dish::isVegetarian) .collect(toList());\",\"筛选各异的元素（去重）\",\"如下方的distinct()方法，会在filter方法返回的偶数流中，去掉重复的元素。\",\"List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); numbers.stream() .filter(i -> i % 2 == 0) .distinct() .forEach(System.out::println);\",\"截短流\",\"流支持limit(n)方法，该方法会返回一个不超过给定长度n的流。如下图，第3行的limit(3)方法会返回流中的前3个元素。\",\"如果limit方法的参数超过了流中元素的数量，limit返回的流会包含所有元素。不会报错。\",\"List<Dish> dishes = menu.stream() .filter(d -> d.getCalories() > 300) .limit(3) .collect(toList());\",\"跳过元素\",\"流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。\",\"List<Integer> list = Arrays.asList(1, 2, 3, 1, 2, 4, 1).stream() .skip(10) // 跳过10个元素，会返回一个空流。 .collect(Collectors.toList());\"]},\"549\":{\"h\":\"映射\",\"t\":[\"Stream API通过map和flatMap方法提供了映射方法，用来提取某些对象中的信息。\",\"对流中每个元素应用函数\",\"如下方代码，把方法引用Dish::getName传给了map方法，来提取流中菜肴的名称。因为getName方法返回一个String，所以map方法输出的流的类型就是Stream<String>。\",\"List<String> dishNames = menu.stream() .map(Dish::getName) .collect(toList());\",\"也可以像下方代码这样，对流中每个字符串元素，返回它们的长度。最终返回Stream<Integer>。\",\"List<String> words = Arrays.asList(\\\"Java 8\\\", \\\"Lambdas\\\", \\\"In\\\", \\\"Action\\\"); List<Integer> wordLengths = words.stream() .map(String::length) .collect(toList())\",\"流的扁平化\",\"如下方代码所示，map()方法会将原始流内的每个字符串转换为字符串数组，该方法返回一个数组串数组流Stream<String[]>。而flatMap()方法，会将流扁平化，对字符串数组流中的每个数组，都应用Arrays::stream方法，将每个数组都转成字符串流Stream<String>的内容，并返回这个字符串流。\",\"Stream<String> stream = Arrays.asList(\\\"Hello\\\", \\\"World\\\").stream() .map(s -> s.split(\\\"\\\")) .flatMap(Arrays::stream);\",\"使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用Arrays::stream时生成的单个流都被合并起来，即扁平化为一个流。一言以蔽之，flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。\",\"再看一个稍微复杂的例子：给定两个数字列表，如何返回所有的数对呢？如，给定 int[] arr1 = {1, 2, 3}，int[] arr2 = {3, 4}；需要返回_[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)_\",\"List<int[]> pairs = Arrays.asList(1, 2, 3).stream() .flatMap(i -> Arrays.asList(3, 4).stream().map(j -> new int[]{i, j})) .collect(Collectors.toList());\",\"再进一步，如果只返回总和能被3整除的数对呢？加一个筛选即可。如下方代码所示：\",\"List<int[]> pairs = Arrays.asList(1, 2, 3).stream() .flatMap( i -> Arrays.asList(3, 4).stream(). filter(j -> (i+j)%3 == 0) .map(j -> new int[]{i, j}) ).collect(Collectors.toList());\"]},\"550\":{\"h\":\"查找和匹配\",\"t\":[\"主要有这些方法：allMatch、anyMatch、noneMatch、findFirst和findAny。\"]},\"551\":{\"h\":\"规约\"},\"552\":{\"h\":\"数值流\"},\"553\":{\"h\":\"构建流\"},\"554\":{\"h\":\"日期相关\"},\"555\":{\"h\":\"前言\",\"t\":[\"java8的日期相关类做了很多升级。解决了很多java8之前使用日期类的痛点：\",\"util包下的Date和Calendar类不支持时区，线程不安全。\",\"格式化类java.text.SimpleDateFormat线程不安全（相关资料）。\",\"API调用繁琐。\",\"java8新增的日期类：\",\"java8新增的日期类都在java.time包中，时间日期类包含LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period。日期格式化类DateTimeFormatter。\",\"新的时区类java.time.ZoneId替代原有的java.util.TimeZone；ZoneId对象可以通过ZoneId.of()方法创建，也可以通过ZoneId.systemDefault()获取系统默认时区。\"]},\"556\":{\"h\":\"Java8 常用日期类概述\"},\"557\":{\"h\":\"Instant类\",\"t\":[\"Instant类对时间轴上的单一瞬时点建模，可以用于记录应用程序中的事件时间戳，之后学习的类型转换中，均可以使用Instant类作为中间类完成转换。\",\"封装的是UTC（格林威治时间），比我们晚8小时。\"]},\"558\":{\"h\":\"Duration类\",\"t\":[\"Duration类表示秒或纳秒时间间隔，适合处理较短的时间，需要更高的精确性。\"]},\"559\":{\"h\":\"Period类\",\"t\":[\"Period类表示一段时间的年、月、日。\",\"使用例子如下，作用是给日期加上指定的年月日。\",\"public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 1, 10, 10); System.out.println(localDateTime); // 2020-01-01T10:10 Period of = Period.of(3, 1, 2); System.out.println(localDateTime.plus(of)); // 2023-02-03T10:10 }\"]},\"560\":{\"h\":\"LocalDate类\",\"t\":[\"LocalDate是一个不可变的日期时间对象，表示日期，通常被视为年月日。默认当前系统时区。\"]},\"561\":{\"h\":\"LocalTime类\",\"t\":[\"LocalTime是一个不可变的日期时间对象，代表一个时间，通常被看作是小时-秒，时间表示为纳秒精度。默认当前系统时区。\"]},\"562\":{\"h\":\"LocalDateTime类\",\"t\":[\"LocalDateTime类是一个不可变的日期时间对象，代表日期时间，通常被视为年-月-日=时-分-秒。默认当前系统时区。\",\"如果需要手动指定时区，可以向下方这样实现。先打印可用的时区id字符串，再通过ZoneId.of()获取对应的时区对象。\",\"public static void main(String[] args) { // System.out.println(ZoneId.systemDefault()); // 获取当前系统默认时区字符串 ZoneId.getAvailableZoneIds().stream().forEach(System.out::println); System.out.printf(\\\"now%s\\\\n\\\", LocalDateTime.now(ZoneId.of(\\\"Asia/Shanghai\\\"))); }\",\"查看给定的LocalDateTime在其他时区的时间\",\"public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 10, 10, 11, 20, 30); // 获取指定参数对应的上海时区的时间 ZonedDateTime shanghaiTime = localDateTime.atZone(ZoneId.of(\\\"Asia/Shanghai\\\")); // 获取指定ZoneDateTime，在另一个时区对应的时间 ZonedDateTime tokyoDateTime = shanghaiTime.withZoneSameInstant(ZoneId.of(\\\"Asia/Tokyo\\\")); System.out.printf(\\\"shanghaiTime %s\\\\n\\\", shanghaiTime); System.out.printf(\\\"tokyoDateTime %s\\\\n\\\", tokyoDateTime); }\",\"修改时间格式\",\"withXXX()系列方法，可以在不知道时间值的情况下，把对应的年月日时分秒等修改为想要的值。\"]},\"563\":{\"h\":\"Year\"},\"564\":{\"h\":\"YearMonth\"},\"565\":{\"h\":\"MonthDay\",\"t\":[\"上述这些类均提供了静态的now()方法，可以根据当前日期或时间创建实例。\",\"上述这些类均提供了静态的of()方法可以根据给定的参数生成对应的日期/时间对象，基本上每个基本类都有of方法用于生成的对应的对象，而且重载形式对边，可以根据不同的参数生成对应的数据。\",\"LocalDate与LocalTime都是不可变对象（确保线程安全），它们中有plus()/minus()系列方法，可以在已有对象上进行年月日时分秒/纳秒的加减。\"]},\"566\":{\"h\":\"Month\",\"t\":[\"是一个枚举。Month中包含标准日历中的12个月份的常量（从JANUARY到DECEMEBER），也提供了一些方便的方法供我们使用。\",\"推荐在初始化LocalDate和LocalDateTime对象的时候，月份的参数使用枚举的方式传入，这样更简单易懂而且不易出错。如果是老的思维，Calendar传入0的话，会出现异常。\"]},\"567\":{\"h\":\"其他相关类/接口\"},\"568\":{\"h\":\"时间单位\",\"t\":[\"TemporalUnit：接口，主要实现类是ChronoUnit\",\"ChronoUnit：枚举，实现了TemporalUnit。主要是提供一些时间单位，如时分秒，半天，年月日，四年，百年，千年...等。用法参考：\",\"public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 1, 10, 10); LocalDateTime localDateTime1 = localDateTime.plus(1, ChronoUnit.MILLENNIA); // 加一千年 System.out.println(localDateTime1); // 3020-01-01T10:10 }\"]},\"569\":{\"h\":\"TemporalAdjuster 调节器\",\"t\":[\"使用形式：with(TemporalAdjuster adjuster)\",\"我们可以通过with方法修改日期时间对象中封装的数据，但是有一些时候可能会做一些复杂的操作，比如说将时间调整到下个周的周日，下一个工作日，或者本月中的某一天，这个时候可以使用调节器TemporalAdjuster来更方便的处理日期。\",\"如上方的使用形式，with方法有一个重载形式，需要传入一个TemporalAdjuster对象，通过查看发现TemporalAdjuster是一个接口，那么实际上传入的是这个接口的实现类对象，通常使用TemporalAdjusters来生成。\",\"如下图第3行，表示把日期修改为当月的第一天；第4行表示改为下一个周日。\",\"public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 3, 16, 10, 10); LocalDateTime localDateTime1 = localDateTime.with(TemporalAdjusters.firstDayOfMonth()); LocalDateTime localDateTime2 = localDateTime.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(localDateTime); // 2020-03-16T10:10 System.out.println(localDateTime1); // 2020-03-01T10:10 System.out.println(localDateTime2); // 2020-03-22T10:10 }\"]},\"570\":{\"h\":\"其他\"},\"571\":{\"h\":\"Date转换为LocalDate\",\"t\":[\"使用Instant中转，如下所示。\",\"public static void main(String[] args) { Date date = new Date(); Instant instant = date.toInstant(); ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault()); LocalDate localDate = zonedDateTime.toLocalDate(); System.out.println(date); System.out.println(localDate); }\"]},\"572\":{\"h\":\"线程安全的日期解析与格式化工具\"},\"573\":{\"h\":\"\",\"t\":[\"DateTimeFormatter类提供了大量预定义格式化器，包括常量（如ISO_LOCAL_DATE），模式字母（如yyyy-MM-dd）以及本地化样式。\",\"与SimpleDateFormat不同的是，新版本的日期/时间API的格式化与解析不需要再创建转换器对象了，通过时间日期对象的parse/format方法可以直接进行转换。\",\"public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 3, 3, 1, 1, 1); String s1 = localDateTime.format(DateTimeFormatter.ISO_DATE); String s2 = localDateTime.format(DateTimeFormatter.ISO_DATE_TIME); String s3 = localDateTime.format(DateTimeFormatter.ofPattern(\\\"yyyy,MM,dd...hh:mm:ss:SSS\\\")); System.out.println(s1); // 2020-03-03 System.out.println(s2); // 2020-03-03T01:01:01 System.out.println(s3); // 2020,03,03...01:01:01:000 LocalDateTime parse = LocalDateTime.parse(s3); System.out.println(parse); // 2020-03-03T01:01:01 }\",\"FormatStyle：\",\"public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 3, 3, 1, 1, 1); System.out.println(localDateTime.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL))); // 2020年3月3日 星期二 System.out.println(localDateTime.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG))); // 2020年3月3日 System.out.println(localDateTime.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM))); // 2020-3-3 System.out.println(localDateTime.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT))); // 20-3-3 }\",\"注意\",\"这种方式中，FULL、LONG在不同时区下显示的效果会不一样！\"]},\"574\":{\"h\":\"其他工具类\",\"t\":[\"hutool中关于时间的API。\",\"Joda-Time。在java8之前就出现的一个开源包，用来解决之前的日期类相关的问题。其团队也参与了java.time包的开发。\"]},\"575\":{\"h\":\"Java8\",\"t\":[\"Java8的相关操作总结。\"]},\"576\":{\"h\":\"Docker常用命令\"},\"577\":{\"h\":\"docker ps [OPTIONS]\",\"t\":[\"列出容器\",\"OPTIONS说明：\",\"-a :显示所有的容器，包括未运行的。\",\"-q :静默模式，只显示容器编号。\",\"--format :指定返回值的模板文件。\",\"-l :显示最近创建的容器。\",\"-n :列出最近创建的n个容器。\",\"--no-trunc :不截断输出。\",\"-s :显示总的文件大小。\",\"-f 或-filter :根据条件过滤显示的内容。格式为key=value，如果超过一个过滤，就传递多个标志（如-filter \\\"foo=bar\\\" -filter \\\"bif=baz\\\"）\",\"-f 目前支持的过滤器\",\"id (容器的id）\",\"label\",\"name（容器名称）\",\"exited （整数-容器退出状态码，只有在使用-all才有用）\",\"status 容器状态（created,restarting,running,paused,exited,dead）\",\"ances tor 过滤从指定镜像创建的容器\",\"before （容器的名称或id）,过滤在给定id或名称之后创建的容器\",\"isolation (default process hyperv) (windows daemon only)\",\"volume (数据卷名称或挂载点)，--过滤挂载有指定数据卷的容器\",\"network（网络id或名称），过滤连接到指定网络的容器\",\"如：docker ps -f status=exited // 列出已退出的容器\"]},\"578\":{\"h\":\"Docker常见问题\"},\"579\":{\"h\":\"/var/lib/docker/overlay2占用过大\",\"t\":[\"解决方法\"]},\"580\":{\"h\":\"Git常用操作\"},\"581\":{\"h\":\"常用操作\"},\"582\":{\"h\":\"合并某个或某些提交到其他分支\",\"t\":[\"比如，在A分支提交了代码，想合并到B分支。\"]},\"583\":{\"h\":\"方法1 - 使用 sourcetree【常用】\",\"t\":[\"切换到B分支，选择线上所有分支\",\"点击A分支需要合并的提交，右击，选择『遴选』\",\"点击确定\",\"点击推送\",\"image-20221012110108730\",\"image-20221012110139249\"]},\"584\":{\"h\":\"方法2 - 使用git命令\",\"t\":[\"#1.aaa是commit id git cherry-pick aaa #2.合并aaa bbb git cherry-pick A B #3.合并从aaa到bbb的所有提交，不包括aaa git cherry-pick A..B #4.合并从aaa到bbb的所有提交，包括aaa git cherry-pick A^..B\"]},\"585\":{\"h\":\"已提交的内容进行修改\",\"t\":[\"有时提交过代码之后，发现一个地方改错了，下次提交时不想保留上一次的记录；或者上一次的commit message的描述有误，这时候可以使用接下来的这个命令：git commit --amend。\",\"修改提交时的注释。输入git commit --amend，在bash或弹出的记事本里修改即可。\",\"修改文件。修改完毕后暂存，再输入git commit --amend，进入bash或弹出的记事本后直接退出。此时再查看刚才的提交，可以发现修改的内容已经进去了。\",\"警告\",\"只能在commit后，push前使用。\",\"该操作会改变原来的commit id。\"]},\"586\":{\"h\":\"常见问题\"},\"587\":{\"h\":\"errno 10054\",\"t\":[\"错误描述：OpenSSL SSL_read: Connection was reset, errno 10054\",\"GitHub pull/push时会遇到这个问题。错误原因可能是网络不稳定，连接超时造成的，可以试试下面的命令\",\"git config --global http.sslVerify \\\"false\\\"\"]},\"588\":{\"h\":\"errno 443\",\"t\":[\"fatal: unable to access 'https://github.com/xxxxx/': Failed to connect to github.com port 443: Timed out\"]},\"589\":{\"h\":\"Spring面试题\"},\"590\":{\"h\":\"参考内容：\",\"t\":[\"JavaGuide - Spring常见问题总结\",\"JavaGuide - Spring事务总结\",\"JavaGuide - Spring中都用到了哪些设计模式？\",\"9 种设计模式在 Spring 中的运用，一定要非常熟练！\",\"SpringBoot+Spring常用注解总结\",\"Spring IOC 容器源码分析\"]},\"591\":{\"h\":\"什么是Spring框架？（谈谈你对Spring的理解？）\",\"t\":[\"Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。\",\"我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。\",\"Spring 官网列出的 Spring 的 6 个特征:\",\"核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。\",\"测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。\",\"数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。\",\"Web支持 : Spring MVC和Spring WebFlux Web框架。\",\"集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。\",\"语言 ：Kotlin，Groovy，动态语言。\"]},\"592\":{\"h\":\"Spring跟SpringMVC的区别？\",\"t\":[\"1、Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架，可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。 Spring也提供了很多基础功能（事务管理、持久化框架集成等等）\",\"2、Spring MVC就是一个MVC模式的WEB开发框架，是基于Spring功能之上添加的Web框架，想用SpringMVC必须先依赖Spring。Spring是一个通用解决方案, 最大的用处就是通过Ioc/AOP解耦, 降低软件复杂性。\",\"3、Spring可以说是一个管理bean的容器，也可以说是包括很多开源项目的总称，spring mvc是其中一个开源项目。\"]},\"593\":{\"h\":\"Spring流程？\"},\"594\":{\"h\":\"什么是IOC？什么是AOP？\",\"t\":[\"参考-javaguide\"]},\"595\":{\"h\":\"IOC\",\"t\":[\"IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。\",\"将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。\",\"Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。\",\"推荐阅读：https://www.zhihu.com/question/23277575/answer/169698662\",\"Spring IoC的初始化过程：\",\"IoC源码阅读\",\"https://javadoop.com/post/spring-ioc\"]},\"596\":{\"h\":\"AOP\",\"t\":[\"AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制、异常处理等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\",\"Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：\",\"当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。\",\"使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。\"]},\"597\":{\"h\":\"IOC注入的方式？\",\"t\":[\"构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。\",\"Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。\",\"注解注入：基于@Autowired的自动装配，默认是根据类型注入，可以用于构造器、字段、方法注入。\",\"可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。\"]},\"598\":{\"h\":\"请解释 Spring Bean 的自动装配？\",\"t\":[\"no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。\",\"byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。\",\"byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。\",\"constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。\",\"autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。\"]},\"599\":{\"h\":\"如何开启基于注解的自动装配？说一下这些注解？\",\"t\":[\"@Autowired(required = false) 当不能确定 Spring 容器中一定拥有某个类的 Bean 时，可以在需要自动注入该类 Bean 的地方可以使用 @Autowired(required = false)，这等于告诉 Spring：在找不到匹配 Bean 时也不报错。\",\"@Autowired @Qualifier(\\\"office\\\") private Office office; //xml配置文件中存在office和office2两个Bean\",\"在 Spring 容器中配置了两个类型为 Office 类型的 Bean，当对 Boss 的 office 成员变量进行自动注入时，Spring 容器将无法确定到底要用哪一个 Bean，因此异常发生了。Spring 允许我们通过 @Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了。\",\"@Qualifier(\\\"office\\\") 中的 office 是 Bean 的名称，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。\",\"@Autowired 可以对成员变量、方法以及构造函数进行注释，而 @Qualifier 的标注对象是成员变量、方法入参、构造函数入参。\",\"正是由于注释对象的不同，所以 Spring 不将 @Autowired 和 @Qualifier 统一成一个注释类。 @Autowired是根据类型注入，@Qualifier是根据名称注入\",\"以上说的Bean 的名称是指bean中的id\"]},\"600\":{\"h\":\"构造方法注入和设值注入有什么区别？\",\"t\":[\"在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。\",\"设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。\",\"在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。\",\"在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出ObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。\",\"1、构造器注入适用具有强依赖和不变性的依赖； 2、Setter注入适用于具有可选性和可变性的依赖注入； 3、Field注入，尽量少使用，如果需要则使用@Resource进行替代，以降低耦合性。\"]},\"601\":{\"h\":\"使用@Autowired注解自动装配的过程是怎样的？\",\"t\":[\"使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。 在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：\",\"如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\",\"如果查询的结果不止一个，那么@Autowired会根据名称来查找；\",\"如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false\"]},\"602\":{\"h\":\"Spring AOP和AspectJ AOP有什么区别？\",\"t\":[\"Spring AOP 基于动态代理实现，属于运行时增强。 AspectJ 则属于编译时增强，主要有3种方式：\",\"编译时织入：指的是增强的代码和源代码我们都有，直接使用 AspectJ 编译器编译就行了，编译之后生成一个新的类，他也会作为一个正常的 Java 类装载到JVM。\",\"编译后织入：指的是代码已经被编译成 class 文件或者已经打成 jar 包，这时候要增强的话，就是编译后织入，比如你依赖了第三方的类库，又想对他增强的话，就可以通过这种方式。\",\"加载时织入：指的是在 JVM 加载类的时候进行织入。\",\"总结下来的话，就是 Spring AOP 只能在运行时织入，不需要单独编译，性能相比 AspectJ 编译织入的方式慢，而 AspectJ 只支持编译前后和类加载时织入，性能更好，功能更加强大。\",\"Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。 Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。\"]},\"603\":{\"h\":\"Spring AOP的实现原理？\",\"t\":[\"实现AOP的技术，主要分为两大类：\",\"一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行。\",\"二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。\",\"Spring AOP 的实现原理：AOP 框架负责动态地生成 AOP 代理类，这个代理类的方法则由 Advice和回调目标对象的方法所组成, 并将该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异，AOP方法在特定切入点添加了增强处理，并回调了目标对象的方法。\",\"Spring AOP使用动态代理技术在运行期织入增强代码。使用两种代理机制：\",\"基于JDK的动态代理（JDK本身只提供接口的代理）、基于CGlib的动态代理。\",\"JDK的动态代理：\",\"JDK的动态代理主要涉及java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler只是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态的将横切逻辑与业务逻辑织在一起。而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。\",\"其代理对象必须是某个接口的实现, 它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理.只能实现接口的类生成代理,而不能针对类\",\"CGLib的动态代理：\",\"CGLib采用底层的字节码技术，为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类的调用方法，并顺势织入横切逻辑.它运行期间生成的代理对象是目标类的扩展子类.所以无法通知final、private的方法,因为它们不能被覆写。是针对类实现代理,主要是为指定的类生成一个子类,覆盖其中方法。\",\"在spring中默认情况下使用JDK动态代理实现AOP,如果proxy-target-class设置为true或者使用了优化策略那么会使用CGLIB来创建动态代理。\",\"Spring AOP在这两种方式的实现上基本一样。以JDK代理为例，会使用JdkDynamicAopProxy来创建代理，在invoke()方法首先需要织入到当前类的增强器封装到拦截器链中，然后递归的调用这些拦截器完成功能的织入．最终返回代理对象。\"]},\"604\":{\"h\":\"AOP的常用术语及其含义？\",\"t\":[\"面向切面编程（AOP）：允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。\",\"切面(Aspect) ：AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。\",\"通知(Advice)：通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。Spring切面可以执行一下五种类型的通知:\",\"before(前置通知)：在一个方法之前执行的通知。\",\"after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出。\",\"after-returning(后置通知)：在某连接点正常完成后执行的通知。\",\"after-throwing(异常通知)：在方法抛出异常退出时执行的通知。\",\"around(环绕通知)：在方法调用前后触发的通知。\",\"连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。\",\"切入点(Pointcut)：切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。\",\"引入（Introduction）：引入允许我们在已有的类上添加新的方法或属性。\",\"目标对象（Target Object）：被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。\",\"代理：代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。有以下几种代理：\",\"BeanNameAutoProxyCreator：bean名称自动代理创建器DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器Metadata autoproxying：元数据自动代理\",\"织入（Weaving）：将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。\"]},\"605\":{\"h\":\"项目中如何进行AOP配置？\",\"t\":[\"import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Service; @Service @Aspect public class AspectDemo { // 访问下方的方法时会触发 @Pointcut(\\\"execution(* com.hpt.demo01.controller.Hello.*(..))\\\") public void test() { } @Before(\\\"test()\\\") public void doBefore() { System.out.println(\\\"before!\\\"); } @After(\\\"test()\\\") public void doAfter() { System.out.println(\\\"after!\\\"); } @AfterThrowing(pointcut=\\\"test()\\\", throwing=\\\"exception\\\") public void doAfterThrow() { System.out.println(\\\"Error!!!\\\"); } @AfterReturning(\\\"test()\\\") public void doAfterRe() { System.out.println(\\\"AfterReturning!\\\"); } @Around(\\\"test()\\\") public void doAround(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\\\"doAround111!\\\"); joinPoint.proceed(); System.out.println(\\\"doAround222!\\\"); } }\",\"访问指定方法，console结果如下：\",\"doAround111! before! hello~~~~~~~~ AfterReturning! after! doAround222!\"]},\"606\":{\"h\":\"JDK动态代理和CGLIB代理有什么区别？\",\"t\":[\"JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。他基于反射的机制实现，生成一个实现同样接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。 而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。他的底层原理是基于 asm 第三方框架，通过修改字节码生成成成一个子类，然后重写父类的方法，实现对代码的增强。\"]},\"607\":{\"h\":\"动态代理跟静态代理的区别？\",\"t\":[\"静态代理：是由程序员创建或特定工具自动生成源代码，在对其进行编译。在程序运行之前，代理类的.class文件就已经存在了。\",\"动态代理：在程序运行时，运用反射机制动态创建而成。\",\"灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！\",\"JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。\"]},\"608\":{\"h\":\"反射的实现原理？\",\"t\":[\"JAVA反射机制是在运行状态中： 对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\",\"原理：Java在编译之后会生成一个class文件，反射通过字节码文件找到其类中的方法和属性等。\"]},\"609\":{\"h\":\"Spring自动注入类型？\",\"t\":[\"@Autowired注解——由spring提供\",\"@Qualifier （与@Autowired搭配按名称，如@Qualifier(\\\"iUserDao\\\")）\",\"@Resource注解——由JSR-250提供\",\"@Inject注解——由JSR-330提供\"]},\"610\":{\"h\":\"BeanFactory和FactoryBean的区别？\",\"t\":[\"都是用来创建对象的。\",\"BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。\",\"FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。\",\"使用BeanFactory的时候必须遵循完整的创建过程，这个过程是由Spring来管理控制的。而使用FactoryBean 只需要调用getObject就可以返回具体的对象，整个对象的创建过程是由用户自己来控制的，更加灵活。\"]},\"611\":{\"h\":\"BeanFactory和ApplicationContext有什么区别？\",\"t\":[\"ApplicationContext接口继承BeanFactory接口，Spring核心工厂是BeanFactory,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean,ApplicationContext是会在加载配置文件时初始化Bean。\",\"ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext,web项目使用WebApplicationContext，很少用到BeanFactory。\",\"两者都是通过xml配置文件加载bean,ApplicationContext和BeanFacotry相比,提供了更多的扩展功能，但其主要区别在于后者是延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用ApplicationContext。 BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\"]},\"612\":{\"h\":\"Bean是什么？\",\"t\":[\"Bean 在代码层面上可以简单认为是 BeanDefinition 的实例，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。 BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。\",\"BeanDefinition是一个接口。在接口中，默认只提供 sington 和 prototype 两种范围。request, session, globalSession, application, websocket 这几种属于基于 web 的扩展。\"]},\"613\":{\"h\":\"Bean的加载过程？\",\"t\":[\"实例化;\",\"设置属性值;\",\"如果实现了BeanNameAware接口,调用setBeanName设置Bean的ID或者Name;\",\"如果实现BeanFactoryAware接口,调用setBeanFactory 设置BeanFactory;\",\"如果实现ApplicationContextAware,调用setApplicationContext设置ApplicationContext\",\"调用BeanPostProcessor的预先初始化方法;\",\"调用InitializingBean的afterPropertiesSet()方法;\",\"调用定制init-method方法；\",\"调用BeanPostProcessor的后初始化方法;\"]},\"614\":{\"h\":\"Bean的生命周期？\",\"t\":[\"SpringBean 生命周期简单概括为4个阶段：\",\"实例化，创建一个Bean对象\",\"填充属性，为属性赋值\",\"初始化\",\"如果实现了xxxAware接口，通过不同类型的Aware接口拿到Spring容器的资源\",\"如果实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation和postProcessAfterInitialization方法\",\"如果配置了init-method方法，则会执行init-method配置的方法\",\"销毁\",\"容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法\",\"如果配置了destroy-method方法，则会执行destroy-method配置的方法\",\"另外一种描述：\",\"下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/open in new window ，除了这篇文章，再推荐一篇很不错的文章 ：https://www.cnblogs.com/zrtqsk/p/3735273.htmlopen in new window 。\",\"Bean 容器找到配置文件中 Spring Bean 的定义。\",\"Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。\",\"如果涉及到一些属性值 利用 set()方法设置一些属性值。\",\"如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。\",\"如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。\",\"如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。\",\"与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。\",\"如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法\",\"如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。\",\"如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。\",\"如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法\",\"当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。\",\"当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。\",\"Spring Bean 生命周期\"]},\"615\":{\"h\":\"Bean的作用范围？\",\"t\":[\"singleton（默认）：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。\",\"prototype： 每次请求都会创建一个新的 bean 实例。\",\"request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。\",\"session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境。\",\"global-Session：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境。Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。\"]},\"616\":{\"h\":\"Spring的单例实现原理\",\"t\":[\"Spring框架对单例的支持是采用单例注册表的方式进行实现的，而这个注册表的缓存是HashMap对象，如果配置文件中的配置信息不要求使用单例，Spring会采用新建实例的方式返回对象实例。\"]},\"617\":{\"h\":\"@Component 和 @Bean 的区别是什么？\",\"t\":[\"@Component 注解作用于类，而@Bean注解作用于方法。\",\"@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。\",\"@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。\",\"@Bean注解使用示例：\",\"@Configuration public class AppConfig { @Bean public TransferService transferService() { return new TransferServiceImpl(); } }\",\"上面的代码相当于下面的 xml 配置\",\"<beans> <bean id=\\\"transferService\\\" class=\\\"com.acme.TransferServiceImpl\\\"/> </beans>\",\"下面这个例子是通过 @Component 无法实现的。\",\"@Bean public OneService getService(status) { case (status) { when 1: return new serviceImpl1(); when 2: return new serviceImpl2(); when 3: return new serviceImpl3(); } }\"]},\"618\":{\"h\":\"将一个类声明为 bean 的注解有哪些?\",\"t\":[\"我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：\",\"@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。\",\"@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。\",\"@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。\",\"@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。\"]},\"619\":{\"h\":\"bean 标签中可以定义哪些属性？\",\"t\":[\"Property\",\"Introduce\",\"class\",\"类的全限定名\",\"name\",\"可指定 id、name(用逗号、分号、空格分隔)\",\"scope\",\"作用域\",\"constructor arguments\",\"指定构造参数\",\"properties\",\"设置属性的值\",\"autowiring mode\",\"no(默认值)、byName、byType、 constructor\",\"lazy-initialization mode\",\"是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)\",\"initialization method\",\"bean 属性设置完成后，会调用这个方法\",\"destruction method\",\"bean 销毁后的回调方法\",\"除了上面举例出来的这些，还有 factory-bean、factory-method、lookup-method、replaced-method、meta、qualifier\"]},\"620\":{\"h\":\"不同作用域的Bean相互依赖，有什么问题？如何处理？\",\"t\":[\"不同作用域Bean的依赖\"]},\"621\":{\"h\":\"Bean循环依赖问题？如何解决？\",\"t\":[\"高频面试题：Spring 如何解决循环依赖？Spring循环依赖三级缓存是否可以减少为二级缓存？\",\"首先，Spring 解决循环依赖有两个前提条件：\",\"不全是构造器方式的循环依赖\",\"必须是单例\",\"基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化的对象。\",\"第一级缓存：用来保存实例化、初始化都完成的对象\",\"第二级缓存：用来保存实例化完成，但是未初始化完成的对象\",\"第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象\",\"假设一个简单的循环依赖场景，A、B互相依赖。\",\"A对象的创建过程：\",\"创建对象A，实例化的时候把A对象工厂放入三级缓存\",\"A注入属性时，发现依赖B，转而去实例化B\",\"同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。\",\"接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存\",\"最后，一级缓存中保存着实例化、初始化都完成的A、B对象\",\"因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。\"]},\"622\":{\"h\":\"为什么要三级缓存？二级不行吗？\",\"t\":[\"不可以，主要是为了生成代理对象。\",\"因为三级缓存中放的是生成具体对象的匿名内部类，他可以生成代理对象，也可以是普通的实例对象。\",\"使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。\",\"假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，BeanPostProcessor去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。\"]},\"623\":{\"h\":\"Spring用到了哪些设计模式？\"},\"624\":{\"h\":\"\",\"t\":[\"又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\"]},\"625\":{\"h\":\"\",\"t\":[\"通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。\"]},\"626\":{\"h\":\"\",\"t\":[\"保证一个类仅有一个实例，并提供一个访问它的全局访问点。 spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。\"]},\"627\":{\"h\":\"\",\"t\":[\"在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。\"]},\"628\":{\"h\":\"\",\"t\":[\"在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ 首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。 spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。\"]},\"629\":{\"h\":\"\",\"t\":[\"为其他对象提供一种代理以控制对这个对象的访问。 从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。\"]},\"630\":{\"h\":\"\",\"t\":[\"定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 spring中Observer模式常用的地方是listener的实现。如ApplicationListener。\"]},\"631\":{\"h\":\"\",\"t\":[\"定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\"]},\"632\":{\"h\":\"\",\"t\":[\"定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。\"]},\"633\":{\"h\":\"Spring事务的实现方式有几种？\",\"t\":[\"Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。\",\"实现方式：\",\"编程式事务管理，在代码中调用 commit()、rollback()等事务管理相关的方法\",\"基于 TransactionProxyFactoryBean 的声明式事务管理\",\"基于注解 @Transactional 的声明式事务管理\",\"基于Aspectj AOP配置事务\"]},\"634\":{\"h\":\"Spring事务中的隔离级别有哪几种？\",\"t\":[\"隔离级别\",\"含义\",\"ISOLATION_DEFAULT\",\"使用后端数据库默认的隔离级别\",\"ISOLATION_READ_UNCOMMITTED\",\"允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。\",\"ISOLATION_READ_COMMITTED\",\"（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。\",\"ISOLATION_REPEATABLE_READ\",\"（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。\",\"ISOLATION_SERIALIZABLE\",\"完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。\",\"脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\",\"不可重复读 ：是指在一个事务内，多次读同一数据。\",\"幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\",\"配置参考：@Transactional(isolation = Isolation.READ_UNCOMMITTED)\"]},\"635\":{\"h\":\"Spring事务的传播行为？\",\"t\":[\"Propagation.REQUIRED（required）：支持当前事务，如果当前有事务， 那么加入事务， 如果当前没有事务则新建一个(默认情况)\",\"Propagation.REQUIRES_NEW (requires_new) ：支持当前事务，如果当前有事务，则挂起当前事务，然后新创建一个事务，如果当前没有事务，则自己创建一个事务。\",\"Propagation.MANDATORY (mandatory) ：支持当前事务，如果当前没有事务，则抛出异常。（当前必须有事务）\",\"Propagation.SUPPORTS (supports) ：如果当前有事务则加入，如果没有则不用事务。\",\"Propagation.NESTED (nested 嵌套事务) ：如果当前存在事务，则嵌套在当前事务中。如果当前没有事务，则新建一个事务自己执行（和required一样）。嵌套的事务使用保存点作为回滚点，当内部事务回滚时不会影响外部事物的提交；但是外部回滚会把内部事务一起回滚回去。（这个和新建一个事务的区别）\",\"Propagation.NOT_SUPPORTED（not_supported) ： 以非事务方式执行操作，如果当前存在事务就把当前事务挂起，执行完后恢复事务（忽略当前事务）；\",\"PROPAGATION_NEVER (never) ：以非事务方式执行，如果当前存在事务，则抛出异常。（当前必须不能有事务）\",\"配置参考：@Transactional(propagation=Propagation.REQUIRED)\"]},\"636\":{\"h\":\"Spring事务失效的场景？\",\"t\":[\"参考-Spring事务失效的 8 大原因\"]},\"637\":{\"h\":\"@Transactional(rollbackFor=Exception.class注解了解吗？\",\"t\":[\"如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚。\"]},\"638\":{\"h\":\"Spring框架中的单例Beans是线程安全的么？\",\"t\":[\"不是。因为当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。 但是，一般情况下，我们常用的 Controller、Service、Dao 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。 常见的有 2 种解决办法：\",\"在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。\",\"改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。\"]},\"639\":{\"h\":\"spring应用销毁是在哪里？\"},\"640\":{\"h\":\"Spring有哪些重要的扩展点？\"},\"641\":{\"h\":\"SpringMVC面试题\"},\"642\":{\"h\":\"Spring MVC 运行流程\",\"t\":[\"第一步：发起请求到前端控制器(DispatcherServlet)\",\"第二步：前端控制器请求HandlerMapping查找处理器Handler（ 可以根据xml配置、注解进行查找）\",\"第三步：处理器映射器HandlerMapping向前端控制器返回Handler\",\"第四步：前端控制器调用处理器适配器去执行Handler\",\"第五步：处理器适配器去执行Handler\",\"第六步：Handler执行完成给处理器适配器返回ModelAndView\",\"第七步：处理器适配器向前端控制器返回ModelAndView（ModelAndView是Springmvc框架的一个底层对象，包括Model和view）\",\"第八步：前端控制器请求视图解析器(ViewResolver)去进行视图解析（根据逻辑视图名称进行查找，生成视图对象）\",\"第九步：视图解析器向前端控制器返回视图对象View\",\"第十步：前端控制器进行视图渲染（ 视图渲染将模型数据(在ModelAndView对象中)填充到request域）\",\"第十一步：前端控制器向用户响应结果\",\"image-20220526224304005\"]},\"643\":{\"h\":\"说说对Spring MVC的理解？\",\"t\":[\"MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。\"]},\"644\":{\"h\":\"Springmvc的优点\",\"t\":[\"可以支持各种视图技术,而不仅仅局限于JSP；\",\"与Spring框架集成（如IoC容器、AOP等）；\",\"清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。\",\"支持各种请求资源的映射策略。\"]},\"645\":{\"h\":\"什么是MVC模式？\",\"t\":[\"MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。\",\"V 即View视图，是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。\",\"M 即model模型，是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。\",\"C 即controller控制器，是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。\"]},\"646\":{\"h\":\"Spring MVC的主要组件？\",\"t\":[\"前端控制器DispatcherServlet：其作用是接收用户请求，然后给用户反馈结果。它的作用相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。\",\"处理器映射器HandlerMapping：其作用是根据请求的URL路径，通过注解或者XML配置，寻找匹配的处理器信息。\",\"处理器适配器HandlerAdapter：其作用是根据映射器处理器找到的处理器信息，按照特定规则执行相关的处理器（Handler）。\",\"处理器Handler：其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至ModelAndView对象中。\",\"视图解析器ViewResolver：其作用是进行解析操作，通过ModelAndView对象中的View信息将逻辑视图名解析成真正的视图View（如通过一个JSP路径返回一个真正的JSP页面）。\",\"视图**View：View**是一个接口，实现类支持不同的View类型（JSP、FreeMarker、Excel等）。\"]},\"647\":{\"h\":\"Servlet原理？\"},\"648\":{\"h\":\"过滤器跟拦截器的区别？\",\"t\":[\"过滤器：\",\"Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可以进行逻辑判断，如用户是否已经登录、有没有权限访问该页面等等工作，它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关的请求，只有当你的web应用停止或重新部署的时候才能销毁。\",\"拦截器：\",\"拦截器是在面向切面编程中应用的，就是在你的service或者一个方法前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。\",\"拦截器不是在web.xml配置的，比如struts在struts.xml配置，而springMVC在Spring与springMVC整合的配置文件中配置。在springmvc中，定义拦截器要实现HandlerInterceptor接口，并实现该接口中提供的三个方法。\",\"拦截器是基于Java的反射机制的，而过滤器是基于函数回调\",\"过滤器依赖与servlet容器，而拦截器不依赖与servlet容器\",\"拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用\",\"拦截器可以访问action上下文、值栈里的对象，而过滤器不能\",\"在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次\",\"Filter需要在web.xml中配置，依赖于Servlet\",\"Interceptor需要在SpringMVC中配置，依赖于框架\",\"Filter的执行顺序在Interceptor之前。Filter包裹servlet，servlet包裹Interceptor \"]},\"649\":{\"h\":\"Springmvc 中如何解决 GET | POST请求中文乱码问题？\",\"t\":[\"GET方式：\",\"在服务器端配置URL编码格式：修改tomcat的配置文件server.xml：\",\"只需增加 URIEncoding=“UTF-8” 这一句，然后重启tomcat即可。\",\"<ConnectorURIEncoding=\\\"UTF-8\\\" port=\\\"8080\\\" maxHttpHeaderSize=\\\"8192\\\" maxThreads=\\\"150\\\" minSpareThreads=\\\"25\\\" maxSpareThreads=\\\"75\\\"connectionTimeout=\\\"20000\\\" disableUploadTimeout=\\\"true\\\" URIEncoding=\\\"UTF-8\\\"/>\",\"POST方式：\",\"SpringMVC默认提供一个解决post请求乱码的过滤器，在web.xml中配置即可（要注意的是它的位置一定要是第一个执行的过滤器）：\",\"<filter> <filter-name>characterEncodingFilter</filter-name> <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class> <init-param> <param-name>encoding</param-name> <param-value>UTF-8</param-value> </init-param> </filter> <filter-mapping> <filter-name>characterEncodingFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping>\",\"该过滤器要做的其实就是强制为所有请求和响应设置编码格式：\",\"request.setCharacterEncoding(“utf-8”); response.setCharacterEncoding(“utf-8”);\"]},\"650\":{\"h\":\"Springmvc 如何做异常处理 ？\",\"t\":[\"可以将异常抛给Spring框架，由Spring框架来处理；自定义实现spring的全局异常解析器HandlerExceptionResolver，在异常处理器中添视图页面即可。\",\"若与SpringBoot搭配使用，建议使用SpringBoot提供的全局异常处理：@ControllerAdvise\"]},\"651\":{\"h\":\"SpringMVC 常用注解都有哪些？\",\"t\":[\"@requestMapping：用于请求 url 映射。\",\"@RequestBody： 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。\",\"@ResponseBody ：注解实现将 controller 方法返回对象转化为 json 响应给客户。\",\"@Conntroller：控制器的注解，表示是表现层,不能用用别的注解代替。\",\"@Valid：标志参数被Hibernate-Validator校验框架校验。\",\"@PathVariable：用于接收uri地址传过来的参数，Url中可以通过一个或多个{Xxx}占位符映射，通过@PathVariable可以绑定占位符参数到方法参数中，在RestFul接口风格中经常使用。 例如：请求URL：http://localhost/user/21/张三/query (Long类型可以根据需求改变为String或int，SpringMVC会自动做转换)\",\"@RequestMapping(\\\"/user/{userId}/{userName}/query\\\") public User query(@PathVariable(\\\"userId\\\") Long userId, @PathVariable(\\\"userName\\\") String userName){ ... }\",\"@RequestParam：用于将请求参数映射到控制器方法的形参上，有如下三个属性\",\"value：参数名。\",\"required：是否必需，默认为true，表示请求参数中必须包含该参数，如果不包含抛出异常。\",\"defaultValue：默认参数值，如果设置了该值自动将required设置为false，如果参数中没有包含该参数则使用默认值。 示例：@RequestParam(value = \\\"pageNum”, required = false, defaultValue = \\\"1\\\")\"]},\"652\":{\"h\":\"如何开启注解处理器和适配器？\",\"t\":[\"在配置文件中（一般命名为springmvc.xml ）通过开启 <mvc:annotation-driven>来实现注解处理器和适配器的开启。\"]},\"653\":{\"h\":\"Springmvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？\",\"t\":[\"是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段；或者使用ThreadLocal。\"]},\"654\":{\"h\":\"Springmvc 和struts2的区别有哪些?\",\"t\":[\"Springmvc的入口是一个servlet，即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。\",\"Springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\",\"Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。\"]},\"655\":{\"h\":\"Springmvc 中对于文件的上传有哪些需要注意\",\"t\":[\"在页面form中提交enctype=\\\"multipart/form-data\\\"的数据时，需要springmvc对multipart类型的数据进行解析。\",\"在springmvc.xml中配置multipart类型解析器。\",\"方法中使用：MultipartFile attach (单个文件上传) 或者 MultipartFile[] attachs (多个文件上传)\"]},\"656\":{\"h\":\"Springmvc 中拦截器如何使用？\",\"t\":[\"定义拦截器\",\"实现HandlerInterceptor接口。接口中提供三个方法：\",\"preHandle() ：进入 Handler方法之前执行，用于身份认证、身份授权，比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\",\"postHandle()：进入Handler方法之后，返回modelAndView之前执行，应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\",\"afterCompletion()：执行Handler完成执行此方法，应用场景：统一异常处理，统一日志处理\",\"拦截器配置：\",\"针对HandlerMapping配置(不推荐)：springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该 拦截器。(一般不推荐使用)\",\"类似全局的拦截器：springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。\",\"<!-- 写法参考 --> <mvc:interceptors> <!-- 可配置多个。下面的例子只针对部分请求拦截。 --> <mvc:interceptor> <mvc:mapping path=\\\"/modelMap.do\\\" /> <bean class=\\\"com.et.action.MyHandlerInterceptorAdapter\\\"/> </mvc:interceptor> <mvc:interceptors>\"]},\"657\":{\"h\":\"SpringMVC\"},\"658\":{\"h\":\"SpringMVC\"},\"659\":{\"h\":\"相关资料和教程\"},\"660\":{\"h\":\"教程\",\"t\":[\"程序员泥瓦匠 - springboot-learning-example\",\"程序猿DD - Spring Boot 2.x基础教程\",\"芋道源码 - SpringBoot教程\"]},\"661\":{\"h\":\"文章\",\"t\":[\"芋道 Spring Boot Jar 启动原理\",\"芋道 Spring Boot Jar 启动原理\",\"送你一份Spring Boot 知识清单\",\"Springboot启动扩展点超详细总结，再也不怕面试官问了\",\"震惊!你还不知道SpringBoot真正的启动引导类\"]},\"662\":{\"h\":\"相关工具\",\"t\":[\"Snyk: 依赖性安全漏洞扫描工具\"]},\"663\":{\"h\":\"SpringBoot面试题\"},\"664\":{\"h\":\"什么是spring boot，它主要有哪些优点\",\"t\":[\"Springboot是spring的子项目，称为一站式解决方案，集成了外部很多的优秀的框架，如常用的mysql、jdbc。\",\"主要优点：通过maven导入各种jar包，可以减少jar包的冲突；屏息了繁琐的xml配置文件；集成的开发框架，可以做到开箱即用。\"]},\"665\":{\"h\":\"为什么要用spring boot？\",\"t\":[\"优点：\",\"快速创建独立运行的Spring应用以及与主流框架集成\",\"1.1. 使用嵌入式的Servlet容器，应用最终可以打成Jar包的形式独立运行。\",\"1.2. 版本仲裁中心和不同的场景启动器(starter)为Spring Boot应用开发管理这不同的框架和版本依赖。\",\"1.3. 约定大于配置，Spring Boot为开发者导入项目所使用的框架设置好了默认配置。\",\"1.4. Java Config代替了原有难以管理的SpringXML配置。\",\"1.5. 提供了准生产环境的运行时的应用监控。\",\"1.6. 与云计算的天然集成，Spring Cloud相关框架技术。\",\"缺点：\",\"从以上优点可知，Spring Boot的最大优点就是为开发者屏蔽了底层框架的复杂性。这样恰好是其缺点。Spring Boot降低了入门门槛，但是其封装使后期学习曲线陡峭。所以如果需要熟练的掌握该框架，必须了解其底层原理。\"]},\"666\":{\"h\":\"spring boot跟spring cloud的区别？\",\"t\":[\"SpringBoot只是一个快速开发框架，使用注解简化了xml配置，内置了Servlet容器，以Java应用程序进行执行。\",\"SpringCloud是一系列框架的集合，可以包含SpringBoot。\"]},\"667\":{\"h\":\"Spring Boot与Spring MVC的区别\",\"t\":[\"Spring Boot是Spring和Spring MVC的整合，而Spring MVC只是Spring的一个模块，一个轻量级的Web层框架\",\"Spring Boot几乎可以实现零配置，所有功能使用注解进行开发，运用了'约定大于配置'的思想，简化了项目开发难度，而Spring MVC需要依赖于xml配置进行开发\",\"Spring Boot提供了内置的tomcat,可以打成jar包直接运行，也可以使用外置容器\",\"Spring Boot还集成了许多第三方库配置，例如JDBC, Mongo, Redis等,应用这些第三方库，几乎可以零配置使用\"]},\"668\":{\"h\":\"SpringBoot如何修改端口号？\",\"t\":[\":::: tabs cache-lifetime=\\\"5\\\" :options=\\\"{ useUrlFragment: false }\\\"\",\"::: tab yml\",\"server: port: 8888\",\":::\",\"::: tab properties\",\"server.port = 8888\",\":::\",\"::: tab 命令行\",\"java -jar demo.jar --server.port=8888 java - Dserver.port=8888 -jar demo.jar\",\":::\",\"::::\"]},\"669\":{\"h\":\"Springboot热部署的方式\",\"t\":[\"SpringBoot 1.3后才拥有SpringBoot devtools热部署\"]},\"670\":{\"h\":\"方式一：spring-boot-devtools\",\"t\":[\"在项目的pom文件中添加依赖:\",\"<!--热部署jar--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> </dependency>\",\"然后在Settings→Build→Compiler中将Build project automatically勾选上，最后使用 shift+ctrl+alt+\\\"/\\\" （IDEA中的快捷键） 选择\\\"Registry\\\" 然后勾选 compiler.automake.allow.when.app.running\",\"还需要修改配置：\",\"spring: devtools: restart: enabled: true #设置开启热部署 additional-paths: src/main/java #重启目录 exclude: WEB-INF/**\",\"原理\",\"devtools实现原理是使用了两个classloader，一个是base classloader，用来加载那些不会改变的类（比如第三方jar包等），另一个ClassLoader加载会更改的类，称为restart ClassLoader，这样在有代码更改的时候，原来的restart ClassLoader会被丢弃，重新创建一个ClassLoader，也就意味着应用程序重新启动通常比“冷启动”快得多，因为base classloader已经填充好了并且是可用的。\",\"简而言之就是：通过监控类路径资源，当类路径上的文件发生更改时，自动重新启动应用程序，由于只需要重新读取被修改的类，所以要比冷启动快。\"]},\"671\":{\"h\":\"方式二：Spring Loaded\",\"t\":[\"在项目中添加如下代码\",\" <build> <plugins> <plugin> <!-- springBoot编译插件--> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <dependencies> <!-- spring热部署 --> <!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --> <dependency> <groupId>org.springframework</groupId> <artifactId>springloaded</artifactId> <version>1.2.6.RELEASE</version> </dependency> </dependencies> </plugin> </plugins> </build>\",\"添加完毕后需要使用mvn指令运行：\",\"首先找到IDEA中的Edit configurations，然后进行如下操作：（点击左上角的\\\"+\\\",然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun）\",\"点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可。\"]},\"672\":{\"h\":\"方式三：Jrebel\",\"t\":[\"Jrebel是一款热部署插件。可参考这篇文章来配置：IDEA JRebel 插件热部署（史上最全）\"]},\"673\":{\"h\":\"Spring Boot 中如何解决跨域问题 ?\",\"t\":[\"跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋。\",\"因此我们推荐在后端通过 （CORS，Crossorigin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfifigurer接口然后重写addCorsMappings方法解决跨域问题。\",\"@Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\\\"/**\\\") .allowedOrigins(\\\"*\\\") .allowCredentials(true) .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"PUT\\\", \\\"DELETE\\\", \\\"OPTIONS\\\") .maxAge(3600); } }\",\"也可以在方法或者类上加@CrossOrigin注解来解决：\",\"@RestController public class DeliveryController { @CrossOrigin @PostMapping(\\\"/delivery/addRecord\\\") public CommonResult<Integer> add(@RequestBody DeliveryRecord deliveryRecord) { // ... } @GetMapping(\\\"/delivery/checkRecord\\\") public CommonResult<DeliveryRecord> checkRecord(@RequestParam Integer deliveryId) { // ... } }\",\"参考：注解@CrossOrigin\"]},\"674\":{\"h\":\"Spring boot的自动配置是如何实现的？\",\"t\":[\"@SpringBootApplication=@Configuration + @EnableAutoConfiguration + @ComponentScan\",\"其实说白了SpringBoot的自动配置，实际是依赖@Conditional来实现的。\",\"@Conditional是一个条件注解，是Spring4提供的一个新特性，用于根据特定条件来控制Bean的创建行为。\",\"SpringBoot中对@Conditional的引用链如下：\",\"@SpringBootApplication -> @EnableAutoConfiguration -> @Import(AutoConfigurationImportSelector.class) -> 在AutoConfigurationImportSelector类中会执行getCandidateConfigurations（AnnotationMetadata metadata, AnnotationAttributes attributes）方法，里面有一行：\",\"List configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\",\"这里就会扫描具有MEAT-INF/spring.factories文件的jar包，得到所有的配置类。\",\"而这些配置类上，基本都有以下类型的注解：\",\"@ConditionalOnClass, @ConditionalOnMissingClass\",\"@ConditionalOnBean, @ConditionalOnMissingBean\",\"@ConditionalOnProperty, @ConditionalOnResource\",\"@ConditionalOnEnabledHealthIndicator, ...\",\"如果满足条件，则把对应的配置类装载入spring容器。\",\"总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。\",\"参考：\",\"CSDN - SpringBoot自动配置原理\",\"Spring Boot自动配置原理、实战\"]},\"675\":{\"h\":\"@Conditional相关的注解？\",\"t\":[\"@Conditional要配合Condition的实现类（ClassCondition）进行使用。SpringBoot 提供的常用条件注解：\",\"@ConditionalOnBean 组合@Conditional注解，当容器中有指定Bean才开启配置。\",\"@ConditionalOnMissingBean 组合@Conditional注解，当容器中没有值当Bean才可开启配置。\",\"@ConditionalOnClass 组合@Conditional注解，当容器中有指定Class才可开启配置。\",\"@ConditionalOnMissingClass 组合@Conditional注解，当容器中没有指定Class才可开启配置。\",\"@ConditionOnWebApplication 组合@Conditional注解，当前项目类型是WEB项目才可开启配置。项目有以下三种类型：\",\" 1. ANY：任意一个Web项目 1. SERVLET： Servlet的Web项目 1. REACTIVE ：基于reactive-base的Web项目 \",\"@ConditionOnNotWebApplication 组合@Conditional注解，当前项目类型不是WEB项目才可开启配置。\",\"@ConditionalOnProperty 组合@Conditional注解，当指定的属性有指定的值时才可开启配置。\",\"@ConditionalOnExpression 组合@Conditional注解，当SpEl表达式为true时才可开启配置。\",\"@ConditionOnJava 组合@Conditional注解，当运行的Java JVM在指定的版本范围时才开启配置。\",\"@ConditionalResource 组合@Conditional注解，当类路径下有指定的资源才开启配置。\",\"@ConditionOnJndi 组合@Conditional注解，当指定的JNDI存在时才开启配置。\",\"@ConditionalOnCloudPlatform 组合@Conditional注解，当指定的云平台激活时才可开启配置。\",\"@ConditiomalOnSingleCandidate 组合@Conditional注解，当制定的Class在容器中只有一个Bean，或者同时有多个但为首选时才开启配置。\"]},\"676\":{\"h\":\"SpringBoot 中怎么禁用某些自动配置特性？\",\"t\":[\"有 3 种方法。如果我们想禁用某些自动配置特性，可以使用 @EnableAutoConfiguration 或 @SpringBootApplication 注解的 exclude 属性来指明。\",\"// 方案1，下面的代码段是使 DataSourceAutoConfiguration 无效： @EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class) public class MyConfiguration {} // 方案2 @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) public class MyConfiguration { } // 方案3，在配置文件中配置 spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\"]},\"677\":{\"h\":\"SpringBoot的加载流程？\",\"t\":[\"https://www.jianshu.com/p/dc12081b3598\"]},\"678\":{\"h\":\"SpringBoot运行原理\",\"t\":[\"1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：\",\"根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。\",\"使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。\",\"使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。\",\"推断并设置main方法的定义类。\",\"2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。\",\"3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。\",\"4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。\",\"5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。\",\"6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。\",\"7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。\",\"8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。\",\"9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。\",\"10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。\",\"11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。\",\"12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。\",\"13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理。\"]},\"679\":{\"h\":\"Spring boot容器替换？\",\"t\":[\"<!-- 下面的配置将使用undertow来做服务器而不是tomcat --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <exclusions> <exclusion> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-tomcat</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-undertow</artifactId> </dependency>\",\"在spring-boot-starter-web中，使用<exclusion>排除掉web中引入的tomcat，使用<dependency>重新导入undertow 即可。也可以用同样的方法，把容器替换为Jetty。\"]},\"680\":{\"h\":\"Spring boot集成Mybatis?\",\"t\":[\"加入依赖即可。这个starter是mybatis提供的。\",\"<dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.3.0</version> </dependency>\"]},\"681\":{\"h\":\"SpringBoot读取配置相关注解有？\",\"t\":[\"@PropertySource\",\"@Value\",\"@Environment\",\"@ConfigurationProperties\"]},\"682\":{\"h\":\"Starters是什么？\",\"t\":[\"Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA访问数据库，只要加入spring-boot-starter-data-jpa启动器依赖就能使用了。\",\"Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。\",\"Starters命名\",\"Spring Boot官方的启动器都是以spring-boot-starter-开头命名的，代表了一个特定的应用类型。\",\"第三方的启动器不能以spring-boot开头命名，它们都被Spring Boot官方保留。一般一个第三方的应该这样命名，像mybatis的mybatis-spring-boot-starter。\"]},\"683\":{\"h\":\"spring boot的starter的执行原理\",\"t\":[\"利用starter实现自动化配置只需要两个条件――maven依赖、配置文件，这里简单介绍下starter实现自动化配置的流程。\",\"引入maven实质上就是导入jar包，spring-boot启动的时候会找到starter jar包中的resources/META-INF/spring.factories文件，根据spring.factories文件中的配置，找到需要自动配置的类。\"]},\"684\":{\"h\":\"Spring Boot自己实现starter?\",\"t\":[\"SpringBoot应用篇（一）：自定义starter\"]},\"685\":{\"h\":\"Spring-boot-starter-parent 有什么用 ?\",\"t\":[\"我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：\",\"定义了 Java 编译版本为 1.8 。\",\"使用 UTF-8 格式编码。\",\"继承自spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。\",\"执行打包操作的配置。\",\"自动化的资源过滤。\",\"自动化的插件配置。\",\"针对 application.properties 和 application.yml 的资源过滤，包括通过 profile\",\"定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。\"]},\"686\":{\"h\":\"Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?\",\"t\":[\"Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。\",\"Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \\\\BOOT-INF\\\\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。\"]},\"687\":{\"h\":\"如何在 Spring Boot 启动的时候运行一些特定的代码？\",\"t\":[\"可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法。如下所示：\",\"public interface CommandLineRunner { /** * Callback used to run the bean. * @param args incoming main method arguments * @throws Exception on error */ void run(String... args) throws Exception; } //--- public interface ApplicationRunner { /** * Callback used to run the bean. * @param args incoming application arguments * @throws Exception on error */ void run(ApplicationArguments args) throws Exception; }\",\"使用方式\",\"import org.springframework.boot.* import org.springframework.stereotype.* @Component public class MyBean implements CommandLineRunner { public void run(String... args) { // Do something... } } // 或者 @Bean public CommandLineRunner init() { return (String... strings) -> { }; }\",\"启动顺序\",\"如果启动的时候有多个ApplicationRunner和CommandLineRunner，想控制它们的启动顺序，可以实现 org.springframework.core.Ordered接口或者使用 org.springframework.core.annotation.Order注解。\"]},\"688\":{\"h\":\"SpringBoot\"},\"689\":{\"h\":\"SpringBoot\"},\"690\":{\"h\":\"RabbitMQ - 介绍\",\"t\":[\"RabbitMQ 官网\"]},\"691\":{\"h\":\"RabbitMQ的概念\",\"t\":[\"RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。\"]},\"692\":{\"h\":\"四大核心概念\",\"t\":[\"生产者：产生数据发送消息的程序\",\"交换机：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\",\"队列：是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\",\"消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\"]},\"693\":{\"h\":\"各个名词介绍\",\"t\":[\"image-20220603215359527\",\"Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker\",\"Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等\",\"Connection：publisher／consumer 和 broker 之间的 TCP 连接\",\"Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销\",\"Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)\",\"Queue：消息最终被送到这里等待 consumer 取走\",\"Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据\"]},\"694\":{\"h\":\"RabbitMQ - 基础案例\"},\"695\":{\"h\":\"Hello RabbitMQ\",\"t\":[\"用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者\",\"在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区\",\"image-20211109170013018\",\"注\",\"Java 进行连接的时候，需要 Linux 开放 5672 端口，否则会连接超时\",\"访问 Web 界面的端口是 15672，连接服务器的端口是 5672\",\"2021-11-09 @Young Kbt\",\"步骤图：\",\"image-20211109170150330\"]},\"696\":{\"h\":\"添加依赖\",\"t\":[\"先创建好 Maven 工程，pom.xml 添入依赖：\",\"<dependencies> <!--rabbitmq 依赖客户端--> <dependency> <groupId>com.rabbitmq</groupId> <artifactId>amqp-client</artifactId> <version>5.8.0</version> </dependency> <!--操作文件流的一个依赖--> <dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> <version>2.6</version> </dependency> </dependencies> <!--指定 jdk 编译版本--> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>8</source> <target>8</target> </configuration> </plugin> </plugins> </build>\",\"版本根据需求选择\"]},\"697\":{\"h\":\"消息生产者\",\"t\":[\"创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里\",\"步骤：\",\"创建 RabbitMQ 连接工厂\",\"进行 RabbitMQ 工厂配置信息\",\"创建 RabbitMQ 连接\",\"创建 RabbitMQ 信道\",\"生成一个队列\",\"发送一个消息到交换机，交换机发送到队列。\\\"\\\" 代表默认交换机\",\"package com.kbt.demo01; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; public class Producer { public static final String QUEUE_NAME = \\\"queue1\\\"; public static void main(String[] args) throws IOException, TimeoutException { // 1.创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); // 2.RabbitMQ 工厂配置信息 connectionFactory.setHost(\\\"192.168.199.27\\\"); connectionFactory.setPort(5672); connectionFactory.setUsername(\\\"admin\\\"); connectionFactory.setPassword(\\\"123456\\\"); // 3.创建连接 Connection connection = connectionFactory.newConnection(); // 4.创建信道 Channel channel = connection.createChannel(); /** * 生成一个队列 * 1.队列名称 * 2.队列里面的消息是否持久化 默认消息存储在内存中 * 3.该队列是否只供一个消费者进行消费 是否进行共享，true 可以多个消费者消费 * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除，true 自动删除 * 5.其他参数 */ channel.queueDeclare(QUEUE_NAME,false,false,false,null); String message = \\\"Hello RabbitMQ\\\"; /** * 发送一个消息 * 1.发送到哪个交换机，\\\"\\\" 代表默认交换机 * 2.路由的 key 是哪个 * 3.其他的参数信息 * 4.发送消息的消息体 */ channel.basicPublish(\\\"\\\",QUEUE_NAME,null,message.getBytes()); System.out.println(\\\"消息发送完毕\\\"); } }\",\"消息队列名字和步骤 2 的信息根据自己的需求进行配置\",\"方法解释\",\"声明队列：\",\"channel.queueDeclare(队列名/String, 持久化/boolean, 共享消费/boolean, 自动删除/boolean, 配置参数/Map);\",\"配置参数现在是 null，后面死信队列延迟队列等会用到，如：\",\"队列的优先级\",\"队列里的消息如果没有被消费，何去何从？（死信队列）\",\"Map<String, Object> params = new HashMap(); // 设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU params.put(\\\"x-max-priority\\\", 10); // 声明当前队列绑定的死信交换机 params.put(\\\"x-dead-letter-exchange\\\", Y_DEAD_LETTER_EXCHANGE); // 声明当前队列的死信路由 key params.put(\\\"x-dead-letter-routing-key\\\", \\\"YD\\\"); channel.queueDeclare(QUEUE_NAME, true, false, false, params);\",\"发布消息：\",\"channel.basicPublish(交换机名/String, 队列名/String, 配置参数/Map, 消息/String);\",\"配置参数现在是 null，后面死信队列、延迟队列等会用到，如：\",\"发布的消息优先级\",\"发布的消息标识符 id\",\"// 给消息赋予 优先级 ID 属性 AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).messageId(\\\"1\\\")build(); channel.basicPublish(\\\"\\\", QUEUE_NAME, properties, message.getBytes());\"]},\"698\":{\"h\":\"消息消费者\",\"t\":[\"创建一个类作为消费者，消费 RabbitMQ 队列的消息\",\"package com.kbt.demo01; import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; public class Consumer { public static final String QUEUE_NAME = \\\"queue1\\\"; public static void main(String[] args) throws IOException, TimeoutException { // 1.创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); // 2.RabbitMQ 工厂配置信息 connectionFactory.setHost(\\\"192.168.199.27\\\"); connectionFactory.setUsername(\\\"admin\\\"); connectionFactory.setPassword(\\\"123456\\\"); // 3.创建连接 Connection connection = connectionFactory.newConnection(); // 4.创建信道 Channel channel = connection.createChannel(); System.out.println(\\\"等待接收消息......\\\"); // 推送的消息进行消费的接口回调 DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody()); System.out.println(\\\"接受到的消息：\\\" + message); }; //取消消费的一个回调接口 如在消费的时候队列被删除掉了 CancelCallback cancelCallback = (consumerTag) -> { System.out.println(\\\"消息消费被中断\\\"); }; /** * 消费者消费消息 * 1.消费哪个队列 * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答 * 3.消费者成功消费的回调 * 4.消费者取消消费的回调 */ channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback); } }\",\"值得一提的是，basicConsume 的参数中，第三个和第四个参数都是接口，所以需要实现该接口的方法\",\"channel.basicConsume(队列名字/String, 是否自动签收/boolean, 消费时的回调/接口类, 无法消费的回调/接口类);\"]},\"699\":{\"h\":\"Work Queues\",\"t\":[\"Work Queues 是工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\"]},\"700\":{\"h\":\"轮询消费\",\"t\":[\"轮询消费消息指的是轮流消费消息，即每个工作队列都会获取一个消息进行消费，并且获取的次数按照顺序依次往下轮流。\",\"案例中生产者叫做 Task，一个消费者就是一个工作队列，启动两个工作队列消费消息，这个两个工作队列会以轮询的方式消费消息。\"]},\"701\":{\"h\":\"轮询案例\",\"t\":[\"首先把 RabbitMQ 的配置参数封装为一个工具类：RabbitMQUtils\",\"package com.kbt.utils; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/9 17:15 * @description 连接 RabbitMQ 的工具类 */ public class RabbitMQUtils { public static Channel getChannel() throws IOException, TimeoutException { // 1.创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); // 2.rabbit工厂配置信息 connectionFactory.setHost(\\\"192.168.199.27\\\"); connectionFactory.setUsername(\\\"admin\\\"); connectionFactory.setPassword(\\\"123456\\\"); // 3.创建连接 Connection connection = connectionFactory.newConnection(); // 4.创建信道 return connection.createChannel(); } }\",\"创建两个工作队列，并且启动\",\"package com.kbt.demo02; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.CancelCallback; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DeliverCallback; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/9 17:32 * @description 一个工作线程，相当于之前的消费者 */ public class Worker01 { public static final String QUEUE_NAME = \\\"queue2\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); //消息接受的回调 DeliverCallback deliverCallback = (consumerTag, delivery) -> { String receivedMessage = new String(delivery.getBody()); System.out.println(\\\"接收到消息:\\\" + receivedMessage); }; //消息被取消的回调 CancelCallback cancelCallback = (consumerTag) -> { System.out.println(consumerTag + \\\"消费者取消消费接口回调逻辑\\\"); }; System.out.println(\\\"first 消费者启动等待消费.................. \\\"); channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback); } }\",\"创建好一个工作队列，只需要以多线程方式启动两次该 main 函数即可，以 first、second 区别消息队列。\",\"要开启多线程功能，首先启动该消息队列，然后如图开启多线程：\",\"image-20211109173848856\",\"选中 Allow multiple instances\",\"image-20211109173921923\",\"两个工作队列都启动后\",\"image-20211109174147712\",\"创建一个生产者，发送消息进程\",\"package com.kbt.demo02; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.Channel; import java.util.Scanner; /** * @author Young Kbt * @date 2021/11/9 17:42 * @description 生产消息 */ public class Task01 { public static final String QUEUE_NAME = \\\"queue1\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String message = scanner.next(); channel.basicPublish(\\\"\\\", QUEUE_NAME, null, message.getBytes()); System.out.println(\\\"消息发送完成：\\\" + message); } } }\",\"结果演示\",\"通过程序执行发现生产者总共发送 4 个消息，消费者 first 和消费者 second 分别分得两个消息，并且是按照有序的一个接收一次消息\"]},\"702\":{\"h\":\"Web页面添加队列\",\"t\":[\"进入自己的 RabbitMQ Web 页面，点击 Queues 菜单\",\"image-20211113004348652\",\"防止图片失效，这里记录步骤\",\"点击 Queues 菜单\",\"点击 Add a new queue，弹出下拉菜单\",\"下方的很多参数可以进行选择（旁边有 ？的参数），如优先级（Lazy mode）、绑定死信队列（Dead letter exchange/routing key）\",\"执行步骤 3 后，在 Arguments 的第一个文本框弹出对应的参数，类似于 Map 的 key\",\"第二个文本框填写参数，类似于 Map 的 value\",\"第三个是下拉菜单，选择 value 类型\",\"点击 Add queue，添加队列\",\"旁边有 ？的参数，就是 channel.queueDeclare(队列名/String, 持久化/boolean, 共享消费/boolean, 自动删除/boolean, 配置参数/Map); 或者 channel.basicPublish(交换机名/String, 队列名/String, 配置参数/Map, 消息/String); 的参数：配置参数/Map 的 key\"]},\"703\":{\"h\":\"RabbitMQ - 应答与发布\"},\"704\":{\"h\":\"消息应答\",\"t\":[\"消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\",\"为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。\"]},\"705\":{\"h\":\"自动应答\",\"t\":[\"消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。\"]},\"706\":{\"h\":\"手动消息应答的方法\",\"t\":[\"Channel.basicAck (肯定确认应答)：\",\"basicAck(long deliveryTag, boolean multiple);\",\"第一个参数是消息的标记，第二个参数表示是否应用于多消息，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\",\"Channel.basicReject (否定确认应答)\",\"basicReject(long deliveryTag, boolean requeue);\",\"第一个参数表示拒绝 deliveryTag 对应的消息，第二个参数表示是否 requeue：true 则重新入队列，false 则丢弃或者进入死信队列。\",\"该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。\",\"Channel.basicNack (用于否定确认)：示己拒绝处理该消息，可以将其丢弃了\",\"basicNack(long deliveryTag, boolean multiple, boolean requeue);\",\"第一个参数表示拒绝 deliveryTag 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 requeue，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。\",\"Channel.basicRecover\",\"basicRecover(boolean requeue);\",\"是否恢复消息到队列，参数是是否 requeue，true 则重新入队列，并且尽可能的将之前 recover 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己。\",\"Multiple 的解释：\",\"手动应答的好处是可以批量应答并且减少网络拥堵\",\"true 代表批量应答 channel 上未应答的消息\",\"比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答\",\"false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\",\"image-20211109191455909\"]},\"707\":{\"h\":\"消息自动重新入队\",\"t\":[\"如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\",\"image-20211109191528743\"]},\"708\":{\"h\":\"手动应答案例\",\"t\":[\"默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\",\"消费者启用两个线程，消费 1 一秒消费一个消息，消费者 2 十秒消费一个消息，然后在消费者 2 消费消息的时候，停止运行，这时正在消费的消息是否会重新进入队列，而后给消费者 1 消费呢？\",\"消息生产者：\",\"package com.kbt.demo03; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.Channel; import java.util.Scanner; /** * @author Young Kbt * @date 2021/11/9 19:02 * @description 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费 */ public class Task03 { private static final String TASK_QUEUE_NAME = \\\"ack_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); //声明队列 channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null); Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入信息：\\\"); while (sc.hasNext()) { String message = sc.nextLine(); //发布消息 channel.basicPublish(\\\"\\\", TASK_QUEUE_NAME, null, message.getBytes(\\\"UTF-8\\\")); System.out.println(\\\"生产者发出消息：\\\" + message); } } }\",\"消费者 1：\",\"消费者在简单案例代码的基础上增加了以下内容\",\"channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); // 采用手动应答 boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\",\"完整代码\",\"package com.kbt.demo03; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.CancelCallback; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DeliverCallback; /** * @author Young Kbt * @date 2021/11/9 19:03 * @description 消费者 */ public class worker03 { private static final String TASK_QUEUE_NAME = \\\"ack_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); System.out.println(\\\"first 等待接收消息处理时间较 短\\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"接收到消息:\\\" + message); /** * 1.消息标记 tag * 2.是否批量应答未应答的消息 */ channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); }; CancelCallback cancelCallback = (s) -> { System.out.println(s + \\\"消费者取消消费接口回调逻辑\\\"); }; // 采用手动应答 boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback); } }\",\"消费者 2：\",\"将 23 行代码的睡眠时间改为 10 秒：\",\"Thread.sleep(10000);\"]},\"709\":{\"h\":\"效果演示\",\"t\":[\"正常情况下消息生产者发送两个消息， first 和 second 分别接收到消息并进行处理\",\"image-20211109193046505\",\"当发送者发送消息 DD 到队列，此时是 second 来消费该消息，但是由于它处理时间较长，在还未处理完时间里停止运行，也就是说 second 还没有执行到 ack 代码的时候，second 被停掉了，此时会看到消息被 first 接收到了，说明消息 DD 被重新入队，然后分配给能处理消息的 first 处理了\",\"image-20211109193341523\",\"image-20211109193534701\"]},\"710\":{\"h\":\"RabbitMQ持久化\",\"t\":[\"当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。\"]},\"711\":{\"h\":\"队列持久化\",\"t\":[\"之前我们创建的队列都是非持久化的，RabbitMQ 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化\",\"在消息生产者开启持久化：\",\"package com.kbt.demo03; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.Channel; import java.util.Scanner; /** * @author Young Kbt * @date 2021/11/9 19:02 * @description 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费 */ public class Task03 { private static final String TASK_QUEUE_NAME = \\\"ack_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); //让队列持久化 boolean durable = true; //声明队列 channel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null); Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入信息：\\\"); while (sc.hasNext()) { String message = sc.nextLine(); //发布消息 channel.basicPublish(\\\"\\\", TASK_QUEUE_NAME, null, message.getBytes(\\\"UTF-8\\\")); System.out.println(\\\"生产者发出消息：\\\" + message); } } }\",\"注意\",\"如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列\",\"2021-11-09 @Young Kbt\",\"不然就会出现如下错误：\",\"image-20211109213659474\",\"以下为控制台中持久化与非持久化队列的 UI 显示区\",\"image-20211109213727483\"]},\"712\":{\"h\":\"消息持久化\",\"t\":[\"需要在消息生产者发布消息的时候，开启消息的持久化\",\"在 basicPublish 方法的第二个参数添加这个属性： MessageProperties.PERSISTENT_TEXT_PLAIN,如 13 行代码\",\"public class Task03 { private static final String TASK_QUEUE_NAME = \\\"ack_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); //声明队列 channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null); Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入信息：\\\"); while (sc.hasNext()) { String message = sc.nextLine(); //发布消息 channel.basicPublish(\\\"\\\", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\\\"UTF-8\\\")); System.out.println(\\\"生产者发出消息：\\\" + message); } } }\",\"将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。\"]},\"713\":{\"h\":\"不公平分发\"},\"714\":{\"h\":\"介绍\",\"t\":[\"在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。\",\"为了避免这种情况，在消费者中消费消息之前，设置参数 channel.basicQos(1);\",\"public class worker03 { private static final String TASK_QUEUE_NAME = \\\"ack_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); System.out.println(\\\"first 等待接收消息处理时间较 短\\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"接收到消息:\\\" + message); /** * 1.消息标记 tag * 2.是否批量应答未应答的消息 */ channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); }; CancelCallback cancelCallback = (s) -> { System.out.println(s + \\\"消费者取消消费接口回调逻辑\\\"); }; // 不公平分发 int prefetchCount = 1; channel.basicQos(prefetchCount); // 采用手动应答 boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback); } }\",\"开启成功，会看到如下结果：\",\"image-20211109214706617\",\"不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则不拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略。\"]},\"715\":{\"h\":\"效果演示\",\"t\":[\"生产者生产多个消息，两个消费者的消费时间不同，则消费消息的次数也不同\",\"image-20211109221107761\"]},\"716\":{\"h\":\"预取值分发\"},\"717\":{\"h\":\"介绍\",\"t\":[\"带权的消息分发\",\"默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设置「预取计数」值来完成的。\",\"该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。\",\"通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\",\"预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。\",\"image-20211109215549448\",\"public class worker03 { private static final String TASK_QUEUE_NAME = \\\"ack_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); System.out.println(\\\"first 等待接收消息处理时间较 短\\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"接收到消息:\\\" + message); /** * 1.消息标记 tag * 2.是否批量应答未应答的消息 */ channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); }; CancelCallback cancelCallback = (s) -> { System.out.println(s + \\\"消费者取消消费接口回调逻辑\\\"); }; // 不公平分发 // int prefetchCount = 1; // channel.basicQos(prefetchCount); // 当值不等于 1，则代表预取值 int prefetchCount = 2; channel.basicQos(prefetchCount); // 采用手动应答 boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback); } }\",\"注\",\"不公平分发和预取值分发都用到 basic.qos 方法，如果取值为 1，代表不公平分发，取值不为1，代表预取值分发\",\"2021-11-09 @Young Kbt\"]},\"718\":{\"h\":\"效果演示\",\"t\":[\"设置了预取值为 2。生产者发送 5 条消息到 MQ 中，因为消费者 2 处理时间长，所以会有 2 条消息就堆积在了队列中，不会超过 3 个。防止因为队列处理时间长，从而堆积太多消息，导致效率低的问题出现\",\"image-20211109221107761\"]},\"719\":{\"h\":\"发布确认\",\"t\":[\"生产者发布消息到 RabbitMQ 后，需要 RabbitMQ 返回「ACK（已收到）」给生产者，这样生产者才知道自己生产的消息成功发布出去。\"]},\"720\":{\"h\":\"发布确认逻辑\",\"t\":[\"生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\",\"confirm 模式最大的好处在于是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。\"]},\"721\":{\"h\":\"发布确认的策略\",\"t\":[\"开启发布确认的方法:\",\"发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法\",\"//开启发布确认 channel.confirmSelect();\"]},\"722\":{\"h\":\"单个确认发布\",\"t\":[\"这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\",\"这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\",\"package com.kbt.demo04; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.Channel; import java.io.IOException; import java.util.UUID; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/9 22:28 * @description 单个确认发布 */ public class ConfirmMessage { public static final int MESSAGE_COUNT = 1000; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { Channel channel = RabbitMQUtils.getChannel(); // 队列声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, true, false, false, null); // 开启发布确认 channel.confirmSelect(); long begin = System.currentTimeMillis(); for (int i = 0; i < MESSAGE_COUNT; i++) { String message = i + \\\"\\\"; channel.basicPublish(\\\"\\\", queueName, null, message.getBytes()); // 服务端返回 false 或超时时间内未返回，生产者可以消息重发 boolean flag = channel.waitForConfirms(); if (flag) { System.out.println(\\\"消息发送成功\\\"); } } long end = System.currentTimeMillis(); System.out.println(\\\"发布\\\" + MESSAGE_COUNT + \\\"个单独确认消息,耗时\\\" + (end - begin) + \\\"ms\\\"); } }\",\"确认发布指的是成功发送到了队列，并不是消费者消费了消息。\"]},\"723\":{\"h\":\"批量确认发布\",\"t\":[\"单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\",\"package com.kbt.demo04; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.Channel; import java.io.IOException; import java.util.UUID; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/9 22:39 * @description 批量确认发布 */ public class ConfirmMessage2 { public static final int MESSAGE_COUNT = 1000; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { Channel channel = RabbitMQUtils.getChannel(); // 队列声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, true, false, false, null); // 开启发布确认 channel.confirmSelect(); long begin = System.currentTimeMillis(); // 批量确认消息大小 int batchSize = 100; // 未确认消息个数 int outstandingMessageCount = 0; for (int i = 0; i < MESSAGE_COUNT; i++) { String message = i + \\\"\\\"; channel.basicPublish(\\\"\\\", queueName, null, message.getBytes()); outstandingMessageCount++; if (outstandingMessageCount == batchSize) { channel.waitForConfirms(); outstandingMessageCount = 0; } } // 为了确保还有剩余没有确认消息 再次确认 if (outstandingMessageCount > 0) { channel.waitForConfirms(); } long end = System.currentTimeMillis(); System.out.println(\\\"发布\\\" + MESSAGE_COUNT + \\\"个批量确认消息,耗时\\\" + (end - begin) + \\\"ms\\\"); } }\"]},\"724\":{\"h\":\"异步确认发布\",\"t\":[\"异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面详细讲解异步确认是怎么实现的。\",\"image-20211109224549666\",\"添加回调函数，在回调函数里进行确认发布\",\"实际案例里，将发布的消息存入 Map 里，方便获取。headMap 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 headMap 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。\",\"如何处理异步未确认消息?\",\"最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\",\"以上 3 种发布确认速度对比:\",\"单独发布消息\",\"同步等待确认，简单，但吞吐量非常有限。\",\"批量发布消息\",\"批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\",\"异步处理\",\"最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些\"]},\"725\":{\"h\":\"应答和发布区别\",\"t\":[\"应答功能属于消费者，消费完消息告诉 RabbitMQ 已经消费成功。\",\"发布功能属于生产者，生产消息到 RabbitMQ，RabbitMQ 需要告诉生产者已经收到消息。\"]},\"726\":{\"h\":\"RabbitMQ - 交换机\"},\"727\":{\"h\":\"Exchanges\",\"t\":[\"RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\",\"相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\",\"image-20211110165519202\"]},\"728\":{\"h\":\"Exchanges的类型\",\"t\":[\"直接(direct)：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。\",\"主题(topic)：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.* 只会匹配到 abc.def。\",\"标题(headers)：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。\",\"匹配规则 x-match 有下列两种类型：\",\"x-match = all ：表示所有的键值对都匹配才能接受到消息\",\"x-match = any ：表示只要有键值对匹配就能接受到消息\",\"扇出(fanout)：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。\"]},\"729\":{\"h\":\"默认exchange\",\"t\":[\"通过空字符串(\\\"\\\")进行标识的交换机是默认交换\",\"channel.basicPublish(\\\"\\\", TASK_QUEUE_NAME, null, message.getBytes(\\\"UTF-8\\\"));\",\"第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key\",\"image-20211110170447102\"]},\"730\":{\"h\":\"临时队列\",\"t\":[\"之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。\",\"每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\",\"创建临时队列的方式如下:\",\"String queueName = channel.queueDeclare().getQueue();\",\"image-20211110172121531\"]},\"731\":{\"h\":\"绑定bindings\",\"t\":[\"什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定\",\"image-20211110171004071\",\"image-20211110171016043\"]},\"732\":{\"h\":\"Fanout exchange\"},\"733\":{\"h\":\"Fanout介绍\",\"t\":[\"Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些 exchange 类型\",\"image-20211110171053309\"]},\"734\":{\"h\":\"Fanout实战\",\"t\":[\"为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘\",\"图例\",\"image-20211110171112477\",\"Logs 和临时队列的绑定关系如下图\",\"image-20211110171142496\",\"代码\",\"注意\",\"先启动两个消费者再启动生产者。\",\"生产者生产消息后，如果没有对应的消费者接收，则该消息是遗弃的消息\",\"2021-11-10 @Young Kbt\",\"生产者EmitLog 发送消息给两个消费者进行消费\",\"package com.kbt.demo05; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.Channel; import java.io.IOException; import java.util.Scanner; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/10 17:15 * @description 生产者 */ public class EmitLog { private static final String EXCHANGE_NAME = \\\"logs\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); /** * 声明一个 exchange * 1.exchange 的名称 * 2.exchange 的类型 */ channel.exchangeDeclare(EXCHANGE_NAME, \\\"fanout\\\"); Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入信息：\\\"); while (sc.hasNext()) { String message = sc.nextLine(); channel.basicPublish(EXCHANGE_NAME, \\\"\\\", null, message.getBytes(\\\"UTF-8\\\")); System.out.println(\\\"生产者发出消息：\\\" + message); } } }\",\"ReceiveLogs01 将接收到的消息打印在控制台\",\"ReceiveLogs02 把消息写出到文件\"]},\"735\":{\"h\":\"Direct exchange\",\"t\":[\"在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\",\"我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, \\\"routingKey\\\");\",\"绑定之后的意义由其交换类型决定。\"]},\"736\":{\"h\":\"Direct介绍\",\"t\":[\"上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。\",\"image-20211110172746642\",\"在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个：一个绑定键为 black，另一个绑定键为 green.\",\"在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。\"]},\"737\":{\"h\":\"多重绑定\",\"t\":[\"image-20211110172858521\",\"当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。\"]},\"738\":{\"h\":\"Direct实战\",\"t\":[\"关系：\",\"image-20211110173025837\",\"交换机：\",\"image-20211110173046439\",\"C1 消费者：绑定 console 队列，routingKey 为 info、warning\",\"C2 消费者：绑定 disk 队列，routingKey 为 error\",\"当生产者生产消息到 direct_logs 交换机里，该交换机会检测消息的 routingKey 条件，然后分配到满足条件的队列里，最后由消费者从队列消费消息。\",\"生产者\",\"package com.kbt.demo06; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import java.io.IOException; import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/10 17:43 * @description 生产者 */ public class EmitLogDirect { private static final String EXCHANGE_NAME = \\\"direct_logs\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); // 创建多个 bindingKey Map<String, String> bindingKeyMap = new HashMap<>(); bindingKeyMap.put(\\\"info\\\", \\\"这是一个 info 信息\\\"); bindingKeyMap.put(\\\"warning\\\", \\\"这是一个 warning 信息\\\"); bindingKeyMap.put(\\\"error\\\", \\\"这是一个 error 信息\\\"); // debug 没有消费这接收这个消息 所有就丢失了 bindingKeyMap.put(\\\"debug\\\", \\\"这是一个 debug 信息\\\"); for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) { // 获取 key value String bindingKey = bindingKeyEntry.getKey(); String message = bindingKeyEntry.getValue(); channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message .getBytes()); System.out.println(\\\"生产者发出消息:\\\" + message); } } }\",\"两个消费者\"]},\"739\":{\"h\":\"Topics exchange\"},\"740\":{\"h\":\"Topic的介绍\",\"t\":[\"在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。\",\"尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型\",\"Topic 的要求\",\"发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词\",\"比如说：\\\"stock.usd.nyse\\\", \\\"nyse.vmw\\\", \\\"quick.orange.rabbit\\\" 这种类型的。\",\"当然这个单词列表最多不能超过 255 个字节。\",\"在这个规则列表中，其中有两个替换符是大家需要注意的：\",\"*(星号)可以代替一个位置\",\"#(井号)可以替代零个或多个位置\"]},\"741\":{\"h\":\"Topic匹配案例\",\"t\":[\"下图绑定关系如下\",\"image-20211110175137166\",\"Q1-->绑定的是 \",\"中间带 orange 带 3 个单词的字符串 (*.orange.*)\",\"Q2-->绑定的是 \",\"最后一个单词是 rabbit 的 3 个单词 (*.*.rabbit)\",\"第一个单词是 lazy 的多个单词 (lazy.#)\",\"上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的\",\"例子\",\"说明\",\"quick.orange.rabbit\",\"被队列 Q1Q2 接收到\",\"azy.orange.elephant\",\"被队列 Q1Q2 接收到\",\"quick.orange.fox\",\"被队列 Q1 接收到\",\"lazy.brown.fox\",\"被队列 Q2 接收到\",\"lazy.pink.rabbit\",\"虽然满足两个绑定但只被队列 Q2 接收一次\",\"quick.brown.fox\",\"不匹配任何绑定不会被任何队列接收到会被丢弃\",\"quick.orange.male.rabbit\",\"是四个单词不匹配任何绑定会被丢弃\",\"lazy.orange.male.rabbit\",\"是四个单词但匹配 Q2\",\"注\",\"当一个队列绑定键是 #，那么这个队列将接收所有数据，就有点像 fanout 了\",\"如果队列绑定键当中没有 # 和 * 出现，那么该队列绑定类型就是 direct 了\",\"2021-11-10 @Young Kbt\"]},\"742\":{\"h\":\"Topic实战\",\"t\":[\"image-20211110175456673\",\"生产多个消息到交换机，交换机按照通配符分配消息到不同的队列中，队列由消费者进行消费\",\"生产者 EmitLogTopic\",\"package com.kbt.demo07; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/10 18:57 * @description 生产者 */ public class EmitLogTopic { private static final String EXCHANGE_NAME = \\\"topic_logs\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); /** * Q1-->绑定的是 * 中间带 orange 带 3 个单词的字符串(*.orange.*) * Q2-->绑定的是 * 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit) * 第一个单词是 lazy 的多个单词(lazy.#) */ HashMap<String, String> bindingKeyMap = new HashMap<>(); bindingKeyMap.put(\\\"quick.orange.rabbit\\\", \\\"被队列 Q1Q2 接收到\\\"); bindingKeyMap.put(\\\"lazy.orange.elephant\\\", \\\"被队列 Q1Q2 接收到\\\"); bindingKeyMap.put(\\\"quick.orange.fox\\\", \\\"被队列 Q1 接收到\\\"); bindingKeyMap.put(\\\"lazy.brown.fox\\\", \\\"被队列 Q2 接收到\\\"); bindingKeyMap.put(\\\"lazy.pink.rabbit\\\", \\\"虽然满足两个绑定但只被队列 Q2 接收一次\\\"); bindingKeyMap.put(\\\"quick.brown.fox\\\", \\\"不匹配任何绑定不会被任何队列接收到会被丢弃\\\"); bindingKeyMap.put(\\\"quick.orange.male.rabbit\\\", \\\"是四个单词不匹配任何绑定会被丢弃\\\"); bindingKeyMap.put(\\\"lazy.orange.male.rabbit\\\", \\\"是四个单词但匹配 Q2\\\"); for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) { String bindingKey = bindingKeyEntry.getKey(); String message = bindingKeyEntry.getValue(); channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\\\"生产者发出消息：\\\" + message); } } }\",\"两个消费者\"]},\"743\":{\"h\":\"RabbitMQ - 死信队列\"},\"744\":{\"h\":\"死信的概念\",\"t\":[\"先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\",\"应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。\"]},\"745\":{\"h\":\"死信的来源\",\"t\":[\"消息 TTL 过期\",\"TTL是 Time To Live 的缩写, 也就是生存时间\",\"队列达到最大长度\",\"队列满了，无法再添加数据到 MQ 中\",\"消息被拒绝\",\"(basic.reject 或 basic.nack) 并且 requeue = false\"]},\"746\":{\"h\":\"死信实战\",\"t\":[\"交换机类型是 direct，两个消费者，一个生产者，两个队列：消息队列和死信队列\",\"image-20211110190646829\"]},\"747\":{\"h\":\"消息TTL过期\",\"t\":[\"生产者代码\",\"package com.kbt.demo08; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.AMQP; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/10 19:10 * @description 生产者 */ public class Producer { private static final String NORMAL_EXCHANGE = \\\"normal_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); // 设置消息的 TTL 时间 10s AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\\\"10000\\\").build(); // 该信息是用作演示队列个数限制 for (int i = 1; i <= 10; i++) { String message = \\\"info\\\" + i; channel.basicPublish(NORMAL_EXCHANGE, \\\"zhangsan\\\", properties, message.getBytes()); System.out.println(\\\"生产者发送消息:\\\" + message); } } }\",\"消费者 C1 代码(启动之后关闭该消费者 模拟其接收不到消息)\",\"package com.kbt.demo08; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DeliverCallback; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/10 19:13 * @description 消费者 C1 */ public class Consumer01 { // 普通交换机名称 private static final String NORMAL_EXCHANGE = \\\"normal_exchange\\\"; // 死信交换机名称 private static final String DEAD_EXCHANGE = \\\"dead_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); // 声明死信和普通交换机 类型为 direct channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT); // 声明私信队列 String deadQueueName = \\\"dead-queue\\\"; channel.queueDeclare(deadQueueName, false, false, false, null); // 死信队列绑定：队列、交换机、路由键（routingKey） channel.queueBind(deadQueueName, DEAD_EXCHANGE, \\\"lisi\\\"); // 正常队列绑定死信队列信息 Map<String, Object> params = new HashMap<>(); // 正常队列设置死信交换机 参数 key 是固定值 params.put(\\\"x-dead-letter-exchange\\\", DEAD_EXCHANGE); //正常队列设置死信 routing-key 参数 key 是固定值 params.put(\\\"x-dead-letter-routing-key\\\", \\\"lisi\\\"); // 正常队列 String normalQueue = \\\"normal-queue\\\"; channel.queueDeclare(normalQueue, false, false, false, params); channel.queueBind(normalQueue, NORMAL_EXCHANGE, \\\"zhangsan\\\"); System.out.println(\\\"等待接收消息........... \\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\\\"Consumer01 接收到消息\\\" + message); }; channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -> {}); } }\",\"先启动消费者 C1，创建出队列，然后停止该 C1 的运行，则 C1 将无法收到队列的消息，无法收到的消息 10 秒后进入死信队列。启动生产者 producer 生产消息\",\"image-20211110192243321\",\"生产者生产消息完成，10 秒后启动 C2 消费者，它消费死信队列里面的消息，如果消费成功，则代表原本 C1 消费的消息 10 秒进入了死信队列\",\"消费者 C2 代码\",\"package com.kbt.demo08; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DeliverCallback; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeoutException; /** * @author Young Kbt * @date 2021/11/10 19:13 * @description 消费者 C1 */ public class Consumer02 { // 死信交换机名称 private static final String DEAD_EXCHANGE = \\\"dead_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); // 声明交换机 channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT); // 声明队列 String deadQueue = \\\"dead-queue\\\"; channel.queueDeclare(deadQueue, false, false, false, null); channel.queueBind(deadQueue, DEAD_EXCHANGE, \\\"lisi\\\"); System.out.println(\\\"等待接收死信消息........... \\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\\\"Consumer02 接收到消息\\\" + message); }; channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -> {}); } }\",\"效果演示\",\"image-20211110192743276\",\"image-20211110192651293\"]},\"748\":{\"h\":\"死信最大长度\",\"t\":[\"消息生产者代码去掉 TTL 属性，basicPublish 的第三个参数改为 null\",\"public class Producer { private static final String NORMAL_EXCHANGE = \\\"normal_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); // 设置消息的 TTL 时间 10s // AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\\\"10000\\\").build(); // 该信息是用作演示队列个数限制 for (int i = 1; i <= 10; i++) { String message = \\\"info\\\" + i; channel.basicPublish(NORMAL_EXCHANGE, \\\"zhangsan\\\", null, message.getBytes()); System.out.println(\\\"生产者发送消息:\\\" + message); } } }\",\"C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息)\",\"public class Consumer01 { // 普通交换机名称 private static final String NORMAL_EXCHANGE = \\\"normal_exchange\\\"; // 死信交换机名称 private static final String DEAD_EXCHANGE = \\\"dead_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); // 声明死信和普通交换机 类型为 direct channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT); // 声明私信队列 String deadQueueName = \\\"dead-queue\\\"; channel.queueDeclare(deadQueueName, false, false, false, null); // 死信队列绑定：队列、交换机、路由键（routingKey） channel.queueBind(deadQueueName, DEAD_EXCHANGE, \\\"lisi\\\"); // 正常队列绑定死信队列信息 Map<String, Object> params = new HashMap<>(); // 正常队列设置死信交换机 参数 key 是固定值 params.put(\\\"x-dead-letter-exchange\\\", DEAD_EXCHANGE); //正常队列设置死信 routing-key 参数 key 是固定值 params.put(\\\"x-dead-letter-routing-key\\\", \\\"lisi\\\"); // 设置正常队列长度的限制，例如发送 10 个消息，6 个位正常，4 个则为死信 params.put(\\\"x-max-length\\\", 6); // 正常队列 String normalQueue = \\\"normal-queue\\\"; channel.queueDeclare(normalQueue, false, false, false, params); channel.queueBind(normalQueue, NORMAL_EXCHANGE, \\\"zhangsan\\\"); System.out.println(\\\"等待接收消息........... \\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\\\"Consumer01 接收到消息\\\" + message); }; channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -> {}); } }\",\"注意\",\"因为参数改变了，所以需要把原先队列删除\",\"2021-11-10 @Young Kbt\",\"C2 消费者代码不变(启动 C2 消费者)\",\"image-20211110193547802\"]},\"749\":{\"h\":\"死信消息被拒\",\"t\":[\"1、消息生产者代码同上生产者一致\",\"2、需求：消费者 C1 拒收消息 \\\"info5\\\"\",\"消费者 C1 代码\",\"/** * @author Young Kbt * @date 2021/11/10 19:13 * @description 消费者 C1 */ public class Consumer01 { // 普通交换机名称 private static final String NORMAL_EXCHANGE = \\\"normal_exchange\\\"; // 死信交换机名称 private static final String DEAD_EXCHANGE = \\\"dead_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); // 声明死信和普通交换机 类型为 direct channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT); // 声明私信队列 String deadQueueName = \\\"dead-queue\\\"; channel.queueDeclare(deadQueueName, false, false, false, null); // 死信队列绑定：队列、交换机、路由键（routingKey） channel.queueBind(deadQueueName, DEAD_EXCHANGE, \\\"lisi\\\"); // 正常队列绑定死信队列信息 Map<String, Object> params = new HashMap<>(); // 正常队列设置死信交换机 参数 key 是固定值 params.put(\\\"x-dead-letter-exchange\\\", DEAD_EXCHANGE); //正常队列设置死信 routing-key 参数 key 是固定值 params.put(\\\"x-dead-letter-routing-key\\\", \\\"lisi\\\"); // 设置正常队列长度的限制，例如发送 10 个消息，6 个位正常，4 个则为死信 // params.put(\\\"x-max-length\\\", 6); // 正常队列 String normalQueue = \\\"normal-queue\\\"; channel.queueDeclare(normalQueue, false, false, false, params); channel.queueBind(normalQueue, NORMAL_EXCHANGE, \\\"zhangsan\\\"); System.out.println(\\\"等待接收消息........... \\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); if (message.equals(\\\"info5\\\")) { System.out.println(\\\"Consumer01 接收到消息\\\" + message + \\\"并拒绝签收该消息\\\"); //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中 channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false); } else { System.out.println(\\\"Consumer01 接收到消息\\\" + message); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } }; // 开启手动应答 channel.basicConsume(normalQueue, false, deliverCallback, consumerTag -> {}); } }\",\"image-20211110194202134\",\"C2 消费者代码不变\",\"/** * @author Young Kbt * @date 2021/11/10 19:13 * @description 消费者 C1 */ public class Consumer02 { // 死信交换机名称 private static final String DEAD_EXCHANGE = \\\"dead_exchange\\\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMQUtils.getChannel(); // 声明交换机 channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT); // 声明队列 String deadQueue = \\\"dead-queue\\\"; channel.queueDeclare(deadQueue, false, false, false, null); channel.queueBind(deadQueue, DEAD_EXCHANGE, \\\"lisi\\\"); System.out.println(\\\"等待接收死信消息........... \\\"); DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\\\"Consumer02 接收到消息\\\" + message); }; channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -> { }); } }\",\"启动消费者 C1 等待 10 秒，再启动消费者 C2\",\"效果演示\",\"image-20211110194727053\"]},\"750\":{\"h\":\"RabbitMQ - 延迟队列\"},\"751\":{\"h\":\"延迟队列介绍\",\"t\":[\"延迟队列概念：\",\"延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。\",\"延迟队列使用场景：\",\"订单在十分钟之内未支付则自动取消\",\"新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒\",\"用户注册成功后，如果三天内没有登陆则进行短信提醒\",\"用户发起退款，如果三天内没有得到处理则通知相关运营人员\",\"预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\",\"这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？\",\"如果数据量比较少，确实可以这样做，比如：对于「如果账单一周内未支付则进行自动结算」这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：「订单十分钟内未支付则关闭」，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\",\"image-20211110215651792\"]},\"752\":{\"h\":\"TTL的两种设置\",\"t\":[\"TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\",\"换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。\",\"队列设置 TTL\",\"在创建队列的时候设置队列的 x-message-ttl 属性\",\"Map<String, Object> params = new HashMap<>(); params.put(\\\"x-message-ttl\\\",5000); return QueueBuilder.durable(\\\"QA\\\").withArguments(args).build(); // QA 队列的最大存活时间位 5000 毫秒\",\"消息设置 TTL\",\"针对每条消息设置 TTL\",\"rabbitTemplate.converAndSend(\\\"X\\\",\\\"XC\\\",message,correlationData -> { correlationData.getMessageProperties().setExpiration(\\\"5000\\\"); });\",\"两个代码块来自下方的案例\",\"两者区别\",\"如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。\",\"另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃\"]},\"753\":{\"h\":\"整合SpringBoot\",\"t\":[\"前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。\",\"创建一个 Maven 工程或者 Spring Boot工程\",\"添加依赖，这里的 Spring Boot 是2.5.5 版本\",\"<parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.5.5</version> <relativePath/> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.47</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> <!--RabbitMQ 依赖--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-amqp</artifactId> </dependency> </dependencies>\",\"创建 application.yml 文件\",\"server: port: 8808 spring: rabbitmq: host: 112.74.169.231 port: 5672 username: admin password: 123456\",\"这里是 8808 端口，可根据需求决定端口\",\"新建启动类 RabbitmqApplication\",\"package com.kbt; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; /** * @author Young Kbt * @date 2021/11/10 23:23 * @description */ @SpringBootApplication public class RabbitmqApplication { public static void main(String[] args) { SpringApplication.run(RabbitmqApplication.class, args); } }\"]},\"754\":{\"h\":\"队列TTL\",\"t\":[\"代码架构图\",\"创建两个队列 QA 和 QB，两个队列的 TTL 分别设置为 10S 和 40S，然后再创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：\",\"image-20211110225716769\",\"原先配置队列信息，写在了生产者和消费者代码中，现在可写在配置类中，生产者只发消息，消费者只接受消息\",\"配置类代码\",\"package com.kbt.config; import org.springframework.amqp.core.*; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; /** * @author Young Kbt * @date 2021/11/10 22:58 * @description rabbitmq 配置类 */ @Configuration public class TtlQueueConfig { // X 交换机 public static final String X_EXCHANGE = \\\"X\\\"; // 队列 QA 绑定 X 交换机 public static final String QUEUE_QA = \\\"QA\\\"; // 队列 QB 绑定 X 交换机 public static final String QUEUE_QB = \\\"QB\\\"; // 死信交换机 public static final String Y_DEAD_LETTER_EXCHANGE = \\\"Y\\\"; // 死信队列 public static final String DEAD_LETTER_QUEUE = \\\"QD\\\"; /** * 声明 xExchange 交换机 */ @Bean(\\\"xExchange\\\") public DirectExchange xExchange() { return new DirectExchange(X_EXCHANGE); } /** * 声明死信队列交换机 */ @Bean(\\\"yExchange\\\") public DirectExchange yExchange() { return new DirectExchange(Y_DEAD_LETTER_EXCHANGE); } /** * 声明队列 QA 的 ttl 为 10s 并绑定到对应的死信交换机 */ @Bean(\\\"queueA\\\") public Queue queueA() { Map<String, Object> params = new HashMap<>(); // 声明当前队列绑定的死信交换机 params.put(\\\"x-dead-letter-exchange\\\", Y_DEAD_LETTER_EXCHANGE); // 声明当前队列的死信路由 key params.put(\\\"x-dead-letter-routing-key\\\", \\\"YD\\\"); // 声明队列的 TTL params.put(\\\"x-message-ttl\\\", 10000); return QueueBuilder.durable(QUEUE_QA).withArguments(params).build(); } /** * 声明队列 QA 绑定 X 交换机 */ @Bean public Binding queueBindingX(@Qualifier(\\\"queueA\\\") Queue queueA, @Qualifier(\\\"xExchange\\\") DirectExchange xExchange) { return BindingBuilder.bind(queueA).to(xExchange).with(\\\"XA\\\"); } /** * 声明队列 QB ttl 为 40s 并绑定到对应的死信交换机 */ @Bean(\\\"queueB\\\") public Queue queueB() { Map<String, Object> params = new HashMap<>(); // 声明当前队列绑定的死信交换机 params.put(\\\"x-dead-letter-exchange\\\", Y_DEAD_LETTER_EXCHANGE); // 声明当前队列的死信路由 key params.put(\\\"x-dead-letter-routing-key\\\", \\\"YD\\\"); // 声明队列的 TTL params.put(\\\"x-message-ttl\\\", 40000); return QueueBuilder.durable(QUEUE_QB).withArguments(params).build(); } /** * 声明队列 QB 绑定 X 交换机 */ @Bean public Binding queuebBindingX(@Qualifier(\\\"queueB\\\") Queue queue1B, @Qualifier(\\\"xExchange\\\") DirectExchange xExchange) { return BindingBuilder.bind(queue1B).to(xExchange).with(\\\"XB\\\"); } /** * 声明死信队列 QD */ @Bean(\\\"queueD\\\") public Queue queueD() { return new Queue(DEAD_LETTER_QUEUE); } /** * 声明死信队列 QD 绑定关系 */ @Bean public Binding deadLetterBindingQAD(@Qualifier(\\\"queueD\\\") Queue queueD, @Qualifier(\\\"yExchange\\\") DirectExchange yExchange) { return BindingBuilder.bind(queueD).to(yExchange).with(\\\"YD\\\"); } }\",\"Controller 层代码，获取消息，放到 RabbitMQ 里\",\"package com.kbt.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Date; /** * @author Young Kbt * @date 2021/11/10 23:17 * @description controller 层 */ @RestController @Slf4j @RequestMapping(\\\"/ttl\\\") public class SendMsgController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\\\"/sendMsg/{message}\\\") public void sendMsg(@PathVariable(\\\"message\\\") String message) { log.info(\\\"当前时间：{},发送一条信息给两个 TTL 队列:{}\\\", new Date(), message); rabbitTemplate.convertAndSend(\\\"X\\\", \\\"XA\\\", \\\"消息来自 ttl 为 10S 的队列: \\\" + message); rabbitTemplate.convertAndSend(\\\"X\\\", \\\"XB\\\", \\\"消息来自 ttl 为 40S 的队列: \\\" + message); } }\",\"消费者代码\",\"监听死信队列是否出现消息，有则打印到控制台\",\"package com.kbt.consumer; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; import java.util.Date; /** * @author Young Kbt * @date 2021/11/10 23:19 * @description 消费者 */ @Slf4j @Component public class DeadLetterQueueConsumer { /** * 监听死信队列 QD */ @RabbitListener(queues = \\\"QD\\\") public void receiveD(Message message, Channel channel) { String msg = new String(message.getBody()); log.info(\\\"当前时间：{},收到死信队列信息{}\\\", new Date().toString(), msg); } }\",\"发起一个请求：http://localhost:8808/ttl/sendMsg/我是可乐\",\"image-20211111002950970\",\"第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。\",\"不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？\",\"番外\",\"当然也可以自定义 RabbitMQ 的配置信息\",\"点击查看代码\",\"package com.kbt.config; import org.springframework.amqp.rabbit.connection.CachingConnectionFactory; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Value; import org.springframework.beans.factory.config.ConfigurableBeanFactory; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; /** * @author Young Kbt * @date 2021/11/10 23:41 * @description */ @Configuration public class RabbitConfig { @Value(\\\"${spring.rabbitmq.host}\\\") private String host; @Value(\\\"${spring.rabbitmq.port}\\\") private int port; @Value(\\\"${spring.rabbitmq.username}\\\") private String username; @Value(\\\"${spring.rabbitmq.password}\\\") private String password; @Bean(\\\"connectionFactory\\\") public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(host,port); connectionFactory.setUsername(username); connectionFactory.setPassword(password); connectionFactory.setVirtualHost(\\\"/\\\"); return connectionFactory; } @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); return template; } }\"]},\"755\":{\"h\":\"延时队列TTL优化\",\"t\":[\"在这里新增了一个队列 QC，该队列不设置 TTL 时间，根据前端的请求确定 TTL 时间，绑定关系如下：\",\"image-20211111000716623\",\"新增一个配置文件类，用于新增队列 QC，也可以放在上方的配置文件类里\",\"package com.kbt.config; import org.springframework.amqp.core.*; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; /** * @author Young Kbt * @date 2021/11/11 0:11 * @description */ @Configuration public class MsgTtlQueueConfig { public static final String Y_DEAD_LETTER_EXCHANGE = \\\"Y\\\"; public static final String QUEUE_C = \\\"QC\\\"; //声明队列 C 死信交换机 @Bean(\\\"queueC\\\") public Queue queueC() { Map<String, Object> args = new HashMap<>(3); //声明当前队列绑定的死信交换机 args.put(\\\"x-dead-letter-exchange\\\", Y_DEAD_LETTER_EXCHANGE); //声明当前队列的死信路由 key args.put(\\\"x-dead-letter-routing-key\\\", \\\"YD\\\"); //没有声明 TTL 属性 return QueueBuilder.durable(QUEUE_C).withArguments(args).build(); } //声明队列 C 绑定 X 交换机 @Bean public Binding queuecBindingX(@Qualifier(\\\"queueC\\\") Queue queueC, @Qualifier(\\\"xExchange\\\") DirectExchange xExchange) { return BindingBuilder.bind(queueC).to(xExchange).with(\\\"XC\\\"); } }\",\"Controller 新增方法\",\"该方法接收的请求要带有 TTL 时间\",\"/** * @author Young Kbt * @date 2021/11/10 23:17 * @description controller 层 */ @RestController @Slf4j @RequestMapping(\\\"/ttl\\\") public class SendMsgController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\\\"/sendMsg/{message}\\\") public void sendMsg(@PathVariable(\\\"message\\\") String message) { log.info(\\\"当前时间：{},发送一条信息给两个 TTL 队列:{}\\\", new Date(), message); rabbitTemplate.convertAndSend(\\\"X\\\", \\\"XA\\\", \\\"消息来自 ttl 为 10S 的队列: \\\" + message); rabbitTemplate.convertAndSend(\\\"X\\\", \\\"XB\\\", \\\"消息来自 ttl 为 40S 的队列: \\\" + message); } @GetMapping(\\\"sendExpirationMsg/{message}/{ttlTime}\\\") public void sendMsg(@PathVariable(\\\"message\\\") String message, @PathVariable(\\\"ttlTime\\\") String ttlTime) { rabbitTemplate.convertAndSend(\\\"X\\\", \\\"XC\\\", message, correlationData -> { correlationData.getMessageProperties().setExpiration(ttlTime); return correlationData; }); log.info(\\\"当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}\\\", new Date(), ttlTime, message); } }\",\"重启下面，发送请求：\",\"http://localhost:8808/ttl/sendExpirationMsg/你好1/20000\",\"http://localhost:8808/ttl/sendExpirationMsg/你好2/2000\",\"image-20211111002753539\",\"看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时「死亡」\",\"因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\",\"这也就是为什么如图的时间：你好 2 延时 2 秒，却后执行，还要等待你好 1 消费后再执行你好 2\"]},\"756\":{\"h\":\"Rabbitmq插件实现延迟队列\",\"t\":[\"上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\",\"安装延时队列插件\",\"可去官网下载找到 rabbitmq_delayed_message_exchange 插件，放置到 RabbitMQ 的插件目录。\",\"因为官网也是跳转去该插件的 GitHub 地址进行下载：点击跳转\",\"打开 Linux，用 Xftp 将插件放到 RabbitMQ 的安装目录下的 plgins 目录，\",\"RabbitMQ 与其 plgins 目录默认分别位于\",\"# RabbitMQ 安装目录 cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.9.8 # RabbitMQ 的 plgins 所在目录 cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.9.8/plugins\",\"其中我的版本是 /rabbitmq_server-3.9.8\",\"进入目录后执行下面命令让该插件生效，然后重启 RabbitMQ\",\"# 安装 rabbitmq-plugins enable rabbitmq_delayed_message_exchange # 重启服务 systemctl restart rabbitmq-server\",\"解释\",\"安装命令不能出现插件版本和后缀，如 rabbitmq-plugins enable rabbitmq_delayed_message_exchange-3.9.0.ez 会报错\",\"必须是 rabbitmq-plugins enable rabbitmq_delayed_message_exchange，后面不允许填入版本和文件后缀\",\"打开 Web 界面，查看交换机的新增功能列表，如果多出了如图所示，代表成功添加插件\",\"image-20211111180530451\"]},\"757\":{\"h\":\"插件实战\",\"t\":[\"在这里新增了一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下:\",\"image-20211111180629701\",\"配置类代码\",\"新增一个配置类 DelayedQueueConfig，也可以放在原来的配置文件里，代码里使用了 CustomExchange 类，通过参数来自定义一个类型(direct、topic等)\",\"在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\",\"/** * @author Young Kbt * @date 2021/11/11 18:08 * @description */ @Configuration public class DelayedQueueConfig { public static final String DELAYED_QUEUE_NAME = \\\"delayed.queue\\\"; public static final String DELAYED_EXCHANGE_NAME = \\\"delayed.exchange\\\"; public static final String DELAYED_ROUTING_KEY = \\\"delayed.routingkey\\\"; @Bean public Queue delayedQueue() { return new Queue(DELAYED_QUEUE_NAME); } //自定义交换机 我们在这里定义的是一个延迟交换机 @Bean public CustomExchange delayedExchange() { Map<String, Object> args = new HashMap<>(); //自定义交换机的类型 args.put(\\\"x-delayed-type\\\", \\\"direct\\\"); return new CustomExchange(DELAYED_EXCHANGE_NAME, \\\"x-delayed-message\\\", true, false, args); } @Bean public Binding bindingDelayedQueue(@Qualifier(\\\"delayedQueue\\\") Queue queue, @Qualifier(\\\"delayedExchange\\\") CustomExchange delayedExchange) { return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs(); } }\",\"生产者代码\",\"在 controller 里新增一个方法\",\"@RestController @Slf4j @RequestMapping(\\\"/ttl\\\") public class SendMsgController { @Autowired private RabbitTemplate rabbitTemplate; public static final String DELAYED_EXCHANGE_NAME = \\\"delayed.exchange\\\"; public static final String DELAYED_ROUTING_KEY = \\\"delayed.routingkey\\\"; // ...... @GetMapping(\\\"sendDelayMsg/{message}/{delayTime}\\\") public void sendMsg(@PathVariable String message, @PathVariable(\\\"delayTime\\\") Integer delayTime) { rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message, correlationData -> { correlationData.getMessageProperties().setDelay(delayTime); return correlationData; }); log.info(\\\" 当 前 时 间 ： {}, 发 送 一 条 延 迟 {} 毫秒的信息给队列 delayed.queue:{}\\\", new Date(), delayTime, message); } }\",\"消费者代码\",\"监听延时队列，如果有消息进入该队列，则打印到控制台\",\"package com.kbt.consumer; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.util.Date; /** * @author Young Kbt * @date 2021/11/11 18:14 * @description */ @Slf4j @Component public class DelayQueueConsumer { public static final String DELAYED_QUEUE_NAME = \\\"delayed.queue\\\"; @RabbitListener(queues = DELAYED_QUEUE_NAME) public void receiveDelayedQueue(Message message) { String msg = new String(message.getBody()); log.info(\\\"当前时间：{},收到延时队列的消息：{}\\\", new Date().toString(), msg); } }\",\"发送请求：\",\"http://localhost:8808/ttl/sendDelayMsg/hello1/20000\",\"http://localhost:8808/ttl/sendDelayMsg/hello2/2000\",\"image-20211111181554596\",\"可以看到哪怕 hello1 需要20秒再进入延时队列，hello2 2 秒后直接进入延时队列，无需等待 hello1\"]},\"758\":{\"h\":\"总结\",\"t\":[\"延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。\",\"当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景\"]},\"759\":{\"h\":\"RabbitMQ - 高级发布确认\",\"t\":[\"在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？\"]},\"760\":{\"h\":\"发布确认springboot版本\",\"t\":[\"简单的发布确认机制在应答与签收已经介绍，本内容将介绍整合了 SpringBoot 的发布确认机制。\"]},\"761\":{\"h\":\"介绍\",\"t\":[\"首先发布消息后进行备份在缓存里，如果消息成功发布确认到交换机，则从缓存里删除该消息，如果没有成功发布，则设置一个定时任务，重新从缓存里获取消息发布到交换机，直到成功发布到交换机。\",\"确认机制图例：\",\"image-20211112000502762\"]},\"762\":{\"h\":\"实战\",\"t\":[\"一个交换机：confirm.exchange，一个队列：confirm.queue，一个消费者：confirm.consumer\",\"其中交换机类型时 direct，与队列关联的 routingKey 是 key1\",\"代码架构图：\",\"image-20211112000539340\",\"在配置文件当中需要添加：\",\"server: port: 8808 spring: rabbitmq: host: 112.74.169.231 port: 5672 username: admin password: 123456 publisher-confirm-type: correlated\",\"NONE 值是禁用发布确认模式，是默认值\",\"CORRELATED 值是发布消息成功到交换器后会触发回调方法\",\"SIMPLE 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;\",\"添加配置类\",\"声明交换机和队列，并且将交换机和队列进行绑定\",\"package com.kbt.config; import org.springframework.amqp.core.*; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @author Young Kbt * @date 2021/11/12 0:09 * @description 高级确认发布 配置类 */ @Configuration public class ConfirmConfig { public static final String CONFIRM_EXCHANGE_NAME = \\\"confirm.exchange\\\"; public static final String CONFIRM_QUEUE_NAME = \\\"confirm.queue\\\"; /** * 声明业务 Exchange */ @Bean(\\\"confirmExchange\\\") public DirectExchange confirmExchange() { return new DirectExchange(CONFIRM_EXCHANGE_NAME); } /** * 声明确认队列 */ @Bean(\\\"confirmQueue\\\") public Queue confirmQueue() { return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build(); } /** * 声明确认队列绑定关系 */ @Bean public Binding queueBinding(@Qualifier(\\\"confirmQueue\\\") Queue queue, @Qualifier(\\\"confirmExchange\\\") DirectExchange exchange{ return BindingBuilder.bind(queue).to(exchange).with(\\\"key1\\\"); } }\",\"消息生产者发布消息后的回调接口\",\"只要生产者发布消息，交换机不管是否收到消息，都会调用该类的 confirm 方法\",\"package com.kbt.back; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; /** * @author Young Kbt * @date 2021/11/12 0:17 * @description 消息生产者发布消息后的回调接口 */ @Component @Slf4j public class MyCallBack implements RabbitTemplate.ConfirmCallback { /** * 交换机不管是否收到消息的一个回调方法 * * @param correlationData 消息相关数据 * @param ack 交换机是否收到消息 * @param cause 为收到消息的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) { String id = correlationData != null ? correlationData.getId() : \\\"\\\"; if(ack) { log.info(\\\"交换机已经收到 id 为:{}的消息\\\", id); }else { log.info(\\\"交换机还未收到 id 为:{}消息，原因:{}\\\", id, cause); } } }\",\"消息生产者，也可以说是 Controller 层\",\"package com.kbt.controller; import com.kbt.back.MyCallBack; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.PostConstruct; /** * @author Young Kbt * @date 2021/11/12 0:16 * @description 高级消息发布 消息生产者 */ @RestController @RequestMapping(\\\"/confirm\\\") @Slf4j public class ProducerController { public static final String CONFIRM_EXCHANGE_NAME = \\\"confirm.exchange\\\"; @Autowired private RabbitTemplate rabbitTemplate; @Autowired private MyCallBack myCallBack; // 调用类构造器之后调用该方法，依赖注入 RabbitMQ 的回调对象 @PostConstruct public void init() { rabbitTemplate.setConfirmCallback(myCallBack); } /** * 消息回调和退回 */ @GetMapping(\\\"sendMessage/{message}\\\") public void sendMessage(@PathVariable String message) { //指定消息 id 为 1 CorrelationData correlationData1 = new CorrelationData(\\\"1\\\"); String routingKey = \\\"key1\\\"; rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1); log.info(routingKey + \\\"发送消息内容:{}\\\", message + routingKey); CorrelationData correlationData2 = new CorrelationData(\\\"2\\\"); routingKey = \\\"key2\\\"; rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2); log.info(routingKey + \\\"发送消息内容:{}\\\", message + routingKey); } }\",\"消息消费者\",\"监听 confirm.queue 队列\",\"package com.kbt.consumer; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; /** * @author Young Kbt * @date 2021/11/12 0:24 * @description 高级发布确认 消费者 */ @Component @Slf4j public class ConfirmConsumer { public static final String CONFIRM_QUEUE_NAME = \\\"confirm.queue\\\"; @RabbitListener(queues = CONFIRM_QUEUE_NAME) public void receiveMsg(Message message) { String msg = new String(message.getBody()); log.info(\\\"接受到队列 confirm.queue 消息:{}\\\", msg); } }\",\"访问：http://localhost:8808/confirm/sendMessage/可乐\",\"结果分析：\",\"image-20211112173526575\",\"可以看到，发送了两条消息，第一条消息的 RoutingKey 为 \\\"key1\\\"，第二条消息的 RoutingKey 为 \\\"key2\\\"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\",\"丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败\"]},\"763\":{\"h\":\"回退消息\"},\"764\":{\"h\":\"介绍\",\"t\":[\"获取回退的消息，首先在配置文件开启该功能，然后需要自定义类实现 RabbitTemplate.ReturnsCallback 接口，并且初始化时，使用该自定义类作为回退消息的处理类，同时开启 Mandatory，设置为 true\",\"在启动开启 Mandatory，或者在代码里手动开启 Mandatory 参数，或者都开启😸\",\"配置类文件开启：\",\"# 新版 spring: rabbitmq: template: mandatory: true # 旧版 spring: rabbitmq: mandatory: true\",\"代码中开启：\",\"rabbitTemplate.setMandatory(true);\",\"在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。\",\"那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。\"]},\"765\":{\"h\":\"实战\",\"t\":[\"修改配置文件\",\"server: port: 8808 spring: rabbitmq: host: 112.74.169.231 port: 5672 username: admin password: 123456 publisher-confirm-type: correlated publisher-returns: true template: mandatory: true\",\"修改回调接口\",\"实现 RabbitTemplate.ReturnsCallback 接口，并实现方法\",\"/** * @author Young Kbt * @date 2021/11/12 0:17 * @description 消息生产者发布消息后的回调接口 */ @Component @Slf4j public class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback { /** * 交换机不管是否收到消息的一个回调方法 * * @param correlationData 消息相关数据 * @param ack 交换机是否收到消息 * @param cause 为收到消息的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) { String id = correlationData != null ? correlationData.getId() : \\\"\\\"; if(ack) { log.info(\\\"交换机已经收到 id 为:{}的消息\\\", id); }else { log.info(\\\"交换机还未收到 id 为:{}消息，原因:{}\\\", id, cause); } } /** * 当消息无法路由的时候的回调方法 * @param message 消息 * @param replyCode 编码 * @param replyText 退回原因 * @param exchange 从哪个交换机退回 * @param routingKey 通过哪个路由 key 退回 */ @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) { log.error(\\\"消息：{}，被交换机 {} 退回，原因：{}，路由key：{},code:{}\\\", new String(message.getBody()), exchange, replyText, routingKey, replyCode); } }\",\"其他可能没有 RabbitTemplate.ReturnCallback 请用 RabbitTemplate.ReturnsCallback\",\"//当消息无法路由的时候的回调方法 @Override public void returnedMessage(ReturnedMessage returned) { log.error(\\\"消息：{}，被交换机 {} 退回，原因：{}，路由key：{},code:{}\\\", new String(returned.getMessage().getBody()), returned.getExchange(), returned.getReplyText(), returned.getRoutingKey(), returned.getReplyCode()); }\",\"修改生产者 ProducerController\",\"@RestController @RequestMapping(\\\"/confirm\\\") @Slf4j public class ProducerController { // 调用类构造器之后调用该方法，依赖注入 RabbitMQ 的回调对象 @PostConstruct public void init() { // 消息回调 rabbitTemplate.setConfirmCallback(myCallBack); /** * true：交换机无法将消息进行路由时，会将该消息返回给生产者 * false：如果发现消息无法进行路由，则直接丢弃 */ rabbitTemplate.setMandatory(true); // 设置回退消息交给谁处理 rabbitTemplate.setReturnCallback(myCallBack); } // 其他方法 ...... }\",\"打开浏览器访问地址：http://localhost:8808/confirm/sendMessage/可乐\",\"image-20211112175031225\"]},\"766\":{\"h\":\"备份交换机\"},\"767\":{\"h\":\"介绍\",\"t\":[\"理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？\",\"前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。\",\"什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。\"]},\"768\":{\"h\":\"实战\",\"t\":[\"需要一个备份交换机 backup.exchange，类型为 fanout，该交换机发送消息到队列 backup.queue 和 warning.queue\",\"代码架构图：\",\"image-20211112002641439\",\"修改高级确认发布 配置类\",\"/** * @author Young Kbt * @date 2021/11/12 0:09 * @description 高级确认发布 配置类 */ @Configuration public class ConfirmConfig { public static final String CONFIRM_EXCHANGE_NAME = \\\"confirm.exchange\\\"; public static final String CONFIRM_QUEUE_NAME = \\\"confirm.queue\\\"; // 关于备份的 public static final String BACKUP_EXCHANGE_NAME = \\\"backup.exchange\\\"; public static final String BACKUP_QUEUE_NAME = \\\"backup.queue\\\"; public static final String WARNING_QUEUE_NAME = \\\"warning.queue\\\"; /** * 声明确认队列 */ @Bean(\\\"confirmQueue\\\") public Queue confirmQueue() { return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build(); } /** * 声明确认队列绑定关系 */ @Bean public Binding queueBinding(@Qualifier(\\\"confirmQueue\\\") Queue queue, @Qualifier(\\\"confirmExchange\\\") DirectExchange exchange) { return BindingBuilder.bind(queue).to(exchange).with(\\\"key1\\\"); } /** * 声明备份 Exchange */ @Bean(\\\"backupExchange\\\") public FanoutExchange backupExchange() { return new FanoutExchange(BACKUP_EXCHANGE_NAME); } /** * 声明确认 Exchange 交换机的备份交换机 */ @Bean(\\\"confirmExchange\\\") public DirectExchange confirmExchange() { ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME) .durable(true) //设置该交换机的备份交换机 .withArgument(\\\"alternate-exchange\\\", BACKUP_EXCHANGE_NAME); return exchangeBuilder.build(); } /** * 声明警告队列 */ @Bean(\\\"warningQueue\\\") public Queue warningQueue() { return QueueBuilder.durable(WARNING_QUEUE_NAME).build(); } /** * 声明报警队列绑定关系 */ @Bean public Binding warningBinding(@Qualifier(\\\"warningQueue\\\") Queue queue, @Qualifier(\\\"backupExchange\\\") FanoutExchange backupExchange) { return BindingBuilder.bind(queue).to(backupExchange); } /** * 声明备份队列 */ @Bean(\\\"backQueue\\\") public Queue backQueue() { return QueueBuilder.durable(BACKUP_QUEUE_NAME).build(); } /** * 声明备份队列绑定关系 */ @Bean public Binding backupBinding(@Qualifier(\\\"backQueue\\\") Queue queue, @Qualifier(\\\"backupExchange\\\") FanoutExchange backupExchange) { return BindingBuilder.bind(queue).to(backupExchange); } }\",\"报警消费者\",\"package com.kbt.consumer; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; /** * @author Young Kbt * @date 2021/11/12 17:59 * @description */ @Component @Slf4j public class WarningConsumer { public static final String WARNING_QUEUE_NAME = \\\"warning.queue\\\"; @RabbitListener(queues = WARNING_QUEUE_NAME) public void receiveWarningMsg(Message message) { String msg = new String(message.getBody()); log.error(\\\"报警发现不可路由消息：{}\\\", msg); } }\",\"由于之前写过 confirm.exchange 交换机，当更改配置了，需要删掉，不然会报错\",\"image-20211112180036082\",\"打开浏览器访问地址：http://localhost:8808/confirm/sendMessage/可乐\",\"image-20211112180434452\",\"Mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。\"]},\"769\":{\"h\":\"RabbitMQ - 优先级\"},\"770\":{\"h\":\"幂等性\"},\"771\":{\"h\":\"概念\",\"t\":[\"用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。\",\"可以理解为验证码，只能输入一次，再次重新输入会刷新验证码，原来的验证码失效。\"]},\"772\":{\"h\":\"消息重复消费\",\"t\":[\"消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\"]},\"773\":{\"h\":\"解决思路\",\"t\":[\"MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。\"]},\"774\":{\"h\":\"消费端的幂等性保障\",\"t\":[\"在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。\",\"业界主流的幂等性有两种操作：\",\"唯一 ID+ 指纹码机制,利用数据库主键去重\",\"指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。\",\"Redis 的原子性\",\"利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费\"]},\"775\":{\"h\":\"优先级队列\"},\"776\":{\"h\":\"使用场景\",\"t\":[\"在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。\",\"但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。\"]},\"777\":{\"h\":\"添加方法\",\"t\":[\"Web 页面添加\",\"image-20211112222646574\",\"防止图片失效，这里记录步骤\",\"进入 Web 页面，点击 Queue 菜单，然后点击 Add a new queue\",\"点击下方的 Maximum priority\",\"执行第二步，则会自动在 Argument 生成 x-max-priority 字符串\",\"点击 Add queue 即可添加优先级队列成功\",\"声明队列的时候添加优先级\",\"设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU\",\"Map<String, Object> params = new HashMap(); // 优先级为 10 params.put(\\\"x-max-priority\\\", 10); channel.queueDeclare(\\\"hello\\\", true, false, false, params);\",\"注意事项：\",\"队列实现优先级需要做的事情有如下：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序\"]},\"778\":{\"h\":\"实战\",\"t\":[\"生产者发送十个消息，如果消息为 info5，则优先级是最高的，当消费者从队列获取消息的时候，优先获取 info5 消息\"]},\"779\":{\"h\":\"非SpringBoot\",\"t\":[\"生产者代码\",\"package com.kbt.demo09; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.AMQP; import com.rabbitmq.client.Channel; /** * @author Young Kbt * @date 2021/11/12 22:35 * @description 优先级 生产者 */ public class PriorityProducer { private static final String QUEUE_NAME = \\\"priority_queue\\\"; public static void main(String[] args) throws Exception{ Channel channel = RabbitMQUtils.getChannel(); // 给消息赋予一个 priority 属性 AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build(); for (int i = 1; i < 11; i++) { String message = \\\"info\\\" + i; if (i == 5) { channel.basicPublish(\\\"\\\", QUEUE_NAME, properties, message.getBytes()); } else { channel.basicPublish(\\\"\\\", QUEUE_NAME, null, message.getBytes()); } System.out.println(\\\"发送消息完成：\\\" + message); } } }\",\"消费者代码\",\"package com.kbt.demo09; import com.kbt.utils.RabbitMQUtils; import com.rabbitmq.client.CancelCallback; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DeliverCallback; import java.util.HashMap; import java.util.Map; /** * @author Young Kbt * @date 2021/11/12 22:35 * @description 优先级 消费者 */ public class PriorityConsumer { private final static String QUEUE_NAME = \\\"priority_queue\\\"; public static void main(String[] args) throws Exception { Channel channel = RabbitMQUtils.getChannel(); //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU Map<String, Object> params = new HashMap(); params.put(\\\"x-max-priority\\\", 10); channel.queueDeclare(QUEUE_NAME, true, false, false, params); //推送的消息如何进行消费的接口回调 DeliverCallback deliverCallback = (consumerTag, delivery) -> { String message = new String(delivery.getBody()); System.out.println(\\\"消费的消息：\\\" + message); }; //取消消费的一个回调接口 如在消费的时候队列被删除掉了 CancelCallback cancelCallback = (consumerTag) -> { System.out.println(\\\"消息消费被中断\\\"); }; channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback); } }\",\"效果演示\",\"info 5 的优先级为 10，优先级最高。消费者消费信息效果如图：\",\"image-20211112224104960\"]},\"780\":{\"h\":\"整合SpringBoot\",\"t\":[\"仅需在声明队列的时候加上参数即可\",\"配置类代码\",\"声明队列时，给队列设置优先级\",\"@Configuration public class QueueConfig { /** * 声明优先级队列 */ @Bean(\\\"queue\\\") public Queue queue() { Map<String, Object> args = new HashMap<>(3); params.put(\\\"x-max-priority\\\", 10); return QueueBuilder.durable(\\\"priority_queue\\\").withArguments(args).build(); } /** * 声明一个交换机 */ @Bean(\\\"exchange\\\") public DirectExchange exchange() { return new DirectExchange(\\\"priority_exchange\\\"); } /* * 交换机和优先级队列进行绑定 */ @Bean public Binding queuecBindingX(@Qualifier(\\\"queue\\\") Queue queue, @Qualifier(\\\"exchange\\\") DirectExchange exchange) { return BindingBuilder.bind(queue).to(exchange).with(\\\"priority\\\"); } }\",\"生产者 Controller 代码\",\"获取请求发来的消息，并给消息设置优先级\",\"@RestController @Slf4j public class SendMsgController { @GetMapping(\\\"sendExpirationMsg/{message}\\\") public void sendMsg(@PathVariable(\\\"message\\\") String message) { rabbitTemplate.convertAndSend(\\\"X\\\", \\\"XC\\\", message, correlationData -> { // 设置消息的优先级 correlationData.getMessageProperties().setPriority(10); return correlationData; }); log.info(\\\"当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}\\\", new Date(), ttlTime, message); } }\",\"消费者代码\",\"@Component public class DeadLetterQueueConsumer { /** * 监听优先级队列 priority_queue */ @RabbitListener(queues = \\\"priority_queue\\\") public void receiveD(Message message, Channel channel) { String msg = new String(message.getBody()); System.out.println(\\\"消费的消息：\\\" + message); } }\",\"效果如图\",\"image-20211112224104960\"]},\"781\":{\"h\":\"惰性队列\"},\"782\":{\"h\":\"使用场景\",\"t\":[\"RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\",\"默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。\"]},\"783\":{\"h\":\"两种模式\",\"t\":[\"队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\",\"在队列声明的时候可以通过 x-queue-mode 参数来设置队列的模式，取值为 default 和 lazy。下面示例中演示了一个惰性队列的声明细节：\",\"Map<String, Object> args = new HashMap<String, Object>(); args.put(\\\"x-queue-mode\\\", \\\"lazy\\\"); channel.queueDeclare(\\\"myqueue\\\", false, false, false, args);\",\"也可以在 Web 页面添加队列时，选择 Lazy mode\",\"image-20211112224619178\"]},\"784\":{\"h\":\"内存开销对比\",\"t\":[\"image-20211112224647270\",\"在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB\"]},\"785\":{\"h\":\"RabbitMQ\"},\"786\":{\"h\":\"RabbitMQ\"},\"787\":{\"h\":\"WebSecurityConfigurerAdapter 相关\",\"t\":[\"提示\",\"此处主要记录了 SpringSecurity 配合jwt使用时 WebSecurityConfigurerAdapter 类的常用配置，如何快速地配置接口访问规则，以及新版本中该类被弃用后的替代品的使用方法。\"]},\"788\":{\"h\":\"WebSecurityConfigurerAdapter\",\"t\":[\"类路径：org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter\",\"如下方的配置，我们使用自定义注解@AnonymousAccess，快速、集中配置允许匿名访问的url。\",\"@Configuration @EnableWebSecurity public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Bean GrantedAuthorityDefaults grantedAuthorityDefaults() { // 去除 ROLE_ 前缀 return new GrantedAuthorityDefaults(\\\"\\\"); } @Bean public PasswordEncoder passwordEncoder() { // 密码加密方式 return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity httpSecurity) throws Exception { // 搜寻匿名标记 url： @AnonymousAccess Map<RequestMappingInfo, HandlerMethod> handlerMethodMap = applicationContext.getBean(RequestMappingHandlerMapping.class).getHandlerMethods(); // 获取匿名标记 Map<String, Set<String>> anonymousUrls = getAnonymousUrl(handlerMethodMap); httpSecurity // 由于使用的是JWT，我们这里不需要csrf .csrf().disable() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) // 授权异常 .exceptionHandling().authenticationEntryPoint(authenticationErrorHandler) .accessDeniedHandler(jwtAccessDeniedHandler) // 防止iframe 造成跨域 .and() .headers() .frameOptions() .disable() // 不创建会话 .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 静态资源等等 .antMatchers( HttpMethod.GET, \\\"/*.html\\\", \\\"/**/*.html\\\", \\\"/**/*.css\\\", \\\"/**/*.js\\\", \\\"/webSocket/**\\\" ).permitAll() // swagger 文档 .antMatchers(\\\"/user/getUserById/**\\\").permitAll() .antMatchers(\\\"/doc.html\\\").permitAll() .antMatchers(\\\"/swagger-ui.html\\\").permitAll() .antMatchers(\\\"/swagger-resources/**\\\").permitAll() .antMatchers(\\\"/webjars/**\\\").permitAll() .antMatchers(\\\"/*/api-docs\\\").permitAll() // 阿里巴巴 druid .antMatchers(\\\"/druid/**\\\").permitAll() // 放行OPTIONS请求 .antMatchers(HttpMethod.OPTIONS, \\\"/**\\\").permitAll() // 自定义匿名访问所有url放行：允许匿名和带Token访问，细腻化到每个 Request 类型 // GET .antMatchers(HttpMethod.GET, anonymousUrls.get(RequestMethodEnum.GET.getType()).toArray(new String[0])).permitAll() // POST .antMatchers(HttpMethod.POST, anonymousUrls.get(RequestMethodEnum.POST.getType()).toArray(new String[0])).permitAll() // PUT .antMatchers(HttpMethod.PUT, anonymousUrls.get(RequestMethodEnum.PUT.getType()).toArray(new String[0])).permitAll() // PATCH .antMatchers(HttpMethod.PATCH, anonymousUrls.get(RequestMethodEnum.PATCH.getType()).toArray(new String[0])).permitAll() // DELETE .antMatchers(HttpMethod.DELETE, anonymousUrls.get(RequestMethodEnum.DELETE.getType()).toArray(new String[0])).permitAll() // 所有类型的接口都放行 .antMatchers(anonymousUrls.get(RequestMethodEnum.ALL.getType()).toArray(new String[0])).permitAll() // 除了上面的接口，其他所有请求都需要认证 .anyRequest().authenticated() .and() // 基于token，所以不需要session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder()); } private Map<String, Set<String>> getAnonymousUrl(Map<RequestMappingInfo, HandlerMethod> handlerMethodMap) { Map<String, Set<String>> anonymousUrls = new HashMap<>(6); Set<String> get = new HashSet<>(); Set<String> post = new HashSet<>(); Set<String> put = new HashSet<>(); Set<String> patch = new HashSet<>(); Set<String> delete = new HashSet<>(); Set<String> all = new HashSet<>(); for (Map.Entry<RequestMappingInfo, HandlerMethod> infoEntry : handlerMethodMap.entrySet()) { HandlerMethod handlerMethod = infoEntry.getValue(); AnonymousAccess anonymousAccess = handlerMethod.getMethodAnnotation(AnonymousAccess.class); if (null != anonymousAccess) { List<RequestMethod> requestMethods = new ArrayList<>(infoEntry.getKey().getMethodsCondition().getMethods()); RequestMethodEnum request = RequestMethodEnum.find(requestMethods.size() == 0 ? RequestMethodEnum.ALL.getType() : requestMethods.get(0).name()); switch (Objects.requireNonNull(request)) { case GET: get.addAll(infoEntry.getKey().getPatternsCondition().getPatterns()); break; case POST: post.addAll(infoEntry.getKey().getPatternsCondition().getPatterns()); break; case PUT: put.addAll(infoEntry.getKey().getPatternsCondition().getPatterns()); break; case PATCH: patch.addAll(infoEntry.getKey().getPatternsCondition().getPatterns()); break; case DELETE: delete.addAll(infoEntry.getKey().getPatternsCondition().getPatterns()); break; default: all.addAll(infoEntry.getKey().getPatternsCondition().getPatterns()); break; } } } anonymousUrls.put(RequestMethodEnum.GET.getType(), get); anonymousUrls.put(RequestMethodEnum.POST.getType(), post); anonymousUrls.put(RequestMethodEnum.PUT.getType(), put); anonymousUrls.put(RequestMethodEnum.PATCH.getType(), patch); anonymousUrls.put(RequestMethodEnum.DELETE.getType(), delete); anonymousUrls.put(RequestMethodEnum.ALL.getType(), all); return anonymousUrls; } }\"]},\"789\":{\"h\":\"RequestMappingHandlerMapping\",\"t\":[\"RequestMappingHandlerMapping是在DispatcherServlet的初始化过程中自动加载的，默认会自动加载所有实现HandlerMapping接口的bean。\",\"在上方代码中，会扫描到所有匹配的接口，放入handlerMethodMap，然后传入getAnonymousUrl()方法进行解析。在该方法内，会遍历传入的map，搜索其中带有@AnonymousAccess的，进一步获取其类型（get/post等），然后将接口放入对应的set中。最终又放入anonymousUrls这个map，然后返回。\",\"返回后，就在调用处配置对应接口的放行规则。\"]},\"790\":{\"h\":\"自定义接口\"},\"791\":{\"h\":\"@AnonymousAccess\",\"t\":[\"这个注解是用来注解其他注解的\",\"@Inherited @Documented @Target({ElementType.METHOD,ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface AnonymousAccess { }\"]},\"792\":{\"h\":\"@AnonymousGetMapping\",\"t\":[\"定义允许匿名访问的get接口，如下所示。就相当于是@RequestMapping(method = RequestMethod.GET)，即@GetMapping。\",\"使用该注解可以定义get类型的访问接口，且其可以被匿名访问。\",\"@AnonymousAccess @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented @RequestMapping(method = RequestMethod.GET) public @interface AnonymousGetMapping { /** * Alias for {@link RequestMapping#name}. */ @AliasFor(annotation = RequestMapping.class) String name() default \\\"\\\"; /** * Alias for {@link RequestMapping#value}. */ @AliasFor(annotation = RequestMapping.class) String[] value() default {}; /** * Alias for {@link RequestMapping#path}. */ @AliasFor(annotation = RequestMapping.class) String[] path() default {}; /** * Alias for {@link RequestMapping#params}. */ @AliasFor(annotation = RequestMapping.class) String[] params() default {}; /** * Alias for {@link RequestMapping#headers}. */ @AliasFor(annotation = RequestMapping.class) String[] headers() default {}; /** * Alias for {@link RequestMapping#consumes}. * * @since 4.3.5 */ @AliasFor(annotation = RequestMapping.class) String[] consumes() default {}; /** * Alias for {@link RequestMapping#produces}. */ @AliasFor(annotation = RequestMapping.class) String[] produces() default {}; }\",\"警告\",\"在Spring Security 5.6.5及更旧版本或Spring Boot 2.6.8及更旧版本，像上面这样使用没有问题。然而，如果你的项目使用Spring Security 5.7.1及更新版本或者Spring Boot 2.7.0及更新版本，IDE会警告你：类WebSecurityConfigurerAdapter已被弃用。\"]},\"793\":{\"h\":\"SpringSecurity\"},\"794\":{\"h\":\"SpringSecurity\"},\"795\":{\"h\":\"SpringCloud相关资料和教程\",\"t\":[\"Java技术栈-Spring Cloud合集\"]},\"796\":{\"h\":\"SpringCloud面试题\"},\"797\":{\"h\":\"CAP理论?\",\"t\":[\"Consistency（一致性）\",\"Availability（可用性）\",\"Partition Tolerance（分区容错性）\",\"关于 CAP 的详细解读：《CAP理论解读》\"]},\"798\":{\"h\":\"Dubbo跟SpringCloud的区别？\",\"t\":[\"Dubbo由于是二进制的传输，占用带宽会更少\",\"SpringCloud是Http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大\",\"Dubbo的开发难度较大，原因是Dubbo的jar包依赖问题很多大型工程无法解决\",\"SpringCloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级\",\"Dubbo的注册中心可以选择Zookeeper，Redis等多种，SpringCloud的注册中心只能用eureka或者自研\"]},\"799\":{\"h\":\"fegin调用service的时候是怎么样做到集成的负载均衡和熔断呢（自定义负载均衡）？\"},\"800\":{\"h\":\"Eureka跟zookeeper的区别？\",\"t\":[\"Eureka： 符合AP原则 为了保证了可用性，Eureka 不会等待集群所有节点都已同步信息完成，它会无时无刻提供服务。\",\"Zookeeper： 符合CP原则 为了保证一致性，在所有节点同步完成之前是阻塞状态的。\"]},\"801\":{\"h\":\"Eureka的服务发现机制有啥缺点？\"},\"802\":{\"h\":\"参考文章\",\"t\":[\"参考 - Spring Cloud 中文索引\"]},\"803\":{\"h\":\"SpringCloud\"},\"804\":{\"h\":\"SpringBoot\"},\"805\":{\"h\":\"MyBatis面试题\"},\"806\":{\"h\":\"什么是Mybatis？\",\"t\":[\"Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，加载驱动、创建连接、创建statement等繁杂的过程，开发者开发时只需要关注如何编写SQL语句，可以严格控制sql执行性能，灵活度高。\",\"作为一个半ORM框架，MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\",\"称Mybatis是半自动ORM映射工具，是因为在查询关联对象或关联集合对象时，需要手动编写sql来完成。不像Hibernate这种全自动ORM映射工具，Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。\",\"通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。\",\"由于MyBatis专注于SQL本身，灵活度高，所以比较适合对性能的要求很高，或者需求变化较多的项目，如互联网项目。\"]},\"807\":{\"h\":\"Mybaits的优缺点\",\"t\":[\"优点：\",\"基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。\",\"与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。\",\"很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。\",\"能够与Spring很好的集成。\",\"提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。\",\"缺点：\",\"SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。\",\"SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。\"]},\"808\":{\"h\":\"Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\",\"t\":[\"第一种是使用<resultMap>标签，逐一定义数据库列名和对象属性名之间的映射关系。\",\"第二种是使用sql列的别名功能，将列的别名书写为对象属性名。\",\"有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。\"]},\"809\":{\"h\":\"使用MyBatis的mapper接口调用时有哪些要求？\",\"t\":[\"Mapper接口里的方法名和mapper.xml中定义的每个sql的id相同\",\"Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同\",\"Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\",\"Mapper.xml文件中的namespace即是mapper接口的类路径\"]},\"810\":{\"h\":\"#{}和${}的区别是什么？\",\"t\":[\"${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。\",\"#{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)。#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。\"]},\"811\":{\"h\":\"Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？\",\"t\":[\"还有很多其他的标签， <resultMap> 、 <parameterMap> 、 <sql> 、 <include> 、 <selectKey> ，加上动态 sql 的 9 个标签， trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中 <sql> 为 sql 片段标签，通过 <include> 标签引入 sql 片段， <selectKey> 为不支持自增的主键生成策略标签。\"]},\"812\":{\"h\":\"MyBatis 动态 sql 是做什么的？都有哪些动态 sql？动态 sql 的执行原理？\",\"t\":[\"MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind 。\",\"其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。\"]},\"813\":{\"h\":\"Mybatis的一级、二级缓存？\",\"t\":[\"一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。\",\"二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/>；\",\"对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。\"]},\"814\":{\"h\":\"模糊查询like语句该怎么写？\",\"t\":[\"在Java代码中添加sql通配符\",\"String wildcardname = “%smi%”; list<name> names = mapper.selectlike(wildcardname);\",\"<select id=”selectlike”> select * from foo where bar like #{value} </select>\",\"在sql语句中拼接通配符，会引起sql注入\",\"String wildcardname = “smi”; list<name> names = mapper.selectlike(wildcardname);\",\" <select id=”selectlike”> select * from foo where bar like \\\"%\\\"${value}\\\"%\\\" </select>\"]},\"815\":{\"h\":\"如何获取自动生成的(主)键值?\",\"t\":[\"insert 方法总是返回一个int值 ，这个值代表的是插入的行数，使用usegeneratedkeys接收。\",\"如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。\",\"<insert id=\\\"insertname\\\" usegeneratedkeys=\\\"true\\\" keyproperty=\\\"id\\\"> insert into names (name) values (#{name}) </insert>\",\"name name = new name(); name.setname(“fred”); int rows = mapper.insertname(name); // 完成后,id已经被设置到对象中 system.out.println(“rows inserted = ” + rows); system.out.println(“generated key value = ” + name.getid());\"]},\"816\":{\"h\":\"DAO接口的工作原理？\",\"t\":[\"最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？\",\"Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。\",\"Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement ，举例： com.mybatis3.mappers. StudentDao.findStudentById ，可以唯一找到 namespace 为 com.mybatis3.mappers. StudentDao 下面 id = findStudentById 的 MappedStatement 。在 MyBatis 中，每一个 <select> 、 <insert> 、 <update> 、 <delete> 标签，都会被解析为一个 MappedStatement 对象。\",\"Dao 接口的工作原理是JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 MappedStatement 所代表的 sql，然后将 sql 执行结果返回。\"]},\"817\":{\"h\":\"MyBatis 是如何进行分页的？分页插件的原理是什么？\",\"t\":[\"MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页\",\"可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能\",\"也可以使用分页插件来完成物理分页。\",\"分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。\",\"举例： select _ from student ，拦截 sql 后重写为： select t._ from （select \\\\* from student）t limit 0，10\",\"参考：mybatis-PageHelper的分页原理\"]},\"818\":{\"h\":\"简述 MyBatis 的插件运行原理，以及如何编写一个插件。\",\"t\":[\"MyBatis 仅可以编写针对 ParameterHandler 、 ResultSetHandler 、 StatementHandler 、 Executor 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法，当然，只会拦截那些你指定需要拦截的方法。\",\"实现 MyBatis 的 Interceptor 接口并复写 intercept() 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。\"]},\"819\":{\"h\":\"在mapper中如何传递多个参数?\",\"t\":[\"第一种：\",\"// DAO层的函数 Public UserselectUser(String name,String area); //对应的xml中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数往后加即可。\",\"<select id=\\\"selectUser\\\"resultMap=\\\"BaseResultMap\\\"> select * fromuser_user_t whereuser_name = #{0} anduser_area=#{1} </select>\",\"第二种：\",\"使用 @param 注解:\",\"public interface usermapper { user selectuser(@param(“username”) string username,@param(“hashedpassword”) string hashedpassword); }\",\"然后,就可以在xml像下面这样使用（推荐封装为一个map,作为单个参数传递给mapper）\",\"<select id=”selectuser” resulttype=”user”> select id, username, hashedpassword from some_table where username = #{username} and hashedpassword = #{hashedpassword} </select>\",\"第三种：\",\"多个参数封装成map\",\"try { //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL //由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数 Map<String, Object> map = new HashMap(); map.put(\\\"start\\\", start); map.put(\\\"end\\\", end); return sqlSession.selectList(\\\"StudentID.pagination\\\", map); } catch(Exception e){ ... finally { MybatisUtil.closeSqlSession(); }\"]},\"820\":{\"h\":\"一对一、一对多的关联查询？\",\"t\":[\"一对一使用<association>，一对多使用<collection>\",\"<resultMap type=\\\"com.lcb.user.Classes\\\" id=\\\"ClassesResultMap2\\\"> <result property=\\\"name\\\" column=\\\"c_name\\\"/> <association property=\\\"teacher\\\" javaType=\\\"com.lcb.user.Teacher\\\"> <id property=\\\"id\\\" column=\\\"t_id\\\"/> <result property=\\\"name\\\" column=\\\"t_name\\\"/> </association> <collection property=\\\"student\\\" ofType=\\\"com.lcb.user.Student\\\"> <id property=\\\"id\\\" column=\\\"s_id\\\"/> <result property=\\\"name\\\" column=\\\"s_name\\\"/> </collection> </resultMap>\"]},\"821\":{\"h\":\"MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？\",\"t\":[\"MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false\",\"它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName() ，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。\"]},\"822\":{\"h\":\"MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？\",\"t\":[\"MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中， <parameterMap> 标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。 <resultMap> 标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个 <select>、<insert>、<update>、<delete> 标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。\"]},\"823\":{\"h\":\"为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？\",\"t\":[\"Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。\"]},\"824\":{\"h\":\"参考\",\"t\":[\"JavaGuide - MyBatis 常见面试题总结\"]},\"825\":{\"h\":\"MyBatis-Plus\"},\"826\":{\"h\":\"简介\",\"t\":[\"MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为 简化开发、提高效率而生。提供了通用的mapper和service，可以在不编写田可SQL语句的情况下，快速的实现对单表的CRUD、批量、逻辑删除、分页等操作。\",\"提供了分页、乐观锁、MyBatisX等插件，提供了代码生成器功能。并支持多数据源。\"]},\"827\":{\"h\":\"特性\",\"t\":[\"无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\",\"损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作\",\"强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求\",\"支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\",\"支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由 配置，完美解决主键问题\",\"支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强 大的 CRUD 操作\",\"支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）\",\"内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用\",\"内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等 同于普通 List 查询\",\"分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、 Postgre、SQLServer 等多种数据库\",\"内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出 慢查询\",\"内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\"]},\"828\":{\"h\":\"框架结构\"},\"829\":{\"h\":\"使用配置\"},\"830\":{\"h\":\"引入\",\"t\":[\"<!--mybatis-plus启动器--> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>3.5.1</version> </dependency>\"]},\"831\":{\"h\":\"配置数据源和日志\",\"t\":[\"spring: datasource.: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&useSSL=false&serverTimezone=GMT%2B8 username: xxxxxx password: xxxxxx mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl // 配置日志，可以查看sql语句 type-aliases-package: com.xx.pojo // 配置类别名\"]},\"832\":{\"h\":\"BaseMapper<T>接口\",\"t\":[\"自定义的mapper接口继承这个接口，即可拥有一些简单的增删改查方法。泛型要记得替换。\",\"package com.baomidou.mybatisplus.core.mapper; public interface BaseMapper<T> extends Mapper<T> { int insert(T entity); int deleteById(Serializable id); int deleteById(T entity); int deleteByMap(@Param(\\\"cm\\\") Map<String, Object> columnMap); int delete(@Param(\\\"ew\\\") Wrapper<T> queryWrapper); int deleteBatchIds(@Param(\\\"coll\\\") Collection<?> idList); int updateById(@Param(\\\"et\\\") T entity); int update(@Param(\\\"et\\\") T entity, @Param(\\\"ew\\\") Wrapper<T> updateWrapper); T selectById(Serializable id); List<T> selectBatchIds(@Param(\\\"coll\\\") Collection<? extends Serializable> idList); List<T> selectByMap(@Param(\\\"cm\\\") Map<String, Object> columnMap); default T selectOne(@Param(\\\"ew\\\") Wrapper<T> queryWrapper) { List<T> ts = this.selectList(queryWrapper); if (CollectionUtils.isNotEmpty(ts)) { if (ts.size() != 1) { throw ExceptionUtils.mpe(\\\"One record is expected, but the query result is multiple records\\\", new Object[0]); } else { return ts.get(0); } } else { return null; } } default boolean exists(Wrapper<T> queryWrapper) { Long count = this.selectCount(queryWrapper); return null != count && count > 0L; } Long selectCount(@Param(\\\"ew\\\") Wrapper<T> queryWrapper); List<T> selectList(@Param(\\\"ew\\\") Wrapper<T> queryWrapper); List<Map<String, Object>> selectMaps(@Param(\\\"ew\\\") Wrapper<T> queryWrapper); List<Object> selectObjs(@Param(\\\"ew\\\") Wrapper<T> queryWrapper); <P extends IPage<T>> P selectPage(P page, @Param(\\\"ew\\\") Wrapper<T> queryWrapper); <P extends IPage<Map<String, Object>>> P selectMapsPage(P page, @Param(\\\"ew\\\") Wrapper<T> queryWrapper); }\"]},\"833\":{\"h\":\"通用Service\",\"t\":[\"通用 Service CRUD 封装IService接口，进一步封装 CRUD。\",\"get 查询单行\",\"remove 删除\",\"list 查询集合\",\"page 分页 前缀命名方式区分\",\"Mapper 层避免混淆\",\"泛型 T 为任意实体对象\",\"建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类IService\",\"MyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑\",\"项目中一般这样实现：\",\"添加接口：\",\"public interface UserService extends IService<User> { }\",\"添加实现。这个类继承mp提供的ServiceImpl，实现我们的接口UserService：\",\"public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService { }\"]},\"834\":{\"h\":\"常用注解\"},\"835\":{\"h\":\"@Table\",\"t\":[\"实体类名和表名不一致时，需要中实体类上加@Table(\\\"表名\\\")注解。\",\"该问题也可以通过全局配置解决。如下方的最后一行。\",\"mybatis-plus: configuration: # 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_\"]},\"836\":{\"h\":\"@TableId\",\"t\":[\"指定表里的主键对应的实体类里的字段。默认是id。如果不是，需要在类里面代表id的字段上方添加此注\",\"解。\",\"value属性：如果表里id列名为uid，而实体类里注解名为id，需要这样添加：@TableId(“uid”)\",\"type属性：指定主键生成策略。可选值如下，在com.baomidou.mybatisplus.annotation.IdType里定义。\",\"AUTO(0), // 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，否则无效 NONE(1), INPUT(2), ASSIGN_ID(3), // 默认。基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 ASSIGN_UUID(4); // 使用UUID\",\"使用示例：\",\"@TableId(value = \\\"uId\\\", type = IdType.AUTO) private Long id;\",\"当然，也可以像下面这样全局配置：\",\"mybatis-plus: configuration: # 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ # 配置MyBatis-Plus的主键策略 id-type: auto\"]},\"837\":{\"h\":\"@TableField\",\"t\":[\"MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致。如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？\",\"情况1：\",\"若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格。例如实体类属性userName，表中字段user_name。此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格，相当于在MyBatis中配置。\",\"情况2：\",\"若实体类中的属性和表中的字段不满足情况1，例如实体类属性name，表中字段username。此时需要在实体类属性上使用@TableField(\\\"username\\\")设置属性所对应的字段名。\"]},\"838\":{\"h\":\"@TableLogic\"},\"839\":{\"h\":\"逻辑删除\",\"t\":[\"物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据\",\"逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库 中仍旧能看到此条数据记录。\",\"使用场景：可以进行数据恢复。不会真正删除数据。\"]},\"840\":{\"h\":\"实现逻辑删除\",\"t\":[\"数据库中创建状态列is_deleted，设置默认值为0。\",\"实体类中添加逻辑删除属性。\",\"@TableLogic private Integer isDeleted;\",\"测试\",\"测试删除功能，真正执行的是修改语句： UPDATE t_user SET is_deleted=1 WHERE id=? AND is_deleted=0。 测试查询功能，被逻辑删除的数据默认不会被查询： SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0\"]},\"841\":{\"h\":\"条件构造器和常用接口\"},\"842\":{\"h\":\"Wrapper介绍\",\"t\":[\"image-20220526104944859\",\"Wrapper ： 条件构造抽象类，最顶端父类 \",\"AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 \",\"QueryWrapper ： 查询条件封装\",\"UpdateWrapper ： Update 条件封装\",\"AbstractLambdaWrapper ： 使用Lambda 语法 \",\"LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper\",\"LambdaUpdateWrapper ： Lambda 更新封装Wrapper\"]},\"843\":{\"h\":\"QueryWrapper\",\"t\":[\"可以组装查询、排序、删除条件，还可以设置优先级、子查询。\"]},\"844\":{\"h\":\"组装查询条件\",\"t\":[\"QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.like(\\\"username\\\", \\\"a\\\") .between(\\\"age\\\", 20, 30) .isNotNull(\\\"email\\\"); List<User> list = userMapper.selectList(queryWrapper);\"]},\"845\":{\"h\":\"组装排序条件\",\"t\":[\"QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper .orderByDesc(\\\"age\\\") .orderByAsc(\\\"id\\\"); List<User> users = userMapper.selectList(queryWrapper);\"]},\"846\":{\"h\":\"组装删除条件\",\"t\":[\"QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.isNull(\\\"email\\\"); //条件构造器也可以构建删除语句的条件 int result = userMapper.delete(queryWrapper);\"]},\"847\":{\"h\":\"组装修改条件\",\"t\":[\"queryWrapper .like(\\\"username\\\", \\\"a\\\") .gt(\\\"age\\\", 20) .or() .isNull(\\\"email\\\"); User user = new User(); user.setAge(18); user.setEmail(\\\"user@atguigu.com\\\"); // 参数1，用于设置填充的内容。参数2，用于设置更新条件 int result = userMapper.update(user, queryWrapper);\",\"等于执行以下SQL：\",\"UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND age > ? OR email IS NULL)\"]},\"848\":{\"h\":\"修改更新的优先级\",\"t\":[\"如果更新条件为：将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改。即sql为：\",\"UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND (age > ? OR email IS NULL))\",\"此时可以使用lambda表达式，它里面的逻辑优先运算。\",\"queryWrapper .like(\\\"username\\\", \\\"a\\\") .and(i -> i.gt(\\\"age\\\", 20).or().isNull(\\\"email\\\")); User user = new User(); user.setAge(18); user.setEmail(\\\"user@atguigu.com\\\"); int result = userMapper.update(user, queryWrapper);\"]},\"849\":{\"h\":\"组装Select子句\",\"t\":[\"需求：查询用户信息的username和age字段：SELECT username,age FROM t_user\",\"QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.select(\\\"username\\\", \\\"age\\\"); //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null List<Map<String, Object>> maps = userMapper.selectMaps(queryWrapper);\"]},\"850\":{\"h\":\"子查询\",\"t\":[\"需求：查询id小于等于3的用户信息。\",\"SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (id IN (select id from t_user where id <= 3))\",\"QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.inSql(\\\"id\\\", \\\"select id from t_user where id <= 3\\\"); List<User> list = userMapper.selectList(queryWrapper);\"]},\"851\":{\"h\":\"UpdateWrapper\",\"t\":[\"和QueryWrapper相比，更新时可以设置条件和字段。\",\"UpdateWrapper<User> updateWrapper = new UpdateWrapper<>(); //lambda表达式内的逻辑优先运算 updateWrapper .set(\\\"age\\\", 18) .set(\\\"email\\\", \\\"user@atguigu.com\\\") .like(\\\"username\\\", \\\"a\\\") .and(i -> i.gt(\\\"age\\\", 20).or().isNull(\\\"email\\\")); int result = userMapper.update(null, updateWrapper);\",\"UPDATE user SET name=?,email=? WHERE is_deleted=0 AND (name LIKE ? AND (age > ? OR email IS NULL))\"]},\"852\":{\"h\":\"condition\",\"t\":[\"在mybatis-plus中如何判断参数是否为空呢。我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写。\",\"queryWrapper.like(StringUtils.isNotBlank(name), \\\"name\\\", name);\",\"如上方代码，如果name为null或空字符串，则queryWrapper不会拼接此条件。否则拼接。\",\"更多示例：\",\"queryWrapper .like(StringUtils.isNotBlank(username), \\\"username\\\", \\\"a\\\") .ge(ageBegin != null, \\\"age\\\", ageBegin) .le(ageEnd != null, \\\"age\\\", ageEnd); //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age >=? AND age <= ?) List<User> users = userMapper.selectList(queryWrapper);\"]},\"853\":{\"h\":\"LambdaQueryWrapper\",\"t\":[\"如下方代码所示，可以在LambdaQueryWrapper里使用类似User::getAge的语法。\",\"这样，如果User类里的age字段改名，这里就会触发错误提示，可以在开发阶段识别风险。\",\"@Test public void test09() { //定义查询条件，有可能为null（用户未输入） String username = \\\"a\\\"; Integer ageBegin = 10; Integer ageEnd = 24; LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>(); //避免使用字符串表示字段，防止运行时错误 queryWrapper .like(StringUtils.isNotBlank(username), User::getName, username) .ge(ageBegin != null, User::getAge, ageBegin) .le(ageEnd != null, User::getAge, ageEnd); List<User> users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); }\"]},\"854\":{\"h\":\"LambdaUpdateWrapper\",\"t\":[\"@Test public void test10() { //组装set子句 LambdaUpdateWrapper<User> updateWrapper = new LambdaUpdateWrapper<>(); updateWrapper .set(User::getAge, 18) .set(User::getEmail, \\\"user@atguigu.com\\\") .like(User::getName, \\\"a\\\") .and(i -> i.lt(User::getAge, 24).or().isNull(User::getEmail)); //lambda表达式内的逻辑优先运算 User user = new User(); int result = userMapper.update(user, updateWrapper); System.out.println(\\\"受影响的行数：\\\" + result); }\",\"那如果QueryWrapper也想用lambda风格的写法，如何实现呢？可以这样实现：\",\"QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.lambda().eq(User::getUname, \\\"hpt\\\");\"]},\"855\":{\"h\":\"插件\"},\"856\":{\"h\":\"分页插件\",\"t\":[\"MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能\"]},\"857\":{\"h\":\"添加配置类\",\"t\":[\"@Configuration @MapperScan(\\\"com.atguigu.mybatisplus.mapper\\\") //可以将主类中的注解移到此处 public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } }\"]},\"858\":{\"h\":\"测试\",\"t\":[\"@Test public void selectPage() { Page<User> page = new Page<>(1, 3); QueryWrapper<User> queryWrapper = new QueryWrapper<>(); queryWrapper.like(\\\"name\\\", \\\"a\\\"); userMapper.selectPage(page, queryWrapper); page.getRecords().forEach(System.out::println); System.out.println(\\\"page.getPages() = \\\" + page.getPages()); System.out.println(\\\"page.getTotal() = \\\" + page.getTotal()); System.out.println(\\\"page.hasNext() = \\\" + page.hasNext()); System.out.println(\\\"page.hasPrevious() = \\\" + page.hasPrevious()); }\"]},\"859\":{\"h\":\"xml自定义分页\",\"t\":[\"如果想在自己写的sql中使用分页插件，如何配置？\",\"先定义接口方法，然后正常调用即可。\",\"注意：返回值必须是Page对象，Page对象也必须是方法的第一个参数。\",\"/** * 根据年龄分页查询用户信息 * @param page mp提供的分页对象，必须是第一个参数。 * @param age * @return */ Page<User> selectPageVo(@Param(\\\"page\\\") Page<User> page, @Param(\\\"age\\\") Integer age);\"]},\"860\":{\"h\":\"乐观锁\",\"t\":[\"使用版本号机制实现乐观锁。数据库中添加version字段，取出记录时，获取当前version：\",\"SELECT id, name, price, version FROM product WHERE id=1\",\"更新时，version + 1，如果where语句中的version版本不对，则更新失败：\",\"UPDATE product SET price=price+50, version=version + 1 WHERE id=1 AND version=1\",\"MyBatis-Plus实现乐观锁\",\"在代表版本的字段上加@Version注解。\",\"@Data public class Product { private Long id; private String name; private Integer price; @Version private Integer version; }\",\"配置类中添加乐观锁插件\",\"@Configuration //@MapperScan(\\\"com.atguigu.mybatisplus.mapper\\\") public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); // 添加乐观锁插件 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; } }\"]},\"861\":{\"h\":\"动态表名SQL解析器\",\"t\":[\"当数据量特别大的时候，我们通常会采用分库分表。这时，可能就会有多张表，其表结构相同，但表名不同。例如order_1，order_2，order_3，查询时，我们可能需要动态设置要查的表名。\",\"mp提供了动态表名SQL解析器。\"]},\"862\":{\"h\":\"代码生成器\"},\"863\":{\"h\":\"引入依赖\",\"t\":[\"<dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-generator</artifactId> <version>3.5.1</version> </dependency> <dependency> <groupId>org.freemarker</groupId> <artifactId>freemarker</artifactId> <version>2.3.31</version> </dependency>\"]},\"864\":{\"h\":\"快速生成\",\"t\":[\"具体可参考官网\",\"public class FastAutoGeneratorTest { public static void main(String[] args) { FastAutoGenerator.create(\\\"jdbc:mysql://127.0.0.1:3306/mybatis_plus?characterEncoding=utf-8&userSSL=false\\\", \\\"root\\\", \\\"123456\\\") .globalConfig(builder -> { builder.author(\\\"atguigu\\\") // 设置作者 .fileOverride() // 覆盖已生成文件 .outputDir(\\\"D://mybatis_plus\\\"); // 指定输出目录 }) .packageConfig(builder -> { builder.parent(\\\"com.atguigu\\\") // 设置父包名 .moduleName(\\\"mybatisplus\\\") // 设置父包模块名 // 设置mapperXml生成路径 .pathInfo(Collections.singletonMap(OutputFile.mapperXml, \\\"D://mybatis_plus\\\")); }).strategyConfig(builder -> { builder.addInclude(\\\"t_user\\\") // 设置需要生成的表名 .addTablePrefix(\\\"t_\\\", \\\"c_\\\"); // 设置过滤表前缀 }).templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); } }\"]},\"865\":{\"h\":\"多数据源\",\"t\":[\"官网的说明\"]},\"866\":{\"h\":\"配置\",\"t\":[\"spring: # 配置数据源信息 datasource: dynamic: # 设置默认的数据源或者数据源组,默认值即为master primary: master # 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: master: url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 slave_1: url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456\",\"在service类，或者类里的方法上加上@DS(\\\"dsName\\\")即可指定该类或方法使用的数据源。\",\"注解\",\"结果\",\"没有@DS\",\"默认数据源\",\"@DS(\\\"dsName\\\")\",\"dsName可以为组名也可以为具体某个库的名称\"]},\"867\":{\"h\":\"MyBatisX插件\",\"t\":[\"官网描述\",\"MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\",\"可以在xml和mapper接口之间跳转\",\"可以根据jpa风格的方法名生成对应的sql语句\"]},\"868\":{\"h\":\"MyBatis\"},\"869\":{\"h\":\"MyBatis\"},\"870\":{\"h\":\"Dubbo基础\",\"t\":[\"👾\",\"本文大部分内容收集自网络。侵删。\"]},\"871\":{\"h\":\"RPC\"},\"872\":{\"h\":\"为什么要有RPC？\",\"t\":[\"http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。\",\"第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。\",\"socket只是一个简单的网络通信方式，只是创建通信双方的通信通道，而要实现rpc的功能，还需要对其进行封装，以实现更多的功能。\",\"RPC一般配合netty框架、spring自定义注解来编写轻量级框架，其实netty内部是封装了socket的，较新的jdk的IO一般是NIO，即非阻塞IO，在高并发网站中，RPC的优势会很明显。\"]},\"873\":{\"h\":\"什么是RPC？\",\"t\":[\"RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。\",\"简单的说，RPC就是从一台机器(客户端)上通过参数传递的方式调用另一台机器(服务器)上的一个函数或方法(可以统称为服务)并得到返回的结果。\"]},\"874\":{\"h\":\"PRC架构组件\",\"t\":[\"一个基本的RPC架构里面应该至少包含以下4个组件：\",\"1、客户端（Client）:服务调用方（服务消费者）\",\"2、客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端\",\"3、服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理\",\"4、服务端（Server）:服务的真正提供者\",\"img\",\"具体调用过程：\",\"1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；\",\"2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；\",\"3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；\",\"4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；\",\"5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；\",\"6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；\",\"7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；\",\"8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；\",\"9、服务消费方得到最终结果；\",\"而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让 用户感觉上像调用本地服务一样的调用远程服务。\"]},\"875\":{\"h\":\"RPC和SOA、SOAP、REST的区别\",\"t\":[\"1、REST\",\"可以看着是HTTP协议的一种直接应用，默认基于JSON作为传输格式,使用简单,学习成本低效率高,但是安全性较低。\",\"2、SOAP\",\"SOAP是一种数据交换协议规范,是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。\",\"它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。\",\"3、SOA\",\"面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。\",\"SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。\",\"4、REST 和 SOAP、RPC 有何区别呢?\",\"没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。\"]},\"876\":{\"h\":\"RPC框架需要解决的问题？\",\"t\":[\"1、如何确定客户端和服务端之间的通信协议？\",\"2、如何更高效地进行网络通信？\",\"3、服务端提供的服务如何暴露给客户端？\",\"4、客户端如何发现这些暴露的服务？\",\"5、如何更高效地对请求对象和响应结果进行序列化和反序列化操作？\"]},\"877\":{\"h\":\"RPC的实现基础？\",\"t\":[\"1、需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架；\",\"2、需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架；\",\"3、可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等；\",\"4、如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能；\"]},\"878\":{\"h\":\"RPC使用了哪些关键技术？\",\"t\":[\"1、动态代理\",\"生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。\",\"2、序列化和反序列化\",\"在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。\",\"序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。\",\"反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。\",\"3、NIO通信\",\"出于并发性能的考虑，传统的阻塞式IO显然不太合适，因此我们需要异步的IO，即NIO。Java提供了NIO的解决方案，Java 7 也提供了更优秀的NIO.2支持。可以选择Netty或者MINA来解决NIO数据传输的问题。\",\"4、服务注册中心\",\"可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。\"]},\"879\":{\"h\":\"主流RPC框架有哪些？\",\"t\":[\"1、RMI\",\"利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化。\",\"2、Hessian\",\"是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。\",\"3、protobuf-rpc-pro\",\"是一个Java类库，提供了基于 Google 的 Protocol Buffers 协议的远程方法调用的框架。基于Netty 底层的 NIO 技术。支持 TCP 重用/ keep-alive、SSL加密、RPC 调用取消操作、嵌入式日志等功能。\",\"4、Thrift\",\"是一种可伸缩的跨语言服务的软件框架。它拥有功能强大的代码生成引擎，无缝地支持C + +，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述文件，描述数据类型和服务接口。\",\"依据该文件，编译器方便地生成RPC客户端和服务器通信代码。\",\"最初由facebook开发用做系统内个语言之间的RPC通信，2007年由facebook贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务，跨越语言的C/S RPC调用。底层通讯基于SOCKET。\",\"5、Avro\",\"出自Hadoop之父Doug Cutting, 在Thrift已经相当流行的情况下推出Avro的目标不仅是提供一套类似Thrift的通讯中间件,更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。支持HTTP，TCP两种协议。\",\"6、Dubbo\",\"Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。\"]},\"880\":{\"h\":\"Dubbo\"},\"881\":{\"h\":\"为什么要用Dubbo？\",\"t\":[\"随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架就出现了，Dubbo 也就这样产生了。\"]},\"882\":{\"h\":\"Dubbo架构\",\"t\":[\"Dubbo官网\",\"注意\",\"需要会画上面这个图！\",\"Container 服务运行的容器\",\"用来运行服务的。\",\"Provider 服务提供者\",\"service，实际执行业务逻辑的服务层。\",\"Consumer 服务消费者\",\"用来调用service的，不关注service具体实现的应用层。\",\"Registry 注册中心\",\"存储Provider，consumer信息的中介。\",\"Monitor\",\"Dubbo负责收集服务调用信息的监控中心。\",\"大致流程：\",\"首先服务提供者 Provider 启动然后向注册中心注册自己所能提供的服务。\",\"服务消费者 Consumer 启动向注册中心订阅自己所需的服务。然后注册中心将提供者元信息通知给 Consumer， 之后 Consumer 因为已经从注册中心获取提供者的地址，因此可以通过负载均衡选择一个 Provider 直接调用 。\",\"之后服务提供方元数据变更的话注册中心会把变更推送给服务消费者。\",\"服务提供者和消费者都会在内存中记录着调用的次数和时间，然后定时的发送统计数据到监控中心。\"]},\"883\":{\"h\":\"Dubbo分层架构\",\"t\":[\"Dubbo大的三层分别为 Business（业务层）、RPC 层、Remoting层，也可以分为 API 层和 SPI 层。\",\"分为大三层其实就是和我们知道的网络分层一样的意思，只有层次分明，职责边界清晰才能更好的扩展。\",\"而分 API 层和 SPI 层这是 Dubbo 成功的一点，采用微内核设计+SPI扩展，使得有特殊需求的接入方可以自定义扩展，做定制的二次开发。\",\"每一层的作用如下：\",\"Service，业务层，就是咱们开发的业务逻辑层。\",\"Config，配置层，主要围绕 ServiceConfig 和 ReferenceConfig，初始化配置信息。\",\"Proxy，代理层，服务提供者和消费者都会生成一个代理类，使得服务接口透明化，代理层做远程调用和返回结果。\",\"Register，注册层，封装了服务注册和发现。\",\"Cluster，路由和集群容错层，负责选取具体调用的节点，处理特殊的调用要求和负责远程调用失败的容错措施。\",\"Monitor，监控层，负责监控统计调用时间和次数。\",\"Portocol，远程调用层，主要是封装 RPC 调用，主要负责管理 Invoker，Invoker代表一个抽象封装了的执行体。\",\"Exchange，信息交换层，用来封装请求响应模型，同步转异步。\",\"Transport，网络传输层，抽象了网络传输的统一接口，这样用户想用 Netty 就用 Netty，想用 Mina 就用 Mina（默认也推荐使用netty作为通信框架，还有mina）\",\"Serialize，序列化层，将数据序列化成二进制流，当然也做反序列化。\"]},\"884\":{\"h\":\"Dubbo的使用场景有哪些？\",\"t\":[\"透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。\",\"软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。\",\"服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\"]},\"885\":{\"h\":\"Dubbo核心功能有哪些？\",\"t\":[\"Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。\",\"Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。\",\"Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。\"]},\"886\":{\"h\":\"Dubbo和Spring Cloud有什么关系？\",\"t\":[\"Dubbo是SOA时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而Spring Cloud诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了Spring、Spring Boot的优势之上，两个框架在开始目标就不一致，Dubbo定位服务治理，Spring Cloud是打造一个生态。\"]},\"887\":{\"h\":\"Dubbo和Spring Cloud有什么哪些区别？\",\"t\":[\"Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成 RPC通信。\",\"Spring Cloud是基于Http协议Rest接口调用远程过程的通信，相对来说Http请求会有更大的报文，占的带宽也会更多。但是 REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。\"]},\"888\":{\"h\":\"Dubbo支持哪些协议，它们的优缺点有哪些？\",\"t\":[\"Dubbo：单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步 Hessian序列化。Dubbo推荐使用dubbo协议。\",\"RMI： 采用JDK标准的RMI协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。 多个短连接 TCP协议传输，同步传输，适用常规的远程服务调用和RMI互操作。在依赖低版本的Common-Collections 包，Java 序列化存在安全漏洞。\",\"WebService：基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。\",\"HTTP： 基于 Http 表单提交的远程调用协议，使用Spring的HttpInvoke 实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用。\",\"Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。\",\"Memcache：基于Memcache实现的RPC协议。\",\"Redis：基于Redis实现的RPC协议。\"]},\"889\":{\"h\":\"服务暴露的流程？\",\"t\":[\"参考这里\",\"服务的暴露起始于 Spring IOC 容器刷新完毕之后，会根据配置参数组装成 URL， 然后根据 URL 的参数来进行本地或者远程调用。\",\"会通过 proxyFactory.getInvoker，利用 javassist 来进行动态代理，封装真的实现类，然后再通过 URL 参数选择对应的协议来进行 protocol.export，默认是 Dubbo 协议。\",\"在第一次暴露的时候会调用 createServer 来创建 Server，默认是 NettyServer。\",\"然后将 export 得到的 exporter 存入一个 Map 中，供之后的远程调用查找，然后会向注册中心注册提供者的信息。\",\"基本上就是这么个流程，说了这些差不多了，太细的谁都记住不。\",\"img\"]},\"890\":{\"h\":\"服务引入的流程？\",\"t\":[\"服务的引入时机有两种，第一种是饿汉式，第二种是懒汉式。\",\"饿汉式就是加载完毕就会引入，懒汉式是只有当这个服务被注入到其他类中时启动引入流程，默认是懒汉式。\",\"会先根据配置参数组装成 URL ，一般而言我们都会配置的注册中心，所以会构建 RegistryDirectory 向注册中心注册消费者的信息，并且订阅提供者、配置、路由等节点。\",\"得知提供者的信息之后会进入 Dubbo 协议的引入，会创建 Invoker ，期间会包含 NettyClient，来进行远程通信，最后通过 Cluster 来包装 Invoker，默认是 FailoverCluster，最终返回代理类。\",\"说这么多差不多了，关键的点都提到了。\",\"切忌不要太过细，不要把你知道的都说了，这样会抓不住重点，比如上面的流程你要插入，引入的三种方式：本地引入、直连远程引入、通过注册中心引入。\",\"然后再分别说本地引入怎样的，就会很乱，所以面试的时候是需要删减的，要直击重点。\"]},\"891\":{\"h\":\"服务调用的流程？\",\"t\":[\"调用某个接口的方法会调用之前生成的代理类，然后会从 cluster 中经过路由的过滤、负载均衡机制选择一个 invoker 发起远程调用，此时会记录此请求和请求的 ID 等待服务端的响应。\",\"服务端接受请求之后会通过参数找到之前暴露存储的 map，得到相应的 exporter ，然后最终调用真正的实现类，再组装好结果返回，这个响应会带上之前请求的 ID。\",\"消费者收到这个响应之后会通过 ID 去找之前记录的请求，然后找到请求之后将响应塞到对应的 Future 中，唤醒等待的线程，最后消费者得到响应，一个流程完毕。\",\"关键的就是 cluster、路由、负载均衡，然后 Dubbo 默认是异步的，所以请求和响应是如何对应上的。\"]},\"892\":{\"h\":\"知道什么是 SPI 嘛？\",\"t\":[\"从上面的回答中，不论是从 Dubbo 协议，还是 cluster ，什么 export 方法等等无处不是 SPI 的影子，所以如果是问 Dubbo 方面的问题，问 SPI 是毋庸置疑的，因为源码里 SPI 无处不在，而且 SPI 也是 Dubbo 可扩展性的基石。\",\"所以这个题目没什么套路，直接答就行。\",\"SPI 是 Service Provider Interface，主要用于框架中，框架定义好接口，不同的使用者有不同的需求，因此需要有不同的实现，而 SPI 就通过定义一个特定的位置，Java SPI 约定在 Classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，然后文件里面记录的是此 jar 包提供的具体实现类的全限定名。\",\"所以就可以通过接口找到对应的文件，获取具体的实现类然后加载即可，做到了灵活的替换具体的实现类。\"]},\"893\":{\"h\":\"为什么 Dubbo 不用 JDK 的 SPI，而是要自己实现?\",\"t\":[\"问这个问题就是看你有没有深入的了解，或者自己思考过，不是死板的看源码，或者看一些知识点。\",\"很多点是要思考的，不是书上说什么就是什么，你要知道这样做的理由，有什么好处和坏处，这很容易看出一个人是死记硬背还是有自己的思考。\",\"答：因为 Java SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类全部实例化，假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了资源的浪费。\",\"因此 Dubbo 就自己实现了一个 SPI，给每个实现类配了个名字，通过名字去文件里面找到对应的实现类全限定名然后加载实例化，按需加载。\"]},\"894\":{\"h\":\"Dubbo 为什么默认用 Javassist\",\"t\":[\"上面你回答 Dubbo 用 Javassist 动态代理，所以很可能会问你为什么要用这个代理，可能还会引申出 JDK 的动态代理、ASM、CGLIB。\",\"很简单，就是快，且字节码生成方便。\",\"ASM 比 Javassist 更快，但是没有快一个数量级，而Javassist 只需用字符串拼接就可以生成字节码，而 ASM 需要手工生成，成本较高，比较麻烦。\"]},\"895\":{\"h\":\"🔴Dubbo 异步转同步如何实现的\"},\"896\":{\"h\":\"服务调用是阻塞的吗？\",\"t\":[\"默认是阻塞的，可以异步调用，没有返回值的可以这么做。 Dubbo是基于NIO的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个Future对象。\"]},\"897\":{\"h\":\"Dubbo有哪些注册中心？\",\"t\":[\"Multicast注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。\",\"Zookeeper注册中心（推荐使用）：基于分布式协调系统Zookeeper 实现，采用Zookeeper的watch机制实现数据变更。\",\"Redis注册中心：基于Redis实现，采用key/map存储，key存储服务名和类型，map中key存储服务url，value服务过期时间。基于Redis的发布/订阅模式通知数据变更。\",\"Simple注册中心。\"]},\"898\":{\"h\":\"默认使用什么序列化框架，你知道的还有哪些？\",\"t\":[\"推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。\"]},\"899\":{\"h\":\"服务提供者能实现失效踢出是什么原理？\",\"t\":[\"服务失效踢出基于zookeeper 的临时节点原理。\"]},\"900\":{\"h\":\"服务上线怎么不影响旧版本？\",\"t\":[\"采用多版本开发。多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。\"]},\"901\":{\"h\":\"Dubbo服务降级怎么做？\",\"t\":[\"方法1：在dubbo:reference 中设置 mock=“return null”。\",\"方法2：在dubbo:reference 中设置 mock=“true”，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在Mock类里实现自己的降级逻辑。\"]},\"902\":{\"h\":\"Dubbo Monitor实现原理？\",\"t\":[\"Consumer端在发起调用之前会先走filter链；provider端在接收到请求时也是先走filter链，然后才进行真正的业务逻辑处理。\",\"默认情况下，在consumer和provider的filter链中都会有Monitorfilter。\",\"1、MonitorFilter向DubboMonitor 发送数据\",\"2、DubboMonitor将数据进行聚合后（默认聚合1min中的统计数据）暂存到ConcurrentMap<Statistics, AtomicReference> statisticsMap，然后使用一个含有3个线程（线程名字：DubboMonitorSendTimer）的线程池每隔1min钟，调用SimpleMonitorService遍历发送statisticsMap 中的统计数据，每发送完毕一个，就重置当前的Statistics的AtomicReference\",\"3、SimpleMonitorService将这些聚合数据塞入BlockingQueue queue中（队列大写为100000）\",\"4、SimpleMonitorService使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将queue中的数据写入文件（该线程以死循环的形式来写）\",\"5、SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔5min钟，将文件中的统计数据画成图表\"]},\"903\":{\"h\":\"Dubbo用到哪些设计模式？\",\"t\":[\"Dubbo框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。\"]},\"904\":{\"h\":\"工厂模式\",\"t\":[\"Provider在export服务时，会调用ServiceConfig的export方法。ServiceConfig中有个字段：\",\"private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\",\"Dubbo里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了JDKSPI的机制。这么实现的优点是可扩展性强，想要扩展实现，只需要在classpath下增加个文件就可以了，代码零侵入。另外，像上面的Adaptive实现，可以做到调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码调试比较麻烦，需要分析出实际调用的实现类。\"]},\"905\":{\"h\":\"装饰器模式\",\"t\":[\"Dubbo在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在ProtocolFilterWrapper 的buildInvokerChain完成的，具体是将注解中含有group=provider的Filter实现，按照order排序，最后的调用顺序是：\",\"EchoFilter -> ClassLoaderFilter -> GenericFilter -> ContextFilter -> ExecuteLimitFilter -> TraceFilter -> TimeoutFilter -> MonitorFilter -> ExceptionFilter\",\"更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter则只是在主功能上添加了功能，更改当前线程的ClassLoader，这是典型的装饰器模式。\"]},\"906\":{\"h\":\"观察者模式\",\"t\":[\"Dubbo的Provider启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个listener。注册中心会每5秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个notify消息，provider接受到notify消息后，即运行NotifyListener的notify方法，执行监听器方法。\"]},\"907\":{\"h\":\"动态代理模式\",\"t\":[\"Dubbo扩展JDK SPI的类ExtensionLoader的Adaptive实现是典型的动态代理实现。Dubbo需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是ExtensionLoader的createAdaptiveExtensionClassCode方法。代理类的主要逻辑是，获取URL参数中指定参数的值作为获取实现类的key。\"]},\"908\":{\"h\":\"Dubbo配置文件是如何加载到Spring中的？\",\"t\":[\"Spring容器在启动的时候，会读取到Spring默认的一些schema以及Dubbo自定义的schema，每个schema都会对应一个自己的NamespaceHandler，NamespaceHandler里面通过BeanDefinitionParser来解析配置信息并转化为需要加载的 bean 对象。\"]},\"909\":{\"h\":\"Dubbo SPI和Java SPI区别？\",\"t\":[\"JDK SPI\",\"JDK标准的SPI会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。 所以只希望加载某个的实现，就不现实了。\",\"DUBBO SPI\",\"对 Dubbo进行扩展，不需要改动Dubbo的源码\",\"延迟加载，可以一次只加载自己想要加载的扩展实现。\",\"增加了对扩展点IOC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。\",\"Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean。\"]},\"910\":{\"h\":\"Dubbo支持分布式事务吗？\",\"t\":[\"目前暂时不支持，可与通过tcc-transaction框架实现\",\"介绍：tcc-transaction 是开源的TCC补偿性分布式事务框架\",\"Git 地址：https://github.com/changmingxie/tcc-transaction\",\"TCC-Transaction 通过Dubbo隐式传参的功能，避免自己对业务代码的入侵。\",\"参考：dubbo分布式事务\"]},\"911\":{\"h\":\"Dubbo可以对结果进行缓存吗？\",\"t\":[\"为了提高数据访问的速度。Dubbo提供了声明式缓存，以减少用户加缓存的工作量\",\"<dubbo:reference cache=\\\"true\\\" />\",\"其实比普通的配置文件就多了一个标签 cache=“true”\"]},\"912\":{\"h\":\"Dubbo telnet命令能做什么？\",\"t\":[\"dubbo服务发布之后，我们可以利用telnet命令进行调试、管理。Dubbo2.0.5以上版本服务提供端口支持telnet命令连接服务\",\"telnet localhost20880//键入回车进入Dubbo命令模式。\",\"查看服务列表：\",\"img\"]},\"913\":{\"h\":\"Dubbo如何优雅停机？\",\"t\":[\"Dubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果使用kill -9 PID等强制关闭指令，是不会执行优雅停机的，只有通过kill PID 时，才会执行。\"]},\"914\":{\"h\":\"Dubbo和Dubbox之间的区别？\",\"t\":[\"Dubbox是继Dubbo停止维护后，当当网基于Dubbo做的一个扩展项目，如加了服务可Restful调用，更新了开源组件等。\"]},\"915\":{\"h\":\"Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？\",\"t\":[\"可以通讯。启动Dubbo 时，消费者会从Zookeeper拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。\"]},\"916\":{\"h\":\"Dubbo集群提供了哪些负载均衡策略？\",\"t\":[\"Random LoadBalance（默认）: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。\",\"RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。\",\"LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。\",\"ConstantHash LoadBalance: 一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。\"]},\"917\":{\"h\":\"Dubbo的集群容错方案有哪些？\",\"t\":[\"Failover Cluster（默认）：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。\",\"Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\",\"Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\",\"Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\",\"Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=″2″ 来设置最大并行数。\",\"Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。\"]},\"918\":{\"h\":\"Dubbo超时设置有哪些方式？\",\"t\":[\"Dubbo超时设置有两种方式：\",\"服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。\",\"服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。\",\"因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。\"]},\"919\":{\"h\":\"如果让你设计一个 RPC 框架，如何设计？\",\"t\":[\"面试官都很喜欢问这类问题，来考验候选人的设计能力，和平日有无全方面的了解过一个框架。\",\"如果你平时没有思考，没有往这方面想过答出来的东西就会没有条理性，会显得杂乱无章，不过你也不用慌张，不用想的很全面，答的很细致，没有必要，面试官要的是那些关键的重点。\",\"你可以从底层向上开始说起。\",\"首先需要实现高性能的网络传输，可以采用 Netty 来实现，不用自己重复造轮子，然后需要自定义协议，毕竟远程交互都需要遵循一定的协议，然后还需要定义好序列化协议，网络的传输毕竟都是二进制流传输的。\",\"然后可以搞一套描述服务的语言，即 IDL（Interface description language），让所有的服务都用 IDL 定义，再由框架转换为特定编程语言的接口，这样就能跨语言了。\",\"此时最近基本的功能已经有了，但是只是最基础的，工业级的话首先得易用，所以框架需要把上述的细节对使用者进行屏蔽，让他们感觉不到本地调用和远程调用的区别，所以需要代理实现。\",\"然后还需要实现集群功能，因此的要服务发现、注册等功能，所以需要注册中心，当然细节还是需要屏蔽的。\",\"最后还需要一个完善的监控机制，埋点上报调用情况等等，便于运维。\",\"这样一个 RPC 框架的雏形就差不多了。\"]},\"920\":{\"h\":\"Dubbo使用过程中都遇到了些什么问题？\",\"t\":[\"在注册中心找不到对应的服务。检查service实现类是否添加了@service注解\",\"无法连接到注册中心，检查配置文件中的对应的注册中心IP是否正确。\"]},\"921\":{\"h\":\"参考\",\"t\":[\"Dubbo笔记\",\"Dubbo源代码分析-官网\",\"最新Dubbo面试题，附带详细答案（持续更新）\"]},\"922\":{\"h\":\"Dubbo\"},\"923\":{\"h\":\"Dubbo\"},\"924\":{\"h\":\"300-最大上升子序列\"},\"925\":{\"h\":\"📋 代码1 - 动态规划\",\"t\":[\"public class Solution { public int lengthOfLIS(int[] nums) { // 判断入参。如果是以下情况则直接返回0。 if (nums == null || nums.length == 0) return 0; int max = 1; int[] dp = new int[nums.length]; // 初始化dp数组中的元素，全部置为1。因为子序列长度至少为1（特殊情况第1行已经判断过） Arrays.fill(dp, 1); for (int i = 1; i < dp.length; i++) { for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) { // 如果i处元素大于j处元素，则给dp[i]赋值。 dp[i] = Math.max(dp[i], dp[j] + 1); } } max = Math.max(dp[i], max); // 内部for执行一圈下来，dp[i]的值和在 i处的max的值都确定了。 } //外部for执行完毕后，dp数组的值都设置完了，最终的max也得到了。返回max即可。 return max; } }\"]},\"926\":{\"h\":\"💡 思路1 - 动态规划\",\"t\":[\"动态规划的重点，就是找到状态转移方程。本题也不例外。 定义 dp[i] 为前 i 个元素中的最长上升子序列的长度（包含 nums[i] ）。那么最大值就是 max( dp[i] )，即dp数组中的最大值。 从小到大计算dp[i]，在计算dp[i]前，i 之前的值已经得到。则状态转移方程为： dp[i] = max(dp[j]) + 1 其中，j < i，且必须满足 nums[i] > nums[j]。对每个 i ，遍历完0~i-1，如果存在这样的值（j < i，且 nums[i] > nums[j]），则dp[i] 就是dp[j] + 1，否则，dp[i]为1。 为了不再最后遍历dp数组来获取最大值，每确定一个dp[i]就更新一次max。循环结束后，直接返回max即可。\"]},\"927\":{\"h\":\"💡 思路2 - 二分查找\",\"t\":[\"待补充。\"]},\"928\":{\"h\":\"674-最长连续递增序列\"},\"929\":{\"h\":\"💬 描述\",\"t\":[\"给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1:\",\"输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。\",\"示例 2:\",\"输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。\",\"注意：数组长度不会超过10000。 \"]},\"930\":{\"h\":\"💡 思路\",\"t\":[\"遍历数组。ans为最终准备返回的长度值，curLen为当前下标对应的长度。 每次遍历中，如果下一个数比前面的数大，则curLen++，否则代表连续递增中断了，将curLen重置为1。 每次循环的最后，比较ans和curLen，将较大者赋给ans。 循环结束后，返回ans。 \"]},\"931\":{\"h\":\"📋 代码\",\"t\":[\"class Solution { public int findLengthOfLCIS(int[] nums) { if (nums.length <= 1) return nums.length; int ans = 1, curLen = 1; for (int i = 0; i < nums.length-1; i++) { if (nums[i+1] > nums[i]) { curLen++; } else { curLen = 1; } ans = curLen > ans ? curLen : ans; } return ans; } }\",\"复杂度： 时间：O(n) 空间：O(1) \"]},\"932\":{\"h\":\"695-岛屿的最大面积\"},\"933\":{\"h\":\"💬 描述\",\"t\":[\"给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1:\",\"[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]\",\"对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。\",\"示例 2:\",\"[[0,0,0,0,0,0,0,0]]\",\"对于上面这个给定的矩阵, 返回 0。\",\"注意: 给定的矩阵grid 的长度和宽度都不超过 50。\"]},\"934\":{\"h\":\"📋 代码\",\"t\":[\"public class Solution { int area = 0; int tmp = 0; int xx, yy; int m, n; boolean[][] visited; int[] dx = {1,-1,0,0}; int[] dy = {0,0,1,-1}; public int maxAreaOfIsland(int[][] grid) { if (grid == null || grid.length == 0 || grid[0].length == 0) { return 0; } m = grid.length; n = grid[0].length; visited = new boolean[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 1 && !visited[i][j]) { tmp = 0; dfs(grid, i, j); area = Math.max(tmp, area); } } } return area; } private void dfs(int[][] grid, int i, int j) { visited[i][j] = true; tmp++; for (int d = 0; d < 4; d++) { xx = i + dx[d]; yy = j + dy[d]; if (xx >=0 && xx < m && yy >=0 && yy < n && grid[xx][yy] == 1 && !visited[xx][yy]) { dfs(grid, xx, yy); } } } }\"]},\"935\":{\"h\":\"💡 思路\",\"t\":[\"经典的DFS题。思路没啥可说的，有几个细节：\",\"可以复用的变量在方法外声明，可节约一点内存。\",\"使用dx、dy数组，可使代码更简洁，在dfs方法中不用再写4个if。\",\"dfs中进行递归前的条件。除了注意xx、yy和是否访问过以外，还要注意 grid[xx][yy] == 1 的判断。第一次写的时候漏了这个条件😥\",\"官方题解中还有一个BFS的解法。但个人感觉没必要看。对这道题来说，掌握了DFS就ok了。\"]},\"936\":{\"h\":\"945-使数组唯一的最小增量\"},\"937\":{\"h\":\"💬 描述\",\"t\":[\"给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。 返回使 A 中的每个值都是唯一的最少操作次数。\",\"示例 1:\",\"输入：[1,2,2] 输出：1 解释：经过一次 move 操作，数组将变为 [1, 2, 3]。\",\"示例 2:\",\"输入：[3,2,1,2,1,7] 输出：6 解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。 可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。\",\"提示：\",\"0 <= A.length <= 40000\",\"0 <= A[i] < 40000\"]},\"938\":{\"h\":\"📋 代码1- 先排序后遍历\",\"t\":[\"首先将数组进行排序，然后从左到右遍历数组。如果当前元素大于上一个元素，保持不变；如果当前元素小于等于上一个元素，就需要增加当前元素，直到大于上一个元素。\",\"class Solution { public int minIncrementForUnique(int[] A) { Arrays.sort(A); int times = 0; for (int i = 1; i < A.length; i++) { if (A[i] <= A[i-1]) { // 如果当前的数<=上一个数，则需要增加到上一个数+1。 // 如，当前是3，上一个数是5，则需要增加到6。那么增加的次数就是5+1-3。 times += (A[i-1] + 1 - A[i]); A[i] = A[i-1] + 1; } } return times; } }\",\"复杂度： O(nlogn) 。因为排序。\"]},\"939\":{\"h\":\"📋 代码2- 先计数后遍历\",\"t\":[\"通过记录每个数字出现的次数来计算结果。例如输入 [3, 2, 1, 2, 1, 7]，计数之后有两个 1 和两个 2。我们先看最小的数，两个 1 重复了，需要有一个增加到 2，这样 2 的数量变成了三个。在三个 2 中，又有两个需要增加到 3，然后又出现了两个 3…… 以此类推，可以计算出需要增加的次数。 需要注意的是，虽然整数的范围是 0 到 40000，但是由于整数还会因为增加而变大，超出 40000 的范围。例如极端的情况：所有数都是 39999。所以需要对整数中最大的数单独处理。\",\"class Solution { public int minIncrementForUnique(int[] A) { int[] count = new int[40000]; int max = 0; for (int a : A) { count[a]++; // 计数 max = Math.max(max, a); // 计算数组中的最大值 } int res = 0; // 只循环处理<max的情况。 for (int j = 0; j < max; j++) { if (count[j] > 1) { // 有 count[j] - 1 个数需要增加 res += count[j] - 1; // 增加后，j+1这个数出现的次数，就多了（count[j] - 1）个。 // 因此要给 count[j+1] 的值加上这些数量。 count[j+1] += count[j] - 1; } } // count[max] 单独计算，因为对这个数进行增加后，可能会超出count[]数组的边界。 // 这里计算次数可以通过等差数列求和，完成后，可以不再进行 count[j+1] += count[j] - 1。就不会发生越界。 if (count[max] > 1) { int d = count[max] - 1; // 有 d 个数需要增加 // 分别增加为 max + 1, max + 2, ... max + d // 使用等差数列公式求和 res += (1 + d) * d / 2; } return res; } }\"]},\"940\":{\"h\":\"💡 思路\",\"t\":[\"已经写在上方代码注释中。 其中，方法2可以看作是计数排序。它的时间复杂度可以认为是O(n+k)：遍历A，复杂度为n；遍历count，复杂度为k。 在leetcode的提交结果也能看出来，方法2的时间明显少于方法1的时间。 \"]},\"941\":{\"h\":\"994-腐烂的橘子\"},\"942\":{\"h\":\"🔗 链接\",\"t\":[\"LeetCode-994 一道经典的DFS/BFS题。由于公司之前有组织培训及考试，这类题已经快做吐了。在此总结一下。 （因为疫情和工作上的事情，很久没写总结了😪）\"]},\"943\":{\"h\":\"📋 代码1-DFS\",\"t\":[\"按深度优先的方式进行感染，每走一步，腐烂值+1。完成后检查结果。最大的腐烂值-2就是需要的时间。 如果过程中遇到了腐烂值>当前腐烂值+1的场景，则把大的腐烂值更新为当前腐烂值+1。这样才是这个橘子感染的最短时间。\",\"class Solution { int time = 0; // 这2个数组用做上下左右4个方向。 int[] dx = {0, 0, 1, -1}; int[] dy = {1, -1, 0, 0}; int xx = 0; int yy = 0; public int orangesRotting(int[][] grid) { for(int i = 0; i < grid.length; i++) { for(int j = 0; j < grid[0].length; j++) { // 遍历格子，如果是2（烂橘子），进入dfs进行递归传染。 if (grid[i][j] == 2) { dfs(grid, i, j, 2); } } } // 传染完毕。检查结果。即grid[x][y]的最大值。另外，如果此时还有1，说明还存在未腐烂的橘子。返回-1。 for(int i = 0; i < grid.length; i++) { for(int j = 0; j < grid[0].length; j++) { if (grid[i][j] == 1) return -1; if (grid[i][j] > time) { time = grid[i][j]; } } } // time为最大的腐烂值。如果是10，说明从烂橘子（2）感染到它需要8秒。因此需要减去2。 return time-2 <0?0:time-2; } /** * @param grid 输入的格子 * @param i 横坐标 * @param j 纵坐标 * @param k 当前的腐烂值。初始传来的是2 */ private void dfs(int[][] grid, int i, int j, int k) { grid[i][j] = k; for (int d = 0; d < 4; d++) { xx = i + dx[d]; yy = j + dy[d]; //开始传染。条件是： //1.新坐标还在格子里面 //2.即将传染的橘子是好橘子（值为1），或腐烂值>=当前橘子的腐烂值。 // 为什么要加上上条的最后一个条件呢？举个例子。如果即将传染的橘子腐烂值是4，说明另一条路径，经过4分钟后感染了橘子；而当前这条路径3分钟即可感染橘子，那肯定是以小的为准。 if (xx >=0 && xx < grid.length && yy >=0 && yy < grid[0].length && (grid[xx][yy] == 1 || grid[xx][yy] > k+1)) { dfs(grid, xx, yy, k+1); } } } }\"]},\"944\":{\"h\":\"📋 代码2-BFS\",\"t\":[\"按“层”进行感染。在同一时间被感染的橘子为一层。最后的最大层数就是需要的时间。\",\"class Other { int time; int x, y; int xx, yy; int R, C; int code; // 保存处理后的x.y int[] dx = {0,0,1,-1}; int[] dy = {1,-1,0,0}; Queue<Integer> queue = new LinkedList<Integer>(); Map<Integer, Integer> depth = new HashMap<Integer, Integer>(); public int orangesRotting(int[][] grid) { R = grid.length; C = grid[0].length; for(int i = 0; i < R; i++) { for(int j = 0; j < C; j++) { if (grid[i][j] == 2) { // i和j的最大值是10, 这里把j存到code的2个低位，i存到code的高位。 code = i * 100 + j; queue.add(code); // 这个code代表的格子的感染时间为0。 depth.put(code, 0); } } } while (!queue.isEmpty()) { int code = queue.remove(); x = code / 100; y = code % 100; for (int d = 0; d < 4; d++) { xx = x + dx[d]; yy = y + dy[d]; // 如果下一个格子在范围内，而且是新鲜橘子 if (0 <= xx && xx < R && 0 <= yy && yy < C && grid[xx][yy] == 1) { // 就进行感染，把值置为2 grid[xx][yy] = 2; // 服用code变量，保存新格子的坐标。新格子，即上面说的下一层。 int ncode = xx * 100 + yy; queue.add(ncode); // 新格子（下一层）的腐烂时间，是感染它的那个格子的时间+1 depth.put(ncode, depth.get(code) + 1); // time保存当前的最大时间 time = depth.get(ncode); } } } // 到这里，time里存的就是最大时间。但还需要判断是否存在新鲜橘子。如果存在，则返回-1。 for (int[] row: grid) { for (int v: row) { if (v == 1) return -1; } } return time; } }\"]},\"945\":{\"h\":\"📋 代码3-DP\",\"t\":[\"待补充。\"]},\"946\":{\"h\":\"2351-第一个出现两次的字母\"},\"947\":{\"h\":\"🔗 链接\",\"t\":[\"lc-2351\",\"一道普通的字符串/数组类题目。第一时间想到可以用hash表。然后看到官方题解还有利用二进制数进行状态压缩的解法，尝试后也ac了，在此记录一下。\"]},\"948\":{\"h\":\"📋 代码1-hash表\",\"t\":[\"使用占空间较小的boolean类型来保存。false表示未出现过，true表示出现过。\",\"public char repeatedCharacter(String s) { boolean[] vis = new boolean[26]; char c = ' '; for (int i = 0; i < s.length(); i++) { c = s.charAt(i); if (vis[c - 'a']) { break; } else { vis[c - 'a'] = true; } } return c; }\",\"时间复杂度：O(n)，其中 n 是字符串s的长度。\",\"空间复杂度：O(1)。占用的空间为包含了26个字符的数组。\"]},\"949\":{\"h\":\"📋 代码2-状态压缩\",\"t\":[\"如下放代码所示，(vis & (1 << x)) != 0)用于判断vis这个数字的二进制表示中，第x位的值是否为1，与操作的结果不为0，表示第x位的值为1，即表示c这个字符出现过，返回c。否则，使用vis |= (1 << x)，把vis的第x为改为1。\",\"int vis, x; char c; public char repeatedCharacter(String s) { for (int i = 0; i < s.length(); i++) { c = s.charAt(i); x = c - 'a'; if ((vis & (1 << x)) != 0) { return c; } vis |= (1 << x); } return ' '; }\",\"时间复杂度：O(n)，其中 n 是字符串s的长度。\",\"空间复杂度：O(1)。\"]},\"950\":{\"h\":\"数组\"},\"951\":{\"h\":\"算法-数组\",\"t\":[\"待补充。。。\"]},\"952\":{\"h\":\"01.06-字符串压缩\"},\"953\":{\"h\":\"💬 描述\",\"t\":[\"字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。 示例1:\",\"输入：\\\"aabcccccaaa\\\" 输出：\\\"a2b1c5a3\\\"\",\"示例2:\",\"输入：\\\"abbccd\\\" 输出：\\\"abbccd\\\" 解释：\\\"abbccd\\\"压缩后为\\\"a1b2c2d1\\\"，比原字符串长度更长。\",\"提示： 1.字符串长度在[0, 50000]范围内。\"]},\"954\":{\"h\":\"📋 代码\",\"t\":[\"class Solution { public String compressString(String S) { // 特殊情况处理。null好理解。 // <=2是因为，压缩后的长度至少也是2。因此如果小于2就不必压缩 if (S == null || S.length() <= 2) return S; // 用sb接收并返回结果，节省时间和空间。 StringBuilder sb = new StringBuilder(); int i = 0, j = 0; // 转成数组，访问下标能快一点。变量n代替长度同理。 char[] arr = S.toCharArray(); int n = arr.length; // 循环结束条件为，j 走到最后一个元素处。 while (j < n) { // 如果 j 和 i 处的字符相同，则 j右移，j最多可以移到数组的最后一个元素处。 // 每次重新进入外层的while时，i 和 j 总是想等的。下方的while也总是成立的。 while (j < n && arr[j] == arr[i]) { j++; } // 走到这里说明 j 处的字符和 i 处的字符不同，或者 j 走到了数组最后一个元素处。 // 先拼 i 处的字符，再拼(j-i)这个数字即可完成 i 处这个字符的压缩。 // 令 i = j，即开始考察 j 处的元素。之后进入下一个循环。 sb.append(arr[i]).append((j-i)); i = j; } // 判断长度。谁短返回谁。 return sb.length() < S.length() ? sb.toString():S; } }\"]},\"955\":{\"h\":\"💡 思路\",\"t\":[\"参考代码注释。利用双指针来完成此题。 感觉难点在于循环条件结束的判定上。一开始写的代码遇到了 下标越界、漏掉最后一个元素的情况。debug几次，再完善下代码就ok。\",\"LeetCode-面试题 01.06\"]},\"956\":{\"c\":[\"字符串\"]},\"957\":{\"h\":\"2042-检查句子中的数字是否递增\",\"t\":[\"检查句子中的数字是否递增\",\"这道题还是挺简单的，上代码：\",\"public boolean areNumbersAscending(String s) { String[] str = s.split(\\\" \\\"); List<Integer> list = Arrays.stream(str).filter(e -> Character.isDigit(e.charAt(0))).map(Integer::valueOf).collect(Collectors.toList()); for (int i = 0; i < list.size()-1; i++) { if (list.get(i) >= list.get(i+1)) { return false; } } return true; }\",\"提交后发现，耗时长达3ms，击败27.8%。效率有点低。看了官方题解，自己尝试后ac了。在此记录一下。\",\"经验：需要多关注提示，关注入参范围。有些情况下这是提升算法效率的关键。\",\"改进后的代码如下：\",\"public boolean areNumbersAscending(String s) { int pre = 0, pos = 0; while (pos < s.length()) { if (Character.isDigit(s.charAt(pos))) { int cur = 0; while (pos < s.length() && Character.isDigit(s.charAt(pos))) { cur = cur * 10 + s.charAt(pos) - '0'; pos++; } if (cur <= pre) { return false; } pre = cur; } else { pos++; } } return true; }\",\"思路：使用pre表示上一个数字，pos表示当前遍历的下标。\",\"在循环中，判断当前下标pos处的是不是数字，如果不是，pos++。如果是，先把cur（当前数字）初始化为0。然后进入内层while循环。只要下标pos在范围内，且当前字符是数字，则更新cur，pos++。\",\"退出内层循环后判断，如果当前数<=上一个数，返回false。否则，把cur赋给pre。然后继续下一个外层循环。\",\"在循环结束后，返回true。\",\"时间复杂度：O(n)。其中n表示字符串的长度。我们只需遍历一遍字符串即可。\",\"空间复杂度：O(1)。仅用到若干额外变量。\"]},\"958\":{\"c\":[\"字符串\"]},\"959\":{\"h\":\"字符串\"},\"960\":{\"h\":\"算法-字符串\",\"t\":[\"字符串类的算法题总结。\"]},\"961\":{\"h\":\"LeetCode-19 删除倒数第N个节点\"},\"962\":{\"h\":\"🔗 链接\",\"t\":[\"LeetCode-19 该题和 面试题 02.02 类似\"]},\"963\":{\"h\":\"📋 代码1\",\"t\":[\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (head == null || head.next == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while (n-- > 0) { fast = fast.next; } while (fast.next != null) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummy.next; } }\"]},\"964\":{\"h\":\"💡 思路\",\"t\":[\"这种题有一个固定的“套路”，因为要获取目标节点的前一个节点，这里创建哑节点，令它的后继节点为head。 之后，fast/slow都指向它(也可以指向head，但这样必须引入一个计数器，判断要删除的是否是头结点。)。先把fast右移n位；之后，再同时移动fast/slow，直到fast指向最后一个节点。此时，fast指到了最后一个节点，slow指到了目标节点的前一个节点（而不是目标节点）。 之后使用slow.next = slow.next.next即可删除目标节点。最后，使用dummy.next返回需要的节点头即可。 而对于面试题 02.02 ，需要返回倒数第k个节点的值，不需要得到目标节点的前驱节点，因此不需要设置哑节点。首先，fast/slow都指向head，之后先移动fast n次，再同时移动fast/slow。直到fast指向null。此时，slow就是目标节点，返回其值即可。代码如下：\"]},\"965\":{\"h\":\"📋 代码2\",\"t\":[\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int kthToLast(ListNode head, int k) { ListNode slow = head; ListNode fast = head; while (k-- >0) { fast = fast.next; } while (fast != null) { fast = fast.next; slow = slow.next; } return slow.val; } }\"]},\"966\":{\"h\":\"LeetCode-206 反转链表\"},\"967\":{\"h\":\"💬 描述\",\"t\":[\"反转一个单链表。 示例 1:\",\"输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL\",\"进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ \"]},\"968\":{\"h\":\"📋 代码1 - 迭代\",\"t\":[\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; ListNode tmp = null; while (cur != null) { tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } }\",\"复杂度： 时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。 空间复杂度：O(1)。 \"]},\"969\":{\"h\":\"📋 代码2 - 递归\",\"t\":[\"public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; }\",\"复杂度： 时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。 \"]},\"970\":{\"h\":\"💡 思路\",\"t\":[\"迭代： 要反转链表，实际上就是要反转所有相邻节点之间的指针。如代码所示，我们先定义3个指针，cur指向head, tmp指向它的下一个节点，pre指向它的上一个节点。然后进入循环。 在循环中，先找到下一个节点赋值给tmp，防止反转后丢失后续的节点。再把cur的next指向前一个节点（反转）。再进行一次右移：pre移到cur处，cur移到tmp处。 此时，头结点（pre节点）从链表中独立了出来，cur指向了第二个节点。在第二轮循环中，通过 cur.next = pre，把原来的头结点链到第二个节点之后。这就实现了前2个节点的反转。继续循环... 最终，pre会指到最后一个节点处。返回pre即可。 递归： 从后到前进行反转。具体可参照代码。下面附上力扣评论区的解读： 不妨假设链表为1，2，3，4，5。按照递归，当执行reverseList（5）的时候返回了5这个节点，reverseList(4)中的p就是5这个节点，我们看看reverseList（4）接下来执行完之后，5->next = 4, 4->next = null。这时候返回了p这个节点，也就是链表5->4->null，接下来执行reverseList（3），代码解析为4->next = 3,3->next = null，这个时候p就变成了，5->4->3->null, reverseList(2), reverseList(1)依次类推，p就是:5->4->3->2->1->null \"]},\"971\":{\"h\":\"LeetCode-234 回文链表\"},\"972\":{\"h\":\"🔗 链接\",\"t\":[\"LeetCode-234 该题和 面试题 02.06 一样\"]},\"973\":{\"h\":\"📋 代码\",\"t\":[\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ListNode fast = head; ListNode slow = head; ListNode pre = head; ListNode prepre = null; while(fast != null && fast.next != null) { // pre在slow左侧。 pre = slow; // slow/fast分别代表慢/快指针。 slow = slow.next; fast = fast.next.next; // pre指向左边。 pre.next = prepre; // prepre也跟着右移。 prepre = pre; } // 调整slow的位置。 if (fast != null) slow = slow.next; while(pre != null && slow != null) { if (pre.val != slow.val) return false; pre = pre.next; slow = slow.next; } return true; } }\"]},\"974\":{\"h\":\"💡 思路\",\"t\":[\"详见代码注释。其中，第一个while结束后，有两种情况：\",\"链表节点为奇数个。如下图。此时，fast指向最后一个节点，不为null。还需要调整slow的位置。把slow指向节点4。因为奇数个节点，中间的节点3不会影响回文属性，所以无需关注它，直接把slow移到节点4。 移动后，pre和slow分别指向2和4。如下图： \",\"链表节点为偶数个。如下图。此时，fast指向null。无需调整slow的位置。 之后的while就简单了。依次比较pre和slow节点的值。如果不等，返回false；否则，移动pre和slow，直到全部比较完。返回true。\"]},\"975\":{\"h\":\"🎃 缺点\",\"t\":[\"虽然题目没有明确要求不能改变链表，但一般来说仍应在返回结果之前恢复链表。 另附上官方题解\",\"class Solution { public boolean isPalindrome(ListNode head) { if (head == null) return true; // Find the end of first half and reverse second half. ListNode firstHalfEnd = endOfFirstHalf(head); ListNode secondHalfStart = reverseList(firstHalfEnd.next); // Check whether or not there is a palindrome. ListNode p1 = head; ListNode p2 = secondHalfStart; boolean result = true; while (result && p2 != null) { if (p1.val != p2.val) result = false; p1 = p1.next; p2 = p2.next; } // Restore the list and return the result. firstHalfEnd.next = reverseList(secondHalfStart); return result; } private ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; } private ListNode endOfFirstHalf(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast.next != null && fast.next.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } }\"]},\"976\":{\"h\":\"链表\"},\"977\":{\"h\":\"算法-链表\",\"t\":[\"字符串类的算法题总结。\"]},\"978\":{\"h\":\"树\"},\"979\":{\"h\":\"算法-树\",\"t\":[\"树类型的算法题总结。\",\"参考：\",\"宫水三叶的刷题日记 - 树\",\"宫水三叶的刷题日记 - 二叉树\"]},\"980\":{\"h\":\"LeetCode-365 水壶问题\"},\"981\":{\"h\":\"💬 描述\",\"t\":[\"有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许：\",\"装满任意一个水壶\",\"清空任意一个水壶\",\"从一个水壶向另外一个水壶倒水，直到装满或者倒空\",\"示例 1:\",\"输入: x = 3, y = 5, z = 4 输出: True\",\"示例 2:\",\"输入: x = 2, y = 6, z = 5 输出: False\"]},\"982\":{\"h\":\"📋 代码1-BFS1.考虑每个水壶\",\"t\":[\"import java.util.*; class Solution { public boolean canMeasureWater(int x, int y, int z) { // 存储所有可能的状态 Stack<int[]> stack = new Stack<>(); // 存储处理过的状态 Set<Map.Entry<Integer, Integer>> seenSet = new HashSet<>(); // 初始状态：两个水壶都没水 stack.push(new int[]{0,0}); while(!stack.isEmpty()) { int[] arr = stack.pop(); // 如果当前的状态，可以构造出z升水，则返回true。 if((arr[0] == z) || (arr[1] == z) || (arr[0]+arr[1] == z)) return true; // 否则，以当前这种状态进行格式转化，在下面放到已经处理过的集合内 Map.Entry<Integer,Integer> currEntry = new AbstractMap.SimpleEntry<>(arr[0], arr[1]); // 如果之前处理过这个状态，跳过 if(seenSet.contains(currEntry)) continue; // 否则，把处理过的这个状态加入到已经处理过的集合内 seenSet.add(currEntry); // 进行操作 stack.add(new int[]{0, arr[1]}); // 倒空x stack.add(new int[]{arr[0], 0}); // 倒空y stack.add(new int[]{x, arr[1]}); // 加满x stack.add(new int[]{arr[0],y}); // 加满y // x往y中倒水。如果不会倒满，x空，y是当前两桶水之和 if(arr[0] + arr[1] < y) stack.add(new int[]{0, arr[0]+arr[1]}); // 如果会倒满，x中会有剩余，y满 else stack.add(new int[]{arr[0]+arr[1]-y, y}); // y往x中倒水。如果不会倒满，y空，x是当前两桶水之和 if(arr[0] + arr[1] < x) stack.add(new int[]{arr[0]+arr[1], 0}); // 如果会倒满，y中会有剩余，x满 else stack.add(new int[]{x, arr[0]+arr[1]-x}); } // 如果所有状态都执行了还是没得到z，则返回false。 return false; } }\"]},\"983\":{\"h\":\"📋 代码2-BFS2.只考虑水的总量，不关心它在哪个水壶\",\"t\":[\"import java.util.*; class Solution { public boolean canMeasureWater_BFS(int x, int y, int z) { if (z < 0 || z > x + y) { return false; } Set<Integer> set = new HashSet<>(); // 存储所有可能 Queue<Integer> q = new LinkedList<>(); // 初始总水量，0。 q.offer(0); while (!q.isEmpty()) { int n = q.poll(); // 如果当前总水量+x后，水壶能装下，且之前没装过（当前总水量+x）这么多的水。 //则需要考虑这种场景。把n+x放入队列q中。 if (n + x <= x + y && set.add(n + x)) { q.offer(n + x); } // 如果当前总水量+y后，水壶能装下，且之前没装过（当前总水量+x）这么多的水。 //则需要考虑这种场景。把n+y放入队列q中。 if (n + y <= x + y && set.add(n + y)) { q.offer(n + y); } //如果当前水量可以减去x，且减去x后的水量之前没装过，则执行。 if (n - x >= 0 && set.add(n - x)) { q.offer(n - x); } //如果当前水量可以减去y，且减去x后的水量之前没装过，则执行。 if (n - y >= 0 && set.add(n - y)) { q.offer(n - y); } // 如果装过了z升水，说明可以。返回true。 if (set.contains(z)) { return true; } } // 代码走到这里说明不可能拼出z升水。返回false。 return false; } }\",\"通过执行 set.add() 来进行状态处理，以及通过判断它的返回值，来判断之前是否处理过这种状态。\"]},\"984\":{\"h\":\"📋 代码3-最大公约数（执行最快）\",\"t\":[\"需要判断z是否为x,y最大公约数的倍数。此时为题转化为了求解最大公约数，而该问题可以使用gcd算法（辗转相除法）。\",\"class Solution { public boolean canMeasureWater(int x, int y, int z) { if(x == 0 && y == 0) return z == 0; return z == 0 || (z % gcd(x,y) == 0 && x + y >= z); } static int gcd(int x,int y){ if(y == 0) return x; int r = x % y; return gcd(y,r); } }\"]},\"985\":{\"h\":\"💡 思路\",\"t\":[\"已经写在上方代码注释，及代码前后加粗的段落中了。个人感觉是比较重要的算法题。需要记住。\"]},\"986\":{\"h\":\"其他\"},\"987\":{\"h\":\"算法-其他类型\",\"t\":[\"其他类型的算法题总结。\"]},\"988\":{\"h\":\"工具类-part1\",\"t\":[\"Joiner：拼接字符串\",\"Splitter：拆分字符串\",\"Preconditions：断言工具\"]},\"989\":{\"h\":\"Joiner\",\"t\":[\"类路径：com.google.common.base.Joiner\",\"用分隔符将一系列字符串连接在一起可能会不必要地复杂——但不应该如此。如果您的序列包含空值，则会更加困难。流式风格使其变得简单。\"]},\"990\":{\"h\":\"join()方法\",\"t\":[\"下面以代码来演示。\",\"public class JoinerTest { private final List<String> strList = Arrays.asList(\\\"google\\\", \\\"guava\\\", \\\"java\\\"); private final List<String> strListWithNull = Arrays.asList(\\\"google\\\", \\\"guava\\\", \\\"java\\\", null); @Test public void joinOnjoin() { String join = Joiner.on(\\\"#\\\").join(strList); // google#guava#java join = Joiner.on(\\\"#\\\").join(strListWithNull); // 报错 join = Joiner.on(\\\"#\\\").skipNulls().join(strListWithNull); // google#guava#java join = Joiner.on(\\\"#\\\").useForNull(\\\"null\\\").join(strListWithNull); // google#guava#java#null } }\"]},\"991\":{\"h\":\"appendTo()方法\",\"t\":[\"private final List<String> strList = Arrays.asList(\\\"google\\\", \\\"guava\\\", \\\"java\\\"); @Test public void joinAppendTo() { StringBuilder sb = new StringBuilder(\\\"sb\\\"); // 虽然下方方法会返回一个新对象，但和原来的是同一个对象。 StringBuilder stringBuilder = Joiner.on(\\\"#\\\").appendTo(sb, strList);// sbgoogle#guava#java // 通过流，输出到文件中。 try(FileWriter writer = new FileWriter(new File(targetFileName))) { Joiner.on(\\\"#\\\").useForNull(\\\"default\\\").appendTo(writer, strListWithNull); } catch (IOException e) { fail(\\\"error\\\"); } }\"]},\"992\":{\"h\":\"用JavaSE api实现join()\",\"t\":[\"@Test public void joinByStream() { String s1 = strListWithNull.stream().filter(Objects::nonNull).collect(Collectors.joining(\\\"#\\\")); String s2 = Joiner.on(\\\"#\\\").skipNulls().join(strListWithNull); Assert.assertEquals(s1, s2); }\"]},\"993\":{\"h\":\"join map\",\"t\":[\"@Test public void joinOnWithMap() { Map<String, String> map = ImmutableMap.of(\\\"hello\\\", \\\"zs\\\", \\\"hello1\\\", \\\"ls\\\"); String join = Joiner.on('#').withKeyValueSeparator(\\\"=\\\").join(map); System.out.println(join); // hello=zs#hello1=ls }\",\"线程安全\",\"Joiner实例总是不可变的。joiner配置方法将始终返回一个新的joiner，您必须使用它来获得所需的语义。这使得任何Joiner线程都是安全的，并且可用作静态final常量。\"]},\"994\":{\"h\":\"其他\",\"t\":[\"java.lang.Appendable：appendTo()方法的第一个参数是Appendable的实现类。它的实现类主要包括各种流，及StringBuilder、StringBuffer等。\"]},\"995\":{\"h\":\"Splitter\",\"t\":[\"类路径：com.google.common.base.Splitter\",\"用来拆分字符串的工具。Java内置的拆分方法有一些奇怪的行为。例如，String.split会丢弃尾部的分隔符。\",\"如\\\",a,,b,\\\".split(\\\",\\\")，返回值是\\\"\\\", \\\"a\\\", \\\"\\\", \\\"b\\\"。首部会有一个空串，但尾部不会。\"]},\"996\":{\"h\":\"split...()方法\",\"t\":[\"@Test public void testSplitter1() { List<String> split1 = Splitter.on(\\\"|\\\").splitToList(\\\"|hello|world|||\\\"); // [, hello, world, , , ] hello前有一个空格，是因为Splitter内重写了这个返回的list的toString方法。 System.out.println(split1.size()); // 6 split1 = Splitter.on(\\\"|\\\").trimResults().omitEmptyStrings().splitToList(\\\"| hello |world|||\\\"); // [hello, world] System.out.println(split1.size()); // 2 List<String> list = Splitter.fixedLength(3).splitToList(\\\"aaaBBBcccDDD\\\"); System.out.println(list); // [aaa, BBB, ccc, DDD]。每3个元素一份 list = Splitter.on('#').limit(3).splitToList(\\\"hello#world#java#haha#zhangsan#lisi\\\"); System.out.println(list); // [hello, world, java#haha#zhangsan#lisi]。以#拆分，最多拆成3个元素。 }\",\"相关信息\",\"Splitter同时还支持正则。\",\"todo:\",\" Splitter源码分析。里面有很好的设计方法。\"]},\"997\":{\"h\":\"Preconditions 断言\",\"t\":[\"机翻的介绍\",\"Guava在Preconditions类中提供了许多先决条件检查实用程序。我们强烈建议静态导入这些。 每个方法有三种变体：\",\"没有额外的参数。任何抛出的异常都没有异常消息。\",\"一个额外的Object参数。任何抛出的异常都有错误消息 object.toString()。\",\"一个额外的String参数，任意数量的Object参数。这类似于printf，但为了GWT兼容性和效率，它只允许%s指示器。\",\"注意：checkNotNull、checkArgument和checkState有大量的重载方法，它们采用了基本数据类型和Object参数的组合，而不是参数数组——这允许您在绝大多数情况下避免了基本数据类型的装箱和参数数组的分配。\"]},\"998\":{\"h\":\"基本用法\",\"t\":[\"@Test public void testPreconditions() { List<String> list = null; // Preconditions.checkNotNull(list); // java.lang.NullPointerException // Preconditions.checkNotNull(list, \\\"list不能为null\\\"); // java.lang.NullPointerException: list不能为null // Preconditions.checkNotNull(list, \\\"list不能为null, 且长度必须是%s\\\", 2); // java.lang.NullPointerException: list不能为null, 且长度必须是2 String arg = \\\"a\\\"; Preconditions.checkArgument(arg.equals(\\\"b\\\"), \\\"参数错误\\\"); // java.lang.IllegalArgumentException: 参数错误 }\",\"在项目中用的不多。一般都会自定义断言工具类，来指定抛出的异常类型，最后通过统一异常处理。\"]},\"999\":{\"c\":[\"guava\"]},\"1000\":{\"c\":[\"Joiner&Splitter\"]},\"1001\":{\"h\":\"guava\",\"t\":[\"源码：google/guava\",\"官方文档：User Guide\",\"下面的笔记记录了开发中常用的，或个人认为比较重要的类和API。\"]},\"1002\":{\"h\":\"Spring源码下载和编译\"},\"1003\":{\"h\":\"前置准备\",\"t\":[\"需要IDEA，JDK 1.8.20 以上。\"]},\"1004\":{\"h\":\"下载源码\",\"t\":[\"这里我们选择4.3.x版本。地址：github - spring-framework 4.3.x\",\"使用git clone -b 4.3.x https://github.com/spring-projects/spring-framework.git来下载这个版本。\",\"下载完大约有453mb（如果下载缓慢，可以安装 dev-sidecar加速）。\"]},\"1005\":{\"h\":\"下载Gradle构建工具\",\"t\":[\"地址： Gradle 4.10.2。\",\"这个版本最好和源码\\\\spring-framework\\\\gradle\\\\wrapper\\\\gradle-wrapper.properties内的一致。进入官网后点击4.10.2版本下的binary-only即可。下载后解压zip包。\"]},\"1006\":{\"h\":\"修改distributionUrl\",\"t\":[\"打开 spring-framework\\\\gradle\\\\wrapper\\\\gradle-wrapper.properties 文件，注释掉distributionUrl=https\\\\://services.gradle.org/distributions/gradle-4.10.2-bin.zip，在下方新增一行：distributionUrl=gradle-4.10.2-bin.zip。并把刚才下载的gradle-4.10.2-bin.zip复制到该目录下。\"]},\"1007\":{\"h\":\"配置环境变量及仓库地址：\",\"t\":[\"变量名：GRADLE_HOME，值：输入刚才解压后的路径。如 D:\\\\0.devEnv\\\\gradle-4.10.2。\",\"变量名：GRADLE_USER_HOME，值：输入本地jar包存放路径即可。如D:\\\\0.devEnv\\\\gradle-repo。\",\"然后在path环境变量内加一条：%GRADLE_HOME%\\\\bin。\",\"验证。打开cmd命令行输入 gradle -v。显示版本则表示配置成功。\"]},\"1008\":{\"h\":\"配置阿里云镜像：\",\"t\":[\"在gradle中的init.d文件夹中（如D:\\\\0.devEnv\\\\gradle-4.10.2\\\\init.d\\\\）新建一个init.gradle文件，并在文件中添加如下配置\",\"allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/public/' } mavenLocal() mavenCentral() } }\"]},\"1009\":{\"h\":\"修改spring源码内gradle的镜像地址\",\"t\":[\"修改\\\\spring-framework\\\\build.gradle文件内gradle的镜像地址。大约在132行，如下方代码所示，在repositories内，mavenCentral()前增加两行配置。\",\"repositories { maven{ url 'https://maven.aliyun.com/nexus/content/groups/public/'} maven{ url 'https://maven.aliyun.com/nexus/content/repositories/jcenter'} mavenCentral() maven { url \\\"https://repo.spring.io/libs-spring-framework-build\\\" } }\"]},\"1010\":{\"h\":\"编译compileTestJava模块\",\"t\":[\"打开源码所在文件夹，在搜索栏输入 cmd 命令，跳转到所在目录的命令行窗口，在当前目录的命令行窗口输入：\",\"gradlew :spring-oxm:compileTestJava\",\"稍等片刻即可编译成功。\"]},\"1011\":{\"h\":\"导入项目到IDEA\",\"t\":[\"使用Idea (File -> New -> Project from Existing Sources) ，选择\\\\spring-framework目录下的build.gradle文件，确认。接下来就是漫长的build了。这个过程中会下载相关的依赖包，大约1.9GB。时长主要取决于网速和本地磁盘性能。\",\"最终，在IDEA的console里看到BUILD SUCCESSFUL，且IDEA没有正在运行的后台任务，表示导入成功。\"]},\"1012\":{\"h\":\"测试\",\"t\":[\"打开spring-test模块，src/test/java目录下，随便找一个@Test方法运行，查看结果是否正常。\"]},\"1013\":{\"h\":\"Spring源码\"},\"1014\":{\"h\":\"Spring源码解析\"},\"1015\":{\"h\":\"Spring Cloud Gateway\"},\"1016\":{\"h\":\"\"},\"1017\":{\"h\":\"LeetCode-572 另一个树的子树\"},\"1018\":{\"h\":\"💬 描述\",\"t\":[\"给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树s：\",\" 3 / \\\\ 4 5 / \\\\ 1 2\",\"给定的树t：\",\" 4 / \\\\ 1 2\",\"返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s：\",\" 3 / \\\\ 4 5 / \\\\ 1 2 / 0\",\"给定的树 t：\",\" 4 / \\\\ 1 2\",\"返回 false。 \"]},\"1019\":{\"h\":\"💡 思路\",\"t\":[\"DFS暴力匹配。DFS 枚举 s 中的每一个节点，判断这个点的子树是否和 t 相等。如何判断一个节点的子树是否和 t 相等呢，我们又需要做一次 DFS 来检查，即让两个指针一开始先指向该节点和 t 的根，然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。 具体到下方代码，如果s为null，则返回false；否则，进行3个判断，之间是或的关系，即任何一个满足即可。这三个判断分别是：判断s和t是否相等；判断s的左孩子和t是否相等，判断s的右孩子和t是否相等。这三者任何一个满足，就返回true。 isSameTree()方法是判断2个二叉树是否相等的。先判断当前的节点值是否想等。若二者都为null，则返回true；若任意一个为null而另一个不是null，或二者的值不同，则返回false。否则，继续check二者的左子树和右子树。左右子树的结果进行与运算，即它们都相等时，两棵树才相等。 \"]},\"1020\":{\"h\":\"📋 代码\",\"t\":[\"class Solution { public boolean isSubtree(TreeNode s, TreeNode t) { if (s == null) return false; return isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t); } boolean isSameTree(TreeNode s, TreeNode t) { if (s == null && t == null) return true; if (s == null || t == null || s.val != t.val) { return false; } return isSameTree(s.left, t.left) && isSameTree(s.right, t.right); } }\",\"复杂度：\"]},\"1021\":{\"h\":\"LeetCode-543 二叉树的直径\"},\"1022\":{\"h\":\"📋 代码\",\"t\":[\"class Solution { int res; int leftDepth, rightDepth; public int diameterOfBinaryTree(TreeNode root) { dfs(root); return res; } private int dfs(TreeNode root) { if (root == null) return 0; leftDepth = dfs(root.left); rightDepth = dfs(root.right); res = Math.max(res, leftDepth + rightDepth); return Math.max(leftDepth, rightDepth) + 1; } }\"]},\"1023\":{\"h\":\"💡 思路\",\"t\":[\"根据题意，求直径，等效于求路径经过的节点数的最大值减去1。我们可以把某个节点及其左右孩子向下遍历的路径拼接起来得到结果。 上方代码，先传入root。它的左右孩子的深度+1，得到它的深度。而通过root得到的直径，等于它的左右孩子的深度之和。每次计算都把最大深度存入res中。最后，所有的节点都被当做”头“来算了一次。res就是最终的最大值，即二叉树的直径。 总结如下：\",\"当前节点的深度 = 左右孩子的最大深度 + 1\",\"当前节点的直径 = 左右孩子的深度之和 3.叶子节点的深度为1，直径为0。\",\"如下图： \",\"4、5的深度为1，直径为0 3的深度为1，直径为0 2的深度为2（4,5的最大深度+1），直径为2（4.5的深度之和）。 1的深度为3（2,3的最大深度+1），直径为3（2,3的深度之和）\"]},\"1024\":{\"h\":\"树的遍历\",\"t\":[\"树的遍历分为四种：前序遍历，中序遍历，后序遍历，层序遍历。\",\" A / \\\\ B C /\\\\ /\\\\ D E F G \\\\ H\",\"前序遍历：前序遍历的遍历顺序是 根→左→右的顺序打印，我们先打印根节点，在打印左孩子，最后打印右孩子，如上图，我们先打印A，然后打印B，发现B也有左孩子，之后我们以B为根节点再进行一次跟左右遍历，打印D，之后我们准备打印B的右孩子就是E，发现E有右孩子，所以我们这边又以E作为根节点，进行跟左右操作，以此类推，得到最后的结果是：ABDEHCFG。\",\"中序遍历：先序遍历的遍历顺序是 左→根→右的顺序打印，我们一开始准备打印A的左孩子B，发现B也有左孩子然后以B为根节点进行左→根→右进行打印，所以我们一开始打印的是D这个节点，中序遍历和先序遍历的思维差不多，无非就是打印顺序的调整。最后的结果为：DBEHAFCG。\",\"后序遍历：先序遍历的遍历顺序是 左→右→根的顺序打印，跟前面两种遍历方式类似，就是打印的顺序不同，我们应该先遍历完左右孩子再进行根节点的打印。最后的结果是：DHEBFGCA。\",\"层序遍历：层序遍历就比较简单，层序遍历就是按照各层顺序打印结果，如上图的层序遍历就是：ABCDEFGH。\",\"前中后遍历，均可以使用递归或迭代的方式进行。层序遍历一般使用迭代来实现。\",\"递归方式\",\"// 前序遍历 void preOrderTraversal(TreeNode root) { if (root == null) { return; } else { System.out.print(root.val + \\\" \\\"); preOrderTraversal(root.left); preOrderTraversal(root.right); } } // 中序遍历 void inOrderTraversal(TreeNode root) { if (root == null) { return; } else { inOrderTraversal(root.left); System.out.print(root.val + \\\" \\\"); inOrderTraversal(root.right); } } //后序遍历 void poseOrderTraversal(TreeNode root) { if (root == null) { return; } else { poseOrderTraversal(root.left); poseOrderTraversal(root.right); System.out.print(root.val + \\\" \\\"); } }\",\"迭代方式（需要使用栈来辅助进行）\",\"// 非递归的前序遍历 void preOrderTraversalNor(TreeNode root) { if (root == null) { return; } Stack<TreeNode> stack = new Stack<>(); TreeNode cur = root; while (cur != null || !stack.empty()) { while (cur != null) { stack.push(cur); System.out.print(cur.val + \\\" \\\"); cur = cur.left; } TreeNode top = stack.pop(); cur = top.right; } } // 非递归的中序遍历 void inOrderTraversalNor(TreeNode root) { if (root == null) { return; } Stack<TreeNode> stack = new Stack<>(); TreeNode cur = root; while (cur != null || !stack.empty()) { while (cur != null) { stack.push(cur); cur = cur.left; } TreeNode top = stack.pop(); System.out.print(top.val + \\\" \\\"); cur = top.right; } } // 非递归的后序遍历 void poseOrderTraversalNor(TreeNode root) { if (root == null) { return; } Stack<TreeNode> stack = new Stack<>(); TreeNode pre = null; TreeNode cur = root; while (cur != null || !stack.empty()) { while (cur != null) { stack.push(cur); cur = cur.left; } cur = stack.peek(); if (cur.right == null||pre==cur.right) { TreeNode top = stack.pop(); System.out.print(top.val+ \\\" \\\"); pre=cur; cur=null; } else { cur=cur.right; } } } // 层序遍历 void levelOderTraversal(TreeNode root) { Queue<TreeNode> q1 = new LinkedList<>(); if (root == null) { return; } q1.offer(root); while (!q1.isEmpty()) { TreeNode top = q1.poll(); System.out.print(top.val + \\\" \\\"); if (top.left != null) { q1.offer(top.left); } if (top.right != null) { q1.offer(top.right); } } System.out.println(); }\",\"为什么采用“栈”：\",\"来看二叉树的前序遍历的特点，先遍历根节点，如果根节点存在左子树，则先遍历左子树，再遍历右子树。而对于左子树，也是同样的遍历方式，先遍历该左子树的根节点，再遍历该左子树的左子树，再遍历该左子树的右子树。也即，一直遍历到最左下。遍历到最左下的时候，如果最左下节点无右子树，则需要回溯到它的父节点，以相同的方式遍历右子树。\",\"在这个回溯的过程中，我们需要能够知道上一个最近访问的节点是哪个，根据这个特点，我们很容易想到Stack，也就是栈的特点。栈就是一个后进先出的数据结构，因此，在非递归中采用栈来保存遍历过的节点。\"]},\"1025\":{\"h\":\"easy\"},\"1026\":{\"h\":\"N叉树-简单类型\"},\"1027\":{\"h\":\"LeetCode-98 验证二叉搜索树\"},\"1028\":{\"h\":\"💬 描述\",\"t\":[\"给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征：\",\"节点的左子树只包含小于当前节点的数。\",\"节点的右子树只包含大于当前节点的数。\",\"所有左子树和右子树自身必须也是二叉搜索树。\",\"示例 1:\",\"输入: 2 / \\\\ 1 3 输出: true\",\"示例 2:\",\"输入: 5 / \\\\ 1 4 / \\\\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。\"]},\"1029\":{\"h\":\"📋 代码1- 递归\",\"t\":[\"由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。 我们可以使用递归函数help(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。 根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 help(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 help(root.right, root.val, upper)。\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean helper(TreeNode node, Integer lower, Integer upper) { if (node == null) return true; int val = node.val; if (lower != null && val <= lower) return false; if (upper != null && val >= upper) return false; if (! helper(node.right, val, upper)) return false; if (! helper(node.left, lower, val)) return false; return true; } public boolean isValidBST(TreeNode root) { return helper(root, null, null); } }\",\"复杂度： 时间复杂度 : O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。 空间复杂度 : O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n)。 \"]},\"1030\":{\"h\":\"📋 代码2- 中序遍历\",\"t\":[\"class Solution { public boolean isValidBST(TreeNode root) { Stack<TreeNode> stack = new Stack(); double inorder = - Double.MAX_VALUE; while (!stack.isEmpty() || root != null) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if (root.val <= inorder) return false; inorder = root.val; root = root.right; } return true; } }\",\"复杂度： 时间复杂度 : O(n)，其中 n 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。 空间复杂度 : O(n)，其中 n 为二叉树的节点个数。栈最多存储 n 个节点，因此需要额外的 O(n) 的空间。 \"]},\"1031\":{\"h\":\"💡 思路\",\"t\":[\"见上方注释。\"]},\"1032\":{\"h\":\"LeetCode-199 二叉树的右视图\"},\"1033\":{\"h\":\"💬 描述\",\"t\":[\"给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1:\",\"输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 <--- / \\\\ 2 3 <--- \\\\ \\\\ 5 4 <---\"]},\"1034\":{\"h\":\"📋 代码1- DFS\",\"t\":[\"按照 根结点 -> 右子树 -> 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点。\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { List<Integer> res = new ArrayList<>(); public List<Integer> rightSideView(TreeNode root) { // 首次加入时，深度为0。 dfs(root, 0); return res; } private void dfs(TreeNode node, int depth) { if (node == null) { return; } // 如果深度 == 结果集中的元素数。说明这是当前层的第一个元素。需要加到结果集中。否则不加。为什么呢？首先第一个进入dfs时，传入的深度为0，res长度也为0。这样可以把root加到res中。 接着深度++，考察右孩子。此时深度又等于res元素数，会把右孩子加入res。继续往下... 若到某一层右孩子为null，会直接在上方返回，这样就会考虑左孩子。从而把左孩子加入集合。若左孩子也是null，会进行回溯，回溯到最近的、未考察过左孩子的节点，去考察它的左孩子（回溯时深度也会变小）。此时深度和res的长度是不相等的，这个左孩子不能加到res。就这样一路回溯。遇到合适的元素就会加到res。直到所有元素都考察一遍。 // 这里把深度和结果集的元素数结合了起来，这个思路是以前没想到的- - if (depth == res.size()) { res.add(node.val); } // 准备考察下层元素，深度+1。 depth++; // 先考察右孩子。这样每次就能先判断右边的元素。 dfs(node.right, depth); dfs(node.left, depth); } }\",\"复杂度： 时间和空间均为O(n) 。\"]},\"1035\":{\"h\":\"📋 代码2- BFS\",\"t\":[\"对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。\",\"class Solution { public List<Integer> rightSideView(TreeNode root) { List<Integer> res = new ArrayList<Integer>(); if (root == null) { return res; } Queue<TreeNode> queue = new LinkedList<>(); queue.add(root); int size = 0; while (!queue.isEmpty()) { // 获取当前queue的长度，这也 代表着二叉树当前层元素的数量。 size = queue.size(); // 遍历当前层的元素。为什么用普通for循环？ // 因为这样可以知道是否到达了当前层的最后一个元素。 for (int i = 0; i < size; i++) { // 把当前元素弹出，把它的孩子节点压入。先压左后压右，这样每层最右边的一个元素的值就是需要加到结果集中的。 TreeNode node = queue.poll(); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } // 如果当前节点是当前层的最后一个节点，则把它的值加到结果集中。 if (i == size - 1) { res.add(node.val); } } } return res; } }\",\"复杂度： 时间和空间均为O(n) 。\"]},\"1036\":{\"h\":\"💡 思路\",\"t\":[\"已经写在上方代码注释中。有些之前没想到的思路。代码主要参考自甜姨。\"]},\"1037\":{\"h\":\"LeetCode-236 二叉树的最近公共祖先\"},\"1038\":{\"h\":\"💬 描述\",\"t\":[\"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\",\"百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png\",\"示例 1:\",\"输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。\",\"示例 2:\",\"输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。\",\"注意：数组长度不会超过10000。 \"]},\"1039\":{\"h\":\"💡 思路\",\"t\":[\"遍历数组。ans为最终准备返回的长度值，curLen为当前下标对应的长度。 每次遍历中，如果下一个数比前面的数大，则curLen++，否则代表连续递增中断了，将curLen重置为1。 每次循环的最后，比较ans和curLen，将较大者赋给ans。 循环结束后，返回ans。 \"]},\"1040\":{\"h\":\"📋 代码\",\"t\":[\"class Solution { public int findLengthOfLCIS(int[] nums) { if (nums.length <= 1) return nums.length; int ans = 1, curLen = 1; for (int i = 0; i < nums.length-1; i++) { if (nums[i+1] > nums[i]) { curLen++; } else { curLen = 1; } ans = curLen > ans ? curLen : ans; } return ans; } }\",\"复杂度： 时间：O(n) 空间：O(1) \"]},\"1041\":{\"h\":\"mid\"},\"1042\":{\"h\":\"N叉树-中等难度类型\"},\"1043\":{\"h\":\"hard\"},\"1044\":{\"h\":\"N叉树-hard类型\"},\"1045\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"1046\":{\"h\":\"Java8\"}},\"dirtCount\":0,\"index\":[[\"满足\",{\"1\":{\"1038\":1}}],[\"满足各类使用需求\",{\"1\":{\"827\":1}}],[\"遇到合适的元素就会加到res\",{\"1\":{\"1034\":1}}],[\"遇到的用法\",{\"1\":{\"103\":1}}],[\"考察右孩子\",{\"1\":{\"1034\":1}}],[\"考虑每个水壶\",{\"0\":{\"982\":1}}],[\"考虑的是微服务治理的方方面面\",{\"1\":{\"886\":1}}],[\"考虑其余物品\",{\"1\":{\"207\":1}}],[\"考虑第一件物品\",{\"1\":{\"207\":1}}],[\"考虑前\",{\"1\":{\"207\":1}}],[\"深度+1\",{\"1\":{\"1034\":1}}],[\"深度为0\",{\"1\":{\"1034\":1}}],[\"深入理解java虚拟机\",{\"1\":{\"505\":1}}],[\"深入理解java并发之synchronized实现原理\",{\"1\":{\"278\":1}}],[\"右子树\",{\"1\":{\"1034\":1}}],[\"右击\",{\"1\":{\"55\":1,\"583\":1}}],[\"右击添加了书签的代码\",{\"1\":{\"11\":2}}],[\"见上方注释\",{\"1\":{\"1031\":1}}],[\"见下方spring\",{\"1\":{\"103\":1}}],[\"左子树\",{\"1\":{\"1034\":1}}],[\"左→右→根的顺序打印\",{\"1\":{\"1024\":1}}],[\"左→根→右的顺序打印\",{\"1\":{\"1024\":1}}],[\"左右孩子的深度之和\",{\"1\":{\"1023\":1}}],[\"左右孩子的最大深度\",{\"1\":{\"1023\":1}}],[\"左右子树的结果进行与运算\",{\"1\":{\"1019\":1}}],[\"根结点\",{\"1\":{\"1034\":1}}],[\"根节点的值为\",{\"1\":{\"1028\":1}}],[\"根→左→右的顺序打印\",{\"1\":{\"1024\":1}}],[\"根据二叉搜索树的性质\",{\"1\":{\"1029\":1}}],[\"根据这个特点\",{\"1\":{\"1024\":1}}],[\"根据解码结果调用本地的服务进行相关处理\",{\"1\":{\"874\":1}}],[\"根据年龄分页查询用户信息\",{\"1\":{\"859\":1}}],[\"根据表达式的值动态拼接\",{\"1\":{\"812\":1}}],[\"根据返回结果来判定下一步的逻辑\",{\"1\":{\"762\":1}}],[\"根据前端的请求确定\",{\"1\":{\"755\":1}}],[\"根据分发规则\",{\"1\":{\"693\":1}}],[\"根据spring\",{\"1\":{\"683\":1}}],[\"根据用户是否明确设置了applicationcontextclass类型以及初始化阶段的推断结果\",{\"1\":{\"678\":1}}],[\"根据classpath里面是否存在某个特征类\",{\"1\":{\"678\":1}}],[\"根据逻辑视图名称进行查找\",{\"1\":{\"642\":1}}],[\"根据客户的需求能够动态切换不同的数据源\",{\"1\":{\"628\":1}}],[\"根据传入一个唯一的标识来获得bean对象\",{\"1\":{\"624\":1}}],[\"根据需求的不同\",{\"1\":{\"604\":1}}],[\"根据条件过滤显示的内容\",{\"1\":{\"577\":1}}],[\"根据目标的停顿时间\",{\"1\":{\"527\":1}}],[\"根据\",{\"1\":{\"445\":1,\"817\":1}}],[\"根据字节码指令\",{\"1\":{\"416\":1}}],[\"根据热点探测功能\",{\"1\":{\"366\":1}}],[\"根据虚拟机当前运行状态的不同\",{\"1\":{\"313\":1}}],[\"根据定制排序\",{\"1\":{\"258\":1}}],[\"根据元素的自然顺序\",{\"1\":{\"258\":1}}],[\"根据经验\",{\"1\":{\"230\":1}}],[\"根据变化参数和返回值\",{\"1\":{\"207\":1}}],[\"根据题意可以得知\",{\"1\":{\"200\":1}}],[\"根据题意\",{\"1\":{\"194\":1,\"1023\":1}}],[\"根据文本匹配emoji\",{\"1\":{\"131\":1}}],[\"根据自己的需要设定\",{\"1\":{\"65\":1}}],[\"根据jpa风格的方法名生成sql等功能\",{\"1\":{\"22\":1}}],[\"叶子节点的深度为1\",{\"1\":{\"1023\":1}}],[\"检验\",{\"1\":{\"1018\":1}}],[\"检查句子中的数字是否递增\",{\"0\":{\"957\":1},\"1\":{\"957\":1}}],[\"检查结果\",{\"1\":{\"943\":1}}],[\"检查配置文件中的对应的注册中心ip是否正确\",{\"1\":{\"920\":1}}],[\"检查service实现类是否添加了\",{\"1\":{\"920\":1}}],[\"检查对应的队列中\",{\"1\":{\"194\":1}}],[\"检查一下自己对设计稿的敏感度怎么样\",{\"1\":{\"143\":1}}],[\"导入项目到idea\",{\"0\":{\"1011\":1}}],[\"导致数据库移植性差\",{\"1\":{\"807\":1}}],[\"导致消息丢失\",{\"1\":{\"759\":1}}],[\"导致消息未发送\",{\"1\":{\"707\":1}}],[\"导致\",{\"1\":{\"759\":1}}],[\"导致效率低的问题出现\",{\"1\":{\"718\":1}}],[\"导致这些消息的积压\",{\"1\":{\"705\":1}}],[\"导致用户体验差\",{\"1\":{\"521\":1}}],[\"导致永久代内存不足\",{\"1\":{\"463\":1}}],[\"导致java程序更容易oom\",{\"1\":{\"444\":1}}],[\"导致方法区溢出\",{\"1\":{\"442\":1}}],[\"导致其嵌套调用次数就会减少\",{\"1\":{\"415\":1}}],[\"导致卡顿\",{\"1\":{\"349\":1}}],[\"稍等片刻即可编译成功\",{\"1\":{\"1010\":1}}],[\"稍微高一点的值将是最佳的\",{\"1\":{\"717\":1}}],[\"机翻的介绍\",{\"1\":{\"997\":1}}],[\"断言\",{\"0\":{\"997\":1}}],[\"断言工具\",{\"1\":{\"988\":1}}],[\"拆分\",{\"1\":{\"996\":1}}],[\"拆分字符串\",{\"1\":{\"988\":1}}],[\"首次加入时\",{\"1\":{\"1034\":1}}],[\"首部会有一个空串\",{\"1\":{\"995\":1}}],[\"首先第一个进入dfs时\",{\"1\":{\"1034\":1}}],[\"首先需要实现高性能的网络传输\",{\"1\":{\"919\":1}}],[\"首先服务提供者\",{\"1\":{\"882\":1}}],[\"首先就是长链接\",{\"1\":{\"872\":1}}],[\"首先在配置文件开启该功能\",{\"1\":{\"764\":1}}],[\"首先在容器中查询对应类型的bean\",{\"1\":{\"601\":1}}],[\"首先发布消息后进行备份在缓存里\",{\"1\":{\"761\":1}}],[\"首先启动该消息队列\",{\"1\":{\"701\":1}}],[\"首先把\",{\"1\":{\"701\":1}}],[\"首先遍历执行所有通过springfactoriesloader可以查找到并加载的springapplicationrunlistener\",{\"1\":{\"678\":1}}],[\"首先找到idea中的edit\",{\"1\":{\"671\":1}}],[\"首先想到在spring的applicationcontext中配置所有的datasource\",{\"1\":{\"628\":1}}],[\"首先会尝试找合适的带参数的构造器\",{\"1\":{\"598\":1}}],[\"首先会把该请求委派给父类加载器的\",{\"1\":{\"332\":1}}],[\"首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象\",{\"1\":{\"597\":1}}],[\"首先计算对象占用窒间大小\",{\"1\":{\"471\":1}}],[\"首先去检查这个指令的参数能否在mataspace\",{\"1\":{\"470\":1}}],[\"首先明确\",{\"1\":{\"461\":1}}],[\"首先将数组进行排序\",{\"1\":{\"938\":1}}],[\"首先将数据分为一段一段的存储\",{\"1\":{\"251\":1}}],[\"首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用\",{\"1\":{\"310\":1}}],[\"首先获取到当前线程\",{\"1\":{\"290\":1}}],[\"首先\",{\"1\":{\"280\":1,\"598\":1,\"621\":1,\"964\":1}}],[\"您必须使用它来获得所需的语义\",{\"1\":{\"993\":1}}],[\"辗转相除法\",{\"1\":{\"984\":1}}],[\"倒空y\",{\"1\":{\"982\":1}}],[\"倒空x\",{\"1\":{\"982\":1}}],[\"装满任意一个水壶\",{\"1\":{\"981\":1}}],[\"装饰器模式\",{\"0\":{\"905\":1}}],[\"水壶能装下\",{\"1\":{\"983\":2}}],[\"水壶问题\",{\"0\":{\"980\":1}}],[\"水\",{\"1\":{\"981\":1}}],[\"水平或垂直\",{\"1\":{\"933\":1}}],[\"宫水三叶的刷题日记\",{\"1\":{\"979\":2}}],[\"宫水三叶的刷题笔记\",{\"1\":{\"206\":1,\"208\":1}}],[\"树的高度为\",{\"1\":{\"1029\":1}}],[\"树的遍历分为四种\",{\"1\":{\"1024\":1}}],[\"树的遍历\",{\"0\":{\"1024\":1}}],[\"树类型的算法题总结\",{\"1\":{\"979\":1}}],[\"树\",{\"0\":{\"978\":1,\"979\":1},\"1\":{\"979\":1}}],[\"头\",{\"1\":{\"1023\":1}}],[\"头结点\",{\"1\":{\"970\":1}}],[\"头像等\",{\"1\":{\"139\":1}}],[\"迭代方式\",{\"1\":{\"1024\":1}}],[\"迭代\",{\"0\":{\"968\":1},\"1\":{\"970\":1}}],[\"套路\",{\"1\":{\"964\":1}}],[\"击败27\",{\"1\":{\"957\":1}}],[\"漏掉最后一个元素的情况\",{\"1\":{\"955\":1}}],[\"感觉难点在于循环条件结束的判定上\",{\"1\":{\"955\":1}}],[\"感染到它需要8秒\",{\"1\":{\"943\":1}}],[\"令它的后继节点为head\",{\"1\":{\"964\":1}}],[\"令\",{\"1\":{\"954\":1}}],[\"走到了数组最后一个元素处\",{\"1\":{\"954\":1}}],[\"走到这里说明\",{\"1\":{\"954\":1}}],[\"走到最后一个元素处\",{\"1\":{\"954\":1}}],[\"处的元素\",{\"1\":{\"954\":1}}],[\"处的字符\",{\"1\":{\"954\":1}}],[\"处的字符不同\",{\"1\":{\"954\":1}}],[\"处的字符和\",{\"1\":{\"954\":1}}],[\"处的字符相同\",{\"1\":{\"954\":1}}],[\"处这个字符的压缩\",{\"1\":{\"954\":1}}],[\"处理特殊的调用要求和负责远程调用失败的容错措施\",{\"1\":{\"883\":1}}],[\"处理路由键\",{\"1\":{\"728\":1}}],[\"处理时间长\",{\"1\":{\"718\":1}}],[\"处理速度却很慢\",{\"1\":{\"714\":1}}],[\"处理任务的速度非常快\",{\"1\":{\"714\":1}}],[\"处理了\",{\"1\":{\"709\":1}}],[\"处理业务\",{\"1\":{\"643\":1}}],[\"处理器handler\",{\"1\":{\"646\":1}}],[\"处理器映射器handlermapping\",{\"1\":{\"646\":1}}],[\"处理器映射器handlermapping向前端控制器返回handler\",{\"1\":{\"642\":1}}],[\"处理器适配器handleradapter\",{\"1\":{\"646\":1}}],[\"处理器适配器\",{\"1\":{\"644\":1}}],[\"处理器适配器向前端控制器返回modelandview\",{\"1\":{\"642\":1}}],[\"处理器适配器去执行handler\",{\"1\":{\"642\":1}}],[\"处理并发安全问题\",{\"1\":{\"471\":1}}],[\"处理过程是字节码解析执行的等效过程\",{\"1\":{\"356\":1}}],[\"处理\",{\"1\":{\"332\":1}}],[\"处理该任务\",{\"1\":{\"275\":1}}],[\"处理日期\",{\"1\":{\"159\":1}}],[\"尝试后也ac了\",{\"1\":{\"947\":1}}],[\"尝试减少程序运行期的内存消耗\",{\"1\":{\"450\":1}}],[\"服用code变量\",{\"1\":{\"944\":1}}],[\"服务上线怎么不影响旧版本\",{\"0\":{\"900\":1}}],[\"服务失效踢出基于zookeeper\",{\"1\":{\"899\":1}}],[\"服务引入的流程\",{\"0\":{\"890\":1}}],[\"服务的引入时机有两种\",{\"1\":{\"890\":1}}],[\"服务的暴露起始于\",{\"1\":{\"889\":1}}],[\"服务的真正提供者\",{\"1\":{\"874\":1}}],[\"服务暴露的流程\",{\"0\":{\"889\":1}}],[\"服务互操作\",{\"1\":{\"888\":1}}],[\"服务注册\",{\"1\":{\"885\":1}}],[\"服务注册中心\",{\"1\":{\"878\":1}}],[\"服务自动注册与发现\",{\"1\":{\"884\":1}}],[\"服务提供方和调用方的依赖只依靠一纸契约\",{\"1\":{\"887\":1}}],[\"服务提供者端设置超时时间\",{\"1\":{\"918\":1}}],[\"服务提供者能实现失效踢出是什么原理\",{\"0\":{\"899\":1}}],[\"服务提供者和消费者都会生成一个代理类\",{\"1\":{\"883\":1}}],[\"服务提供者和消费者都会在内存中记录着调用的次数和时间\",{\"1\":{\"882\":1}}],[\"服务提供者\",{\"1\":{\"882\":1}}],[\"服务提供商\",{\"1\":{\"135\":1}}],[\"服务运行的容器\",{\"1\":{\"882\":1}}],[\"服务路由\",{\"1\":{\"881\":1}}],[\"服务发现\",{\"1\":{\"881\":1}}],[\"服务调用是阻塞的吗\",{\"0\":{\"896\":1}}],[\"服务调用的流程\",{\"0\":{\"891\":1}}],[\"服务调用\",{\"1\":{\"881\":1}}],[\"服务调用方\",{\"1\":{\"874\":1}}],[\"服务之间的调用和依赖关系也越来越复杂\",{\"1\":{\"881\":1}}],[\"服务之间通过简单\",{\"1\":{\"875\":1}}],[\"服务越来越多\",{\"1\":{\"881\":1}}],[\"服务层是soa的基础\",{\"1\":{\"875\":1}}],[\"服务消费方得到最终结果\",{\"1\":{\"874\":1}}],[\"服务消费者端设置超时时间\",{\"1\":{\"918\":1}}],[\"服务消费者\",{\"1\":{\"874\":2,\"882\":2}}],[\"服务端线程不会定制\",{\"1\":{\"918\":1}}],[\"服务端接受请求之后会通过参数找到之前暴露存储的\",{\"1\":{\"891\":1}}],[\"服务端提供的服务如何暴露给客户端\",{\"1\":{\"876\":1}}],[\"服务端\",{\"1\":{\"874\":1}}],[\"服务端存根\",{\"1\":{\"874\":4,\"878\":1}}],[\"服务端返回\",{\"1\":{\"722\":1}}],[\"服务框架\",{\"1\":{\"873\":1,\"885\":1}}],[\"服务化治理\",{\"1\":{\"872\":1}}],[\"服务停掉以后\",{\"1\":{\"710\":1}}],[\"服务器端\",{\"1\":{\"353\":1}}],[\"服务器\",{\"1\":{\"340\":1,\"873\":1}}],[\"服务器上的\",{\"1\":{\"80\":1}}],[\"服务\",{\"1\":{\"135\":1,\"303\":1,\"888\":1}}],[\"纵坐标\",{\"1\":{\"943\":1}}],[\"横坐标\",{\"1\":{\"943\":1}}],[\"烂橘子\",{\"1\":{\"943\":1}}],[\"腐烂值+1\",{\"1\":{\"943\":1}}],[\"腐烂的橘子\",{\"0\":{\"941\":1}}],[\"掌握了dfs就ok了\",{\"1\":{\"935\":1}}],[\"掌握了泄漏对象的类型信息\",{\"1\":{\"450\":1}}],[\"岛屿\",{\"1\":{\"933\":1}}],[\"岛屿的最大面积\",{\"0\":{\"932\":1}}],[\"赋值\",{\"1\":{\"925\":1}}],[\"附带详细答案\",{\"1\":{\"921\":1}}],[\"埋点上报调用情况等等\",{\"1\":{\"919\":1}}],[\"毕竟远程交互都需要遵循一定的协议\",{\"1\":{\"919\":1}}],[\"毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态\",{\"1\":{\"278\":1}}],[\"逐个调用\",{\"1\":{\"917\":1}}],[\"逐一定义数据库列名和对象属性名之间的映射关系\",{\"1\":{\"808\":1}}],[\"截面碰撞率高\",{\"1\":{\"916\":1}}],[\"截短流\",{\"1\":{\"548\":1}}],[\"观察者模式\",{\"0\":{\"906\":1}}],[\"观察openjdk中的源码变化\",{\"1\":{\"504\":1}}],[\"命名规则是\",{\"1\":{\"901\":1}}],[\"命令来运行\",{\"1\":{\"686\":1}}],[\"命令行\",{\"1\":{\"668\":1}}],[\"命令行工具\",{\"0\":{\"340\":1}}],[\"命令为例\",{\"1\":{\"90\":1}}],[\"命令\",{\"1\":{\"90\":1,\"340\":1,\"774\":1,\"1010\":1}}],[\"命令生成\",{\"1\":{\"78\":1}}],[\"命令和构建操作无关\",{\"1\":{\"72\":1}}],[\"订阅时\",{\"1\":{\"906\":1}}],[\"订阅模式通知数据变更\",{\"1\":{\"897\":1}}],[\"订单十分钟内未支付则关闭\",{\"1\":{\"751\":1}}],[\"订单在十分钟之内未支付则自动取消\",{\"1\":{\"751\":1}}],[\"🔗\",{\"0\":{\"942\":1,\"947\":1,\"962\":1,\"972\":1}}],[\"💬\",{\"0\":{\"929\":1,\"933\":1,\"937\":1,\"953\":1,\"967\":1,\"981\":1,\"1018\":1,\"1028\":1,\"1033\":1,\"1038\":1}}],[\"💡\",{\"0\":{\"926\":1,\"927\":1,\"930\":1,\"935\":1,\"940\":1,\"955\":1,\"964\":1,\"970\":1,\"974\":1,\"985\":1,\"1019\":1,\"1023\":1,\"1031\":1,\"1036\":1,\"1039\":1}}],[\"📋\",{\"0\":{\"925\":1,\"931\":1,\"934\":1,\"938\":1,\"939\":1,\"943\":1,\"944\":1,\"945\":1,\"948\":1,\"949\":1,\"954\":1,\"963\":1,\"965\":1,\"968\":1,\"969\":1,\"973\":1,\"982\":1,\"983\":1,\"984\":1,\"1020\":1,\"1022\":1,\"1029\":1,\"1030\":1,\"1034\":1,\"1035\":1,\"1040\":1}}],[\"🔴dubbo\",{\"0\":{\"895\":1}}],[\"👾\",{\"1\":{\"870\":1}}],[\"答的很细致\",{\"1\":{\"919\":1}}],[\"答\",{\"1\":{\"893\":1}}],[\"答案不受影响\",{\"1\":{\"198\":1}}],[\"问这个问题就是看你有没有深入的了解\",{\"1\":{\"893\":1}}],[\"问\",{\"1\":{\"892\":1}}],[\"问题就出现了\",{\"1\":{\"628\":1}}],[\"问题就来了\",{\"1\":{\"435\":1}}],[\"问题\",{\"0\":{\"20\":1,\"358\":1,\"359\":1},\"1\":{\"319\":1,\"522\":1}}],[\"嘛\",{\"0\":{\"892\":1}}],[\"唤醒等待的线程\",{\"1\":{\"891\":1}}],[\"负载均衡\",{\"1\":{\"891\":1}}],[\"负载均衡机制选择一个\",{\"1\":{\"891\":1}}],[\"负责监控统计调用时间和次数\",{\"1\":{\"883\":1}}],[\"负责选取具体调用的节点\",{\"1\":{\"883\":1}}],[\"负责生产和管理\",{\"1\":{\"610\":1}}],[\"负责加载当前应用\",{\"1\":{\"331\":1}}],[\"负责加载\",{\"1\":{\"331\":1}}],[\"期间会包含\",{\"1\":{\"890\":1}}],[\"得知提供者的信息之后会进入\",{\"1\":{\"890\":1}}],[\"得到最后的结果是\",{\"1\":{\"1024\":1}}],[\"得到它的深度\",{\"1\":{\"1023\":1}}],[\"得到相应的\",{\"1\":{\"891\":1}}],[\"得到的\",{\"1\":{\"889\":1}}],[\"得到的余数才能用来要存放的位置也就是对应的数组下标\",{\"1\":{\"246\":1}}],[\"得到所有的配置类\",{\"1\":{\"674\":1}}],[\"得到一个\",{\"1\":{\"317\":1}}],[\"懒汉式是只有当这个服务被注入到其他类中时启动引入流程\",{\"1\":{\"890\":1}}],[\"懒加载\",{\"1\":{\"160\":1}}],[\"饿汉式就是加载完毕就会引入\",{\"1\":{\"890\":1}}],[\"太细的谁都记住不\",{\"1\":{\"889\":1}}],[\"太鼓达人网页版\",{\"1\":{\"142\":1}}],[\"供之后的远程调用查找\",{\"1\":{\"889\":1}}],[\"协议的引入\",{\"1\":{\"890\":1}}],[\"协议的远程方法调用的框架\",{\"1\":{\"879\":1}}],[\"协议\",{\"1\":{\"889\":1,\"892\":1}}],[\"失败自动恢复\",{\"1\":{\"917\":1}}],[\"失败自动切换\",{\"1\":{\"917\":1}}],[\"失败安全\",{\"1\":{\"917\":1}}],[\"失败立即报错\",{\"1\":{\"917\":1}}],[\"失败容错\",{\"1\":{\"885\":1}}],[\"失败重试\",{\"1\":{\"471\":1}}],[\"响应\",{\"1\":{\"885\":1}}],[\"响应给客户\",{\"1\":{\"651\":1}}],[\"透明化的远程方法调用\",{\"1\":{\"884\":1}}],[\"抽象了网络传输的统一接口\",{\"1\":{\"883\":1}}],[\"职责边界清晰才能更好的扩展\",{\"1\":{\"883\":1}}],[\"业务层\",{\"1\":{\"883\":2}}],[\"业界主流的幂等性有两种操作\",{\"1\":{\"774\":1}}],[\"诞生了面向服务的架构体系\",{\"1\":{\"881\":1}}],[\"没什么太大区别\",{\"1\":{\"875\":1}}],[\"没有额外的参数\",{\"1\":{\"997\":1}}],[\"没有必要\",{\"1\":{\"919\":1}}],[\"没有往这方面想过答出来的东西就会没有条理性\",{\"1\":{\"919\":1}}],[\"没有返回值的可以这么做\",{\"1\":{\"896\":1}}],[\"没有\",{\"1\":{\"866\":1}}],[\"没有声明\",{\"1\":{\"755\":1}}],[\"没有消费这接收这个消息\",{\"1\":{\"738\":1}}],[\"没有对传递的消息数量进行限制\",{\"1\":{\"705\":1}}],[\"没有数据库的事务支持\",{\"1\":{\"633\":1}}],[\"没有线程交互的开销\",{\"1\":{\"530\":1}}],[\"没有最好的算法\",{\"1\":{\"524\":1}}],[\"没有碎片\",{\"1\":{\"522\":1}}],[\"没有标记和清除过程\",{\"1\":{\"522\":1}}],[\"没有gc就不能保证应用程序的正常进行\",{\"1\":{\"516\":1}}],[\"没有引用了就必然会回收\",{\"1\":{\"464\":1}}],[\"没有永久代\",{\"1\":{\"462\":1}}],[\"没有父加载器\",{\"1\":{\"382\":1}}],[\"没有任何api侵入\",{\"1\":{\"884\":1}}],[\"没有任何引用链相连的话\",{\"1\":{\"322\":1}}],[\"没有任何三方jar文件会打入最终输出的jar中\",{\"1\":{\"106\":1}}],[\"没有这样的机制\",{\"1\":{\"239\":1}}],[\"没有指定类型的话会报错\",{\"1\":{\"235\":1}}],[\"没有总结的会在后续补充\",{\"1\":{\"165\":1}}],[\"精确定义接口进行通讯\",{\"1\":{\"875\":1}}],[\"松耦合服务架构\",{\"1\":{\"875\":1}}],[\"跨越语言的c\",{\"1\":{\"879\":1}}],[\"跨平台\",{\"1\":{\"875\":1}}],[\"跨语言\",{\"1\":{\"875\":1}}],[\"跨域可以在前端通过\",{\"1\":{\"673\":1}}],[\"易用\",{\"1\":{\"875\":1}}],[\"易错点\",{\"1\":{\"187\":1}}],[\"序列化存在安全漏洞\",{\"1\":{\"888\":1}}],[\"序列化层\",{\"1\":{\"883\":1}}],[\"序列化方式\",{\"1\":{\"881\":1}}],[\"序列化和反序列化\",{\"1\":{\"878\":1}}],[\"序列化\",{\"1\":{\"873\":1,\"874\":1,\"878\":1,\"888\":1}}],[\"严格匹配数据源\",{\"1\":{\"866\":1}}],[\"受影响的行数\",{\"1\":{\"854\":1}}],[\"情况2\",{\"1\":{\"837\":1}}],[\"情况1\",{\"1\":{\"837\":1}}],[\"情况的区域\",{\"1\":{\"399\":1}}],[\"泛型\",{\"1\":{\"833\":1}}],[\"泛型要记得替换\",{\"1\":{\"832\":1}}],[\"泛指一类\",{\"1\":{\"206\":1}}],[\"慢查询\",{\"1\":{\"827\":1}}],[\"慢10倍以上\",{\"1\":{\"495\":1}}],[\"形式调用\",{\"1\":{\"827\":2}}],[\"形成一条流的流水线\",{\"1\":{\"547\":1}}],[\"损耗小\",{\"1\":{\"827\":1}}],[\"乐观锁\",{\"0\":{\"860\":1},\"1\":{\"826\":1}}],[\"逻辑删除\",{\"0\":{\"839\":1},\"1\":{\"826\":1,\"839\":1}}],[\"别忘了在配置文件中配置你编写的插件\",{\"1\":{\"818\":1}}],[\"拦截\",{\"1\":{\"817\":1}}],[\"拦截器配置\",{\"1\":{\"656\":1}}],[\"拦截器可以多次被调用\",{\"1\":{\"648\":1}}],[\"拦截器可以访问action上下文\",{\"1\":{\"648\":1}}],[\"拦截器只能对action请求起作用\",{\"1\":{\"648\":1}}],[\"拦截器是基于java的反射机制的\",{\"1\":{\"648\":1}}],[\"拦截器是在面向切面编程中应用的\",{\"1\":{\"648\":1}}],[\"拦截器不是在web\",{\"1\":{\"648\":1}}],[\"拦截器\",{\"1\":{\"648\":1,\"656\":1,\"821\":1}}],[\"掉并重新更新\",{\"1\":{\"813\":1}}],[\"片段\",{\"1\":{\"811\":1}}],[\"片段标签\",{\"1\":{\"811\":1}}],[\"片段的小型\",{\"1\":{\"615\":1}}],[\"号占位符设置参数值\",{\"1\":{\"810\":1}}],[\"号\",{\"1\":{\"810\":1}}],[\"尤其当字段多\",{\"1\":{\"807\":1}}],[\"尤其是在消息量特别大的时候\",{\"1\":{\"782\":1}}],[\"尤其是类型的卸载\",{\"1\":{\"464\":1}}],[\"避免引起提供者的剧烈变动\",{\"1\":{\"916\":1}}],[\"避免自己对业务代码的入侵\",{\"1\":{\"910\":1}}],[\"避免使用字符串表示字段\",{\"1\":{\"853\":1}}],[\"避免user对象中没有被查询到的列值为null\",{\"1\":{\"849\":1}}],[\"避免了几乎所有的\",{\"1\":{\"806\":1}}],[\"避免类的重复加载\",{\"1\":{\"393\":1}}],[\"细腻化到每个\",{\"1\":{\"788\":1}}],[\"细节做得很好\",{\"1\":{\"137\":1}}],[\"授权异常\",{\"1\":{\"788\":1}}],[\"搜寻匿名标记\",{\"1\":{\"788\":1}}],[\"搜索其中带有\",{\"1\":{\"789\":1}}],[\"搜索神器\",{\"1\":{\"143\":1}}],[\"搜索替换\",{\"1\":{\"41\":1}}],[\"搜索\",{\"1\":{\"6\":1}}],[\"密码加密方式\",{\"1\":{\"788\":1}}],[\"宕机亦或者是由于维护而关闭等\",{\"1\":{\"782\":1}}],[\"惰性队列就很有必要了\",{\"1\":{\"782\":1}}],[\"惰性队列会尽可能的将消息存入磁盘中\",{\"1\":{\"782\":1}}],[\"惰性队列\",{\"0\":{\"781\":1}}],[\"肯定是要分大客户和小客户的对吧\",{\"1\":{\"776\":1}}],[\"肯定确认应答\",{\"1\":{\"706\":1}}],[\"商家对我们来说\",{\"1\":{\"776\":1}}],[\"淘宝会及时将订单推送给我们\",{\"1\":{\"776\":1}}],[\"天然具有幂等性\",{\"1\":{\"774\":1}}],[\"天猫\",{\"1\":{\"465\":1,\"518\":1}}],[\"劣势就是在高并发时\",{\"1\":{\"774\":1}}],[\"未考察过左孩子的节点\",{\"1\":{\"1034\":1}}],[\"未收到确认信息\",{\"1\":{\"772\":1}}],[\"未确认消息个数\",{\"1\":{\"723\":1}}],[\"故最坏情况下空间复杂度为\",{\"1\":{\"1029\":1}}],[\"故\",{\"1\":{\"772\":1}}],[\"举个例子\",{\"1\":{\"943\":1}}],[\"举个最简单的例子\",{\"1\":{\"771\":1}}],[\"举例\",{\"1\":{\"816\":1,\"817\":1}}],[\"举例栈溢出的情况\",{\"0\":{\"427\":1}}],[\"举例说明线程池调优\",{\"0\":{\"277\":1}}],[\"幂等性\",{\"0\":{\"770\":1}}],[\"谁短返回谁\",{\"1\":{\"954\":1}}],[\"谁优先级高\",{\"1\":{\"768\":1}}],[\"谁空谁就是to\",{\"1\":{\"490\":1}}],[\"报警发现不可路由消息\",{\"1\":{\"768\":1}}],[\"报警消费者\",{\"1\":{\"768\":1}}],[\"报错信息说没有main方法\",{\"1\":{\"392\":1}}],[\"报错\",{\"1\":{\"233\":1,\"990\":1}}],[\"入参等信息序列化\",{\"1\":{\"874\":1}}],[\"入这个队列了\",{\"1\":{\"767\":1}}],[\"入栈\",{\"1\":{\"408\":1}}],[\"备胎\",{\"1\":{\"767\":1}}],[\"备份交换机可以理解为\",{\"1\":{\"767\":1}}],[\"备份交换机\",{\"0\":{\"766\":1}}],[\"理这些无法路由的消息是很不优雅的做法\",{\"1\":{\"767\":1}}],[\"理念集中体现在\",{\"1\":{\"69\":1}}],[\"退回\",{\"1\":{\"765\":3}}],[\"退回原因\",{\"1\":{\"765\":1}}],[\"退出内层循环后判断\",{\"1\":{\"957\":1}}],[\"退出或由于某种原因崩溃时\",{\"1\":{\"710\":1}}],[\"退出\",{\"0\":{\"347\":1}}],[\"旧版\",{\"1\":{\"764\":1}}],[\"迟\",{\"1\":{\"757\":1}}],[\"送\",{\"1\":{\"757\":1}}],[\"送你一份spring\",{\"1\":{\"661\":1}}],[\"界面\",{\"1\":{\"756\":1}}],[\"界面的端口是\",{\"1\":{\"695\":1}}],[\"地址\",{\"1\":{\"910\":1,\"1004\":1,\"1005\":1}}],[\"地址路由\",{\"1\":{\"885\":1}}],[\"地址进行下载\",{\"1\":{\"756\":1}}],[\"地址播放\",{\"1\":{\"143\":1}}],[\"却后执行\",{\"1\":{\"755\":1}}],[\"却为业务模块所共同调用的逻辑或责任\",{\"1\":{\"596\":1}}],[\"死亡\",{\"1\":{\"755\":1}}],[\"死信交换机\",{\"1\":{\"754\":1,\"755\":1}}],[\"死信交换机名称\",{\"1\":{\"747\":2,\"748\":1,\"749\":2}}],[\"死信消息被拒\",{\"0\":{\"749\":1}}],[\"死信最大长度\",{\"0\":{\"748\":1}}],[\"死信实战\",{\"0\":{\"746\":1}}],[\"死信的来源\",{\"0\":{\"745\":1}}],[\"死信的概念\",{\"0\":{\"744\":1}}],[\"死信\",{\"1\":{\"744\":1,\"752\":1}}],[\"死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃\",{\"1\":{\"758\":1}}],[\"死信队列绑定\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"死信队列\",{\"0\":{\"743\":1},\"1\":{\"697\":1,\"754\":1}}],[\"看了官方题解\",{\"1\":{\"957\":1}}],[\"看需要适用的场景\",{\"1\":{\"758\":1}}],[\"看起来似乎没什么问题\",{\"1\":{\"755\":1}}],[\"看图轻松理解数据结构与算法系列\",{\"1\":{\"229\":1}}],[\"番外\",{\"1\":{\"754\":1}}],[\"岂不是要增加无数个队列才能满足需求\",{\"1\":{\"754\":1}}],[\"岂不是每增加一个新的时间需求\",{\"1\":{\"754\":1}}],[\"监控层\",{\"1\":{\"883\":1}}],[\"监听优先级队列\",{\"1\":{\"780\":1}}],[\"监听\",{\"1\":{\"762\":1}}],[\"监听延时队列\",{\"1\":{\"757\":1}}],[\"监听死信队列\",{\"1\":{\"754\":1}}],[\"监听死信队列是否出现消息\",{\"1\":{\"754\":1}}],[\"监视与管理控制台\",{\"1\":{\"341\":1}}],[\"监视器锁可以认为直接对应底层操作系统中的互斥量\",{\"1\":{\"278\":1}}],[\"刚刚又介绍了\",{\"1\":{\"753\":1}}],[\"刚切换到idea时都配置了eclipse的keymap\",{\"1\":{\"6\":1}}],[\"毫秒的信息给队列\",{\"1\":{\"757\":1}}],[\"毫秒的时间片段内\",{\"1\":{\"535\":1}}],[\"毫秒\",{\"1\":{\"752\":1,\"755\":1,\"780\":1}}],[\"活动期间甚至会达到百万甚至千万级别\",{\"1\":{\"751\":1}}],[\"预防误操作\",{\"1\":{\"827\":1}}],[\"预定会议后\",{\"1\":{\"751\":1}}],[\"预取值为\",{\"1\":{\"717\":1}}],[\"预取值对用户吞吐量有重大影响\",{\"1\":{\"717\":1}}],[\"预取值分发\",{\"0\":{\"716\":1}}],[\"预取计数\",{\"1\":{\"717\":1}}],[\"延迟加载\",{\"1\":{\"909\":1}}],[\"延迟队列使用场景\",{\"1\":{\"751\":1}}],[\"延迟队列概念\",{\"1\":{\"751\":1}}],[\"延迟队列介绍\",{\"0\":{\"751\":1}}],[\"延迟队列\",{\"0\":{\"750\":1}}],[\"延迟队列等会用到\",{\"1\":{\"697\":1}}],[\"延\",{\"1\":{\"757\":1}}],[\"延时\",{\"1\":{\"755\":1}}],[\"延时队列还有很多其它选择\",{\"1\":{\"758\":1}}],[\"延时队列在需要延时处理的场景下非常有用\",{\"1\":{\"758\":1}}],[\"延时队列ttl优化\",{\"0\":{\"755\":1}}],[\"延时队列就可以新鲜出炉了\",{\"1\":{\"753\":1}}],[\"延时队列就是用来存放需要在指定时间被处理的\",{\"1\":{\"751\":1}}],[\"延时队列中的元素是希望\",{\"1\":{\"751\":1}}],[\"延时队列\",{\"1\":{\"751\":1,\"753\":1}}],[\"拒收消息\",{\"1\":{\"749\":1}}],[\"拒绝签收后的消息也会被自己消费到\",{\"1\":{\"706\":1}}],[\"拒绝签收\",{\"1\":{\"706\":1}}],[\"拒绝策略共有4种\",{\"1\":{\"275\":1}}],[\"普通队列占用内存是\",{\"1\":{\"784\":1}}],[\"普通交换机名称\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"普通的\",{\"1\":{\"686\":1}}],[\"例子\",{\"1\":{\"741\":1}}],[\"例如极端的情况\",{\"1\":{\"939\":1}}],[\"例如输入\",{\"1\":{\"939\":1}}],[\"例如order\",{\"1\":{\"861\":1}}],[\"例如实体类属性name\",{\"1\":{\"837\":1}}],[\"例如实体类属性username\",{\"1\":{\"837\":1}}],[\"例如发送\",{\"1\":{\"748\":1,\"749\":1}}],[\"例如我们希望将日志消息写入磁盘的程序仅接收严重错误\",{\"1\":{\"736\":1}}],[\"例如我们只把严重错误消息定向存储到日志文件\",{\"1\":{\"735\":1}}],[\"例如jdbc\",{\"1\":{\"667\":1}}],[\"例如日志管理和事务管理\",{\"1\":{\"604\":1}}],[\"例如事务处理\",{\"1\":{\"596\":1}}],[\"例如作为调用参数传递到其他地方中\",{\"1\":{\"506\":1}}],[\"例如这个对象是哪个类的实例\",{\"1\":{\"313\":1}}],[\"例如\",{\"1\":{\"65\":2,\"94\":1,\"97\":1,\"99\":2,\"230\":1,\"242\":1,\"273\":2,\"425\":1,\"435\":1,\"444\":1,\"604\":1,\"615\":1,\"651\":1,\"685\":1,\"717\":1,\"905\":1,\"995\":1,\"1038\":1}}],[\"带宽会比较多\",{\"1\":{\"798\":1}}],[\"带\",{\"1\":{\"741\":1,\"742\":1}}],[\"带权的消息分发\",{\"1\":{\"717\":1}}],[\"井号\",{\"1\":{\"740\":1}}],[\"星号\",{\"1\":{\"740\":1}}],[\"星期二\",{\"1\":{\"573\":1}}],[\"吗\",{\"1\":{\"730\":1}}],[\"临时队列\",{\"0\":{\"730\":1}}],[\"扇出\",{\"1\":{\"728\":1}}],[\"匹配规则\",{\"1\":{\"728\":1}}],[\"匹配不多不少一个词\",{\"1\":{\"728\":1}}],[\"匹配一个或多个词\",{\"1\":{\"728\":1}}],[\"匹配查询表中的\",{\"1\":{\"693\":1}}],[\"合理的吞吐量\",{\"1\":{\"724\":1}}],[\"合并从aaa到bbb的所有提交\",{\"1\":{\"584\":2}}],[\"合并aaa\",{\"1\":{\"584\":1}}],[\"合并某个或某些提交到其他分支\",{\"0\":{\"582\":1}}],[\"合并命令\",{\"1\":{\"28\":1}}],[\"异步调用会返回一个future对象\",{\"1\":{\"896\":1}}],[\"异步转同步如何实现的\",{\"0\":{\"895\":1}}],[\"异步\",{\"1\":{\"888\":1}}],[\"异步处理\",{\"1\":{\"724\":1}}],[\"异步确认虽然编程逻辑比上两个要复杂\",{\"1\":{\"724\":1}}],[\"异步确认发布\",{\"0\":{\"724\":1}}],[\"异常通知\",{\"1\":{\"604\":1}}],[\"异常表\",{\"1\":{\"454\":1}}],[\"异常\",{\"1\":{\"305\":1,\"338\":1,\"409\":2,\"422\":1,\"459\":1,\"470\":1,\"485\":1}}],[\"异常处理等\",{\"1\":{\"596\":1}}],[\"异常处理\",{\"1\":{\"301\":1,\"399\":1}}],[\"批量\",{\"1\":{\"826\":1}}],[\"批量同步等待确认\",{\"1\":{\"724\":1}}],[\"批量发布消息\",{\"1\":{\"724\":1}}],[\"批量确认消息大小\",{\"1\":{\"723\":1}}],[\"批量确认发布\",{\"0\":{\"723\":1},\"1\":{\"723\":1}}],[\"批量执行sql\",{\"0\":{\"28\":1}}],[\"行代码\",{\"1\":{\"712\":1}}],[\"行代码的睡眠时间改为\",{\"1\":{\"708\":1}}],[\"短期内未支付的订单数据可能会有很多\",{\"1\":{\"751\":1}}],[\"短\",{\"1\":{\"708\":1,\"714\":1,\"717\":1}}],[\"短域名服务\",{\"1\":{\"127\":1}}],[\"停止运行\",{\"1\":{\"708\":1}}],[\"停顿时间\",{\"1\":{\"535\":1}}],[\"停顿时间要求的同时\",{\"1\":{\"535\":1}}],[\"十秒消费一个消息\",{\"1\":{\"708\":1}}],[\"示己拒绝处理该消息\",{\"1\":{\"706\":1}}],[\"示例2\",{\"1\":{\"953\":1}}],[\"示例1\",{\"1\":{\"953\":1}}],[\"示例代码如下\",{\"1\":{\"241\":1}}],[\"示例\",{\"1\":{\"207\":2,\"651\":1,\"929\":2,\"933\":2,\"937\":2,\"967\":1,\"981\":2,\"1018\":2,\"1028\":2,\"1033\":1,\"1038\":2}}],[\"突然有个消费者挂掉了\",{\"1\":{\"704\":1}}],[\"便立即将该消息标记为删除\",{\"1\":{\"704\":1}}],[\"便于运维\",{\"1\":{\"919\":1}}],[\"便于统一管理\",{\"1\":{\"807\":1}}],[\"便于减少系统的重复代码\",{\"1\":{\"596\":1}}],[\"便于共同引用同一个lib目录\",{\"1\":{\"106\":1}}],[\"绑定关系如下\",{\"1\":{\"755\":1,\"757\":1}}],[\"绑定关系\",{\"1\":{\"754\":1}}],[\"绑定\",{\"1\":{\"738\":2,\"754\":4,\"755\":1}}],[\"绑定键有两个\",{\"1\":{\"736\":1}}],[\"绑定键为\",{\"1\":{\"736\":3}}],[\"绑定类型是\",{\"1\":{\"736\":1}}],[\"绑定了两个队列\",{\"1\":{\"736\":1}}],[\"绑定之后的意义由其交换类型决定\",{\"1\":{\"735\":1}}],[\"绑定用参数\",{\"1\":{\"735\":1}}],[\"绑定是交换机和队列之间的桥梁关系\",{\"1\":{\"735\":1}}],[\"绑定是一个字段\",{\"1\":{\"420\":1}}],[\"绑定bindings\",{\"0\":{\"731\":1}}],[\"绑定指定的\",{\"1\":{\"729\":1}}],[\"绑定时指定的键值对进行匹配\",{\"1\":{\"728\":1}}],[\"绑定死信队列\",{\"1\":{\"702\":1}}],[\"旁边有\",{\"1\":{\"702\":2}}],[\"弹出下拉菜单\",{\"1\":{\"702\":1}}],[\"页面添加队列时\",{\"1\":{\"783\":1}}],[\"页面添加\",{\"1\":{\"777\":1}}],[\"页面\",{\"1\":{\"702\":1,\"777\":1}}],[\"函数表示考虑以\",{\"1\":{\"1029\":1}}],[\"函数即可\",{\"1\":{\"701\":1}}],[\"函数库直接分配堆外内存\",{\"1\":{\"308\":1}}],[\"案例中生产者叫做\",{\"1\":{\"700\":1}}],[\"手动复制日志会更加麻烦而且容易出错\",{\"1\":{\"767\":1}}],[\"手动消息应答的方法\",{\"0\":{\"706\":1}}],[\"手动应答案例\",{\"0\":{\"708\":1}}],[\"手动应答的好处是可以批量应答并且减少网络拥堵\",{\"1\":{\"706\":1}}],[\"手动应答\",{\"1\":{\"698\":1}}],[\"手动实现\",{\"1\":{\"234\":1}}],[\"何去何从\",{\"1\":{\"697\":1}}],[\"何为清除\",{\"1\":{\"521\":1}}],[\"路由\",{\"1\":{\"891\":1}}],[\"路由等节点\",{\"1\":{\"890\":1}}],[\"路由和集群容错层\",{\"1\":{\"883\":1}}],[\"路由key\",{\"1\":{\"765\":2}}],[\"路由键\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"路由的\",{\"1\":{\"697\":1}}],[\"路径下的内容\",{\"1\":{\"382\":1}}],[\"路径可变\",{\"1\":{\"99\":1}}],[\"信道\",{\"1\":{\"697\":1}}],[\"信息交换层\",{\"1\":{\"883\":1}}],[\"信息给队列\",{\"1\":{\"755\":1,\"780\":1}}],[\"信息被保\",{\"1\":{\"693\":1}}],[\"信息\",{\"0\":{\"453\":1,\"454\":1},\"1\":{\"473\":1,\"612\":1,\"738\":4}}],[\"步骤\",{\"1\":{\"697\":1}}],[\"步骤图\",{\"1\":{\"695\":1}}],[\"添入依赖\",{\"1\":{\"696\":1}}],[\"添加乐观锁插件\",{\"1\":{\"860\":1}}],[\"添加分页插件\",{\"1\":{\"860\":1}}],[\"添加实现\",{\"1\":{\"833\":1}}],[\"添加接口\",{\"1\":{\"833\":1}}],[\"添加对应的物理分页语句和物理分页参数\",{\"1\":{\"817\":1}}],[\"添加方法\",{\"0\":{\"777\":1}}],[\"添加配置类\",{\"0\":{\"857\":1},\"1\":{\"762\":1}}],[\"添加回调函数\",{\"1\":{\"724\":1}}],[\"添加队列\",{\"1\":{\"702\":1}}],[\"添加依赖\",{\"0\":{\"696\":1},\"1\":{\"753\":1}}],[\"添加完毕后需要使用mvn指令运行\",{\"1\":{\"671\":1}}],[\"添加元素\",{\"1\":{\"249\":2}}],[\"添加环境变量\",{\"1\":{\"62\":1}}],[\"添加助记符\",{\"1\":{\"11\":1}}],[\"添加书签\",{\"1\":{\"11\":1}}],[\"端口\",{\"1\":{\"695\":1,\"753\":1}}],[\"极大减少了操作系统建立\",{\"1\":{\"693\":1}}],[\"识别\",{\"1\":{\"693\":1}}],[\"户端和\",{\"1\":{\"693\":1}}],[\"许多消费者可以尝试从一个队列接收数据\",{\"1\":{\"692\":1}}],[\"许多生产者可以将消息发送到一个队列\",{\"1\":{\"692\":1}}],[\"亦或者是把消息丢弃\",{\"1\":{\"692\":1}}],[\"像上面的adaptive实现\",{\"1\":{\"904\":1}}],[\"像上面这样使用没有问题\",{\"1\":{\"792\":1}}],[\"像mybatis的mybatis\",{\"1\":{\"682\":1}}],[\"像做\",{\"1\":{\"148\":1}}],[\"嘿\",{\"1\":{\"678\":1}}],[\"告诉\",{\"1\":{\"704\":1}}],[\"告诉他们\",{\"1\":{\"678\":1}}],[\"告诉这些springapplicationrunlistener\",{\"1\":{\"678\":1}}],[\"告知c++编译器去调用一个c的函数\",{\"1\":{\"434\":1}}],[\"推送的消息如何进行消费的接口回调\",{\"1\":{\"779\":1}}],[\"推送的消息进行消费的接口回调\",{\"1\":{\"698\":1}}],[\"推送到队列中\",{\"1\":{\"692\":1}}],[\"推断并设置main方法的定义类\",{\"1\":{\"678\":1}}],[\"推荐如果能在服务端多配置就尽量多配置\",{\"1\":{\"918\":1}}],[\"推荐使用hessian序列化\",{\"1\":{\"898\":1}}],[\"推荐使用\",{\"1\":{\"897\":1}}],[\"推荐使用wait\",{\"1\":{\"273\":1}}],[\"推荐封装为一个map\",{\"1\":{\"819\":1}}],[\"推荐的一种方式\",{\"1\":{\"638\":1}}],[\"推荐阅读\",{\"1\":{\"595\":1}}],[\"推荐在初始化localdate和localdatetime对象的时候\",{\"1\":{\"566\":1}}],[\"推荐\",{\"0\":{\"118\":1},\"1\":{\"234\":1}}],[\"风格的应用中\",{\"1\":{\"673\":1}}],[\"风雨气温图\",{\"1\":{\"152\":1}}],[\"史上最全\",{\"1\":{\"672\":1}}],[\"冷启动\",{\"1\":{\"670\":1}}],[\"约定在\",{\"1\":{\"892\":1}}],[\"约定大于配置\",{\"1\":{\"665\":1,\"667\":1}}],[\"约定的目录结构\",{\"0\":{\"71\":1}}],[\"屏息了繁琐的xml配置文件\",{\"1\":{\"664\":1}}],[\"震惊\",{\"1\":{\"661\":1}}],[\"芋道\",{\"1\":{\"661\":2}}],[\"芋道源码\",{\"1\":{\"660\":1}}],[\"写分页等\",{\"1\":{\"827\":1}}],[\"写在了生产者和消费者代码中\",{\"1\":{\"754\":1}}],[\"写法参考\",{\"1\":{\"656\":1}}],[\"写到最后\",{\"0\":{\"528\":1}}],[\"身份授权\",{\"1\":{\"656\":1}}],[\"张三\",{\"1\":{\"651\":1}}],[\"占的带宽也会更多\",{\"1\":{\"887\":1}}],[\"占用的空间为包含了26个字符的数组\",{\"1\":{\"948\":1}}],[\"占用带宽会更少\",{\"1\":{\"798\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"270\":1}}],[\"占位符映射\",{\"1\":{\"651\":1}}],[\"寻找匹配的处理器信息\",{\"1\":{\"646\":1}}],[\"寻址时间复杂度为\",{\"1\":{\"252\":2}}],[\"达到减少编码的时间\",{\"1\":{\"645\":1}}],[\"填充到request域\",{\"1\":{\"642\":1}}],[\"填充属性\",{\"1\":{\"614\":1}}],[\"忽略当前事务\",{\"1\":{\"635\":1}}],[\"忽略符号位\",{\"1\":{\"244\":1}}],[\"条\",{\"1\":{\"757\":1}}],[\"条件是\",{\"1\":{\"943\":1}}],[\"条件封装\",{\"1\":{\"842\":1}}],[\"条件构造器也可以构建删除语句的条件\",{\"1\":{\"846\":1}}],[\"条件构造器和常用接口\",{\"0\":{\"841\":1}}],[\"条件构造抽象类\",{\"1\":{\"842\":1}}],[\"条件\",{\"1\":{\"738\":1,\"842\":1}}],[\"条件相当苛刻\",{\"1\":{\"464\":1}}],[\"条消息就堆积在了队列中\",{\"1\":{\"718\":1}}],[\"条消息到\",{\"1\":{\"718\":1}}],[\"条记录\",{\"1\":{\"634\":2}}],[\"幻读\",{\"1\":{\"634\":1}}],[\"幻读或不可重复读\",{\"1\":{\"634\":1}}],[\"脏读\",{\"1\":{\"634\":1}}],[\"隔离级别\",{\"1\":{\"634\":1}}],[\"隔离加载类\",{\"1\":{\"386\":1}}],[\"覆盖已生成文件\",{\"1\":{\"864\":1}}],[\"覆盖掉二级缓存中的普通bean对象\",{\"1\":{\"622\":1}}],[\"覆盖其中方法\",{\"1\":{\"603\":1}}],[\"往二级缓存中放的显示一个普通的bean对象\",{\"1\":{\"622\":1}}],[\"往栈中写入数据或提取数据\",{\"1\":{\"416\":1}}],[\"顺利从一级缓存拿到实例化且初始化完成的b对象\",{\"1\":{\"621\":1}}],[\"层序遍历一般使用迭代来实现\",{\"1\":{\"1024\":1}}],[\"层序遍历就是按照各层顺序打印结果\",{\"1\":{\"1024\":1}}],[\"层序遍历就比较简单\",{\"1\":{\"1024\":1}}],[\"层序遍历\",{\"1\":{\"1024\":3}}],[\"层这是\",{\"1\":{\"883\":1}}],[\"层和\",{\"1\":{\"883\":2}}],[\"层避免混淆\",{\"1\":{\"833\":1}}],[\"层代码\",{\"1\":{\"754\":1,\"827\":1}}],[\"层返回数据给前端页面\",{\"1\":{\"618\":1}}],[\"层\",{\"1\":{\"618\":2,\"754\":1,\"755\":1,\"762\":1,\"883\":2,\"944\":1,\"969\":1,\"1029\":1}}],[\"层面\",{\"1\":{\"285\":1,\"607\":1}}],[\"层面实现的\",{\"1\":{\"285\":1}}],[\"层面对\",{\"1\":{\"278\":1}}],[\"属性就有值了\",{\"1\":{\"821\":1}}],[\"属性值\",{\"1\":{\"810\":1}}],[\"属性的队列\",{\"1\":{\"752\":1}}],[\"属性或者进入了设置\",{\"1\":{\"752\":1}}],[\"属性是一个键值对\",{\"1\":{\"728\":1}}],[\"属性来指明\",{\"1\":{\"676\":1}}],[\"属性设置完成后\",{\"1\":{\"619\":1}}],[\"属性\",{\"1\":{\"614\":2,\"697\":1,\"748\":1,\"752\":2,\"755\":1,\"779\":1}}],[\"属于全自动\",{\"1\":{\"823\":1}}],[\"属于静态文本替换\",{\"1\":{\"810\":1}}],[\"属于运行时增强\",{\"1\":{\"602\":1}}],[\"属于前端编译\",{\"1\":{\"357\":1}}],[\"属于堆上的新对象\",{\"1\":{\"317\":1}}],[\"属于对象引用之间以\",{\"1\":{\"317\":1}}],[\"属于字符串常量池中的对象\",{\"1\":{\"317\":1}}],[\"销毁后的回调方法\",{\"1\":{\"619\":1}}],[\"销毁\",{\"1\":{\"614\":1}}],[\"灵活\",{\"1\":{\"875\":1}}],[\"灵活度高\",{\"1\":{\"806\":2}}],[\"灵活性\",{\"1\":{\"607\":1}}],[\"灵活运用css开发技巧\",{\"1\":{\"125\":1}}],[\"运用了\",{\"1\":{\"667\":1}}],[\"运用反射机制动态创建而成\",{\"1\":{\"607\":1}}],[\"运行流程\",{\"0\":{\"642\":1}}],[\"运行高效\",{\"1\":{\"522\":1}}],[\"运行时会使用\",{\"1\":{\"816\":1}}],[\"运行时元数据\",{\"1\":{\"476\":1}}],[\"运行时计算生成\",{\"1\":{\"378\":1}}],[\"运行时环境\",{\"1\":{\"343\":1}}],[\"运行时常量池相对于\",{\"1\":{\"459\":1}}],[\"运行时常量池类似于传统编程语言中的符号表\",{\"1\":{\"459\":1}}],[\"运行时常量池中包含多种不同的常量\",{\"1\":{\"459\":1}}],[\"运行时常量池还在方法区\",{\"1\":{\"307\":1}}],[\"运行时常量池剩下的东西还在方法区\",{\"1\":{\"307\":1,\"343\":1}}],[\"运行时常量池\",{\"0\":{\"307\":1,\"456\":1,\"459\":1},\"1\":{\"451\":1,\"459\":2}}],[\"运行时数据区结构\",{\"1\":{\"439\":1}}],[\"运行时数据区\",{\"0\":{\"300\":1},\"1\":{\"343\":1}}],[\"运行速度比下面这个循环快\",{\"1\":{\"230\":1}}],[\"运行后重启电脑\",{\"1\":{\"114\":1}}],[\"运行你的\",{\"1\":{\"105\":1}}],[\"运行\",{\"1\":{\"72\":1}}],[\"织入可以在编译\",{\"1\":{\"604\":1}}],[\"织入\",{\"1\":{\"604\":1}}],[\"环绕通知\",{\"1\":{\"604\":1}}],[\"环境变量配置\",{\"0\":{\"62\":1}}],[\"切忌不要太过细\",{\"1\":{\"890\":1}}],[\"切入点是一个或一组连接点\",{\"1\":{\"604\":1}}],[\"切入点\",{\"1\":{\"604\":1}}],[\"切面通过带有\",{\"1\":{\"604\":1}}],[\"切面\",{\"1\":{\"604\":1}}],[\"切换到b分支\",{\"1\":{\"583\":1}}],[\"切换全屏\",{\"1\":{\"48\":1}}],[\"功能更加强大\",{\"1\":{\"602\":1}}],[\"统一化的操作\",{\"1\":{\"872\":1}}],[\"统一日志处理\",{\"1\":{\"656\":1}}],[\"统一异常处理\",{\"1\":{\"656\":1}}],[\"统一设置编码\",{\"1\":{\"648\":1}}],[\"统一成一个注释类\",{\"1\":{\"599\":1}}],[\"统计target在list中第一次出现的索引\",{\"1\":{\"258\":1}}],[\"统计元素出现次数\",{\"1\":{\"258\":1}}],[\"造器的自动装配和bytype模式类似\",{\"1\":{\"598\":1}}],[\"造成跨域\",{\"1\":{\"788\":1}}],[\"造成消费者消费了重复的消息\",{\"1\":{\"772\":1}}],[\"造成的结果就是parnew\",{\"1\":{\"534\":1}}],[\"造成系统吞吐量的下降\",{\"1\":{\"526\":1}}],[\"控制整个流程的执行\",{\"1\":{\"646\":1}}],[\"控制器的注解\",{\"1\":{\"651\":1}}],[\"控制器本身不输出任何东西和做任何处理\",{\"1\":{\"645\":1}}],[\"控制器\",{\"1\":{\"645\":1}}],[\"控制层\",{\"1\":{\"618\":1,\"643\":1}}],[\"控制反转\",{\"1\":{\"595\":1}}],[\"控制参数\",{\"1\":{\"531\":1}}],[\"想象自己站在它的右侧\",{\"1\":{\"1033\":1}}],[\"想要扩展实现\",{\"1\":{\"904\":1}}],[\"想用\",{\"1\":{\"883\":1}}],[\"想用springmvc必须先依赖spring\",{\"1\":{\"592\":1}}],[\"想想看\",{\"1\":{\"753\":1}}],[\"想控制它们的启动顺序\",{\"1\":{\"687\":1}}],[\"想合并到b分支\",{\"1\":{\"582\":1}}],[\"远程调用层\",{\"1\":{\"883\":1}}],[\"远程过程调用协议\",{\"1\":{\"873\":1}}],[\"远程处理\",{\"1\":{\"591\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"534\":1}}],[\"集中配置允许匿名访问的url\",{\"1\":{\"788\":1}}],[\"集群的特性\",{\"1\":{\"758\":1}}],[\"集成cxf实现\",{\"1\":{\"888\":1}}],[\"集成的开发框架\",{\"1\":{\"664\":1}}],[\"集成了外部很多的优秀的框架\",{\"1\":{\"664\":1}}],[\"集成\",{\"1\":{\"591\":2,\"888\":1}}],[\"集合list\",{\"1\":{\"228\":1}}],[\"集合中可以存储任意类型的对象\",{\"1\":{\"225\":1,\"227\":1}}],[\"集合的出现就是为了持有对象\",{\"1\":{\"225\":1,\"227\":1}}],[\"集合框架底层数据结构总结\",{\"0\":{\"218\":1}}],[\"集合不仅可以用来存储不同类型不同数量的对象\",{\"1\":{\"217\":1}}],[\"集合同样也是用来存储多个数据的\",{\"1\":{\"217\":1}}],[\"集合\",{\"1\":{\"214\":1,\"217\":1}}],[\"旨在提高开发人员的开发效率以及系统的可维护性\",{\"1\":{\"591\":1}}],[\"谈谈你对spring的理解\",{\"0\":{\"591\":1}}],[\"警告\",{\"1\":{\"585\":1,\"792\":1}}],[\"已把消息发送给消费者\",{\"1\":{\"772\":1}}],[\"已收到\",{\"1\":{\"719\":1}}],[\"已知道该消息并且成功的处理消息\",{\"1\":{\"706\":1}}],[\"已提交的内容进行修改\",{\"0\":{\"585\":1}}],[\"已经写在上方代码注释\",{\"1\":{\"985\":1}}],[\"已经写在上方代码注释中\",{\"1\":{\"940\":1,\"1036\":1}}],[\"已经消费成功\",{\"1\":{\"725\":1}}],[\"已经没有了\",{\"1\":{\"615\":1}}],[\"已经集成了aspectj\",{\"1\":{\"596\":1}}],[\"已经执行完毕\",{\"1\":{\"380\":1}}],[\"已经内置了\",{\"1\":{\"365\":1}}],[\"已经将运行时常量池从方法区中移了出来\",{\"1\":{\"343\":1}}],[\"已经被加载的类会直接返回\",{\"1\":{\"332\":1}}],[\"已经被回收\",{\"1\":{\"329\":1}}],[\"遴选\",{\"1\":{\"583\":1}}],[\"过期\",{\"1\":{\"745\":1}}],[\"过滤器依赖与servlet容器\",{\"1\":{\"648\":1}}],[\"过滤器\",{\"1\":{\"648\":1}}],[\"过滤器跟拦截器的区别\",{\"0\":{\"648\":1}}],[\"过滤连接到指定网络的容器\",{\"1\":{\"577\":1}}],[\"过滤挂载有指定数据卷的容器\",{\"1\":{\"577\":1}}],[\"过滤在给定id或名称之后创建的容器\",{\"1\":{\"577\":1}}],[\"过滤从指定镜像创建的容器\",{\"1\":{\"577\":1}}],[\"过程的收集器时\",{\"1\":{\"471\":1}}],[\"过程\",{\"0\":{\"377\":1}}],[\"过程中的各个环节是自动执行的\",{\"1\":{\"95\":1}}],[\"静默模式\",{\"1\":{\"577\":1}}],[\"静态资源等等\",{\"1\":{\"788\":1}}],[\"静态代理在编译时就将接口\",{\"1\":{\"607\":1}}],[\"静态代理中\",{\"1\":{\"607\":1}}],[\"静态代理\",{\"1\":{\"607\":1}}],[\"静态方法\",{\"1\":{\"421\":1}}],[\"静态链接\",{\"0\":{\"419\":1},\"1\":{\"419\":1}}],[\"静态变量仍在堆\",{\"1\":{\"461\":1}}],[\"静态变量移除\",{\"1\":{\"461\":1}}],[\"静态变量存放在永久代上\",{\"1\":{\"461\":1}}],[\"静态变量和类关联在一起\",{\"1\":{\"455\":1}}],[\"静态变量\",{\"1\":{\"305\":1,\"343\":1,\"451\":1}}],[\"列出已退出的容器\",{\"1\":{\"577\":1}}],[\"列出最近创建的n个容器\",{\"1\":{\"577\":1}}],[\"列出容器\",{\"1\":{\"577\":1}}],[\"列表实现所使用的标记接口\",{\"1\":{\"230\":1}}],[\"列表的结尾会预留一定的容量空间\",{\"1\":{\"229\":1}}],[\"千年\",{\"1\":{\"568\":1}}],[\"百万条消息\",{\"1\":{\"784\":1}}],[\"百年\",{\"1\":{\"568\":1}}],[\"百度百科中最近公共祖先的定义为\",{\"1\":{\"1038\":1}}],[\"百度\",{\"1\":{\"465\":1,\"518\":1}}],[\"百度机翻\",{\"1\":{\"230\":1}}],[\"百度图表\",{\"1\":{\"159\":1}}],[\"百度网盘搜索\",{\"1\":{\"148\":1}}],[\"百度脑图\",{\"1\":{\"133\":1}}],[\"百度指数\",{\"1\":{\"122\":1}}],[\"百度一下🎉\",{\"1\":{\"41\":2}}],[\"半天\",{\"1\":{\"568\":1}}],[\"枚举\",{\"1\":{\"568\":1,\"1019\":1}}],[\"枚举enum\",{\"1\":{\"452\":1}}],[\"纳秒的加减\",{\"1\":{\"565\":1}}],[\"确实是一个问题\",{\"1\":{\"756\":1}}],[\"确实也是一个可行的方案\",{\"1\":{\"751\":1}}],[\"确实可以这样做\",{\"1\":{\"751\":1}}],[\"确认机制图例\",{\"1\":{\"761\":1}}],[\"确认发布指的是成功发送到了队列\",{\"1\":{\"722\":1}}],[\"确认\",{\"1\":{\"707\":1,\"1011\":1}}],[\"确保消息不会丢失需要做两件事\",{\"1\":{\"710\":1}}],[\"确保不发生脏读\",{\"1\":{\"634\":1}}],[\"确保线程安全\",{\"1\":{\"565\":1}}],[\"确定该对象所属的类型\",{\"1\":{\"476\":1}}],[\"系列方法\",{\"1\":{\"562\":1,\"565\":1}}],[\"系统与系统交互较少的情况下\",{\"1\":{\"872\":1}}],[\"系统中默认有些\",{\"1\":{\"733\":1}}],[\"系统中的\",{\"1\":{\"332\":1}}],[\"系统会产生大量的这些对象\",{\"1\":{\"525\":1}}],[\"系统会首先判断当前类是否被加载过\",{\"1\":{\"332\":1}}],[\"系统建议执行fullgc\",{\"1\":{\"496\":1}}],[\"系统类加载器\",{\"0\":{\"384\":1},\"1\":{\"519\":1}}],[\"系统属性所指定的目录中加载类库\",{\"1\":{\"383\":1}}],[\"系统稳定执行以后\",{\"1\":{\"372\":1}}],[\"系统就会出现多个不同的\",{\"1\":{\"333\":1}}],[\"系统变量所指定的路径下的\",{\"1\":{\"331\":1}}],[\"系统\",{\"1\":{\"1\":1}}],[\"秒进入了死信队列\",{\"1\":{\"747\":1}}],[\"秒后直接进入延时队列\",{\"1\":{\"757\":1}}],[\"秒后启动\",{\"1\":{\"747\":1}}],[\"秒后进入死信队列\",{\"1\":{\"747\":1}}],[\"秒\",{\"1\":{\"561\":1,\"562\":1,\"708\":1,\"749\":1,\"755\":1}}],[\"月份的参数使用枚举的方式传入\",{\"1\":{\"566\":1}}],[\"月\",{\"1\":{\"559\":1,\"562\":1}}],[\"格林威治时间\",{\"1\":{\"557\":1}}],[\"格式编码\",{\"1\":{\"685\":1}}],[\"格式为key=value\",{\"1\":{\"577\":1}}],[\"格式化类java\",{\"1\":{\"555\":1}}],[\"格式化代码\",{\"1\":{\"6\":1}}],[\"格式是\",{\"1\":{\"78\":1}}],[\"格式显示的是一个\",{\"1\":{\"78\":1}}],[\"格式\",{\"0\":{\"47\":1},\"1\":{\"43\":1}}],[\"封装真的实现类\",{\"1\":{\"889\":1}}],[\"封装了服务注册和发现\",{\"1\":{\"883\":1}}],[\"封装了常见的业务层逻辑\",{\"1\":{\"833\":1}}],[\"封装iservice接口\",{\"1\":{\"833\":1}}],[\"封装起来\",{\"1\":{\"596\":1}}],[\"封装的是utc\",{\"1\":{\"557\":1}}],[\"封面\",{\"1\":{\"139\":1}}],[\"均可以使用递归或迭代的方式进行\",{\"1\":{\"1024\":1}}],[\"均可以使用instant类作为中间类完成转换\",{\"1\":{\"557\":1}}],[\"均摊性能相比更慢\",{\"1\":{\"231\":1}}],[\"日志输出等行为进行封装的服务框架\",{\"1\":{\"881\":1}}],[\"日志\",{\"1\":{\"736\":1}}],[\"日志模块称为日志的aop切面\",{\"1\":{\"604\":1}}],[\"日志功能\",{\"1\":{\"596\":1}}],[\"日志管理\",{\"1\":{\"596\":1}}],[\"日=时\",{\"1\":{\"562\":1}}],[\"日\",{\"1\":{\"559\":1}}],[\"日期格式化类datetimeformatter\",{\"1\":{\"555\":1}}],[\"日期相关\",{\"0\":{\"554\":1}}],[\"日记\",{\"1\":{\"148\":1}}],[\"映射工具\",{\"0\":{\"823\":1},\"1\":{\"823\":2}}],[\"映射文件和\",{\"0\":{\"822\":1}}],[\"映射文件的命名空间\",{\"1\":{\"819\":1}}],[\"映射文件\",{\"1\":{\"816\":1}}],[\"映射文件内\",{\"1\":{\"812\":1}}],[\"映射文件中\",{\"0\":{\"811\":1},\"1\":{\"822\":1}}],[\"映射\",{\"0\":{\"549\":1},\"1\":{\"651\":1}}],[\"跳过\",{\"1\":{\"982\":1}}],[\"跳过10个元素\",{\"1\":{\"548\":1}}],[\"跳过元素\",{\"1\":{\"548\":1}}],[\"跳转\",{\"1\":{\"301\":1,\"399\":1}}],[\"跳转到所在目录的命令行窗口\",{\"1\":{\"1010\":1}}],[\"跳转到所选内容\",{\"1\":{\"45\":1}}],[\"跳转到文末\",{\"1\":{\"45\":1}}],[\"跳转到文首\",{\"1\":{\"45\":1}}],[\"终端操作\",{\"1\":{\"546\":2}}],[\"流式风格使其变得简单\",{\"1\":{\"989\":1}}],[\"流量监控和熔断\",{\"1\":{\"886\":1}}],[\"流量分发\",{\"1\":{\"886\":1}}],[\"流水记录也变成了两条\",{\"1\":{\"771\":1}}],[\"流的扁平化\",{\"1\":{\"549\":1}}],[\"流的使用一般包括三件事\",{\"1\":{\"547\":1}}],[\"流还支持skip\",{\"1\":{\"548\":1}}],[\"流支持limit\",{\"1\":{\"548\":1}}],[\"流操作分类\",{\"0\":{\"546\":1}}],[\"流操作\",{\"0\":{\"545\":1}}],[\"流只能遍历一次\",{\"1\":{\"544\":1}}],[\"流是java\",{\"1\":{\"544\":1}}],[\"流简介\",{\"0\":{\"544\":1}}],[\"流\",{\"0\":{\"543\":1}}],[\"流程\",{\"1\":{\"518\":1}}],[\"流程图\",{\"1\":{\"133\":1}}],[\"知道什么是\",{\"0\":{\"892\":1}}],[\"知识清单\",{\"1\":{\"661\":1}}],[\"知识库\",{\"1\":{\"148\":1}}],[\"知乎\",{\"1\":{\"540\":2}}],[\"吞吐量优先\",{\"1\":{\"537\":2,\"539\":2}}],[\"划分内存空间以及有优先级的区域回收方式\",{\"1\":{\"535\":1}}],[\"划水网站\",{\"1\":{\"120\":1}}],[\"筛选各异的元素\",{\"1\":{\"548\":1}}],[\"筛选和切片\",{\"0\":{\"548\":1}}],[\"筛选回收\",{\"1\":{\"535\":1}}],[\"筛选的条件是此对象是否有必要执行\",{\"1\":{\"323\":1}}],[\"共享消费\",{\"1\":{\"697\":1,\"702\":1}}],[\"共同的关注点\",{\"1\":{\"535\":1}}],[\"共需要o\",{\"1\":{\"194\":1}}],[\"降低成本\",{\"1\":{\"884\":1}}],[\"降低模块间的耦合度\",{\"1\":{\"596\":1}}],[\"降低软件复杂性\",{\"1\":{\"592\":1}}],[\"降低停顿时间是\",{\"1\":{\"535\":1}}],[\"降低资源消耗\",{\"1\":{\"274\":1}}],[\"低停顿\",{\"1\":{\"534\":1}}],[\"历史最悠久的垃圾收集器了\",{\"1\":{\"530\":1}}],[\"历史内容聚合网站\",{\"1\":{\"148\":1}}],[\"间\",{\"1\":{\"757\":1}}],[\"间断性地还执行了应用程序代码\",{\"1\":{\"526\":1}}],[\"间浪费主要体现在在\",{\"1\":{\"229\":1}}],[\"阶段的开销与存活对象的数据成正比\",{\"1\":{\"525\":1}}],[\"阶段的开销与存活对象的数量成正比\",{\"1\":{\"525\":1}}],[\"阶段的开销与所管理区域的大小成正相关\",{\"1\":{\"525\":1}}],[\"阶你才能到达楼顶\",{\"1\":{\"200\":1}}],[\"速度优先\",{\"1\":{\"539\":5}}],[\"速度很快\",{\"1\":{\"534\":1}}],[\"速度是最快的\",{\"1\":{\"525\":1}}],[\"速率\",{\"1\":{\"524\":1}}],[\"连接处理\",{\"1\":{\"881\":1}}],[\"连接丢失\",{\"1\":{\"707\":1}}],[\"连接已关闭或\",{\"1\":{\"707\":1}}],[\"连接工厂\",{\"1\":{\"697\":1}}],[\"连接服务器的端口是\",{\"1\":{\"695\":1}}],[\"连接点\",{\"1\":{\"604\":1}}],[\"连接超时造成的\",{\"1\":{\"587\":1}}],[\"连接\",{\"1\":{\"525\":1,\"693\":1,\"697\":1,\"701\":1}}],[\"否定确认应答\",{\"1\":{\"706\":1}}],[\"否\",{\"1\":{\"524\":1}}],[\"否则不加\",{\"1\":{\"1034\":1}}],[\"否则不会路由到该队列\",{\"1\":{\"728\":1}}],[\"否则我们要继续递归调用检查它的左右子树是否满足\",{\"1\":{\"1029\":1}}],[\"否则代表连续递增中断了\",{\"1\":{\"930\":1,\"1039\":1}}],[\"否则拼接\",{\"1\":{\"852\":1}}],[\"否则无效\",{\"1\":{\"836\":1}}],[\"否则就是默认优先级\",{\"1\":{\"776\":1}}],[\"否则就会被真的回收\",{\"1\":{\"323\":1}}],[\"否则该消息将会被丢弃\",{\"1\":{\"752\":1}}],[\"否则的话为报错\",{\"1\":{\"600\":1}}],[\"否则将进行fullgc\",{\"1\":{\"504\":1}}],[\"否则通常是很难达成的\",{\"1\":{\"464\":1}}],[\"否则\",{\"1\":{\"392\":1,\"422\":1,\"926\":1,\"949\":1,\"957\":1,\"974\":1,\"982\":2,\"1019\":2}}],[\"否则才会尝试加载\",{\"1\":{\"332\":1}}],[\"否则会连接超时\",{\"1\":{\"695\":1}}],[\"否则会得不偿失\",{\"1\":{\"278\":1}}],[\"否则会抛出\",{\"1\":{\"239\":1}}],[\"否则返回上一个元素\",{\"1\":{\"242\":1}}],[\"否则调用iteratorbinarysearch\",{\"1\":{\"230\":1}}],[\"否则表示当前不装\",{\"1\":{\"207\":1}}],[\"否则是偶数\",{\"1\":{\"182\":1}}],[\"少\",{\"1\":{\"524\":2}}],[\"背景\",{\"1\":{\"523\":1}}],[\"背包最大价值\",{\"1\":{\"207\":1}}],[\"背包九讲\",{\"1\":{\"206\":1}}],[\"背包问题\",{\"0\":{\"206\":1},\"1\":{\"206\":3}}],[\"意味着gc需要维护region之间对象引用关系\",{\"1\":{\"522\":1}}],[\"意思是虚拟机维护了一个列表\",{\"1\":{\"471\":1}}],[\"意思是所有用过的内存在一边\",{\"1\":{\"471\":1}}],[\"碎片导致的concurrent\",{\"1\":{\"525\":1}}],[\"碎片\",{\"1\":{\"522\":1}}],[\"碎片整理将所占用的堆内存移到堆的一端\",{\"1\":{\"516\":1}}],[\"讲一下垃圾回收算法\",{\"1\":{\"518\":1}}],[\"讲讲jvm运行时数据库区\",{\"1\":{\"465\":1}}],[\"滴滴\",{\"1\":{\"518\":1}}],[\"他们的本质都是提供可支持分布式的基础服务\",{\"1\":{\"875\":1}}],[\"他们的订单必须得到优先处理\",{\"1\":{\"776\":1}}],[\"他们共同的缺点是什么\",{\"1\":{\"518\":1}}],[\"他可以生成代理对象\",{\"1\":{\"622\":1}}],[\"他的底层原理是基于\",{\"1\":{\"606\":1}}],[\"他基于反射的机制实现\",{\"1\":{\"606\":1}}],[\"他也会作为一个正常的\",{\"1\":{\"602\":1}}],[\"他会使此线程暂停执行一段时间\",{\"1\":{\"273\":1}}],[\"怎么解决\",{\"0\":{\"653\":1}}],[\"怎么办\",{\"1\":{\"632\":1}}],[\"怎么回收内存\",{\"1\":{\"518\":1}}],[\"怎么使用线程池的\",{\"0\":{\"291\":1}}],[\"弱化java开发任意在程序出现内存溢出时定位问题和解决问题的能力\",{\"1\":{\"517\":1}}],[\"弱引用可以和一个引用队列\",{\"1\":{\"327\":1}}],[\"弱引用与软引用的区别在于\",{\"1\":{\"327\":1}}],[\"弱引用\",{\"0\":{\"327\":1},\"1\":{\"324\":1}}],[\"复杂度为k\",{\"1\":{\"940\":1}}],[\"复杂度为n\",{\"1\":{\"940\":1}}],[\"复杂度\",{\"1\":{\"931\":1,\"938\":1,\"968\":1,\"969\":1,\"1020\":1,\"1029\":1,\"1030\":1,\"1034\":1,\"1035\":1,\"1040\":1}}],[\"复杂\",{\"1\":{\"516\":1}}],[\"复制的成本也将很高\",{\"1\":{\"523\":1}}],[\"复制而不是移动\",{\"1\":{\"522\":1}}],[\"复制过去以后保证空间的连续性\",{\"1\":{\"522\":1}}],[\"复制算法明显变得不合适\",{\"1\":{\"525\":1}}],[\"复制算法的多线程收集器\",{\"1\":{\"532\":1}}],[\"复制算法的效率只和当前存活对象大小有关\",{\"1\":{\"525\":1}}],[\"复制算法的高效性是建立在存活对象少\",{\"1\":{\"523\":1}}],[\"复制算法不会很理想\",{\"1\":{\"522\":1}}],[\"复制算法\",{\"0\":{\"522\":1},\"1\":{\"520\":1,\"530\":1,\"531\":1,\"536\":1,\"539\":1}}],[\"复制之后有交换\",{\"1\":{\"490\":1}}],[\"复制到每个低位上\",{\"1\":{\"253\":1}}],[\"复制代码就能用\",{\"1\":{\"134\":1}}],[\"复制并处理资源文件\",{\"1\":{\"94\":2}}],[\"复制并粘贴当前行\",{\"1\":{\"6\":1}}],[\"复制为markdown\",{\"1\":{\"45\":1}}],[\"复制\",{\"1\":{\"6\":1,\"45\":1,\"524\":1,\"535\":1,\"539\":1}}],[\"甚至在你抛出异常的时候做业务逻辑的操作\",{\"1\":{\"648\":1}}],[\"甚至可能导致内存溢出\",{\"1\":{\"515\":1}}],[\"甚至jvm的一些部分就是用c写的\",{\"1\":{\"435\":1}}],[\"哪些内存需要回收\",{\"1\":{\"515\":1}}],[\"哪些对象可以作为\",{\"1\":{\"322\":1}}],[\"消耗会更大\",{\"1\":{\"798\":1}}],[\"消耗\",{\"1\":{\"717\":1}}],[\"消息需要设置消息的优先级\",{\"1\":{\"777\":1}}],[\"消息重复消费\",{\"0\":{\"772\":1}}],[\"消息究竟何去何从\",{\"1\":{\"768\":1}}],[\"消息回调\",{\"1\":{\"765\":1}}],[\"消息回调和退回\",{\"1\":{\"762\":1}}],[\"消息相关数据\",{\"1\":{\"762\":1,\"765\":1}}],[\"消息可靠投递\",{\"1\":{\"758\":1}}],[\"消息可靠发送\",{\"1\":{\"758\":1}}],[\"消息可能并不会按时\",{\"1\":{\"755\":1}}],[\"消息来自\",{\"1\":{\"754\":2,\"755\":2}}],[\"消息即使过期\",{\"1\":{\"752\":1}}],[\"消息设置\",{\"1\":{\"752\":1}}],[\"消息ttl过期\",{\"0\":{\"747\":1}}],[\"消息队列和死信队列\",{\"1\":{\"746\":1}}],[\"消息队列名字和步骤\",{\"1\":{\"697\":1}}],[\"消息被拒绝\",{\"1\":{\"745\":1}}],[\"消息被取消的回调\",{\"1\":{\"701\":1}}],[\"消息只去到它绑定的\",{\"1\":{\"736\":1}}],[\"消息避免浪费磁盘空间\",{\"1\":{\"736\":1}}],[\"消息能路由发送到队列中其实是由\",{\"1\":{\"729\":1}}],[\"消息传递模型的核心思想是\",{\"1\":{\"727\":1}}],[\"消息还在缓存的一个间隔点\",{\"1\":{\"712\":1}}],[\"消息持久化\",{\"0\":{\"712\":1}}],[\"消息标记\",{\"1\":{\"708\":1,\"714\":1,\"717\":1}}],[\"消息在手动应答时是不丢失的\",{\"1\":{\"708\":1,\"711\":1}}],[\"消息自动重新入队\",{\"0\":{\"707\":1}}],[\"消息发送成功\",{\"1\":{\"722\":1}}],[\"消息发送后立即被认为已经传送成功\",{\"1\":{\"705\":1}}],[\"消息发送完成\",{\"1\":{\"701\":1}}],[\"消息发送完毕\",{\"1\":{\"697\":1}}],[\"消息应答和\",{\"1\":{\"717\":1}}],[\"消息应答就是\",{\"1\":{\"704\":1}}],[\"消息应答\",{\"0\":{\"704\":1}}],[\"消息接受的回调\",{\"1\":{\"701\":1}}],[\"消息消费被中断\",{\"1\":{\"698\":1,\"779\":1}}],[\"消息消费者\",{\"0\":{\"698\":1},\"1\":{\"762\":1}}],[\"消息\",{\"1\":{\"697\":1,\"702\":1,\"720\":2,\"745\":1,\"762\":2,\"765\":4,\"778\":1}}],[\"消息生产者发布消息后的回调接口\",{\"1\":{\"762\":2,\"765\":1}}],[\"消息生产者发送过来的消息不丢失要如何保障\",{\"1\":{\"710\":1}}],[\"消息生产者代码同上生产者一致\",{\"1\":{\"749\":1}}],[\"消息生产者代码去掉\",{\"1\":{\"748\":1}}],[\"消息生产者\",{\"0\":{\"697\":1},\"1\":{\"708\":2,\"711\":1,\"762\":2}}],[\"消息最终被送到这里等待\",{\"1\":{\"693\":1}}],[\"消息到\",{\"1\":{\"693\":1}}],[\"消息和测试模块\",{\"1\":{\"591\":1}}],[\"消费端的幂等性保障\",{\"0\":{\"774\":1}}],[\"消费后再执行你好\",{\"1\":{\"755\":1}}],[\"消费的消息\",{\"1\":{\"747\":1,\"779\":1,\"780\":1}}],[\"消费完消息告诉\",{\"1\":{\"725\":1}}],[\"消费呢\",{\"1\":{\"708\":1}}],[\"消费消息的时候\",{\"1\":{\"708\":1}}],[\"消费时的回调\",{\"1\":{\"698\":1}}],[\"消费成功之后是否要自动应答\",{\"1\":{\"698\":1}}],[\"消费哪个队列\",{\"1\":{\"698\":1}}],[\"消费\",{\"1\":{\"698\":1,\"708\":1}}],[\"消费与接收具有相似的含义\",{\"1\":{\"692\":1}}],[\"消费者会从zookeeper拉取注册的生产者的地址接口等数据\",{\"1\":{\"915\":1}}],[\"消费者收到这个响应之后会通过\",{\"1\":{\"891\":1}}],[\"消费者和提供者个数差不多\",{\"1\":{\"888\":1}}],[\"消费者和消息中间件很多时候并不在同一机器上\",{\"1\":{\"692\":1}}],[\"消费者需要等待消息已经发送到队列中才去消费\",{\"1\":{\"777\":1}}],[\"消费者的幂等性的解决一般使用全局\",{\"1\":{\"773\":1}}],[\"消费者代码\",{\"1\":{\"754\":1,\"757\":1,\"779\":1,\"780\":1}}],[\"消费者代码不变\",{\"1\":{\"748\":1,\"749\":1}}],[\"消费者只接受消息\",{\"1\":{\"754\":1}}],[\"消费者修改以下代码\",{\"1\":{\"748\":1}}],[\"消费者消费信息效果如图\",{\"1\":{\"779\":1}}],[\"消费者消费了大量的消息如果没有确认的话\",{\"1\":{\"717\":1}}],[\"消费者消费消息\",{\"1\":{\"698\":1}}],[\"消费者在给\",{\"1\":{\"772\":1}}],[\"消费者在消费\",{\"1\":{\"772\":1}}],[\"消费者在简单案例代码的基础上增加了以下内容\",{\"1\":{\"708\":1}}],[\"消费者在接收到消息并且处理该消息之后\",{\"1\":{\"704\":1}}],[\"消费者启用两个线程\",{\"1\":{\"708\":1}}],[\"消费者启动等待消费\",{\"1\":{\"701\":1}}],[\"消费者那边出现连接或者\",{\"1\":{\"705\":1}}],[\"消费者完成一个任务可能需要一段时间\",{\"1\":{\"704\":1}}],[\"消费者取消消费接口回调逻辑\",{\"1\":{\"701\":1,\"708\":1,\"714\":1,\"717\":1}}],[\"消费者取消消费的回调\",{\"1\":{\"698\":1}}],[\"消费者成功消费的回调\",{\"1\":{\"698\":1}}],[\"消费者大多时候是一个等待接收消息的程序\",{\"1\":{\"692\":1}}],[\"消费者\",{\"1\":{\"692\":1,\"701\":1,\"708\":4,\"738\":2,\"747\":5,\"748\":1,\"749\":4,\"754\":1,\"762\":1,\"779\":1}}],[\"消亡的区域\",{\"1\":{\"512\":1}}],[\"消除了jdbc大量冗余的代码\",{\"1\":{\"807\":1}}],[\"消除了复制算法当中\",{\"1\":{\"523\":1}}],[\"消除了标记\",{\"1\":{\"523\":1}}],[\"消除\",{\"0\":{\"509\":1}}],[\"消除锁是虚拟机另外一种锁的优化\",{\"1\":{\"278\":1}}],[\"消除二进制表示中最后一个1\",{\"0\":{\"184\":1}}],[\"成本较高\",{\"1\":{\"894\":1}}],[\"成功的一点\",{\"1\":{\"883\":1}}],[\"成能够进行网络传输的消息体\",{\"1\":{\"874\":1}}],[\"成员变量\",{\"1\":{\"638\":1}}],[\"成员变量进行自动注入时\",{\"1\":{\"599\":1}}],[\"成长\",{\"1\":{\"512\":1}}],[\"成为死信的消息都会被投递到死信队列里\",{\"1\":{\"753\":1}}],[\"成为新的当前帧\",{\"1\":{\"413\":1}}],[\"成为日后jar\",{\"1\":{\"378\":1}}],[\"成为默认虚拟机\",{\"1\":{\"351\":1}}],[\"认为通过逃逸分析\",{\"1\":{\"511\":1}}],[\"局部变量等\",{\"1\":{\"519\":1}}],[\"局部变量对象也被回收\",{\"1\":{\"508\":1}}],[\"局部变量表及大小\",{\"1\":{\"454\":1}}],[\"局部变量表中的变量也是重要的垃圾回收根节点\",{\"1\":{\"415\":1}}],[\"局部变量表中的变量只在当前方法调用中有效\",{\"1\":{\"415\":1}}],[\"局部变量表也会随之销毁\",{\"1\":{\"415\":1}}],[\"局部变量表也被称之为局部变量数组或本地变量表\",{\"1\":{\"415\":1}}],[\"局部变量表所需的容量大小是在编译期确定下来的\",{\"1\":{\"415\":1}}],[\"局部变量表\",{\"0\":{\"415\":1},\"1\":{\"302\":1,\"414\":1}}],[\"绝对\",{\"1\":{\"505\":1}}],[\"绝大部分的java对象的销毁都在新生代进行了\",{\"1\":{\"488\":1}}],[\"仝间分配担保\",{\"1\":{\"498\":1}}],[\"长期存活的对象分配到老年代\",{\"1\":{\"498\":1}}],[\"长度为1\",{\"1\":{\"929\":1,\"1038\":1}}],[\"长度为3\",{\"1\":{\"929\":1,\"1038\":1}}],[\"长度为\",{\"1\":{\"235\":1}}],[\"长度是不可改变的\",{\"1\":{\"233\":1}}],[\"长度就不可变了\",{\"1\":{\"217\":1}}],[\"年月日\",{\"1\":{\"568\":1}}],[\"年龄大于20或邮箱为null\",{\"1\":{\"848\":1}}],[\"年龄大于或等于该年龄的对象可以直接进入老年代\",{\"1\":{\"498\":1}}],[\"年龄就增加1岁\",{\"1\":{\"498\":1}}],[\"年轻代\",{\"1\":{\"525\":1}}],[\"年轻代是对象的诞生\",{\"1\":{\"512\":1}}],[\"年轻代gc\",{\"0\":{\"494\":1}}],[\"年轻代与老年代\",{\"0\":{\"488\":1}}],[\"仍然存活的对象\",{\"1\":{\"497\":1}}],[\"~99\",{\"1\":{\"522\":1}}],[\"~\",{\"1\":{\"497\":1}}],[\"发\",{\"1\":{\"757\":1}}],[\"发起远程调用\",{\"1\":{\"891\":1}}],[\"发起一个请求\",{\"1\":{\"754\":1}}],[\"发起请求到前端控制器\",{\"1\":{\"642\":1}}],[\"发布者和订阅者之间还能通信么\",{\"0\":{\"915\":1}}],[\"发布功能属于生产者\",{\"1\":{\"725\":1}}],[\"发布\",{\"1\":{\"722\":1,\"723\":1,\"872\":1}}],[\"发布速度特别的慢\",{\"1\":{\"722\":1}}],[\"发布确认springboot版本\",{\"0\":{\"760\":1}}],[\"发布确认默认是没有开启的\",{\"1\":{\"721\":1}}],[\"发布确认的策略\",{\"0\":{\"721\":1}}],[\"发布确认逻辑\",{\"0\":{\"720\":1}}],[\"发布确认\",{\"0\":{\"719\":1}}],[\"发布的消息标识符\",{\"1\":{\"697\":1}}],[\"发布的消息优先级\",{\"1\":{\"697\":1}}],[\"发布消息\",{\"1\":{\"697\":1,\"708\":1,\"711\":1,\"712\":1}}],[\"发送数据\",{\"1\":{\"902\":1}}],[\"发送了两条消息\",{\"1\":{\"762\":1}}],[\"发送请求\",{\"1\":{\"755\":1,\"757\":1}}],[\"发送一条时长\",{\"1\":{\"755\":1,\"780\":1}}],[\"发送一条信息给两个\",{\"1\":{\"754\":1,\"755\":1}}],[\"发送一个消息\",{\"1\":{\"697\":1}}],[\"发送一个消息到交换机\",{\"1\":{\"697\":1}}],[\"发送到类型是\",{\"1\":{\"740\":1}}],[\"发送到哪个交换机\",{\"1\":{\"697\":1}}],[\"发送消息完成\",{\"1\":{\"779\":1}}],[\"发送消息内容\",{\"1\":{\"762\":2}}],[\"发送消息给两个消费者进行消费\",{\"1\":{\"734\":1}}],[\"发送消息进程\",{\"1\":{\"701\":1}}],[\"发送消息的消息体\",{\"1\":{\"697\":1}}],[\"发送单个消息的生产者和接收消息并打印出来的消费者\",{\"1\":{\"695\":1}}],[\"发生错误立即回滚\",{\"1\":{\"771\":1}}],[\"发生订单生成事件\",{\"1\":{\"751\":1}}],[\"发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据\",{\"1\":{\"634\":1}}],[\"发生了\",{\"1\":{\"495\":1}}],[\"发现e有右孩子\",{\"1\":{\"1024\":1}}],[\"发现b也有左孩子然后以b为根节点进行左→根→右进行打印\",{\"1\":{\"1024\":1}}],[\"发现b也有左孩子\",{\"1\":{\"1024\":1}}],[\"发现依赖b\",{\"1\":{\"621\":1}}],[\"发现一个地方改错了\",{\"1\":{\"585\":1}}],[\"发现一个对象不会被外界访问的话\",{\"1\":{\"510\":1}}],[\"发现没有一个对象是不逃逸的\",{\"1\":{\"511\":1}}],[\"发现如果一个对象并没有逃逸出方法的话\",{\"1\":{\"508\":1}}],[\"发现常量池里没有\",{\"1\":{\"319\":1}}],[\"暂存到concurrentmap<statistics\",{\"1\":{\"902\":1}}],[\"暂停所有的其他线程\",{\"1\":{\"534\":1}}],[\"暂停一切正常的工作\",{\"1\":{\"526\":1}}],[\"暂停其它用户的线程\",{\"1\":{\"494\":1}}],[\"暂未找到\",{\"1\":{\"28\":1}}],[\"触发流水线执行并关闭\",{\"1\":{\"546\":1}}],[\"触发full执行的情况有如下五种\",{\"1\":{\"496\":1}}],[\"触发的条件是eden满\",{\"1\":{\"494\":1}}],[\"触发机制\",{\"0\":{\"494\":1,\"495\":1,\"496\":1}}],[\"触发即时编译或栈上替换\",{\"1\":{\"351\":1}}],[\"混淆使用\",{\"1\":{\"493\":1}}],[\"混合收集\",{\"1\":{\"493\":1}}],[\"针对每条消息设置\",{\"1\":{\"752\":1}}],[\"针对handlermapping配置\",{\"1\":{\"656\":1}}],[\"针对不同年龄段的对象分配原则如下所示\",{\"1\":{\"498\":1}}],[\"针对\",{\"1\":{\"493\":1,\"685\":1}}],[\"针对幸存者s0\",{\"1\":{\"490\":1}}],[\"频繁在新生区收集\",{\"1\":{\"490\":1}}],[\"啥时候能去养老区\",{\"1\":{\"490\":1}}],[\"概述\",{\"0\":{\"490\":1},\"1\":{\"526\":1}}],[\"概念\",{\"0\":{\"85\":1,\"771\":1},\"1\":{\"693\":1}}],[\"朝生夕死\",{\"1\":{\"488\":1,\"497\":1}}],[\"管理\",{\"1\":{\"912\":1}}],[\"管理的最大一块内存空间\",{\"1\":{\"482\":1}}],[\"管理员身份运行\",{\"1\":{\"114\":1}}],[\"己使用的内存和未使用的内存相互交错\",{\"1\":{\"471\":1}}],[\"己经达到了可以和\",{\"1\":{\"365\":1}}],[\"权限控制等功能\",{\"1\":{\"903\":1}}],[\"权限控制\",{\"1\":{\"596\":1}}],[\"权限没有要求\",{\"1\":{\"468\":1}}],[\"权限必须是\",{\"1\":{\"468\":1}}],[\"拼多多\",{\"1\":{\"465\":1}}],[\"拼接字符串\",{\"1\":{\"988\":1}}],[\"拼接对象引用\",{\"1\":{\"317\":1}}],[\"拼接完成之后调用\",{\"1\":{\"317\":1}}],[\"京东\",{\"1\":{\"465\":1,\"518\":1}}],[\"小结\",{\"0\":{\"503\":1,\"512\":1}}],[\"小米这样大商家一年起码能给我们创造很大的利润\",{\"1\":{\"776\":1}}],[\"小米\",{\"1\":{\"465\":1}}],[\"小霸王游戏机\",{\"1\":{\"143\":1}}],[\"蚂蚁金服\",{\"1\":{\"465\":1,\"467\":1,\"518\":1}}],[\"废弃\",{\"1\":{\"464\":1}}],[\"判定一个常量是否\",{\"1\":{\"464\":1}}],[\"判断子树中所有节点的值是否都在\",{\"1\":{\"1029\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"1028\":1}}],[\"判断s的右孩子和t是否相等\",{\"1\":{\"1019\":1}}],[\"判断s的左孩子和t是否相等\",{\"1\":{\"1019\":1}}],[\"判断s和t是否相等\",{\"1\":{\"1019\":1}}],[\"判断对应位置是否相等\",{\"1\":{\"1019\":1}}],[\"判断对象对应的类是否加载\",{\"0\":{\"470\":1}}],[\"判断这个点的子树是否和\",{\"1\":{\"1019\":1}}],[\"判断要删除的是否是头结点\",{\"1\":{\"964\":1}}],[\"判断长度\",{\"1\":{\"954\":1}}],[\"判断入参\",{\"1\":{\"925\":1}}],[\"判断垃圾的位置空间是否够\",{\"1\":{\"521\":1}}],[\"判断当前下标pos处的是不是数字\",{\"1\":{\"957\":1}}],[\"判断当前锁的状态是否为0\",{\"1\":{\"290\":1}}],[\"判断当前元素存放的位置\",{\"1\":{\"244\":1}}],[\"判断n\",{\"1\":{\"182\":1}}],[\"判断奇数偶数\",{\"0\":{\"182\":1}}],[\"曾出现过的若干个严重的bug就是由于低版本的\",{\"1\":{\"464\":1}}],[\"融合工作的一部分\",{\"1\":{\"462\":1}}],[\"演进细节\",{\"0\":{\"461\":1}}],[\"演示\",{\"1\":{\"55\":1}}],[\"池中的数据项像数组项一样\",{\"1\":{\"459\":1}}],[\"几种在常量池内存储的数据类型包括\",{\"1\":{\"458\":1}}],[\"几乎可以零配置使用\",{\"1\":{\"667\":1}}],[\"几乎可以忽略不记\",{\"1\":{\"399\":1}}],[\"几乎不在永久区\",{\"1\":{\"490\":1}}],[\"几乎所有的垃圾回收器都区分新生代和老年代\",{\"1\":{\"525\":1}}],[\"几乎所有的java对象都是在eden区被new出来的\",{\"1\":{\"488\":1}}],[\"几乎所有的对象实例以及数组都在这里分配内存\",{\"1\":{\"304\":1}}],[\"几乎\",{\"1\":{\"482\":1}}],[\"域包含了确认消息的序列号\",{\"1\":{\"720\":1}}],[\"域修饰符\",{\"1\":{\"453\":1}}],[\"域类型\",{\"1\":{\"453\":1}}],[\"域名称\",{\"1\":{\"453\":1}}],[\"域的相关信息包括\",{\"1\":{\"453\":1}}],[\"域\",{\"0\":{\"453\":1},\"1\":{\"720\":1}}],[\"持续更新\",{\"1\":{\"921\":1}}],[\"持续调用时\",{\"1\":{\"183\":1}}],[\"持久性保证并不强\",{\"1\":{\"712\":1}}],[\"持久化\",{\"1\":{\"697\":1,\"702\":1}}],[\"持久化框架集成等等\",{\"1\":{\"592\":1}}],[\"持久代\",{\"1\":{\"465\":1}}],[\"持有状态时间过长的情况\",{\"1\":{\"450\":1}}],[\"替代上述原有的两个参数\",{\"1\":{\"448\":1}}],[\"替换为\",{\"1\":{\"810\":1}}],[\"替换操作\",{\"0\":{\"258\":1},\"1\":{\"256\":1}}],[\"替换\",{\"1\":{\"45\":1}}],[\"仅用到若干额外变量\",{\"1\":{\"957\":1}}],[\"仅支持\",{\"1\":{\"821\":1}}],[\"仅支持方法级别的\",{\"1\":{\"602\":1}}],[\"仅可以编写针对\",{\"1\":{\"818\":1}}],[\"仅需在声明队列的时候加上参数即可\",{\"1\":{\"780\":1}}],[\"仅占整个eden空间的1\",{\"1\":{\"502\":1}}],[\"仅仅通过少量配置即可实现单表大部分\",{\"1\":{\"827\":1}}],[\"仅仅在垃圾收集的时候才会被移除\",{\"1\":{\"482\":1}}],[\"仅仅起到占位符的作用\",{\"1\":{\"478\":1}}],[\"仅分配引用变量空间即可\",{\"1\":{\"471\":1}}],[\"仅是对hotspot而言的\",{\"1\":{\"444\":1}}],[\"仅存在结点之间的关联关系\",{\"1\":{\"289\":1}}],[\"仅存储对象\",{\"1\":{\"240\":1}}],[\"习惯上把方法区称为永久代\",{\"1\":{\"444\":1}}],[\"跟前面两种遍历方式类似\",{\"1\":{\"1024\":1}}],[\"跟堆空间一样\",{\"1\":{\"442\":1}}],[\"跟notify\",{\"0\":{\"287\":1,\"288\":1}}],[\"登记native方法\",{\"1\":{\"437\":1}}],[\"登录页的各种页面设计\",{\"1\":{\"142\":1}}],[\"寄存器值等\",{\"1\":{\"424\":1}}],[\"记住\",{\"1\":{\"818\":1}}],[\"记录上哪些内存块是可用的\",{\"1\":{\"471\":1}}],[\"记录并总结一些面试题\",{\"1\":{\"1\":1}}],[\"记作\",{\"1\":{\"422\":1}}],[\"私有方法\",{\"1\":{\"421\":1}}],[\"晚期绑定\",{\"0\":{\"420\":1},\"1\":{\"420\":1}}],[\"某个队列只想\",{\"1\":{\"740\":1}}],[\"某个事务尝试插入记录\",{\"1\":{\"634\":1}}],[\"某种速率能够处理这些消息的情况下使用\",{\"1\":{\"705\":1}}],[\"某些字节码指令将值压入操作数栈\",{\"1\":{\"416\":1}}],[\"某线程调用runtime类或system类的exit方法\",{\"1\":{\"347\":1}}],[\"遵循\",{\"1\":{\"413\":1}}],[\"维系着方法执行过程中的各种数据信息\",{\"1\":{\"412\":1}}],[\"压栈\",{\"1\":{\"408\":1}}],[\"压缩后的长度至少也是2\",{\"1\":{\"954\":1}}],[\"压缩后为\",{\"1\":{\"953\":1}}],[\"压缩是移动式的\",{\"1\":{\"523\":1}}],[\"压缩\",{\"1\":{\"523\":2,\"525\":1,\"953\":1}}],[\"压缩算法的最终效果等同于标记\",{\"1\":{\"523\":1}}],[\"压缩算法\",{\"0\":{\"523\":1},\"1\":{\"520\":1}}],[\"压缩包中读取\",{\"1\":{\"378\":1}}],[\"压缩效果比tinypng稍好\",{\"1\":{\"132\":1}}],[\"压缩png很有用\",{\"1\":{\"132\":1}}],[\"伴随着进栈\",{\"1\":{\"408\":1}}],[\"访问下标能快一点\",{\"1\":{\"954\":1}}],[\"访问下方的方法时会触发\",{\"1\":{\"605\":1}}],[\"访问指定方法\",{\"1\":{\"605\":1}}],[\"访问效率高\",{\"1\":{\"479\":1}}],[\"访问效率低\",{\"1\":{\"479\":1}}],[\"访问\",{\"1\":{\"479\":1,\"695\":1,\"762\":1}}],[\"访问速度仅次于程序计数器\",{\"1\":{\"408\":1}}],[\"访问某个类或接口的静态变量\",{\"1\":{\"397\":1}}],[\"早期绑定就是指被调用的目标方法如果在编译期可知\",{\"1\":{\"420\":1}}],[\"早期绑定\",{\"0\":{\"420\":1},\"1\":{\"420\":2}}],[\"早期也叫java栈\",{\"1\":{\"407\":1}}],[\"早在\",{\"1\":{\"231\":1}}],[\"众多线程在并发执行过程中\",{\"1\":{\"402\":1}}],[\"规约\",{\"0\":{\"551\":1}}],[\"规定\",{\"1\":{\"482\":1}}],[\"规则\",{\"1\":{\"477\":1}}],[\"规范中方法区的实现\",{\"1\":{\"445\":1}}],[\"规范中\",{\"1\":{\"399\":1}}],[\"规避资源耗尽的风险\",{\"1\":{\"291\":1}}],[\"反之亦然\",{\"1\":{\"600\":1}}],[\"反映java虚拟机内部情况的jmxbean\",{\"1\":{\"519\":1}}],[\"反序列化操作\",{\"1\":{\"874\":1}}],[\"反序列化\",{\"1\":{\"468\":1,\"874\":1,\"878\":2}}],[\"反射通过字节码文件找到其类中的方法和属性等\",{\"1\":{\"608\":1}}],[\"反射的实现原理\",{\"0\":{\"608\":1}}],[\"反射\",{\"1\":{\"397\":1}}],[\"反转一个单链表\",{\"1\":{\"967\":1}}],[\"反转链表\",{\"0\":{\"966\":1}}],[\"反转\",{\"1\":{\"257\":1,\"970\":1}}],[\"试图执行时会报错\",{\"1\":{\"393\":1}}],[\"沙箱安全机制\",{\"0\":{\"392\":1}}],[\"沙盒\",{\"1\":{\"145\":1}}],[\"倘若父类加载器无法完成此加载任务\",{\"1\":{\"391\":1}}],[\"倘若偏向锁失败\",{\"1\":{\"278\":1}}],[\"派生于\",{\"1\":{\"383\":1,\"384\":1}}],[\"出自hadoop之父doug\",{\"1\":{\"879\":1}}],[\"出于并发性能的考虑\",{\"1\":{\"878\":1}}],[\"出于多租户和安全因素设计的\",{\"1\":{\"693\":1}}],[\"出于安全考虑\",{\"1\":{\"382\":1}}],[\"出现异常时\",{\"1\":{\"917\":1}}],[\"出现\",{\"1\":{\"741\":1}}],[\"出现了major\",{\"1\":{\"495\":1}}],[\"出现未处理的异常\",{\"1\":{\"424\":1}}],[\"出现背景\",{\"0\":{\"405\":1}}],[\"出栈\",{\"1\":{\"416\":1}}],[\"出口信息\",{\"1\":{\"303\":1}}],[\"嵌入式日志等功能\",{\"1\":{\"879\":1}}],[\"嵌入式等多用途\",{\"1\":{\"353\":1}}],[\"嵌套的事务使用保存点作为回滚点\",{\"1\":{\"635\":1}}],[\"嵌套事务\",{\"1\":{\"635\":1}}],[\"嵌套在\",{\"1\":{\"382\":1}}],[\"获取url参数中指定参数的值作为获取实现类的key\",{\"1\":{\"907\":1}}],[\"获取具体的实现类然后加载即可\",{\"1\":{\"892\":1}}],[\"获取当前queue的长度\",{\"1\":{\"1035\":1}}],[\"获取当前version\",{\"1\":{\"860\":1}}],[\"获取当前系统默认时区字符串\",{\"1\":{\"562\":1}}],[\"获取匿名标记\",{\"1\":{\"788\":1}}],[\"获取请求发来的消息\",{\"1\":{\"780\":1}}],[\"获取回退的消息\",{\"1\":{\"764\":1}}],[\"获取消息\",{\"1\":{\"754\":1}}],[\"获取指定zonedatetime\",{\"1\":{\"562\":1}}],[\"获取指定参数对应的上海时区的时间\",{\"1\":{\"562\":1}}],[\"获取对应的时区对象\",{\"1\":{\"562\":1}}],[\"获取系统默认时区\",{\"1\":{\"555\":1}}],[\"获取系统类加载器\",{\"1\":{\"381\":1}}],[\"获取进程id\",{\"1\":{\"487\":1}}],[\"获取调用者的\",{\"1\":{\"389\":1}}],[\"获取\",{\"0\":{\"389\":1},\"1\":{\"738\":1}}],[\"获取其上层\",{\"1\":{\"381\":2}}],[\"获得更高的执行效率\",{\"1\":{\"365\":1}}],[\"获得了w\",{\"1\":{\"207\":1}}],[\"典型地是在一个xml文件里\",{\"1\":{\"592\":1}}],[\"典型的防\",{\"1\":{\"378\":1}}],[\"典型场景\",{\"1\":{\"378\":2}}],[\"链接\",{\"0\":{\"379\":1,\"470\":1,\"942\":1,\"947\":1,\"962\":1,\"972\":1},\"1\":{\"375\":1}}],[\"链表节点为偶数个\",{\"1\":{\"974\":1}}],[\"链表节点为奇数个\",{\"1\":{\"974\":1}}],[\"链表会转换成红黑树\",{\"1\":{\"249\":1}}],[\"链表散列\",{\"1\":{\"244\":1}}],[\"链表则是主要为了解决哈希冲突而存在的\",{\"1\":{\"222\":2,\"249\":1}}],[\"链表\",{\"0\":{\"167\":1,\"976\":1,\"977\":1},\"1\":{\"249\":2}}],[\"决定是否使用自定义的resourceloader\",{\"1\":{\"678\":1}}],[\"决定是否使用自定义的beannamegenerator\",{\"1\":{\"678\":1}}],[\"决定该为当前springboot应用创建什么类型的applicationcontext并创建完成\",{\"1\":{\"678\":1}}],[\"决定\",{\"1\":{\"375\":1}}],[\"冗余消除\",{\"1\":{\"372\":1}}],[\"完美解决主键问题\",{\"1\":{\"827\":1}}],[\"完整代码\",{\"1\":{\"708\":1}}],[\"完成后检查结果\",{\"1\":{\"943\":1}}],[\"完成后\",{\"1\":{\"815\":1,\"939\":1}}],[\"完成逻辑判断和动态拼接\",{\"1\":{\"812\":1}}],[\"完成ioc容器可用的最后一道工序\",{\"1\":{\"678\":1}}],[\"完成编译\",{\"1\":{\"357\":1}}],[\"完全服从acid的隔离级别\",{\"1\":{\"634\":1}}],[\"完全不用考虑对象是如何被创建出来的\",{\"1\":{\"595\":1}}],[\"完全无法在新生代找到足够长的连续空闲空间\",{\"1\":{\"512\":1}}],[\"完全废弃了永久代的概念\",{\"1\":{\"445\":1}}],[\"完全采用即时编译器模式执行程序\",{\"1\":{\"371\":1}}],[\"完全采用解释器模式执行程序\",{\"1\":{\"371\":1}}],[\"缺省情况下hotspot\",{\"1\":{\"371\":1}}],[\"缺点是性能下降\",{\"1\":{\"405\":1}}],[\"缺点\",{\"0\":{\"975\":1},\"1\":{\"139\":1,\"278\":1,\"479\":2,\"517\":1,\"521\":1,\"522\":1,\"523\":1,\"526\":1,\"534\":1,\"665\":1,\"807\":1}}],[\"显得更为合适\",{\"1\":{\"887\":1}}],[\"显然\",{\"1\":{\"370\":1}}],[\"显示版本则表示配置成功\",{\"1\":{\"1007\":1}}],[\"显示区\",{\"1\":{\"711\":1}}],[\"显示总的文件大小\",{\"1\":{\"577\":1}}],[\"显示最近创建的容器\",{\"1\":{\"577\":1}}],[\"显示所有的容器\",{\"1\":{\"577\":1}}],[\"显示虚拟机配置信息\",{\"1\":{\"340\":1}}],[\"显示隐藏侧边栏\",{\"1\":{\"48\":1}}],[\"显示状态栏\",{\"1\":{\"38\":1}}],[\"显示类结构\",{\"1\":{\"6\":1}}],[\"纶大部分方法都会被编译成本地代码\",{\"1\":{\"369\":1}}],[\"必然需要一个明确的阈值\",{\"1\":{\"368\":1}}],[\"必须是第一个参数\",{\"1\":{\"859\":1}}],[\"必须是\",{\"1\":{\"756\":1}}],[\"必须是单例\",{\"1\":{\"621\":1}}],[\"必须满足一定的要求\",{\"1\":{\"740\":1}}],[\"必须了解其底层原理\",{\"1\":{\"665\":1}}],[\"必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的\",{\"1\":{\"396\":1}}],[\"必须相同\",{\"1\":{\"395\":1}}],[\"必须先获得锁\",{\"1\":{\"288\":1}}],[\"必须首先获得对应的\",{\"1\":{\"251\":1}}],[\"必须使用集合的\",{\"1\":{\"235\":1}}],[\"必须同时指明数组的长度\",{\"1\":{\"228\":1}}],[\"必须写在\",{\"1\":{\"106\":1}}],[\"必须进入到\",{\"1\":{\"72\":1}}],[\"編译\",{\"1\":{\"368\":1}}],[\"热部署jar\",{\"1\":{\"670\":1}}],[\"热度衰减\",{\"1\":{\"369\":1}}],[\"热点代码\",{\"1\":{\"368\":4}}],[\"热启动\",{\"1\":{\"22\":1}}],[\"逃逸分析\",{\"0\":{\"507\":1,\"511\":1}}],[\"逃逸分析的基本行为就是分析对象动态作用域\",{\"1\":{\"506\":1}}],[\"逃逸分析概述\",{\"0\":{\"506\":1}}],[\"逃逸分析是优化的基础\",{\"1\":{\"372\":1}}],[\"逃生门\",{\"1\":{\"365\":1}}],[\"逃脱词匹配\",{\"1\":{\"143\":1}}],[\"立即执行\",{\"1\":{\"365\":1}}],[\"省去编译的时间\",{\"1\":{\"365\":1}}],[\"尽量少使用\",{\"1\":{\"600\":1}}],[\"尽量避免程序中出现过多的大对象\",{\"1\":{\"498\":1}}],[\"尽量较少碰撞\",{\"1\":{\"246\":1}}],[\"尽管使用\",{\"1\":{\"740\":1}}],[\"尽管它告诉\",{\"1\":{\"712\":1}}],[\"尽管消息流经\",{\"1\":{\"692\":1}}],[\"尽管不是所有的对象实例都能够在tlab中成功分配内存\",{\"1\":{\"502\":1}}],[\"尽管方法区域在逻辑上是堆的一部分\",{\"1\":{\"441\":1}}],[\"尽管\",{\"1\":{\"365\":1,\"929\":1,\"1038\":1}}],[\"尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间\",{\"1\":{\"365\":1}}],[\"平均分布\",{\"1\":{\"916\":1}}],[\"平时你是如何搭配使用垃圾回收器的\",{\"1\":{\"518\":1}}],[\"平时一直在听的一个技术博客\",{\"1\":{\"143\":1}}],[\"平台支持一种叫作即时编译的技术\",{\"1\":{\"363\":1}}],[\"模糊查询like语句该怎么写\",{\"0\":{\"814\":1}}],[\"模拟其接收不到消息\",{\"1\":{\"747\":1,\"748\":1}}],[\"模拟对象\",{\"1\":{\"591\":1}}],[\"模型与数据格式无关\",{\"1\":{\"645\":1}}],[\"模型拥有最多的处理任务\",{\"1\":{\"645\":1}}],[\"模型化思想模型化思想\",{\"0\":{\"68\":1}}],[\"模式的信息交换方式\",{\"1\":{\"885\":1}}],[\"模式即为惰性队列的模式\",{\"1\":{\"783\":1}}],[\"模式最大的好处在于是异步的\",{\"1\":{\"720\":1}}],[\"模式\",{\"1\":{\"624\":1,\"720\":2,\"783\":1,\"827\":1}}],[\"模式字母\",{\"1\":{\"573\":1}}],[\"模块\",{\"1\":{\"362\":2}}],[\"模块构成\",{\"1\":{\"362\":1}}],[\"模块和\",{\"1\":{\"362\":1}}],[\"模板函数中直接产生这条字节码执行时的机器码\",{\"1\":{\"362\":1}}],[\"翻译者\",{\"1\":{\"361\":1}}],[\"翻译\",{\"1\":{\"358\":1,\"361\":1}}],[\"橙色部分由\",{\"1\":{\"357\":1}}],[\"蓝色为编译执行的过程\",{\"1\":{\"357\":1}}],[\"绿色部分为解释执行过程\",{\"1\":{\"357\":1}}],[\"符合cp原则\",{\"1\":{\"800\":1}}],[\"符合ap原则\",{\"1\":{\"800\":1}}],[\"符合元宇宙特征的几个网站\",{\"1\":{\"145\":1}}],[\"符号\",{\"1\":{\"728\":2}}],[\"符号引用的字面量形式明确定义在\",{\"1\":{\"379\":1}}],[\"符号引用就是一组符号来描述所引用的目标\",{\"1\":{\"379\":1}}],[\"符号引用验证\",{\"1\":{\"379\":1}}],[\"符号表\",{\"1\":{\"355\":1}}],[\"物理删除\",{\"1\":{\"839\":1}}],[\"物理分页\",{\"1\":{\"827\":1}}],[\"物理电脑内存大小\",{\"1\":{\"486\":2}}],[\"物理机\",{\"1\":{\"355\":1}}],[\"物品体积\",{\"1\":{\"207\":1}}],[\"广播调用所有提供者\",{\"1\":{\"917\":1}}],[\"广泛用于ibm的各种java产品\",{\"1\":{\"353\":1}}],[\"广度优先搜索\",{\"1\":{\"177\":1}}],[\"桌而应用\",{\"1\":{\"353\":1}}],[\"市场定位与\",{\"1\":{\"353\":1}}],[\"简言之\",{\"1\":{\"873\":1}}],[\"简介\",{\"0\":{\"826\":1}}],[\"简述\",{\"0\":{\"818\":1}}],[\"简而言之就是\",{\"1\":{\"670\":1}}],[\"简化代码的编写\",{\"1\":{\"852\":1}}],[\"简化开发\",{\"1\":{\"826\":1}}],[\"简化了项目开发难度\",{\"1\":{\"667\":1}}],[\"简化操作\",{\"1\":{\"648\":1}}],[\"简短的定义就是\",{\"1\":{\"544\":1}}],[\"简单类型\",{\"0\":{\"1026\":1}}],[\"简单总结为\",{\"1\":{\"875\":1}}],[\"简单的\",{\"1\":{\"875\":1}}],[\"简单的说\",{\"1\":{\"873\":1}}],[\"简单的发布确认机制在应答与签收已经介绍\",{\"1\":{\"760\":1}}],[\"简单\",{\"1\":{\"724\":2}}],[\"简单工厂模式的实质是由一个工厂类根据传入的参数\",{\"1\":{\"624\":1}}],[\"简单高效\",{\"1\":{\"530\":1}}],[\"简单地讲\",{\"1\":{\"434\":1}}],[\"简单来说\",{\"1\":{\"355\":1,\"751\":1}}],[\"简称异常完成出口\",{\"1\":{\"424\":1}}],[\"简称正常完成出口\",{\"1\":{\"424\":1}}],[\"简称\",{\"1\":{\"353\":1,\"826\":1}}],[\"简书\",{\"1\":{\"120\":1}}],[\"跹的优秀特性\",{\"1\":{\"352\":1}}],[\"整合springboot\",{\"0\":{\"753\":1,\"780\":1}}],[\"整合的方式是在\",{\"1\":{\"352\":1}}],[\"整数\",{\"1\":{\"577\":1}}],[\"整堆收集\",{\"1\":{\"493\":1}}],[\"整理算法\",{\"1\":{\"530\":1,\"531\":1}}],[\"整理算法要低于复制算法\",{\"1\":{\"523\":1}}],[\"整理的混合实现\",{\"1\":{\"525\":1}}],[\"整理\",{\"1\":{\"471\":1,\"535\":1}}],[\"整个对象的创建过程是由用户自己来控制的\",{\"1\":{\"610\":1}}],[\"整个过程分为四个步骤\",{\"1\":{\"534\":1}}],[\"整个二进制就只包含1个1\",{\"1\":{\"253\":1}}],[\"整个看起来就像是优化过且线程安全的\",{\"1\":{\"249\":1}}],[\"名字中的\",{\"1\":{\"351\":1}}],[\"名称为\",{\"1\":{\"49\":1}}],[\"具有相同结构和节点值的子树\",{\"1\":{\"1018\":1}}],[\"具有热点探测\",{\"1\":{\"350\":1}}],[\"具各动态性\",{\"1\":{\"459\":1}}],[\"具体到下方代码\",{\"1\":{\"1019\":1}}],[\"具体可参照代码\",{\"1\":{\"970\":1}}],[\"具体可参考官网\",{\"1\":{\"864\":1}}],[\"具体是将注解中含有group=provider的filter实现\",{\"1\":{\"905\":1}}],[\"具体的调用链代码是在protocolfilterwrapper\",{\"1\":{\"905\":1}}],[\"具体的设置还需要根据实际情况进行调整\",{\"1\":{\"277\":1}}],[\"具体情况具体考虑\",{\"1\":{\"887\":1}}],[\"具体调用过程\",{\"1\":{\"874\":1}}],[\"具体就是\",{\"1\":{\"818\":1}}],[\"具体看下方案例\",{\"1\":{\"752\":1}}],[\"具体查看某个参数值的指令\",{\"1\":{\"503\":1}}],[\"具体实现方式\",{\"1\":{\"437\":1}}],[\"具体问题具体分析\",{\"1\":{\"431\":1}}],[\"具体见\",{\"1\":{\"306\":1,\"314\":1,\"330\":1}}],[\"具体见上一条\",{\"1\":{\"279\":1}}],[\"具体内容见\",{\"1\":{\"301\":1}}],[\"具体区别如下\",{\"1\":{\"273\":1}}],[\"具体工作都是由\",{\"1\":{\"97\":1}}],[\"具体来说是由父工程的dependencymanagement来决定\",{\"1\":{\"88\":1}}],[\"具体来说是管理依赖信息的版本\",{\"1\":{\"85\":1}}],[\"具体文件已打包放入阿里云\",{\"1\":{\"38\":1}}],[\"真实删除\",{\"1\":{\"839\":1}}],[\"真正执行的是修改语句\",{\"1\":{\"840\":1}}],[\"真正意义上的并发收集器\",{\"1\":{\"531\":1}}],[\"真正的数据库层的事务提交和回滚是通过binlog或者redo\",{\"1\":{\"633\":1}}],[\"真正的\",{\"1\":{\"132\":1,\"140\":1}}],[\"真真正正在执行的是一个叫做java虚拟机的进程\",{\"1\":{\"346\":1}}],[\"串行\",{\"1\":{\"530\":1,\"539\":4}}],[\"串行收集器\",{\"0\":{\"530\":1}}],[\"串行垃圾收集器\",{\"1\":{\"339\":1}}],[\"串行化消费\",{\"1\":{\"298\":1}}],[\"元素的队列\",{\"1\":{\"751\":1}}],[\"元数据自动代理\",{\"1\":{\"604\":1}}],[\"元数据区大小可以使用参数\",{\"1\":{\"448\":1}}],[\"元空间收集\",{\"1\":{\"490\":1}}],[\"元空间的大小仅受本地内存限制\",{\"1\":{\"462\":1}}],[\"元空间的本质和永久代类似\",{\"1\":{\"445\":1}}],[\"元空间并不在虚拟机中\",{\"1\":{\"462\":1}}],[\"元空间最大可分配空间就是系统可用内存空间\",{\"1\":{\"462\":1}}],[\"元空间二者并不只是名字变了\",{\"1\":{\"445\":1}}],[\"元空间不在虚拟机设置的内存中\",{\"1\":{\"445\":1}}],[\"元空间就是hotspot\",{\"1\":{\"374\":1}}],[\"元空间使用的是本地内存\",{\"1\":{\"338\":1}}],[\"元空间\",{\"0\":{\"338\":1},\"1\":{\"483\":1,\"485\":1}}],[\"元宇宙\",{\"0\":{\"145\":1}}],[\"区域较大\",{\"1\":{\"525\":1}}],[\"区域相对老年代较小\",{\"1\":{\"525\":1}}],[\"区域加锁\",{\"1\":{\"471\":1}}],[\"区复制时\",{\"1\":{\"496\":1}}],[\"区向\",{\"1\":{\"496\":1}}],[\"区的总结\",{\"1\":{\"490\":1}}],[\"区的\",{\"1\":{\"490\":1}}],[\"区\",{\"1\":{\"465\":1,\"490\":4}}],[\"区分不同类的方式不仅仅根据类名\",{\"1\":{\"333\":1}}],[\"区别就是同时支持多个消息\",{\"1\":{\"706\":1}}],[\"区别消息队列\",{\"1\":{\"701\":1}}],[\"区别是\",{\"1\":{\"303\":1,\"532\":1}}],[\"区别\",{\"0\":{\"240\":1,\"241\":1}}],[\"面向服务架构\",{\"1\":{\"875\":1}}],[\"面向切面编程\",{\"1\":{\"591\":1,\"596\":1,\"604\":1}}],[\"面向我们用户的加载器\",{\"1\":{\"331\":1}}],[\"面试官要的是那些关键的重点\",{\"1\":{\"919\":1}}],[\"面试官都很喜欢问这类问题\",{\"1\":{\"919\":1}}],[\"面试题\",{\"0\":{\"465\":1},\"1\":{\"955\":1,\"962\":1,\"972\":1}}],[\"面试必备🎉🎉🎉\",{\"1\":{\"262\":1}}],[\"防止反转后丢失后续的节点\",{\"1\":{\"970\":1}}],[\"防止运行时错误\",{\"1\":{\"853\":1}}],[\"防止iframe\",{\"1\":{\"788\":1}}],[\"防止因为队列处理时间长\",{\"1\":{\"718\":1}}],[\"防止图片失效\",{\"1\":{\"702\":1,\"777\":1}}],[\"防止核心\",{\"1\":{\"393\":1}}],[\"防止源码泄漏\",{\"1\":{\"386\":1}}],[\"防止内存溢出\",{\"1\":{\"328\":1}}],[\"防御性css\",{\"1\":{\"125\":1}}],[\"顾名思义就是无法被消费的消息\",{\"1\":{\"744\":1}}],[\"顾名思义\",{\"1\":{\"328\":1}}],[\"联合使用\",{\"1\":{\"326\":1,\"327\":1,\"328\":1}}],[\"垃圾对象多的前提下的\",{\"1\":{\"523\":1}}],[\"垃圾是指在运行程序中没有任何指针指向的对象\",{\"1\":{\"515\":1}}],[\"垃圾回收算法的实现原理\",{\"1\":{\"518\":1}}],[\"垃圾回收算法有哪些\",{\"1\":{\"518\":1}}],[\"垃圾回收机制\",{\"0\":{\"517\":1}}],[\"垃圾回收也可以清除内存里的记录碎片\",{\"1\":{\"516\":1}}],[\"垃圾回收概述\",{\"0\":{\"514\":1}}],[\"垃圾回收时对象会移动\",{\"1\":{\"479\":1}}],[\"垃圾回收是否会涉及到虚拟机栈\",{\"0\":{\"430\":1}}],[\"垃圾回收器就不会回收它\",{\"1\":{\"326\":1}}],[\"垃圾回收器绝不会回收它\",{\"1\":{\"325\":1}}],[\"垃圾收集线程只收集一小片区域的内存空间\",{\"1\":{\"526\":1}}],[\"垃圾收集策略和算法\",{\"1\":{\"518\":1}}],[\"垃圾收集器是垃圾回收算法的具体实现\",{\"1\":{\"529\":1}}],[\"垃圾收集器\",{\"0\":{\"529\":1},\"1\":{\"482\":1}}],[\"垃圾收集算法\",{\"0\":{\"330\":1}}],[\"垃圾收集行为在这个区域是比较少出现的\",{\"1\":{\"305\":1}}],[\"虚方法表会在类加载的链接阶段被创建并开始初始化\",{\"1\":{\"423\":1}}],[\"虚方法表什么时候被创建\",{\"1\":{\"423\":1}}],[\"虚方法表\",{\"0\":{\"423\":1}}],[\"虚方法\",{\"0\":{\"421\":1}}],[\"虚引用必须和引用队列\",{\"1\":{\"328\":1}}],[\"虚引用与软引用和弱引用的一个区别在于\",{\"1\":{\"328\":1}}],[\"虚引用主要用来跟踪对象被垃圾回收的活动\",{\"1\":{\"328\":1}}],[\"虚引用并不会决定对象的生命周期\",{\"1\":{\"328\":1}}],[\"虚引用\",{\"0\":{\"328\":1},\"1\":{\"328\":1}}],[\"虚引用四种\",{\"1\":{\"324\":1}}],[\"虚拟器启动时\",{\"1\":{\"365\":1}}],[\"虚拟的双向队列即不存在队列实例\",{\"1\":{\"289\":1}}],[\"虚拟机的一个重要进化特征\",{\"1\":{\"535\":1}}],[\"虚拟机的执行引擎输入\",{\"1\":{\"356\":1}}],[\"虚拟机第一款真正意义上的并发收集器\",{\"1\":{\"534\":1}}],[\"虚拟机将分配到的内存空间都初始化为零值\",{\"1\":{\"472\":1}}],[\"虚拟机将这两种情况视为没有必要执行\",{\"1\":{\"323\":1}}],[\"虚拟机是否使用\",{\"1\":{\"471\":1}}],[\"虚拟机采用了两种方式解决并发问题\",{\"1\":{\"471\":1}}],[\"虚拟机采用这种分配方式\",{\"1\":{\"471\":1}}],[\"虚拟机需要解决并发问题\",{\"1\":{\"471\":1}}],[\"虚拟机需要维护一个列表\",{\"1\":{\"471\":1}}],[\"虚拟机需要将分配到的内存空间都初始化为零值\",{\"1\":{\"312\":1}}],[\"虚拟机具备类型卸载的能力\",{\"1\":{\"464\":1}}],[\"虚拟机提供了\",{\"1\":{\"464\":1}}],[\"虚拟机被允许对满足上述三个条件的无用类进行回收\",{\"1\":{\"464\":1}}],[\"虚拟机对常量池的回收策略是很明确的\",{\"1\":{\"464\":1}}],[\"虚拟机对此区域未完全回收而导致内存泄漏\",{\"1\":{\"464\":1}}],[\"虚拟机对方法区的实现为永久代\",{\"1\":{\"307\":1}}],[\"虚拟机指令根据这张常量表找到要执行的类名\",{\"1\":{\"458\":1}}],[\"虚拟机一样会抛出异常\",{\"1\":{\"448\":1}}],[\"虚拟机同样会抛出内存溢出错误\",{\"1\":{\"442\":1}}],[\"虚拟机使用局部变量表完成方法的传递\",{\"1\":{\"415\":1}}],[\"虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程\",{\"1\":{\"415\":1}}],[\"虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间\",{\"1\":{\"504\":1}}],[\"虚拟机会耗尽所有的可用系统内存\",{\"1\":{\"448\":1}}],[\"虚拟机会耗尽所有可用的系统内存\",{\"1\":{\"305\":1,\"338\":1}}],[\"虚拟机会丢弃当前栈帧\",{\"1\":{\"413\":1}}],[\"虚拟机启动时被标明为启动类的类\",{\"1\":{\"397\":1}}],[\"虚拟机必须保证一个类的<clinit>\",{\"1\":{\"380\":1}}],[\"虚拟机\",{\"1\":{\"355\":1}}],[\"虚拟机核心的组成部分之一\",{\"1\":{\"355\":1}}],[\"虚拟机可以知道内存中某个位置的数据具体是什么类型\",{\"1\":{\"350\":1}}],[\"虚拟机可以对满足上述\",{\"1\":{\"329\":1}}],[\"虚拟机各方面的运行数据\",{\"1\":{\"340\":1}}],[\"虚拟机参数等信息\",{\"1\":{\"340\":1}}],[\"虚拟机就会把这个弱引用加入到与之关联的引用队列中\",{\"1\":{\"327\":1}}],[\"虚拟机就会把这个软引用加入到与之关联的引用队列中\",{\"1\":{\"326\":1}}],[\"虚拟机宁愿抛出\",{\"1\":{\"325\":1}}],[\"虚拟机要对对象进行必要的设置\",{\"1\":{\"313\":1}}],[\"虚拟机遇到一条\",{\"1\":{\"310\":1,\"470\":1}}],[\"虚拟机规范中的定义\",{\"1\":{\"305\":1}}],[\"虚拟机规范把方法区描述为堆的一个逻辑部分\",{\"1\":{\"305\":1}}],[\"虚拟机所管理的内存中最大的一块\",{\"1\":{\"304\":1}}],[\"虚拟机中的元空间或者永久代\",{\"1\":{\"464\":1}}],[\"虚拟机中的同步基于monitor对象实现\",{\"1\":{\"278\":1}}],[\"虚拟机中和\",{\"1\":{\"303\":1}}],[\"虚拟机栈中引用的对象\",{\"1\":{\"519\":1}}],[\"虚拟机栈基本内容\",{\"0\":{\"406\":1}}],[\"虚拟机栈概述\",{\"0\":{\"404\":1}}],[\"虚拟机栈合二为一\",{\"1\":{\"303\":1}}],[\"虚拟机栈为虚拟机执行\",{\"1\":{\"303\":1}}],[\"虚拟机栈的内存大小可以动态扩展\",{\"1\":{\"302\":1}}],[\"虚拟机栈的内存大小不允许动态扩展\",{\"1\":{\"302\":1}}],[\"虚拟机栈的最大深度的时候\",{\"1\":{\"302\":1}}],[\"虚拟机栈会出现两种错误\",{\"1\":{\"302\":1}}],[\"虚拟机栈是由一个个栈帧组成\",{\"1\":{\"302\":1}}],[\"虚拟机栈\",{\"0\":{\"403\":1},\"1\":{\"300\":1,\"322\":1}}],[\"虚拟机团队在\",{\"1\":{\"285\":1}}],[\"虚拟机为了避免线程真实地在操作系统层面挂起\",{\"1\":{\"278\":1}}],[\"虚拟机并不会立即升级为重量级锁\",{\"1\":{\"278\":1}}],[\"软负载均衡及容错机制\",{\"1\":{\"884\":1}}],[\"软引用可以和一个引用队列\",{\"1\":{\"326\":1}}],[\"软引用可用来实现内存敏感的高速缓存\",{\"1\":{\"326\":1}}],[\"软引用\",{\"0\":{\"326\":1},\"1\":{\"324\":1}}],[\"软件基金会组织维护的一款专门为\",{\"1\":{\"59\":1}}],[\"软件\",{\"2\":{\"25\":1,\"30\":1,\"51\":1,\"116\":1}}],[\"至于注重通信速度还是方便灵活性\",{\"1\":{\"887\":1}}],[\"至于它是否可以运行\",{\"1\":{\"375\":1}}],[\"至此利用\",{\"1\":{\"753\":1}}],[\"至少要经历两次标记过程\",{\"1\":{\"323\":1}}],[\"至目标测试目录\",{\"1\":{\"94\":1}}],[\"至目标目录\",{\"1\":{\"94\":1}}],[\"缓存在本地\",{\"1\":{\"915\":1}}],[\"缓存区里\",{\"1\":{\"724\":1}}],[\"缓存\",{\"1\":{\"355\":1,\"591\":1}}],[\"缓存相关\",{\"1\":{\"4\":1}}],[\"缓刑阶段\",{\"1\":{\"323\":1}}],[\"呢\",{\"1\":{\"322\":1,\"490\":1,\"731\":1}}],[\"节省时间和空间\",{\"1\":{\"954\":1}}],[\"节点的值\",{\"1\":{\"1029\":1}}],[\"节点的右子树只包含大于当前节点的数\",{\"1\":{\"1028\":1}}],[\"节点的左子树只包含小于当前节点的数\",{\"1\":{\"1028\":1}}],[\"节点返回发送结果\",{\"1\":{\"762\":1}}],[\"节点所走过的路径称为引用链\",{\"1\":{\"322\":1}}],[\"节约时间和精力\",{\"1\":{\"85\":1}}],[\"永远无法回收\",{\"1\":{\"321\":1}}],[\"永久区\",{\"1\":{\"483\":1}}],[\"永久存在\",{\"1\":{\"305\":1}}],[\"永久代不足时才会触发\",{\"1\":{\"463\":1}}],[\"永久代为什么要被元空间替代\",{\"0\":{\"462\":1}}],[\"永久代有固定大小的限制\",{\"1\":{\"306\":1}}],[\"永久代是\",{\"1\":{\"305\":1}}],[\"永久代和元空间则是1\",{\"1\":{\"305\":1}}],[\"永久代可以不考虑\",{\"1\":{\"304\":1,\"483\":1}}],[\"永久代\",{\"0\":{\"338\":1},\"1\":{\"304\":1,\"305\":2,\"338\":2,\"343\":1,\"445\":1,\"485\":1}}],[\"计数\",{\"1\":{\"939\":1}}],[\"计数之后有两个\",{\"1\":{\"939\":1}}],[\"计数器的值作为返回地址\",{\"1\":{\"424\":1}}],[\"计数器就减\",{\"1\":{\"321\":1}}],[\"计数器就加\",{\"1\":{\"321\":1}}],[\"计算数组中的最大值\",{\"1\":{\"939\":1}}],[\"计算\",{\"1\":{\"240\":1}}],[\"及stringbuilder\",{\"1\":{\"994\":1}}],[\"及代码前后加粗的段落中了\",{\"1\":{\"985\":1}}],[\"及之前堆内存锣辑上分为三部分\",{\"1\":{\"483\":1}}],[\"及之后堆内存逻辑上分为三部分\",{\"1\":{\"483\":1}}],[\"及之后\",{\"1\":{\"318\":1}}],[\"及时编译器\",{\"1\":{\"349\":1}}],[\"及时调用它的的remove方法清除数据\",{\"1\":{\"280\":1}}],[\"专注于服务器端应用\",{\"1\":{\"352\":1}}],[\"专注模式\",{\"1\":{\"48\":1}}],[\"专门开辟的一块区域\",{\"1\":{\"317\":1}}],[\"建议如果存在自定义通用\",{\"1\":{\"833\":1}}],[\"建议开发测试时启用该功能\",{\"1\":{\"827\":1}}],[\"建议单例\",{\"1\":{\"654\":1}}],[\"建议使用springboot提供的全局异常处理\",{\"1\":{\"650\":1}}],[\"建议将\",{\"1\":{\"448\":1}}],[\"建立回边计数器统计的目的就是为了触发osr编译\",{\"1\":{\"370\":1}}],[\"建立对象就是为了使用对象\",{\"1\":{\"315\":1}}],[\"建了子module后\",{\"1\":{\"87\":1}}],[\"移植\",{\"1\":{\"352\":1}}],[\"移除了永久代用元空间\",{\"1\":{\"307\":1}}],[\"移动pre和slow\",{\"1\":{\"974\":1}}],[\"移动后\",{\"1\":{\"974\":1}}],[\"移动对象\",{\"1\":{\"524\":1}}],[\"移动对象的同时\",{\"1\":{\"523\":1}}],[\"移动过程中\",{\"1\":{\"523\":1}}],[\"移动端\",{\"1\":{\"157\":1}}],[\"移动\",{\"1\":{\"146\":1}}],[\"初始总水量\",{\"1\":{\"983\":1}}],[\"初始状态\",{\"1\":{\"982\":1}}],[\"初始传来的是2\",{\"1\":{\"943\":1}}],[\"初始标记\",{\"1\":{\"534\":1,\"535\":1}}],[\"初始值及最大值\",{\"1\":{\"503\":1}}],[\"初始堆空间内存\",{\"1\":{\"503\":1}}],[\"初始内存大小\",{\"1\":{\"486\":1}}],[\"初始化为0\",{\"1\":{\"957\":1}}],[\"初始化dp数组中的元素\",{\"1\":{\"925\":1}}],[\"初始化配置信息\",{\"1\":{\"883\":1}}],[\"初始化都完成的a\",{\"1\":{\"621\":1}}],[\"初始化都完成的对象\",{\"1\":{\"621\":1}}],[\"初始化成员变量\",{\"1\":{\"474\":1}}],[\"初始化才正式开始\",{\"1\":{\"474\":1}}],[\"初始化分配到的空间\",{\"0\":{\"472\":1}}],[\"初始化一个类的子类\",{\"1\":{\"397\":1}}],[\"初始化阶段就是执行类构造器方法<clinit>\",{\"1\":{\"380\":1}}],[\"初始化\",{\"0\":{\"380\":1,\"470\":1},\"1\":{\"375\":1,\"614\":1}}],[\"初始化零值完成之后\",{\"1\":{\"313\":1}}],[\"初始化零值\",{\"0\":{\"312\":1}}],[\"初始大小\",{\"1\":{\"305\":1,\"338\":1}}],[\"初始容量大小和每次扩充容量大小的不同\",{\"1\":{\"239\":1}}],[\"了\",{\"1\":{\"305\":1,\"505\":1,\"599\":1,\"741\":2}}],[\"常见面试题总结\",{\"1\":{\"824\":1}}],[\"常见问题\",{\"0\":{\"586\":1}}],[\"常见的有\",{\"1\":{\"638\":1}}],[\"常见的终端操作有\",{\"1\":{\"547\":1}}],[\"常见的中间操作有\",{\"1\":{\"547\":1}}],[\"常见的垃圾收集算法\",{\"0\":{\"520\":1}}],[\"常见的垃圾回收器算法有哪些\",{\"1\":{\"518\":1}}],[\"常见的栈上分配的场景\",{\"1\":{\"508\":1}}],[\"常量保存在本地内存的元空间\",{\"1\":{\"461\":1}}],[\"常量池表\",{\"1\":{\"459\":1}}],[\"常量池中废弃的常量和不再使用的类型\",{\"1\":{\"464\":1}}],[\"常量池中有什么\",{\"0\":{\"458\":1}}],[\"常量池中的对象\",{\"1\":{\"317\":5}}],[\"常量池\",{\"0\":{\"317\":1,\"456\":1},\"1\":{\"458\":1}}],[\"常量\",{\"1\":{\"305\":1,\"343\":1,\"451\":1}}],[\"常用注解\",{\"0\":{\"834\":1}}],[\"常用注解都有哪些\",{\"0\":{\"651\":1}}],[\"常用的类型有\",{\"1\":{\"693\":1}}],[\"常用的实现类\",{\"0\":{\"226\":1}}],[\"常用\",{\"0\":{\"583\":1}}],[\"常用操作\",{\"0\":{\"581\":1}}],[\"常用日期类概述\",{\"0\":{\"556\":1}}],[\"常用调优工具\",{\"0\":{\"492\":1}}],[\"常用参数\",{\"1\":{\"305\":1}}],[\"常用在部分奇偶变化\",{\"1\":{\"183\":1}}],[\"常用算法整理\",{\"0\":{\"181\":1}}],[\"常用效果组件\",{\"0\":{\"158\":1}}],[\"常用设置\",{\"0\":{\"5\":1}}],[\"老年代名称判断\",{\"1\":{\"537\":1}}],[\"老年代采用标记\",{\"1\":{\"530\":1,\"531\":1}}],[\"老年代放置长生命周期的对象\",{\"1\":{\"512\":1}}],[\"老年代2\",{\"1\":{\"503\":1}}],[\"老年代空间不足\",{\"1\":{\"496\":1}}],[\"老年代gc\",{\"0\":{\"495\":1}}],[\"老年代收集\",{\"1\":{\"493\":1}}],[\"老年代占4\",{\"1\":{\"488\":1}}],[\"老年代占2\",{\"1\":{\"488\":1}}],[\"老年代\",{\"1\":{\"304\":1,\"339\":2,\"465\":1,\"483\":2,\"485\":1,\"490\":1,\"493\":1,\"497\":1,\"525\":1,\"537\":2,\"539\":2}}],[\"错误原因可能是网络不稳定\",{\"1\":{\"587\":1}}],[\"错误描述\",{\"1\":{\"587\":1}}],[\"错误出现\",{\"1\":{\"308\":1}}],[\"错误\",{\"1\":{\"302\":1,\"304\":1,\"307\":1,\"325\":1,\"392\":1}}],[\"描述数据类型和服务接口\",{\"1\":{\"879\":1}}],[\"描述\",{\"0\":{\"929\":1,\"933\":1,\"937\":1,\"953\":1,\"967\":1,\"981\":1,\"1018\":1,\"1028\":1,\"1033\":1,\"1038\":1},\"1\":{\"873\":1}}],[\"描述一个方法调用了另外的其他方法时\",{\"1\":{\"417\":1}}],[\"描述的是\",{\"1\":{\"302\":1}}],[\"描述依赖项列表\",{\"1\":{\"103\":1}}],[\"随便找一个\",{\"1\":{\"1012\":1}}],[\"随着服务化的进一步发展\",{\"1\":{\"881\":1}}],[\"随着应用程序所应付的业务越来越庞大\",{\"1\":{\"516\":1}}],[\"随着jit编译期的发展与逃逸分析技术逐渐成熟\",{\"1\":{\"505\":1}}],[\"随着类的加载而加载\",{\"1\":{\"455\":1}}],[\"随着方法栈帧的销毁\",{\"1\":{\"415\":1}}],[\"随着时间的推移\",{\"1\":{\"365\":1}}],[\"随着更多类的创建\",{\"1\":{\"305\":1,\"338\":1}}],[\"随着线程的结束而死亡\",{\"1\":{\"301\":1}}],[\"随机选取提供者策略\",{\"1\":{\"916\":1}}],[\"随机存取存储器\",{\"1\":{\"717\":1}}],[\"随机存取和顺序存取之间的区别往往是模糊的\",{\"1\":{\"230\":1}}],[\"随机排序\",{\"1\":{\"257\":1}}],[\"随机访问\",{\"1\":{\"230\":1}}],[\"独立回收\",{\"1\":{\"527\":1}}],[\"独立存储\",{\"1\":{\"301\":1}}],[\"独立开发者\",{\"1\":{\"120\":1}}],[\"介绍\",{\"0\":{\"399\":1,\"690\":1,\"714\":1,\"717\":1,\"761\":1,\"764\":1,\"767\":1},\"1\":{\"422\":1,\"910\":1}}],[\"介绍下\",{\"0\":{\"300\":1}}],[\"介绍页\",{\"0\":{\"3\":1}}],[\"惊群效应\",{\"0\":{\"293\":1}}],[\"假删除\",{\"1\":{\"839\":1}}],[\"假设\",{\"1\":{\"968\":1,\"969\":1}}],[\"假设一个二叉搜索树具有如下特征\",{\"1\":{\"1028\":1}}],[\"假设一个实现类初始化过程比较消耗资源且耗时\",{\"1\":{\"893\":1}}],[\"假设一个简单的循环依赖场景\",{\"1\":{\"621\":1}}],[\"假设在通道上有未确认的消息\",{\"1\":{\"717\":1}}],[\"假设只有二级缓存的情况\",{\"1\":{\"622\":1}}],[\"假设你正在爬楼梯\",{\"1\":{\"200\":1}}],[\"假如我们需要实例化这个\",{\"1\":{\"595\":1}}],[\"假如有10个人要上厕所\",{\"1\":{\"292\":1}}],[\"假如每个线程各有一个await\",{\"1\":{\"292\":1}}],[\"请判断能否通过使用这两个水壶\",{\"1\":{\"981\":1}}],[\"请创建自己的\",{\"1\":{\"833\":1}}],[\"请问\",{\"1\":{\"816\":1}}],[\"请用\",{\"1\":{\"765\":1}}],[\"请输入信息\",{\"1\":{\"708\":1,\"711\":1,\"712\":1,\"734\":1}}],[\"请注意生产者\",{\"1\":{\"692\":1}}],[\"请解释\",{\"0\":{\"598\":1}}],[\"请将\",{\"1\":{\"392\":1}}],[\"请求参数传递到方法的形参\",{\"1\":{\"654\":1}}],[\"请求url\",{\"1\":{\"651\":1}}],[\"请求的\",{\"1\":{\"651\":1}}],[\"请求到处理器映射\",{\"1\":{\"644\":1}}],[\"请求\",{\"1\":{\"615\":1,\"673\":1,\"885\":1}}],[\"请求中的\",{\"1\":{\"525\":1}}],[\"请求最终将到达顶层的启动类加载器\",{\"1\":{\"391\":1}}],[\"请求与保持条件\",{\"1\":{\"269\":1}}],[\"请考虑使用\",{\"1\":{\"292\":1}}],[\"保持不变\",{\"1\":{\"938\":1}}],[\"保护程序安全\",{\"1\":{\"393\":1}}],[\"保证一个类仅有一个实例\",{\"1\":{\"626\":1}}],[\"保证了\",{\"1\":{\"535\":1}}],[\"保证指针更新操作的原子性\",{\"1\":{\"471\":1}}],[\"保证被加载类的正确性\",{\"1\":{\"379\":1}}],[\"保证所有任务按照指定顺序执行\",{\"1\":{\"291\":1}}],[\"保存新格子的坐标\",{\"1\":{\"944\":1}}],[\"保存处理后的x\",{\"1\":{\"944\":1}}],[\"保存在堆中\",{\"1\":{\"461\":1}}],[\"保存在class文件的常量池里\",{\"1\":{\"417\":1}}],[\"保存在方法的code属性中\",{\"1\":{\"416\":1}}],[\"保存\",{\"1\":{\"37\":1,\"44\":1}}],[\"单独计算\",{\"1\":{\"939\":1}}],[\"单独发布消息\",{\"1\":{\"724\":1}}],[\"单一长连接和nio异步通讯\",{\"1\":{\"888\":1}}],[\"单个确认发布方式非常慢\",{\"1\":{\"723\":1}}],[\"单个确认发布\",{\"0\":{\"722\":1},\"1\":{\"722\":1}}],[\"单个文件上传\",{\"1\":{\"655\":1}}],[\"单个信号量的semaphore对象可以实现互斥锁的功能\",{\"1\":{\"292\":1}}],[\"单线程\",{\"1\":{\"530\":1}}],[\"单线程池\",{\"1\":{\"291\":1}}],[\"单位是毫秒\",{\"1\":{\"752\":1}}],[\"单位是秒\",{\"1\":{\"369\":1}}],[\"单位为\",{\"1\":{\"335\":1}}],[\"单位时间内\",{\"1\":{\"268\":1}}],[\"单位时间内不一定同时执行\",{\"1\":{\"268\":1}}],[\"性能\",{\"1\":{\"873\":1}}],[\"性能基本无损耗\",{\"1\":{\"827\":1}}],[\"性能更好\",{\"1\":{\"602\":1}}],[\"性能相比\",{\"1\":{\"602\":1}}],[\"性能好很多\",{\"1\":{\"291\":1}}],[\"性能肯定比synchronized关键字要好\",{\"1\":{\"281\":1}}],[\"非递归的后序遍历\",{\"1\":{\"1024\":1}}],[\"非递归的中序遍历\",{\"1\":{\"1024\":1}}],[\"非递归的前序遍历\",{\"1\":{\"1024\":1}}],[\"非springboot\",{\"0\":{\"779\":1}}],[\"非常重要的一个部件\",{\"1\":{\"692\":1}}],[\"非常适合web应用\",{\"1\":{\"537\":1}}],[\"非常不错的学习手册\",{\"1\":{\"119\":1}}],[\"非正常退出\",{\"1\":{\"424\":1}}],[\"非虚方法不会出现在表中\",{\"1\":{\"423\":1}}],[\"非虚方法\",{\"0\":{\"421\":1}}],[\"非死不可\",{\"1\":{\"323\":1}}],[\"非堆\",{\"1\":{\"305\":1,\"343\":1,\"441\":1}}],[\"非运行时数据区的一部分\",{\"1\":{\"300\":1}}],[\"非公平锁\",{\"1\":{\"290\":1}}],[\"美团\",{\"1\":{\"289\":1,\"291\":1,\"465\":1,\"467\":1}}],[\"美团技术团队\",{\"1\":{\"262\":3}}],[\"核心技术\",{\"1\":{\"591\":1}}],[\"核心容器\",{\"1\":{\"591\":1}}],[\"核心\",{\"1\":{\"535\":1}}],[\"核心思想\",{\"1\":{\"522\":1}}],[\"核心思想是\",{\"1\":{\"289\":1}}],[\"核心线程数量\",{\"1\":{\"275\":1}}],[\"既然spring\",{\"1\":{\"604\":1}}],[\"既然\",{\"1\":{\"365\":1}}],[\"既然是内存就会受到本机总内存大小以及处理器寻址空间的限制\",{\"1\":{\"308\":1}}],[\"既然是线程放弃对象锁\",{\"1\":{\"288\":1}}],[\"既然wait是放弃对象锁\",{\"1\":{\"288\":1}}],[\"任意数量的object参数\",{\"1\":{\"997\":1}}],[\"任意一台报错则报错\",{\"1\":{\"917\":1}}],[\"任意一个web项目\",{\"1\":{\"675\":1}}],[\"任何抛出的异常都有错误消息\",{\"1\":{\"997\":1}}],[\"任何抛出的异常都没有异常消息\",{\"1\":{\"997\":1}}],[\"任何线程都可以访问到堆区中的共享数据\",{\"1\":{\"501\":1}}],[\"任何一个确定的时刻\",{\"1\":{\"402\":1}}],[\"任何一个线程运行到await方法时就阻塞\",{\"1\":{\"292\":1}}],[\"任何时间一个线程都只有一个方法在执行\",{\"1\":{\"399\":1}}],[\"任何时候计数器为\",{\"1\":{\"321\":1}}],[\"任何对象都可以作为锁\",{\"1\":{\"288\":1}}],[\"任务\",{\"1\":{\"591\":1}}],[\"任务队列是作为参数传进来的\",{\"1\":{\"277\":1}}],[\"任务队列\",{\"1\":{\"275\":1}}],[\"任务可以不需要等到线程创建就能立即执行\",{\"1\":{\"274\":1}}],[\"构建流\",{\"0\":{\"553\":1}}],[\"构成的组合\",{\"1\":{\"933\":1}}],[\"构成\",{\"1\":{\"497\":1}}],[\"构成一个环\",{\"1\":{\"229\":1}}],[\"构造方法注入和设值注入有什么区别\",{\"0\":{\"600\":1}}],[\"构造方法来制定是否是公平的\",{\"1\":{\"286\":1}}],[\"构造函数入参\",{\"1\":{\"599\":1}}],[\"构造器注入适用具有强依赖和不变性的依赖\",{\"1\":{\"600\":1}}],[\"构造器注入则不允许生成依赖关系不完整的对象\",{\"1\":{\"600\":1}}],[\"构造器依赖注入在容器触发构造器的时候完成\",{\"1\":{\"597\":1}}],[\"构造器依赖注入\",{\"1\":{\"597\":1}}],[\"构造器是虚拟机视角下的<init>\",{\"1\":{\"380\":1}}],[\"构造器方法中指令按语句在源文件中出现的顺序执行\",{\"1\":{\"380\":1}}],[\"构造时传入个数\",{\"1\":{\"292\":1}}],[\"改为\",{\"1\":{\"1029\":2}}],[\"改为处理其他事情\",{\"1\":{\"286\":1}}],[\"改进后的代码如下\",{\"1\":{\"957\":1}}],[\"改变\",{\"1\":{\"638\":1}}],[\"改用与\",{\"1\":{\"445\":1}}],[\"改成了习惯的ctrl+w\",{\"1\":{\"6\":1}}],[\"改成了习惯的ctrl+1\",{\"1\":{\"6\":1}}],[\"语法\",{\"1\":{\"842\":1}}],[\"语句以及其执行时间\",{\"1\":{\"827\":1}}],[\"语句块来完成\",{\"1\":{\"285\":1}}],[\"语音编写\",{\"1\":{\"384\":1}}],[\"语言支持等\",{\"1\":{\"873\":1}}],[\"语言\",{\"1\":{\"591\":1}}],[\"语言层次的常量概念\",{\"1\":{\"464\":1}}],[\"语言实现的\",{\"1\":{\"382\":1}}],[\"语言的\",{\"1\":{\"367\":1}}],[\"语言之外\",{\"1\":{\"363\":1}}],[\"语言定位为\",{\"1\":{\"359\":1}}],[\"语雀\",{\"1\":{\"1\":1}}],[\"除外\",{\"1\":{\"434\":1}}],[\"除此之外\",{\"1\":{\"347\":1}}],[\"除非至少有一个未应答的消息被\",{\"1\":{\"717\":1}}],[\"除非至少有一个未处理的消息被确认\",{\"1\":{\"717\":1}}],[\"除非告知它不要这样做\",{\"1\":{\"710\":1}}],[\"除非数据被当前事务本身改变\",{\"1\":{\"634\":1}}],[\"除非是与硬件有关的应用\",{\"1\":{\"436\":1}}],[\"除非这个对象与引用链上的任何一个对象建立关联\",{\"1\":{\"323\":1}}],[\"除非异常或成功执行结束\",{\"1\":{\"282\":1}}],[\"除了注意xx\",{\"1\":{\"935\":1}}],[\"除了常见的\",{\"0\":{\"811\":1}}],[\"除了上面的接口\",{\"1\":{\"788\":1}}],[\"除了上面举例出来的这些\",{\"1\":{\"619\":1}}],[\"除了上述列出的mark\",{\"1\":{\"278\":1}}],[\"除了这篇文章\",{\"1\":{\"614\":1}}],[\"除了追求低停顿外\",{\"1\":{\"535\":1}}],[\"除了使用多线程进行垃圾收集外\",{\"1\":{\"531\":1}}],[\"除了释放没用的对象\",{\"1\":{\"516\":1}}],[\"除了以上七种情况\",{\"1\":{\"397\":1}}],[\"除了类的信息外\",{\"1\":{\"375\":1}}],[\"除了\",{\"1\":{\"331\":1,\"531\":1}}],[\"除了利用提交新任务来创建和启动线程\",{\"1\":{\"275\":1}}],[\"除了开始和末尾的位置上的元素\",{\"1\":{\"201\":1}}],[\"除了系统自带的\",{\"1\":{\"42\":1}}],[\"然而不管怎样\",{\"1\":{\"435\":1}}],[\"然而有些层次的任务用java实现起来不容易\",{\"1\":{\"435\":1}}],[\"然而\",{\"1\":{\"288\":1,\"792\":1}}],[\"然而它却占用内存\",{\"1\":{\"280\":1}}],[\"然后打印b\",{\"1\":{\"1024\":1}}],[\"然后继续下一个外层循环\",{\"1\":{\"957\":1}}],[\"然后进入循环\",{\"1\":{\"970\":1}}],[\"然后进入内层while循环\",{\"1\":{\"957\":1}}],[\"然后进行如下操作\",{\"1\":{\"671\":1}}],[\"然后进行两项工作\",{\"1\":{\"521\":1}}],[\"然后看到官方题解还有利用二进制数进行状态压缩的解法\",{\"1\":{\"947\":1}}],[\"然后又出现了两个\",{\"1\":{\"939\":1}}],[\"然后从左到右遍历数组\",{\"1\":{\"938\":1}}],[\"然后还需要实现集群功能\",{\"1\":{\"919\":1}}],[\"然后还需要定义好序列化协议\",{\"1\":{\"919\":1}}],[\"然后可以搞一套描述服务的语言\",{\"1\":{\"919\":1}}],[\"然后需要自定义协议\",{\"1\":{\"919\":1}}],[\"然后需要自定义类实现\",{\"1\":{\"764\":1}}],[\"然后使用一个含有3个线程\",{\"1\":{\"902\":1}}],[\"然后才进行真正的业务逻辑处理\",{\"1\":{\"902\":1}}],[\"然后文件里面记录的是此\",{\"1\":{\"892\":1}}],[\"然后找到请求之后将响应塞到对应的\",{\"1\":{\"891\":1}}],[\"然后最终调用真正的实现类\",{\"1\":{\"891\":1}}],[\"然后会从\",{\"1\":{\"891\":1}}],[\"然后会向注册中心注册提供者的信息\",{\"1\":{\"889\":1}}],[\"然后根据\",{\"1\":{\"889\":1}}],[\"然后根据条件决定是否添加shutdownhook\",{\"1\":{\"678\":1}}],[\"然后定时的发送统计数据到监控中心\",{\"1\":{\"882\":1}}],[\"然后注册中心将提供者元信息通知给\",{\"1\":{\"882\":1}}],[\"然后正常调用即可\",{\"1\":{\"859\":1}}],[\"然后调用\",{\"1\":{\"821\":1}}],[\"然后调用这个创建好的springapplication的实例方法\",{\"1\":{\"678\":1}}],[\"然后\",{\"1\":{\"819\":1,\"891\":1,\"1019\":1}}],[\"然后返回\",{\"1\":{\"789\":1}}],[\"然后传入getanonymousurl\",{\"1\":{\"789\":1}}],[\"然后点击\",{\"1\":{\"777\":1}}],[\"然后查询判断是否重复\",{\"1\":{\"774\":1}}],[\"然后就利用查询语句进行判断这个\",{\"1\":{\"774\":1}}],[\"然后我们在备份交换机下绑定一个队列\",{\"1\":{\"767\":1}}],[\"然后我们再传入这个回调对象到jdbctemplate\",{\"1\":{\"632\":1}}],[\"然后被消费掉\",{\"1\":{\"754\":1}}],[\"然后被消费者消费掉\",{\"1\":{\"754\":1}}],[\"然后被jvm调用\",{\"1\":{\"435\":1}}],[\"然后处理不就完事了吗\",{\"1\":{\"751\":1}}],[\"然后将\",{\"1\":{\"816\":1,\"889\":1}}],[\"然后将接口放入对应的set中\",{\"1\":{\"789\":1}}],[\"然后将未支付的订单进行关闭\",{\"1\":{\"751\":1}}],[\"然后将eden中的剩余对象移动到\",{\"1\":{\"490\":1}}],[\"然后停止该\",{\"1\":{\"747\":1}}],[\"然后清除该新缓存区的内容\",{\"1\":{\"724\":1}}],[\"然后分配到满足条件的队列里\",{\"1\":{\"738\":1}}],[\"然后分配给能处理消息的\",{\"1\":{\"709\":1}}],[\"然后分别在数量上减去这个最小值\",{\"1\":{\"194\":1}}],[\"然后如图开启多线程\",{\"1\":{\"701\":1}}],[\"然后遍历调用这些applicationcontextinitializer的initialize\",{\"1\":{\"678\":1}}],[\"然后遍历orders\",{\"1\":{\"194\":1}}],[\"然后选择maven将出现右侧面板\",{\"1\":{\"671\":1}}],[\"然后勾选\",{\"1\":{\"670\":1}}],[\"然后给用户反馈结果\",{\"1\":{\"646\":1}}],[\"然后给每一段数据配一把锁\",{\"1\":{\"251\":1}}],[\"然后再跟接口同一个路径下实现一个\",{\"1\":{\"901\":1}}],[\"然后再分别说本地引入怎样的\",{\"1\":{\"890\":1}}],[\"然后再通过\",{\"1\":{\"889\":1}}],[\"然后再调用本地服务进行处理\",{\"1\":{\"874\":1}}],[\"然后再重新声明一个新的\",{\"1\":{\"783\":1}}],[\"然后再创建一个交换机\",{\"1\":{\"754\":1}}],[\"然后再确定用哪个视图来显示返回的数据\",{\"1\":{\"645\":1}}],[\"然后再根据实现这些接口的集合的特点来选用\",{\"1\":{\"216\":1}}],[\"然后新创建一个事务\",{\"1\":{\"635\":1}}],[\"然后另一个事务尝试读取到了记录\",{\"1\":{\"634\":1}}],[\"然后sessionfactory根据客户的每次请求\",{\"1\":{\"628\":1}}],[\"然后重写\",{\"1\":{\"817\":1}}],[\"然后重写父类的方法\",{\"1\":{\"606\":1}}],[\"然后重启\",{\"1\":{\"756\":1}}],[\"然后重启tomcat即可\",{\"1\":{\"649\":1}}],[\"然后重新提交被拒绝的任务\",{\"1\":{\"275\":1}}],[\"然后递归的调用这些拦截器完成功能的织入\",{\"1\":{\"603\":1}}],[\"然后把所有的流连接起来成为一个流\",{\"1\":{\"549\":1}}],[\"然后这个高水位线将会重置\",{\"1\":{\"448\":1}}],[\"然后判断方法调用计数器与回边计数器值之和是否超过方法计数器的阈值\",{\"1\":{\"369\":1}}],[\"然后在path环境变量内加一条\",{\"1\":{\"1007\":1}}],[\"然后在mock类里实现自己的降级逻辑\",{\"1\":{\"901\":1}}],[\"然后在给插件编写注解\",{\"1\":{\"818\":1}}],[\"然后在消费者\",{\"1\":{\"708\":1}}],[\"然后在settings→build→compiler中将build\",{\"1\":{\"670\":1}}],[\"然后在需要的地方引用就行了\",{\"1\":{\"595\":1}}],[\"然后在运行时通过解释器将字节码文件转为机器码执行\",{\"1\":{\"365\":1}}],[\"然后在堆空间中创建\",{\"1\":{\"319\":1}}],[\"然后在<version>标签内引用\",{\"1\":{\"87\":1}}],[\"然后执行后面的程序\",{\"1\":{\"292\":1}}],[\"然后让出cpu\",{\"1\":{\"273\":1}}],[\"然后通过重写方法的方式\",{\"1\":{\"606\":1}}],[\"然后通过一个存储在\",{\"1\":{\"308\":1}}],[\"然后通过\",{\"1\":{\"244\":1}}],[\"然后封装模型相关的数据作为一个对象\",{\"1\":{\"68\":1}}],[\"去考察它的左孩子\",{\"1\":{\"1034\":1}}],[\"去找之前记录的请求\",{\"1\":{\"891\":1}}],[\"去访问远端系统资源\",{\"1\":{\"873\":1}}],[\"去除\",{\"1\":{\"788\":1}}],[\"去除不可能存在共享资源竞争的锁\",{\"1\":{\"278\":1}}],[\"去进行视图解析\",{\"1\":{\"642\":1}}],[\"去进行代理了\",{\"1\":{\"596\":1}}],[\"去创建代理对象\",{\"1\":{\"596\":1}}],[\"去掉重复的元素\",{\"1\":{\"548\":1}}],[\"去掉全部勾选\",{\"1\":{\"37\":2}}],[\"去重\",{\"1\":{\"548\":1}}],[\"去永久代\",{\"1\":{\"461\":1}}],[\"去虚拟化\",{\"1\":{\"372\":1}}],[\"去虚拟化冗余消除\",{\"1\":{\"372\":1}}],[\"竞争程度趋于稳定\",{\"1\":{\"278\":1}}],[\"竞争会越来越激烈效率越低\",{\"1\":{\"249\":1}}],[\"耗时长达3ms\",{\"1\":{\"957\":1}}],[\"耗时短\",{\"1\":{\"372\":1}}],[\"耗时\",{\"1\":{\"278\":1,\"722\":1,\"723\":1}}],[\"适用系统集成和跨语言调用\",{\"1\":{\"888\":1}}],[\"适用常规的远程服务调用和rmi互操作\",{\"1\":{\"888\":1}}],[\"适用于对象型数据的数组\",{\"1\":{\"233\":1}}],[\"适合大并发小数据量的服务调用\",{\"1\":{\"888\":1}}],[\"适合处理较短的时间\",{\"1\":{\"558\":1}}],[\"适当提高该值\",{\"1\":{\"448\":1}}],[\"适应性自旋锁\",{\"1\":{\"278\":1}}],[\"较新的jdk的io一般是nio\",{\"1\":{\"872\":1}}],[\"较大优化\",{\"1\":{\"278\":1}}],[\"较简单的方法\",{\"1\":{\"234\":1}}],[\"庆幸的是在\",{\"1\":{\"278\":1}}],[\"组装\",{\"1\":{\"874\":1}}],[\"组装set子句\",{\"1\":{\"854\":1}}],[\"组装select子句\",{\"0\":{\"849\":1}}],[\"组装修改条件\",{\"0\":{\"847\":1}}],[\"组装删除条件\",{\"0\":{\"846\":1}}],[\"组装排序条件\",{\"0\":{\"845\":1}}],[\"组装查询条件\",{\"0\":{\"844\":1}}],[\"组合和使用\",{\"1\":{\"875\":1}}],[\"组合\",{\"1\":{\"675\":13}}],[\"组合成为复杂的应用\",{\"1\":{\"592\":1}}],[\"组件\",{\"1\":{\"618\":1}}],[\"组件是实现ioc和依赖注入的基础\",{\"1\":{\"591\":1}}],[\"组件是spring\",{\"1\":{\"591\":1}}],[\"组件和\",{\"1\":{\"591\":1}}],[\"组件库\",{\"0\":{\"156\":1}}],[\"组成\",{\"1\":{\"278\":1}}],[\"轻量级锁失败后\",{\"1\":{\"278\":1}}],[\"轻量级锁所适应的场景是线程交替执行同步块的场合\",{\"1\":{\"278\":1}}],[\"轻量级锁能够提升程序性能的依据是对绝大部分的锁\",{\"1\":{\"278\":1}}],[\"轻量级锁等技术来减少锁操作的开销\",{\"1\":{\"278\":1}}],[\"轻量级锁\",{\"0\":{\"278\":1},\"1\":{\"278\":2,\"279\":1}}],[\"轻便快捷\",{\"1\":{\"148\":1}}],[\"偏向时间戳\",{\"1\":{\"476\":1}}],[\"偏向线程id\",{\"1\":{\"476\":1}}],[\"偏向锁失败后\",{\"1\":{\"278\":1}}],[\"偏向锁就失效了\",{\"1\":{\"278\":1}}],[\"偏向锁的核心思想是\",{\"1\":{\"278\":1}}],[\"偏向锁\",{\"0\":{\"278\":1},\"1\":{\"278\":3}}],[\"偏好\",{\"1\":{\"44\":1}}],[\"丢弃的消息交换机是不知道的\",{\"1\":{\"762\":1}}],[\"丢弃队列最前面的任务\",{\"1\":{\"275\":1}}],[\"丢弃任务\",{\"1\":{\"275\":1}}],[\"丢弃任务并抛出rejectedexecutionexception异常\",{\"1\":{\"275\":1}}],[\"方言\",{\"1\":{\"817\":1}}],[\"方便的编写各类查询条件\",{\"1\":{\"827\":1}}],[\"方便获取\",{\"1\":{\"724\":1}}],[\"方便在发生异常的时候找到处理异常的代码\",{\"1\":{\"424\":1}}],[\"方案3\",{\"1\":{\"676\":1}}],[\"方案2\",{\"1\":{\"676\":1}}],[\"方案1\",{\"1\":{\"676\":1}}],[\"方面的问题\",{\"1\":{\"892\":1}}],[\"方面\",{\"1\":{\"603\":2}}],[\"方式三\",{\"0\":{\"672\":1}}],[\"方式二\",{\"0\":{\"671\":1}}],[\"方式一\",{\"0\":{\"670\":1}}],[\"方式2\",{\"1\":{\"487\":1}}],[\"方式1\",{\"1\":{\"487\":1}}],[\"方式\",{\"1\":{\"275\":1,\"308\":1}}],[\"方法发现\",{\"1\":{\"821\":1}}],[\"方法能重载吗\",{\"1\":{\"816\":1}}],[\"方法总是返回一个int值\",{\"1\":{\"815\":1}}],[\"方法如果返回\",{\"1\":{\"762\":1}}],[\"方法如下\",{\"1\":{\"259\":1}}],[\"方法用于将已确认的消息存入新的\",{\"1\":{\"724\":1}}],[\"方法用来判断对象的相等性\",{\"1\":{\"240\":1}}],[\"方法设置\",{\"1\":{\"717\":1}}],[\"方法设置一些属性值\",{\"1\":{\"614\":1}}],[\"方法解释\",{\"1\":{\"697\":1}}],[\"方法首先需要织入到当前类的增强器封装到拦截器链中\",{\"1\":{\"603\":1}}],[\"方法入参\",{\"1\":{\"599\":1}}],[\"方法以及构造函数进行注释\",{\"1\":{\"599\":1}}],[\"方法注入\",{\"1\":{\"597\":1}}],[\"方法可以根据给定的参数生成对应的日期\",{\"1\":{\"565\":1}}],[\"方法可以获取到该类加载器\",{\"1\":{\"384\":1}}],[\"方法创建\",{\"1\":{\"555\":1}}],[\"方法会将原始流内的每个字符串转换为字符串数组\",{\"1\":{\"549\":1}}],[\"方法会返回流中的前3个元素\",{\"1\":{\"548\":1}}],[\"方法进行解析\",{\"1\":{\"789\":1}}],[\"方法进行初始化\",{\"0\":{\"474\":1}}],[\"方法进行通知时\",{\"1\":{\"286\":1}}],[\"方法名\",{\"1\":{\"458\":1}}],[\"方法名称\",{\"1\":{\"454\":1}}],[\"方法引用\",{\"1\":{\"458\":1}}],[\"方法除外\",{\"1\":{\"454\":2}}],[\"方法参数的数量和类型\",{\"1\":{\"454\":1}}],[\"方法正常退出时\",{\"1\":{\"424\":1}}],[\"方法重写的本质\",{\"0\":{\"422\":1}}],[\"方法或者类在符号引用被替换为直接引用的过程\",{\"1\":{\"420\":1}}],[\"方法或者notifyall\",{\"1\":{\"273\":2}}],[\"方法嵌套调用次数越多\",{\"1\":{\"415\":1}}],[\"方法嵌套调用的次数由栈的大小决定\",{\"1\":{\"415\":1}}],[\"方法定义为\",{\"1\":{\"392\":1}}],[\"方法及其获取字节码流的方式\",{\"1\":{\"387\":1}}],[\"方法在多线程下被同步加锁\",{\"1\":{\"380\":1}}],[\"方法类型等\",{\"1\":{\"379\":1}}],[\"方法内联\",{\"1\":{\"372\":1}}],[\"方法调用计数器统计的并不是方法被调用的绝对次数\",{\"1\":{\"369\":1}}],[\"方法调用计数器\",{\"0\":{\"369\":1}}],[\"方法调用计数器用于统计方法的调用次数\",{\"1\":{\"368\":1}}],[\"方法已经被虚拟机调用过时\",{\"1\":{\"323\":1}}],[\"方法实现的\",{\"1\":{\"317\":1}}],[\"方法还没有执行\",{\"1\":{\"314\":1}}],[\"方法执行完后可以被设置到传入的参数对象中\",{\"1\":{\"815\":1}}],[\"方法执行完毕后相应的栈帧也会出栈并释放内存空间\",{\"1\":{\"303\":1}}],[\"方法执行伊始\",{\"1\":{\"678\":1}}],[\"方法执行过程抛出异常时的异常处理\",{\"1\":{\"424\":1}}],[\"方法执行的内存模型\",{\"1\":{\"302\":1}}],[\"方法服务\",{\"1\":{\"303\":1}}],[\"方法出口信息\",{\"1\":{\"302\":1}}],[\"方法区空间不足\",{\"1\":{\"496\":1}}],[\"方法区用于存储己被虚拟机加载的类型信息\",{\"1\":{\"451\":1}}],[\"方法区用于存储已被虚拟机加载的类信息\",{\"1\":{\"343\":1}}],[\"方法区在\",{\"1\":{\"442\":1}}],[\"方法区域的内存不需要是连续的\",{\"1\":{\"441\":1}}],[\"方法区域可以是固定大小的\",{\"1\":{\"441\":1}}],[\"方法区可以看作是一块独立于java堆的内存空间\",{\"1\":{\"441\":1}}],[\"方法区还有一个别名叫non\",{\"1\":{\"441\":1}}],[\"方法区的垃圾收集主要回收两部分内容\",{\"1\":{\"464\":1}}],[\"方法区的垃圾回收\",{\"0\":{\"464\":1}}],[\"方法区的演进细节\",{\"0\":{\"460\":1}}],[\"方法区的内部结构\",{\"0\":{\"451\":1}}],[\"方法区的大小不必是固定的\",{\"1\":{\"446\":1}}],[\"方法区的大小决定了系统可以保存多少个类\",{\"1\":{\"442\":1}}],[\"方法区的大小\",{\"1\":{\"442\":1}}],[\"方法区的基本理解\",{\"0\":{\"442\":1}}],[\"方法区的理解\",{\"0\":{\"440\":1}}],[\"方法区的交互关系\",{\"0\":{\"439\":1},\"1\":{\"439\":1}}],[\"方法区的一部分\",{\"0\":{\"307\":1}}],[\"方法区和永久代并不等价\",{\"1\":{\"444\":1}}],[\"方法区和永久代的关系很像java中接口和类的关系\",{\"1\":{\"374\":1}}],[\"方法区和堆区是所有线程共享的内存区域\",{\"1\":{\"343\":1}}],[\"方法区中还会存放运行时常量池信息\",{\"1\":{\"375\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"322\":1,\"519\":1}}],[\"方法区中类静态属性引用的对象\",{\"1\":{\"322\":1,\"519\":1}}],[\"方法区是在虚拟机启动时创建的\",{\"1\":{\"441\":1}}],[\"方法区是\",{\"1\":{\"305\":1}}],[\"方法区相当于\",{\"1\":{\"305\":1}}],[\"方法区\",{\"0\":{\"305\":1,\"438\":1},\"1\":{\"300\":1,\"305\":2,\"338\":3,\"343\":1,\"374\":1,\"442\":1,\"456\":1,\"493\":1}}],[\"方法时会阻塞\",{\"1\":{\"292\":1}}],[\"方法时候\",{\"1\":{\"273\":1}}],[\"方法将计数器减到0\",{\"1\":{\"292\":1}}],[\"方法相结合可以实现等待\",{\"1\":{\"286\":1}}],[\"方法配合\",{\"1\":{\"285\":1}}],[\"方法添加一个任务时\",{\"1\":{\"277\":1}}],[\"方法来对已经创建好的applicationcontext进行进一步的处理\",{\"1\":{\"678\":1}}],[\"方法来提前启动线程池中的基本线程\",{\"1\":{\"275\":1}}],[\"方法来检查\",{\"1\":{\"242\":1}}],[\"方法必须捕获异常\",{\"1\":{\"273\":1}}],[\"方法必须放在同步控制方法和同步代码块中使用\",{\"1\":{\"273\":1}}],[\"方法则可以放在任何地方使用\",{\"1\":{\"273\":1}}],[\"方法则不同\",{\"1\":{\"273\":1}}],[\"方法后\",{\"1\":{\"273\":1}}],[\"方法并不会释放锁\",{\"1\":{\"273\":1}}],[\"方法是判断2个二叉树是否相等的\",{\"1\":{\"1019\":1}}],[\"方法是浅拷贝\",{\"1\":{\"724\":1}}],[\"方法是用java实现的\",{\"1\":{\"435\":1}}],[\"方法是object类的方法\",{\"1\":{\"273\":1}}],[\"方法是thread类的静态方法\",{\"1\":{\"273\":1}}],[\"方法唤醒所有等待这个对象的线程并允许他们去竞争获得锁\",{\"1\":{\"273\":1}}],[\"方法仅唤醒一个线程\",{\"1\":{\"273\":1}}],[\"方法通知正在等待的其他线程\",{\"1\":{\"273\":1}}],[\"方法更加简化\",{\"1\":{\"244\":1}}],[\"方法源码\",{\"1\":{\"244\":2}}],[\"方法也就是扰动函数是为了防止一些实现比较差的\",{\"1\":{\"244\":1}}],[\"方法也必须被覆盖\",{\"1\":{\"242\":1}}],[\"方法被重写\",{\"1\":{\"242\":1}}],[\"方法被覆盖过\",{\"1\":{\"242\":1}}],[\"方法返回对象转化为\",{\"1\":{\"651\":1}}],[\"方法返回值\",{\"1\":{\"508\":1}}],[\"方法返回地址\",{\"0\":{\"424\":1},\"1\":{\"414\":1}}],[\"方法返回之际\",{\"1\":{\"413\":1}}],[\"方法返回\",{\"1\":{\"242\":1}}],[\"方法中使用\",{\"1\":{\"655\":1}}],[\"方法中定义\",{\"0\":{\"431\":1}}],[\"方法中\",{\"1\":{\"387\":1}}],[\"方法中断\",{\"1\":{\"282\":1}}],[\"方法中也能看到如下说明\",{\"1\":{\"242\":1}}],[\"方法中没有传递任何参数的话返回的是\",{\"1\":{\"235\":1}}],[\"方法只是简单的调用了hashmap的put\",{\"1\":{\"242\":1}}],[\"方法向\",{\"1\":{\"240\":1}}],[\"方法保证\",{\"1\":{\"239\":1}}],[\"方法\",{\"0\":{\"314\":1,\"454\":1,\"990\":1,\"991\":1,\"996\":1},\"1\":{\"229\":1,\"230\":1,\"242\":1,\"244\":4,\"259\":1,\"273\":2,\"286\":2,\"292\":1,\"303\":1,\"307\":1,\"314\":1,\"318\":1,\"322\":1,\"323\":2,\"380\":1,\"387\":2,\"392\":1,\"461\":1,\"468\":1,\"510\":1,\"548\":4,\"549\":1,\"565\":1,\"613\":1,\"614\":7,\"674\":1,\"678\":6,\"687\":1,\"717\":1,\"762\":1,\"818\":2}}],[\"方法的第一个参数是appendable的实现类\",{\"1\":{\"994\":1}}],[\"方法的第二个参数添加这个属性\",{\"1\":{\"712\":1}}],[\"方法的可能\",{\"1\":{\"833\":1}}],[\"方法的名称和描述符\",{\"1\":{\"464\":1}}],[\"方法的字节码\",{\"1\":{\"454\":1}}],[\"方法的修饰符\",{\"1\":{\"454\":1}}],[\"方法的返回值都是流\",{\"1\":{\"546\":1}}],[\"方法的返回值处告诉我们插入前是否存在相同元素\",{\"1\":{\"242\":1}}],[\"方法的返回类型\",{\"1\":{\"454\":1}}],[\"方法的退出就是当前栈帧出栈的过程\",{\"1\":{\"424\":1}}],[\"方法的调用\",{\"0\":{\"418\":1},\"1\":{\"821\":1}}],[\"方法的含义\",{\"0\":{\"318\":1}}],[\"方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题\",{\"1\":{\"286\":1}}],[\"方法的主要作用是让线程暂停执行一段时间\",{\"1\":{\"273\":1}}],[\"方法的性能会稍差一点点\",{\"1\":{\"244\":1}}],[\"方法的参数是一个泛型数组\",{\"1\":{\"235\":1}}],[\"方法的作用\",{\"0\":{\"233\":1}}],[\"方法的时候在参数中设置\",{\"1\":{\"783\":1}}],[\"方法的时候\",{\"1\":{\"229\":1}}],[\"方法的类作为启动类\",{\"1\":{\"106\":1}}],[\"方法2的时间明显少于方法1的时间\",{\"1\":{\"940\":1}}],[\"方法2可以看作是计数排序\",{\"1\":{\"940\":1}}],[\"方法2\",{\"0\":{\"584\":1},\"1\":{\"11\":1,\"901\":1}}],[\"方法1\",{\"0\":{\"583\":1},\"1\":{\"11\":1,\"901\":1}}],[\"方法见切换\",{\"1\":{\"6\":1}}],[\"方法等等无处不是\",{\"1\":{\"892\":1}}],[\"方法等待\",{\"1\":{\"762\":1}}],[\"方法等\",{\"1\":{\"6\":1}}],[\"调度\",{\"1\":{\"591\":1}}],[\"调节器\",{\"0\":{\"569\":1}}],[\"调整slow的位置\",{\"1\":{\"973\":1}}],[\"调整这个空间比例\",{\"1\":{\"488\":1}}],[\"调整栈大小\",{\"0\":{\"428\":1}}],[\"调优和监控\",{\"1\":{\"274\":1}}],[\"调用次数越多\",{\"1\":{\"916\":1}}],[\"调用某个接口的方法会调用之前生成的代理类\",{\"1\":{\"891\":1}}],[\"调用相应的服务方法来调用java语言的服务\",{\"1\":{\"879\":1}}],[\"调用取消操作\",{\"1\":{\"879\":1}}],[\"调用类构造器之后调用该方法\",{\"1\":{\"762\":1,\"765\":1}}],[\"调用类的构造方法\",{\"1\":{\"474\":1}}],[\"调用类的静态方法\",{\"1\":{\"397\":1}}],[\"调用applicationcontext的refresh\",{\"1\":{\"678\":1}}],[\"调用它们的started\",{\"1\":{\"678\":1}}],[\"调用beanpostprocessor的后初始化方法\",{\"1\":{\"613\":1}}],[\"调用beanpostprocessor的预先初始化方法\",{\"1\":{\"613\":1}}],[\"调用定制init\",{\"1\":{\"613\":1}}],[\"调用initializingbean的afterpropertiesset\",{\"1\":{\"613\":1}}],[\"调用interrupt\",{\"1\":{\"282\":1}}],[\"调用getbean\",{\"1\":{\"611\":1}}],[\"调用simplemonitorservice遍历发送statisticsmap\",{\"1\":{\"902\":1}}],[\"调用setapplicationcontext设置applicationcontext\",{\"1\":{\"613\":1}}],[\"调用setbeanfactory\",{\"1\":{\"613\":1}}],[\"调用setbeanname设置bean的id或者name\",{\"1\":{\"613\":1}}],[\"调用system\",{\"1\":{\"496\":1}}],[\"调用sleep\",{\"1\":{\"273\":1}}],[\"调用者的\",{\"1\":{\"424\":1}}],[\"调用wait\",{\"1\":{\"288\":1}}],[\"调用了阻塞类型的系统中断\",{\"1\":{\"267\":1}}],[\"调用\",{\"1\":{\"240\":2,\"317\":1,\"614\":3,\"762\":1,\"883\":1}}],[\"释放资源则反序释放\",{\"1\":{\"270\":1}}],[\"靠按序申请资源来预防\",{\"1\":{\"270\":1}}],[\"破坏循环等待条件\",{\"1\":{\"270\":2}}],[\"破坏不剥夺条件\",{\"1\":{\"270\":1}}],[\"破坏请求与保持条件\",{\"1\":{\"270\":1}}],[\"互斥条件\",{\"1\":{\"269\":1}}],[\"产生数据发送消息的程序\",{\"1\":{\"692\":1}}],[\"产生的停顿时间\",{\"1\":{\"527\":1}}],[\"产生的停顿也越长\",{\"1\":{\"527\":1}}],[\"产生内存碎片\",{\"1\":{\"521\":1}}],[\"产生原因\",{\"1\":{\"280\":1}}],[\"产生interruptedexception\",{\"1\":{\"273\":1}}],[\"产生死锁的必要条件\",{\"1\":{\"269\":1}}],[\"产生死锁的条件\",{\"0\":{\"269\":1}}],[\"产品大牛\",{\"1\":{\"147\":1}}],[\"产品\",{\"0\":{\"147\":1}}],[\"产品模板生成工具\",{\"1\":{\"139\":1}}],[\"留待线程下次占用\",{\"1\":{\"267\":1}}],[\"被逻辑删除的数据默认不会被查询\",{\"1\":{\"840\":1}}],[\"被删除状态\",{\"1\":{\"839\":1}}],[\"被交换机\",{\"1\":{\"765\":2}}],[\"被队列\",{\"1\":{\"741\":4,\"742\":4}}],[\"被重新入队\",{\"1\":{\"709\":1}}],[\"被停掉了\",{\"1\":{\"709\":1}}],[\"被其他项目依赖\",{\"1\":{\"686\":1}}],[\"被模型返回的数据是中立的\",{\"1\":{\"645\":1}}],[\"被代理\",{\"1\":{\"604\":1}}],[\"被一个或者多个切面所通知的对象\",{\"1\":{\"604\":1}}],[\"被视为\",{\"1\":{\"535\":1}}],[\"被耗尽的时候\",{\"1\":{\"521\":1}}],[\"被保留的空间无法被其他对象使用\",{\"1\":{\"515\":1}}],[\"被声明为final的常量值等\",{\"1\":{\"464\":1}}],[\"被捕获的异常类的常量池索引\",{\"1\":{\"454\":1}}],[\"被所有jvm线程共享\",{\"1\":{\"441\":1}}],[\"被同一个虚拟机所加载\",{\"1\":{\"395\":1}}],[\"被随意篡改\",{\"1\":{\"393\":1}}],[\"被彻底移除了\",{\"1\":{\"338\":1}}],[\"被判定为需要执行的对象将会被放在一个队列中进行第二次标记\",{\"1\":{\"323\":1}}],[\"被\",{\"1\":{\"317\":1}}],[\"被通知的线程是由\",{\"1\":{\"286\":1}}],[\"被终止或结束运行\",{\"1\":{\"267\":1}}],[\"被管理的依赖并没有真正被引入到工程\",{\"1\":{\"87\":1}}],[\"说这么多差不多了\",{\"1\":{\"890\":1}}],[\"说了这些差不多了\",{\"1\":{\"889\":1}}],[\"说说对spring\",{\"0\":{\"643\":1}}],[\"说说并发与并行的区别\",{\"0\":{\"268\":1}}],[\"说一下这些注解\",{\"0\":{\"599\":1}}],[\"说一下回收的过程\",{\"1\":{\"518\":1}}],[\"说一下gc算法\",{\"1\":{\"518\":1}}],[\"说一下\",{\"1\":{\"465\":1}}],[\"说下gl的应用场景\",{\"1\":{\"518\":1}}],[\"说下aqs的原理\",{\"0\":{\"289\":1}}],[\"说下java线程的生命周期\",{\"0\":{\"266\":1}}],[\"说明这是当前层的第一个元素\",{\"1\":{\"1034\":1}}],[\"说明不是二叉搜索树\",{\"1\":{\"1030\":1}}],[\"说明可以\",{\"1\":{\"983\":1}}],[\"说明另一条路径\",{\"1\":{\"943\":1}}],[\"说明从烂橘子\",{\"1\":{\"943\":1}}],[\"说明还存在未腐烂的橘子\",{\"1\":{\"943\":1}}],[\"说明消息\",{\"1\":{\"709\":1}}],[\"说明当前锁没有被其他线程占有\",{\"1\":{\"290\":1}}],[\"说明\",{\"1\":{\"78\":1,\"496\":1,\"741\":1}}],[\"说明配置成功\",{\"1\":{\"63\":1}}],[\"英文写作just\",{\"1\":{\"343\":1}}],[\"英文字体jetbrains\",{\"1\":{\"38\":1}}],[\"英语\",{\"1\":{\"264\":1}}],[\"事务管理等等场景都用到了\",{\"1\":{\"596\":1}}],[\"事务管理\",{\"1\":{\"592\":1}}],[\"事务\",{\"1\":{\"591\":1}}],[\"事件传递和bean自动装配以及各种不同应用层的context实现开发中基本都在使用applicationcontext\",{\"1\":{\"611\":1}}],[\"事件\",{\"1\":{\"591\":1}}],[\"事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在\",{\"1\":{\"464\":1}}],[\"事实上\",{\"1\":{\"379\":1}}],[\"事\",{\"1\":{\"262\":1}}],[\"锁信息等数据存储在对象的对象头中\",{\"1\":{\"473\":1}}],[\"锁升级锁降级\",{\"0\":{\"296\":1}}],[\"锁队列的一个结点\",{\"1\":{\"289\":1}}],[\"锁可以绑定多个条件\",{\"1\":{\"286\":1}}],[\"锁降级的本质是释放掉独占锁\",{\"1\":{\"279\":1}}],[\"锁降级\",{\"0\":{\"279\":1}}],[\"锁膨胀为偏向锁\",{\"1\":{\"279\":1}}],[\"锁膨胀\",{\"0\":{\"279\":1}}],[\"锁竞争时间不确定\",{\"1\":{\"278\":1}}],[\"锁不仅不存在多线程竞争\",{\"1\":{\"278\":1}}],[\"锁粗化\",{\"1\":{\"278\":1}}],[\"锁消除\",{\"1\":{\"278\":2}}],[\"锁效率也优化得很不错了\",{\"1\":{\"278\":1}}],[\"锁状态标志\",{\"1\":{\"476\":1}}],[\"锁状态\",{\"1\":{\"278\":1}}],[\"锁标记位等\",{\"1\":{\"278\":1}}],[\"锁的计数器都自增\",{\"1\":{\"271\":1,\"284\":1}}],[\"锁\",{\"1\":{\"262\":1,\"292\":2}}],[\"锁做了很多优化\",{\"1\":{\"249\":1}}],[\"旋转\",{\"1\":{\"257\":1}}],[\"交由spring框架来管理\",{\"1\":{\"595\":1}}],[\"交换机和优先级队列进行绑定\",{\"1\":{\"780\":1}}],[\"交换机的备份交换机\",{\"1\":{\"768\":1}}],[\"交换机的消息的\",{\"1\":{\"740\":1}}],[\"交换机无法将消息进行路由时\",{\"1\":{\"765\":1}}],[\"交换机接收到消息后\",{\"1\":{\"764\":1}}],[\"交换机还未收到\",{\"1\":{\"762\":1,\"765\":1}}],[\"交换机已经收到\",{\"1\":{\"762\":1,\"765\":1}}],[\"交换机是否收到消息\",{\"1\":{\"762\":1,\"765\":1}}],[\"交换机不管是否收到消息的一个回调方法\",{\"1\":{\"762\":1,\"765\":1}}],[\"交换机不管是否收到消息\",{\"1\":{\"762\":1}}],[\"交换机类型是\",{\"1\":{\"746\":1}}],[\"交换机按照通配符分配消息到不同的队列中\",{\"1\":{\"742\":1}}],[\"交换机改进了我们的系统\",{\"1\":{\"740\":1}}],[\"交换机里\",{\"1\":{\"738\":1}}],[\"交换机转发消息是最快的\",{\"1\":{\"728\":1}}],[\"交换机必须确切知道如何处理收到的消息\",{\"1\":{\"727\":1}}],[\"交换机必须确切知道如何处理它接收到的消息\",{\"1\":{\"692\":1}}],[\"交换机工作的内容非常简单\",{\"1\":{\"727\":1}}],[\"交换机名\",{\"1\":{\"697\":1,\"702\":1}}],[\"交换机发送到队列\",{\"1\":{\"697\":1}}],[\"交换机\",{\"0\":{\"726\":1},\"1\":{\"692\":1,\"738\":1,\"740\":2,\"747\":1,\"748\":1,\"749\":1,\"754\":6,\"755\":1,\"768\":1}}],[\"交换两个内存的角色\",{\"1\":{\"522\":1}}],[\"交换两个索引位置的元素\",{\"1\":{\"257\":1}}],[\"交换\",{\"1\":{\"416\":1}}],[\"交互\",{\"0\":{\"142\":1}}],[\"定时重发\",{\"1\":{\"917\":1}}],[\"定位\",{\"1\":{\"479\":1}}],[\"定制排序\",{\"1\":{\"257\":1}}],[\"定义\",{\"1\":{\"919\":1,\"926\":1}}],[\"定义查询条件\",{\"1\":{\"853\":1}}],[\"定义允许匿名访问的get接口\",{\"1\":{\"792\":1}}],[\"定义的不同环境的配置文件\",{\"1\":{\"685\":1}}],[\"定义了\",{\"1\":{\"685\":1}}],[\"定义拦截器\",{\"1\":{\"656\":1}}],[\"定义拦截器要实现handlerinterceptor接口\",{\"1\":{\"648\":1}}],[\"定义一个操作中的算法的骨架\",{\"1\":{\"632\":1}}],[\"定义一个长度为n的int数组dp\",{\"1\":{\"200\":1}}],[\"定义一系列的算法\",{\"1\":{\"631\":1}}],[\"定义对象间的一种一对多的依赖关系\",{\"1\":{\"630\":1}}],[\"定义为一个数字数组\",{\"1\":{\"415\":1}}],[\"定义这个方法的类就是当前类\",{\"1\":{\"413\":1}}],[\"定义动态规划的状态\",{\"1\":{\"204\":1,\"205\":1}}],[\"守护着一个\",{\"1\":{\"251\":1}}],[\"扮演锁的角色\",{\"1\":{\"251\":1}}],[\"红黑二叉树\",{\"1\":{\"249\":1,\"252\":1}}],[\"红黑树的情况需要使用\",{\"1\":{\"249\":1}}],[\"红黑树就是为了解决二叉查找树的缺陷\",{\"1\":{\"245\":1}}],[\"红黑树深入剖析及java实现\",{\"1\":{\"238\":1}}],[\"红黑树\",{\"1\":{\"220\":1,\"222\":1,\"249\":1}}],[\"分摊至其他提供者\",{\"1\":{\"916\":1}}],[\"分布越均匀\",{\"1\":{\"916\":1}}],[\"分布式唯一主键生成方案\",{\"0\":{\"294\":1}}],[\"分为大三层其实就是和我们知道的网络分层一样的意思\",{\"1\":{\"883\":1}}],[\"分页\",{\"1\":{\"833\":1}}],[\"分页插件\",{\"0\":{\"856\":1}}],[\"分页插件支持多种数据库\",{\"1\":{\"827\":1}}],[\"分页插件的基本原理是使用\",{\"1\":{\"817\":1}}],[\"分页插件的原理是什么\",{\"0\":{\"817\":1}}],[\"分页等操作\",{\"1\":{\"826\":1}}],[\"分区容错性\",{\"1\":{\"797\":1}}],[\"分区算法将整个堆空间划分成连续的不同小区间\",{\"1\":{\"527\":1}}],[\"分区算法\",{\"0\":{\"527\":1}}],[\"分发消息采用的轮询分发\",{\"1\":{\"714\":1}}],[\"分发\",{\"1\":{\"693\":1}}],[\"分号\",{\"1\":{\"619\":1}}],[\"分\",{\"1\":{\"562\":1}}],[\"分析oom等\",{\"1\":{\"540\":1}}],[\"分离对象或标量替换\",{\"1\":{\"507\":1}}],[\"分代收集\",{\"1\":{\"535\":1}}],[\"分代收集算法应运而生\",{\"1\":{\"525\":1}}],[\"分代收集算法\",{\"0\":{\"525\":1},\"1\":{\"525\":1}}],[\"分代算法将按照对象的生命周期长短划分成两个部分\",{\"1\":{\"527\":1}}],[\"分代的思想被现有的虚拟机广泛使用\",{\"1\":{\"525\":1}}],[\"分代的唯一理由就是优化gc性能\",{\"1\":{\"497\":1}}],[\"分代回收说下\",{\"1\":{\"518\":1}}],[\"分代年龄等信息\",{\"1\":{\"313\":1}}],[\"分代年龄\",{\"1\":{\"278\":1}}],[\"分层编译策略\",{\"1\":{\"372\":1}}],[\"分别增加为\",{\"1\":{\"939\":1}}],[\"分别设置为\",{\"1\":{\"754\":1}}],[\"分别接收到消息并进行处理\",{\"1\":{\"709\":1}}],[\"分别分得两个消息\",{\"1\":{\"701\":1}}],[\"分别干什么的\",{\"1\":{\"465\":1}}],[\"分别为引导类加载器\",{\"1\":{\"381\":1}}],[\"分别为方法调用计数器\",{\"1\":{\"368\":1}}],[\"分别是client\",{\"1\":{\"372\":1}}],[\"分别描述原理\",{\"0\":{\"292\":1}}],[\"分配新的消息到该工作队列\",{\"1\":{\"714\":1}}],[\"分配完成后\",{\"1\":{\"508\":1}}],[\"分配的栈内存越大越好吗\",{\"0\":{\"429\":1}}],[\"分配方式有\",{\"1\":{\"311\":1}}],[\"分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了\",{\"1\":{\"471\":1}}],[\"分配内存\",{\"0\":{\"311\":1},\"1\":{\"482\":1}}],[\"分支\",{\"1\":{\"301\":1,\"399\":1}}],[\"分段锁\",{\"1\":{\"249\":1,\"252\":1}}],[\"分段的数组+链表\",{\"1\":{\"249\":1}}],[\"分治\",{\"0\":{\"179\":1}}],[\"种主键策略\",{\"1\":{\"827\":1}}],[\"种接口对象的方法时\",{\"1\":{\"818\":1}}],[\"种接口的插件\",{\"1\":{\"818\":1}}],[\"种动态\",{\"1\":{\"812\":1}}],[\"种发布确认速度对比\",{\"1\":{\"724\":1}}],[\"种方法\",{\"1\":{\"676\":1}}],[\"种解决办法\",{\"1\":{\"638\":1}}],[\"种设计模式在\",{\"1\":{\"590\":1}}],[\"种遍历方式与性能分析\",{\"1\":{\"248\":1}}],[\"种类丰富\",{\"1\":{\"139\":1}}],[\"详见代码注释\",{\"1\":{\"974\":1}}],[\"详情请查看\",{\"1\":{\"247\":1}}],[\"详细可以查看\",{\"1\":{\"222\":1}}],[\"能快速揪出\",{\"1\":{\"827\":1}}],[\"能让使用者明确指定在一个长度为\",{\"1\":{\"535\":1}}],[\"能充分利用\",{\"1\":{\"535\":1}}],[\"能及时回收内存\",{\"1\":{\"463\":1}}],[\"能够做到灵活的调用\",{\"1\":{\"907\":1}}],[\"能够与spring很好的集成\",{\"1\":{\"807\":1}}],[\"能够匹配到\",{\"1\":{\"728\":1}}],[\"能够将那些与业务无关\",{\"1\":{\"596\":1}}],[\"能够执行那些不被硬件直接支持的指令集格式\",{\"1\":{\"355\":1}}],[\"能够提高运算效率\",{\"1\":{\"246\":1}}],[\"能从这个网站找到不少动画交互的灵感\",{\"1\":{\"139\":1}}],[\"亿长度的数组\",{\"1\":{\"246\":1}}],[\"亿的映射空间\",{\"1\":{\"246\":1}}],[\"若左孩子也是null\",{\"1\":{\"1034\":1}}],[\"若到某一层右孩子为null\",{\"1\":{\"1034\":1}}],[\"若它的右子树不空\",{\"1\":{\"1029\":1}}],[\"若任意一个为null而另一个不是null\",{\"1\":{\"1019\":1}}],[\"若二者都为null\",{\"1\":{\"1019\":1}}],[\"若实体类中的属性和表中的字段不满足情况1\",{\"1\":{\"837\":1}}],[\"若实体类中的属性使用的是驼峰命名风格\",{\"1\":{\"837\":1}}],[\"若与springboot搭配使用\",{\"1\":{\"650\":1}}],[\"若养老区执行了\",{\"1\":{\"490\":1}}],[\"若该类具有父类\",{\"1\":{\"380\":1}}],[\"若\",{\"1\":{\"302\":1,\"953\":1}}],[\"若当前线程一直不结束\",{\"1\":{\"280\":1}}],[\"若线程池已创建的线程数小于corepoolsize\",{\"1\":{\"275\":1}}],[\"若干进程之间形成一种头尾相接的循环等待资源关系\",{\"1\":{\"269\":1}}],[\"若无外力作用\",{\"1\":{\"269\":1}}],[\"若遇到哈希冲突\",{\"1\":{\"244\":1}}],[\"若存在多个依赖项时则采用空格分隔\",{\"1\":{\"103\":1}}],[\"次以下的\",{\"1\":{\"937\":1}}],[\"次或\",{\"1\":{\"937\":1}}],[\"次方\",{\"1\":{\"246\":1}}],[\"次\",{\"1\":{\"244\":1,\"937\":1}}],[\"^\",{\"1\":{\"244\":5}}],[\"^=1\",{\"1\":{\"203\":2}}],[\"^=\",{\"1\":{\"183\":1,\"244\":1}}],[\"换另一种方式\",{\"1\":{\"457\":1}}],[\"换句话说就是内存中的对象确实都还必须存活着\",{\"1\":{\"450\":1}}],[\"换句话说\",{\"1\":{\"395\":1,\"752\":1}}],[\"换句话说使用扰动函数之后可以减少碰撞\",{\"1\":{\"244\":1}}],[\"换到上一行\",{\"1\":{\"8\":1}}],[\"换到下一行\",{\"1\":{\"8\":1}}],[\"结合使用时\",{\"1\":{\"599\":1}}],[\"结合在一起使用也就是\",{\"1\":{\"244\":1}}],[\"结论\",{\"1\":{\"506\":1}}],[\"结束生命\",{\"1\":{\"512\":1}}],[\"结束位置\",{\"1\":{\"454\":1}}],[\"结束阻塞\",{\"1\":{\"292\":1}}],[\"结果集中的元素数\",{\"1\":{\"1034\":1}}],[\"结果集执行的内存分页\",{\"1\":{\"817\":1}}],[\"结果分析\",{\"1\":{\"762\":1}}],[\"结果演示\",{\"1\":{\"701\":1}}],[\"结果\",{\"1\":{\"332\":1,\"866\":1}}],[\"结果为2048\",{\"1\":{\"253\":1}}],[\"结果为\",{\"1\":{\"184\":2,\"253\":5}}],[\"启动dubbo\",{\"1\":{\"915\":1}}],[\"启动向注册中心订阅自己所需的服务\",{\"1\":{\"882\":1}}],[\"启动然后向注册中心注册自己所能提供的服务\",{\"1\":{\"882\":1}}],[\"启动即会自动注入基本\",{\"1\":{\"827\":1}}],[\"启动消费者\",{\"1\":{\"749\":1}}],[\"启动生产者\",{\"1\":{\"747\":1}}],[\"启动之后关闭该消费者\",{\"1\":{\"747\":1,\"748\":1}}],[\"启动两个工作队列消费消息\",{\"1\":{\"700\":1}}],[\"启动顺序\",{\"1\":{\"687\":1}}],[\"启动的时候运行一些特定的代码\",{\"0\":{\"687\":1}}],[\"启动的时候被创建\",{\"1\":{\"442\":1}}],[\"启动完毕后\",{\"1\":{\"674\":1}}],[\"启动原理\",{\"1\":{\"661\":2}}],[\"启动时间并非是关注重点\",{\"1\":{\"365\":1}}],[\"启动\",{\"0\":{\"345\":1},\"1\":{\"748\":1}}],[\"启动类加载器只加载包名为java\",{\"1\":{\"382\":1}}],[\"启动类加载器\",{\"0\":{\"382\":1},\"1\":{\"331\":1}}],[\"启动选项\",{\"1\":{\"37\":1}}],[\"启蒙书\",{\"1\":{\"242\":1}}],[\"综上\",{\"1\":{\"241\":1,\"242\":1}}],[\"总是想等的\",{\"1\":{\"954\":1}}],[\"总是\",{\"1\":{\"604\":1}}],[\"总是使用\",{\"1\":{\"239\":2}}],[\"总消耗时间的比值\",{\"1\":{\"532\":1}}],[\"总的来说\",{\"1\":{\"526\":1}}],[\"总为空\",{\"1\":{\"497\":1}}],[\"总会去继承\",{\"1\":{\"387\":1}}],[\"总结如下\",{\"1\":{\"1023\":1}}],[\"总结一下\",{\"1\":{\"674\":1}}],[\"总结下来的话\",{\"1\":{\"602\":1}}],[\"总结\",{\"0\":{\"465\":1,\"758\":1},\"1\":{\"318\":1,\"372\":1}}],[\"总工程\",{\"1\":{\"90\":1}}],[\"②\",{\"1\":{\"239\":1,\"249\":1,\"503\":1}}],[\"倍\",{\"1\":{\"239\":1,\"252\":1}}],[\"①\",{\"1\":{\"239\":1,\"249\":1,\"503\":1}}],[\"键入回车进入dubbo命令模式\",{\"1\":{\"912\":1}}],[\"键值\",{\"0\":{\"815\":1}}],[\"键值对的值可以是任何类型\",{\"1\":{\"728\":1}}],[\"键和\",{\"1\":{\"239\":1}}],[\"键式设计工具+智能抠图\",{\"1\":{\"148\":1}}],[\"吧\",{\"1\":{\"239\":1}}],[\"型数组\",{\"1\":{\"235\":1}}],[\"传染完毕\",{\"1\":{\"943\":1}}],[\"传输协议http\",{\"1\":{\"888\":1}}],[\"传输协议tcp\",{\"1\":{\"888\":2}}],[\"传输\",{\"1\":{\"888\":2}}],[\"传输数据包大小混合\",{\"1\":{\"888\":1}}],[\"传输参数和返回参数对象需要实现\",{\"1\":{\"888\":1}}],[\"传统的阻塞式io显然不太合适\",{\"1\":{\"878\":1}}],[\"传递参数是通过类的属性\",{\"1\":{\"654\":1}}],[\"传递的数组必须是对象数组\",{\"1\":{\"233\":1}}],[\"传入的深度为0\",{\"1\":{\"1034\":1}}],[\"传入的是类型完全一致\",{\"1\":{\"235\":1}}],[\"传入参数较大\",{\"1\":{\"888\":1}}],[\"传入参数大小混合\",{\"1\":{\"888\":1}}],[\"传入参数和\",{\"1\":{\"340\":1}}],[\"传入\",{\"1\":{\"614\":3}}],[\"扩容时扩一半\",{\"1\":{\"232\":1}}],[\"扩展加载源\",{\"1\":{\"386\":1}}],[\"扩展目录\",{\"1\":{\"383\":1}}],[\"扩展类加载器\",{\"0\":{\"383\":1},\"1\":{\"331\":1,\"381\":1}}],[\"扩展collection接口的接口\",{\"1\":{\"225\":1}}],[\"扩展语法\",{\"1\":{\"40\":1}}],[\"虽然下方方法会返回一个新对象\",{\"1\":{\"991\":1}}],[\"虽然题目没有明确要求不能改变链表\",{\"1\":{\"975\":1}}],[\"虽然整数的范围是\",{\"1\":{\"939\":1}}],[\"虽然满足两个绑定但只被队列\",{\"1\":{\"741\":1,\"742\":1}}],[\"虽然自动应答传输消息速率是最佳的\",{\"1\":{\"717\":1}}],[\"虽然这项技术并不十分成熟\",{\"1\":{\"511\":1}}],[\"虽然经过逃逸分析可以做标量替换\",{\"1\":{\"511\":1}}],[\"虽然源码中还定义了handlepromotionrailure参数\",{\"1\":{\"504\":1}}],[\"虽然新生代中\",{\"1\":{\"488\":1}}],[\"虽然java虚拟机规范把方法区描述为堆的一个逻辑部分\",{\"1\":{\"343\":1}}],[\"虽然也是以\",{\"1\":{\"317\":1}}],[\"虽然在\",{\"1\":{\"249\":1}}],[\"虽然\",{\"1\":{\"231\":1,\"305\":1,\"535\":1,\"782\":1}}],[\"才会执行\",{\"1\":{\"913\":1}}],[\"才投递到目标队列中\",{\"1\":{\"757\":1}}],[\"才对该bean进行加载实例化\",{\"1\":{\"611\":1}}],[\"才有永久代\",{\"1\":{\"461\":1}}],[\"才有\",{\"1\":{\"374\":1}}],[\"才由自己来处理\",{\"1\":{\"332\":1}}],[\"才被引入的\",{\"1\":{\"231\":1}}],[\"才能确保下面的插件后执行\",{\"1\":{\"106\":1}}],[\"与操作的结果不为0\",{\"1\":{\"949\":1}}],[\"与操作系统交互\",{\"1\":{\"435\":1}}],[\"与数据库id是否设置自增无关\",{\"1\":{\"836\":1}}],[\"与jdbc相比\",{\"1\":{\"807\":1}}],[\"与java环境外交互\",{\"1\":{\"435\":1}}],[\"与队列的\",{\"1\":{\"762\":1}}],[\"与队列关联的\",{\"1\":{\"762\":1}}],[\"与其\",{\"1\":{\"756\":1}}],[\"与其他几种引用都不同\",{\"1\":{\"328\":1}}],[\"与发布线程之间进行消息的传递\",{\"1\":{\"724\":1}}],[\"与单个等待确认消息相比\",{\"1\":{\"723\":1}}],[\"与快递站的主要区别在于\",{\"1\":{\"691\":1}}],[\"与云计算的天然集成\",{\"1\":{\"665\":1}}],[\"与spring框架集成\",{\"1\":{\"644\":1}}],[\"与simpledateformat不同的是\",{\"1\":{\"573\":1}}],[\"与上面的类似\",{\"1\":{\"614\":1}}],[\"与机器物理内存对比看是否还可以调大\",{\"1\":{\"450\":1}}],[\"与性能调优关系最密切的部分就是局部变量表\",{\"1\":{\"415\":1}}],[\"与当前栈帧相对应的方法就是当前方法\",{\"1\":{\"413\":1}}],[\"与缓存区\",{\"1\":{\"308\":1}}],[\"与永久代不同\",{\"1\":{\"305\":1,\"448\":1}}],[\"与程序计数器一样\",{\"1\":{\"302\":1}}],[\"与运算后结果\",{\"1\":{\"253\":5}}],[\"与\",{\"0\":{\"231\":1},\"1\":{\"242\":1,\"442\":1,\"535\":1,\"536\":1,\"609\":1,\"615\":1,\"706\":1,\"728\":2,\"731\":1,\"1018\":1}}],[\"与微软\",{\"1\":{\"110\":1}}],[\"人们认识到\",{\"1\":{\"230\":1}}],[\"鼓励通用列表算法在应用算法之前检查给定列表是否是该接口的实例\",{\"1\":{\"230\":1}}],[\"该题和\",{\"1\":{\"962\":1,\"972\":1}}],[\"该线程以死循环的形式来写\",{\"1\":{\"902\":1}}],[\"该问题也可以通过全局配置解决\",{\"1\":{\"835\":1}}],[\"该\",{\"1\":{\"813\":1}}],[\"该条消息会重新发给其他的消费者\",{\"1\":{\"772\":1}}],[\"该交换机发送消息到队列\",{\"1\":{\"768\":1}}],[\"该交换机会检测消息的\",{\"1\":{\"738\":1}}],[\"该怎么做呢\",{\"1\":{\"767\":1}}],[\"该信息是用作演示队列个数限制\",{\"1\":{\"747\":1,\"748\":1}}],[\"该值定义通道上允许的未确认消息的最大数量\",{\"1\":{\"717\":1}}],[\"该队列不设置\",{\"1\":{\"755\":1}}],[\"该队列如果配置了死信交换机将发送到死信队列中\",{\"1\":{\"749\":1}}],[\"该队列就会被删除掉\",{\"1\":{\"711\":1}}],[\"该队列是否自动删除\",{\"1\":{\"697\":1}}],[\"该队列是否只供一个消费者进行消费\",{\"1\":{\"697\":1}}],[\"该消费者先前接收未\",{\"1\":{\"706\":1}}],[\"该消费者还是会消费到该条被\",{\"1\":{\"706\":1}}],[\"该依赖在此处下载不下来\",{\"1\":{\"671\":1}}],[\"该过滤器要做的其实就是强制为所有请求和响应设置编码格式\",{\"1\":{\"649\":1}}],[\"该过程如同闹钟一样\",{\"1\":{\"273\":1}}],[\"该作用域同样仅适用于webapplicationcontext环境\",{\"1\":{\"615\":1}}],[\"该作用域仅适用于webapplicationcontext环境\",{\"1\":{\"615\":2}}],[\"该模块含有一组api提供\",{\"1\":{\"604\":1}}],[\"该模式自动探测使用构造器自动装配或者bytype自动装配\",{\"1\":{\"598\":1}}],[\"该选项可以根据bean类型设置依赖关系\",{\"1\":{\"598\":1}}],[\"该选项可以根据bean名称设置依赖关系\",{\"1\":{\"598\":1}}],[\"该构造器有一系列的参数\",{\"1\":{\"597\":1}}],[\"该操作会改变原来的commit\",{\"1\":{\"585\":1}}],[\"该类型请确保数据库设置了id自增\",{\"1\":{\"836\":1}}],[\"该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中\",{\"1\":{\"757\":1}}],[\"该类全限定名\",{\"1\":{\"388\":1}}],[\"该类加载是程序中默认的类加载器\",{\"1\":{\"384\":1}}],[\"该类对应的\",{\"1\":{\"329\":1,\"464\":1}}],[\"该类所有的实例都已经被回收\",{\"1\":{\"329\":1,\"464\":1}}],[\"该类用于控制信号量的个数\",{\"1\":{\"292\":1}}],[\"该对象就可以被程序使用\",{\"1\":{\"326\":1}}],[\"该资源任意一个时刻只由一个线程占用\",{\"1\":{\"269\":1}}],[\"该方法接收的请求要带有\",{\"1\":{\"755\":1}}],[\"该方法\",{\"1\":{\"706\":1}}],[\"该方法返回一个数组串数组流stream<string\",{\"1\":{\"549\":1}}],[\"该方法返回的arraylist全限定名是java\",{\"1\":{\"233\":1}}],[\"该方法会返回一个不超过给定长度n的流\",{\"1\":{\"548\":1}}],[\"该方法的实现由非java语言实现\",{\"1\":{\"434\":1}}],[\"该方法的大概意思是判断是否有线程等待的时间比当前线程等待时间还要久\",{\"1\":{\"290\":1}}],[\"该方法可以将指定集合包装成线程同步的集合\",{\"1\":{\"259\":1}}],[\"该方法内容如下\",{\"1\":{\"253\":1}}],[\"该循环\",{\"1\":{\"230\":1}}],[\"该算法将提供较差的性能\",{\"1\":{\"230\":1}}],[\"该接口的主要目的是允许通用算法在应用于随机或顺序访问列表时改变其行为\",{\"1\":{\"230\":1}}],[\"该插件提供了构建\",{\"1\":{\"103\":1}}],[\"阅读接口的注释\",{\"1\":{\"230\":1}}],[\"什么\",{\"1\":{\"892\":1}}],[\"什么情况下触发垃圾回收\",{\"1\":{\"518\":1}}],[\"什么时候回收\",{\"1\":{\"515\":1}}],[\"什么时候对象会进入老年代\",{\"1\":{\"465\":1}}],[\"什么是rpc\",{\"0\":{\"873\":1}}],[\"什么是mybatis\",{\"0\":{\"806\":1}}],[\"什么是mvc模式\",{\"0\":{\"645\":1}}],[\"什么是备份交换机呢\",{\"1\":{\"767\":1}}],[\"什么是spring\",{\"0\":{\"664\":1}}],[\"什么是spring框架\",{\"0\":{\"591\":1}}],[\"什么是aop\",{\"0\":{\"594\":1}}],[\"什么是ioc\",{\"0\":{\"594\":1}}],[\"什么是垃圾\",{\"0\":{\"515\":1}}],[\"什么是tlab\",{\"0\":{\"500\":1}}],[\"什么是本地方法\",{\"0\":{\"434\":1}}],[\"什么是\",{\"0\":{\"358\":1},\"1\":{\"731\":1}}],[\"什么是解释器\",{\"0\":{\"358\":1}}],[\"什么是死锁\",{\"0\":{\"269\":1}}],[\"什么是进程\",{\"0\":{\"264\":1}}],[\"什么都没有定义\",{\"1\":{\"230\":1}}],[\"什么有很多完整的产品原型可以借鉴\",{\"1\":{\"147\":1}}],[\"更改当前线程的classloader\",{\"1\":{\"905\":1}}],[\"更确切地说\",{\"1\":{\"905\":1}}],[\"更快\",{\"1\":{\"894\":1}}],[\"更是要建立一个新的\",{\"1\":{\"879\":1}}],[\"更有超多自定义配置等您来使用\",{\"1\":{\"827\":1}}],[\"更有强大的条件构造器\",{\"1\":{\"827\":1}}],[\"更多示例\",{\"1\":{\"852\":1}}],[\"更多参数往后加即可\",{\"1\":{\"819\":1}}],[\"更多的情况是本地方法由外部的动态链接库\",{\"1\":{\"435\":1}}],[\"更多的空间\",{\"1\":{\"229\":1}}],[\"更像是一种对功能的限制\",{\"1\":{\"629\":1}}],[\"更加灵活\",{\"1\":{\"610\":1}}],[\"更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程\",{\"1\":{\"530\":1}}],[\"更常见的情况是大部分对象都是存活对象\",{\"1\":{\"523\":1}}],[\"更准确一些\",{\"1\":{\"367\":1}}],[\"更利于让编译器有机会优化我们的代码\",{\"1\":{\"318\":1}}],[\"更通用一些\",{\"1\":{\"288\":1}}],[\"更好\",{\"1\":{\"231\":1}}],[\"更新了开源组件等\",{\"1\":{\"914\":1}}],[\"更新时\",{\"1\":{\"860\":1}}],[\"更新时可以设置条件和字段\",{\"1\":{\"851\":1}}],[\"更新封装wrapper\",{\"1\":{\"842\":1}}],[\"更新\",{\"1\":{\"37\":1}}],[\"近似\",{\"1\":{\"229\":1}}],[\"采用了观察者模式\",{\"1\":{\"906\":1}}],[\"采用多版本开发\",{\"1\":{\"900\":1}}],[\"采用key\",{\"1\":{\"897\":1}}],[\"采用zookeeper的watch机制实现数据变更\",{\"1\":{\"897\":1}}],[\"采用jdk标准的rmi协议实现\",{\"1\":{\"888\":1}}],[\"采用微内核设计+spi扩展\",{\"1\":{\"883\":1}}],[\"采用二进制编解码\",{\"1\":{\"879\":1}}],[\"采用二进制位操作\",{\"1\":{\"246\":1}}],[\"采用代码或者\",{\"1\":{\"827\":1}}],[\"采用手动应答\",{\"1\":{\"708\":2,\"714\":1,\"717\":1}}],[\"采用工厂模式\",{\"1\":{\"625\":1}}],[\"采用以下注解可实现\",{\"1\":{\"618\":1}}],[\"采用parallel\",{\"1\":{\"534\":1}}],[\"采用基于\",{\"1\":{\"525\":1}}],[\"采用基于计数器的热点探测\",{\"1\":{\"368\":1}}],[\"采用在类的方法区建立一个虚方法表\",{\"1\":{\"423\":1}}],[\"采用解释器+即时编译器的混合模式共同执行程序\",{\"1\":{\"371\":1}}],[\"采用\",{\"1\":{\"252\":1,\"888\":1}}],[\"采用的数据结构跟\",{\"1\":{\"249\":1}}],[\"采用链表存储\",{\"1\":{\"229\":1}}],[\"采用数组存储\",{\"1\":{\"229\":1}}],[\"向该服务的提供者发送一个notify消息\",{\"1\":{\"906\":1}}],[\"向注册中心注册消费者的信息\",{\"1\":{\"890\":1}}],[\"向线程池提交一个任务\",{\"1\":{\"275\":1}}],[\"向\",{\"1\":{\"240\":1}}],[\"向前移一位的操作\",{\"1\":{\"229\":1}}],[\"向量\",{\"1\":{\"65\":1}}],[\"容易产生\",{\"1\":{\"462\":1}}],[\"容易产生perm区的oom\",{\"1\":{\"306\":1}}],[\"容易导致死锁问题的发生\",{\"1\":{\"273\":1}}],[\"容量变为原来的\",{\"1\":{\"239\":2}}],[\"容量可动态增长\",{\"1\":{\"228\":1}}],[\"容器刷新完毕之后\",{\"1\":{\"889\":1}}],[\"容器相关的\",{\"1\":{\"614\":2}}],[\"容器利用\",{\"1\":{\"614\":1}}],[\"容器找到配置文件中\",{\"1\":{\"614\":1}}],[\"容器关闭后\",{\"1\":{\"614\":1}}],[\"容器自动装载了一个autowiredannotationbeanpostprocessor后置处理器\",{\"1\":{\"601\":1}}],[\"容器将无法确定到底要用哪一个\",{\"1\":{\"599\":1}}],[\"容器将根据bean的类型自动在在配置文件中查询一个匹配的bean\",{\"1\":{\"598\":1}}],[\"容器将根据bean的名称自动在在配置文件中查询一个匹配的bean\",{\"1\":{\"598\":1}}],[\"容器中\",{\"1\":{\"617\":2,\"674\":1}}],[\"容器中配置了两个类型为\",{\"1\":{\"599\":1}}],[\"容器中一定拥有某个类的\",{\"1\":{\"599\":1}}],[\"容器就会自动选择bytpe的自动装配方式\",{\"1\":{\"598\":1}}],[\"容器就像是一个工厂一样\",{\"1\":{\"595\":1}}],[\"容器完成对象的注入\",{\"1\":{\"595\":1}}],[\"容器来管理\",{\"1\":{\"595\":1}}],[\"容器实际上就是个map\",{\"1\":{\"595\":1}}],[\"容器是\",{\"1\":{\"595\":1}}],[\"容器源码分析\",{\"1\":{\"590\":1}}],[\"容器的核心\",{\"1\":{\"610\":1}}],[\"容器的名称或id\",{\"1\":{\"577\":1}}],[\"容器的id\",{\"1\":{\"577\":1}}],[\"容器状态\",{\"1\":{\"577\":1}}],[\"容器退出状态码\",{\"1\":{\"577\":1}}],[\"容器名称\",{\"1\":{\"577\":1}}],[\"容器概述\",{\"0\":{\"213\":1,\"214\":1}}],[\"容器\",{\"1\":{\"4\":1,\"615\":1}}],[\"线程名为\",{\"1\":{\"902\":1}}],[\"线程名字\",{\"1\":{\"902\":2}}],[\"线程执行的\",{\"1\":{\"535\":1}}],[\"线程执行顺序\",{\"0\":{\"297\":1}}],[\"线程开始对未标记的区域做清扫\",{\"1\":{\"534\":1}}],[\"线程无法保证可达性分析的实时性\",{\"1\":{\"534\":1}}],[\"线程同步的佧价是相当高的\",{\"1\":{\"509\":1}}],[\"线程持有的锁\",{\"1\":{\"476\":1}}],[\"线程持有锁的时间都不会太长\",{\"1\":{\"278\":1}}],[\"线程恢复等基础功能都需要依赖这个计数器来完成\",{\"1\":{\"399\":1}}],[\"线程恢复等功能都需要依赖这个计数器来完成\",{\"1\":{\"301\":1}}],[\"线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合\",{\"1\":{\"340\":1}}],[\"线程私有\",{\"1\":{\"301\":1}}],[\"线程私有的\",{\"1\":{\"300\":1}}],[\"线程共享的\",{\"1\":{\"300\":1,\"482\":1}}],[\"线程对象可以注册在指定的condition中\",{\"1\":{\"286\":1}}],[\"线程id可能不变导致内存泄漏\",{\"1\":{\"280\":1}}],[\"线程结束后不被销毁\",{\"1\":{\"280\":1}}],[\"线程阻塞造成的线程切换等\",{\"1\":{\"278\":1}}],[\"线程饱和策略\",{\"1\":{\"275\":1}}],[\"线程工厂\",{\"1\":{\"275\":1}}],[\"线程的空闲时间如果超过线程存活时间\",{\"1\":{\"275\":1}}],[\"线程存活保持时间\",{\"1\":{\"275\":1}}],[\"线程池会判断\",{\"1\":{\"277\":1}}],[\"线程池会做如下判断\",{\"1\":{\"277\":1}}],[\"线程池也不会马上执行它们\",{\"1\":{\"277\":1}}],[\"线程池刚创建时\",{\"1\":{\"277\":1}}],[\"线程池从建立开始的任务调度机制\",{\"0\":{\"277\":1}}],[\"线程池所允许的最大同时可执行线程数量\",{\"1\":{\"275\":1}}],[\"线程池的工作过程如下\",{\"1\":{\"277\":1}}],[\"线程池的拒绝策略\",{\"0\":{\"275\":1}}],[\"线程池的基本参数\",{\"0\":{\"275\":1}}],[\"线程会释放掉他所占用的锁\",{\"1\":{\"273\":1}}],[\"线程会从占用\",{\"1\":{\"267\":1}}],[\"线程已获得的资源在未使用完之前不能被其他线程强行剥夺\",{\"1\":{\"269\":1}}],[\"线程切换意味着需要保存当前线程的上下文\",{\"1\":{\"267\":1}}],[\"线程被阻塞\",{\"1\":{\"267\":1}}],[\"线程在执行过程中会有自己的运行条件和状态\",{\"1\":{\"267\":1}}],[\"线程唤醒的方法\",{\"0\":{\"265\":1}}],[\"线程是稀缺资源\",{\"1\":{\"274\":1}}],[\"线程是系统分配处理器时间资源的基本单元\",{\"1\":{\"264\":1}}],[\"线程是否安全\",{\"1\":{\"239\":1}}],[\"线程\",{\"0\":{\"264\":1},\"1\":{\"264\":1,\"525\":1}}],[\"线程安全的日期解析与格式化工具\",{\"0\":{\"572\":1}}],[\"线程安全的\",{\"1\":{\"259\":4}}],[\"线程安全的具体实现方式\",{\"0\":{\"250\":1}}],[\"线程安全\",{\"1\":{\"226\":1,\"993\":1}}],[\"线程不安全\",{\"1\":{\"226\":2,\"555\":1}}],[\"效率有点低\",{\"1\":{\"957\":1}}],[\"效率也较低\",{\"1\":{\"693\":1}}],[\"效率不高\",{\"1\":{\"521\":1}}],[\"效率较差\",{\"1\":{\"349\":1}}],[\"效率非常低\",{\"1\":{\"259\":1}}],[\"效率非常低下\",{\"1\":{\"249\":1,\"362\":1}}],[\"效率又提升\",{\"1\":{\"252\":1}}],[\"效率\",{\"1\":{\"239\":1}}],[\"效率低下\",{\"1\":{\"278\":1}}],[\"效率低\",{\"1\":{\"226\":1}}],[\"效率高一点\",{\"1\":{\"239\":1}}],[\"效率高\",{\"1\":{\"226\":2,\"321\":1,\"522\":1}}],[\"效果如图\",{\"1\":{\"780\":1}}],[\"效果演示\",{\"0\":{\"709\":1,\"715\":1,\"718\":1},\"1\":{\"747\":1,\"749\":1,\"779\":1}}],[\"效果很棒\",{\"1\":{\"142\":1}}],[\"效果\",{\"1\":{\"73\":1}}],[\"效果是在选中内容后的右键菜单内\",{\"1\":{\"41\":1}}],[\"底层通讯基于socket\",{\"1\":{\"879\":1}}],[\"底层的\",{\"1\":{\"879\":1}}],[\"底层原理\",{\"0\":{\"283\":1}}],[\"底层具体实现\",{\"0\":{\"250\":1}}],[\"底层都用到了红黑树\",{\"1\":{\"245\":1}}],[\"底层是\",{\"1\":{\"244\":1}}],[\"底层就是基于\",{\"1\":{\"240\":1}}],[\"底层使用的是\",{\"1\":{\"229\":2}}],[\"底层数据结构\",{\"1\":{\"229\":1,\"239\":1,\"249\":1}}],[\"底层数据结构是链表\",{\"1\":{\"226\":1}}],[\"底层数据结构是数组\",{\"1\":{\"226\":2}}],[\"底层采用\",{\"1\":{\"220\":1,\"249\":1}}],[\"源数据验证\",{\"1\":{\"379\":1}}],[\"源码\",{\"1\":{\"1001\":1}}],[\"源码的话就应该知道\",{\"1\":{\"240\":1}}],[\"源码详细分析\",{\"1\":{\"222\":1}}],[\"源代码模式\",{\"1\":{\"48\":1}}],[\"使数组唯一的最小增量\",{\"0\":{\"936\":1}}],[\"使相同参数请求总是发到同一提供者\",{\"1\":{\"916\":1}}],[\"使服务提供方可以平滑增加或减少机器\",{\"1\":{\"885\":1}}],[\"使服务消费方能动态的查找服务提供方\",{\"1\":{\"885\":1}}],[\"使地址透明\",{\"1\":{\"885\":1}}],[\"使得服务接口透明化\",{\"1\":{\"883\":1}}],[\"使得有特殊需求的接入方可以自定义扩展\",{\"1\":{\"883\":1}}],[\"使得应用可通过高性能的rpc实现服务的输出和输入功能\",{\"1\":{\"879\":1}}],[\"使得局部变量表膨胀\",{\"1\":{\"415\":1}}],[\"使得前一个栈帧重新成为当前栈帧\",{\"1\":{\"413\":1}}],[\"使得上面的结构可以保持键值对的插入顺序\",{\"1\":{\"222\":1}}],[\"使自定义类加载器编写更加简洁\",{\"1\":{\"387\":1}}],[\"使程序异常终止\",{\"1\":{\"325\":1}}],[\"使其他线程可以获取到读锁\",{\"1\":{\"279\":1}}],[\"使用idea\",{\"1\":{\"1011\":1}}],[\"使用instant中转\",{\"1\":{\"571\":1}}],[\"使用git\",{\"1\":{\"1004\":1}}],[\"使用git命令\",{\"0\":{\"584\":1}}],[\"使用pre表示上一个数字\",{\"1\":{\"957\":1}}],[\"使用pc寄存器存储字节码指令地址的作用\",{\"0\":{\"401\":1}}],[\"使用vis\",{\"1\":{\"949\":1}}],[\"使用占空间较小的boolean类型来保存\",{\"1\":{\"948\":1}}],[\"使用等差数列公式求和\",{\"1\":{\"939\":1}}],[\"使用阻塞式短连接\",{\"1\":{\"888\":1}}],[\"使用简单的方法提供了rmi的功能\",{\"1\":{\"879\":1}}],[\"使用简单\",{\"1\":{\"875\":1}}],[\"使用freemarker引擎模板\",{\"1\":{\"864\":1}}],[\"使用flatmap方法的效果是\",{\"1\":{\"549\":1}}],[\"使用版本号机制实现乐观锁\",{\"1\":{\"860\":1}}],[\"使用lambda\",{\"1\":{\"842\":1}}],[\"使用uuid\",{\"1\":{\"836\":1}}],[\"使用usegeneratedkeys接收\",{\"1\":{\"815\":1}}],[\"使用数据库的自增策略\",{\"1\":{\"836\":1}}],[\"使用数组存储对象具有一定的弊端\",{\"1\":{\"217\":1}}],[\"使用配置\",{\"0\":{\"829\":1}}],[\"使用二级缓存属性类需要实现serializable序列化接口\",{\"1\":{\"813\":1}}],[\"使用mybatis的mapper接口调用时有哪些要求\",{\"0\":{\"809\":1}}],[\"使用该注解可以定义get类型的访问接口\",{\"1\":{\"792\":1}}],[\"使用该自定义类作为回退消息的处理类\",{\"1\":{\"764\":1}}],[\"使用场景\",{\"0\":{\"776\":1,\"782\":1},\"1\":{\"839\":1}}],[\"使用方式\",{\"1\":{\"687\":1}}],[\"使用<dependency>重新导入undertow\",{\"1\":{\"679\":1}}],[\"使用<exclusion>排除掉web中引入的tomcat\",{\"1\":{\"679\":1}}],[\"使用spring的httpinvoke\",{\"1\":{\"888\":1}}],[\"使用springfactoriesloader在应用的classpath中查找并加载所有可用的applicationlistener\",{\"1\":{\"678\":1}}],[\"使用springfactoriesloader在应用的classpath中查找并加载所有可用的applicationcontextinitializer\",{\"1\":{\"678\":1}}],[\"使用setter方法实现可选的依赖关系\",{\"1\":{\"597\":1}}],[\"使用set来保存遍历过的元素\",{\"1\":{\"186\":1}}],[\"使用set作为滑动窗口\",{\"1\":{\"186\":1}}],[\"使用注解简化了xml配置\",{\"1\":{\"666\":1}}],[\"使用注解快速生成get\",{\"1\":{\"22\":1}}],[\"使用嵌入式的servlet容器\",{\"1\":{\"665\":1}}],[\"使用后端数据库默认的隔离级别\",{\"1\":{\"634\":1}}],[\"使用三级缓存主要是为了保证不管什么时候使用的都是一个对象\",{\"1\":{\"622\":1}}],[\"使用三个\",{\"1\":{\"65\":1}}],[\"使用beanfactory的时候必须遵循完整的创建过程\",{\"1\":{\"610\":1}}],[\"使用两种代理机制\",{\"1\":{\"603\":1}}],[\"使用required=false\",{\"1\":{\"601\":1}}],[\"使用return指令\",{\"1\":{\"413\":1}}],[\"使用这些模块可以很方便地协助我们进行开发\",{\"1\":{\"591\":1}}],[\"使用这种方式\",{\"1\":{\"526\":1}}],[\"使用形式\",{\"1\":{\"569\":1}}],[\"使用例子如下\",{\"1\":{\"559\":1}}],[\"使用流\",{\"0\":{\"547\":1}}],[\"使用多个\",{\"1\":{\"535\":1}}],[\"使用逃逸分析\",{\"1\":{\"507\":1}}],[\"使用tlab可以避免一系列的线程安全问题\",{\"1\":{\"500\":1}}],[\"使用空闲列表分配\",{\"1\":{\"471\":1}}],[\"使用指针碰撞\",{\"1\":{\"471\":2}}],[\"使用元空间取代了永久代\",{\"1\":{\"444\":1}}],[\"使用索引表来代替查找\",{\"1\":{\"423\":1}}],[\"使用它们后再把结果压入栈\",{\"1\":{\"416\":1}}],[\"使用参数\",{\"1\":{\"410\":1}}],[\"使用系统classloader\",{\"1\":{\"389\":1}}],[\"使用当前类加载器以\",{\"1\":{\"470\":1}}],[\"使用当前类的classloader\",{\"1\":{\"389\":1}}],[\"使用当前线程的classloader\",{\"1\":{\"389\":1}}],[\"使用最多的是\",{\"1\":{\"378\":1}}],[\"使用最通用的设置\",{\"1\":{\"18\":1,\"19\":1}}],[\"使用软引用的情况较多\",{\"1\":{\"328\":1}}],[\"使用双引号声明的\",{\"1\":{\"318\":1}}],[\"使用直接指针访问方式最大的好处就是速度快\",{\"1\":{\"315\":1}}],[\"使用句柄来访问的最大好处是\",{\"1\":{\"315\":1}}],[\"使用的advice\",{\"1\":{\"627\":1}}],[\"使用的\",{\"1\":{\"534\":1}}],[\"使用的局部变量是否线程安全\",{\"0\":{\"431\":1}}],[\"使用的是直接内存\",{\"1\":{\"300\":1}}],[\"使用的操作系统版本为\",{\"1\":{\"114\":1}}],[\"使用了又不再调用get\",{\"1\":{\"280\":1}}],[\"使用线程池可以进行统一的分配\",{\"1\":{\"274\":1}}],[\"使用线程池的好处\",{\"0\":{\"274\":1}}],[\"使用区域不同\",{\"1\":{\"273\":1}}],[\"使用成员对象来计算\",{\"1\":{\"240\":1}}],[\"使用键\",{\"1\":{\"240\":1}}],[\"使用集合转数组的方法\",{\"1\":{\"235\":1}}],[\"使用java8的stream\",{\"1\":{\"234\":1}}],[\"使用java8的stream简化代码\",{\"1\":{\"194\":1}}],[\"使用容量不超过\",{\"1\":{\"207\":1}}],[\"使用单个变量代替dp数组\",{\"1\":{\"202\":1}}],[\"使用dummy\",{\"1\":{\"964\":1}}],[\"使用dx\",{\"1\":{\"935\":1}}],[\"使用dp数组来表示对于第i位元素\",{\"1\":{\"202\":1}}],[\"使用dependencymanagement标签配置对依赖的管理\",{\"1\":{\"87\":1}}],[\"使用有限的几个变量即可\",{\"1\":{\"200\":1}}],[\"使用cur来记录窗口内元素的和\",{\"1\":{\"187\":1}}],[\"使用ascii编码生成视频动画\",{\"1\":{\"143\":1}}],[\"使用此目标后\",{\"1\":{\"106\":1}}],[\"使用2\",{\"1\":{\"104\":1}}],[\"使用时会报错\",{\"1\":{\"103\":1}}],[\"使用时要求所有\",{\"1\":{\"85\":1}}],[\"使用示例\",{\"1\":{\"101\":1,\"106\":1,\"836\":1}}],[\"使用合适的单元测试框架运行测试\",{\"1\":{\"94\":1}}],[\"使用框架时所需要的\",{\"1\":{\"85\":1}}],[\"使用同一个框架内的不同\",{\"1\":{\"85\":1}}],[\"使用excludes标签配置依赖的排除\",{\"1\":{\"83\":1}}],[\"使用\",{\"0\":{\"583\":1,\"601\":1},\"1\":{\"78\":1,\"89\":2,\"106\":1,\"139\":1,\"244\":1,\"249\":1,\"596\":1,\"601\":1,\"685\":1,\"758\":1,\"812\":1,\"817\":1,\"818\":1,\"819\":1,\"821\":1,\"823\":1,\"849\":1,\"888\":1}}],[\"使用快捷键\",{\"1\":{\"21\":1}}],[\"使用过程中直接注入对应\",{\"1\":{\"674\":1}}],[\"使用过\",{\"1\":{\"1\":1}}],[\"拉链法\",{\"1\":{\"222\":1,\"244\":1}}],[\"双亲委派机制\",{\"0\":{\"390\":1}}],[\"双亲委派模型保证了\",{\"1\":{\"333\":1}}],[\"双亲委派模型的好处\",{\"0\":{\"333\":1}}],[\"双亲委派模型\",{\"0\":{\"332\":1},\"1\":{\"332\":1}}],[\"双向循环链表\",{\"1\":{\"229\":1}}],[\"双向链表\",{\"1\":{\"167\":1,\"219\":1,\"229\":3}}],[\"双指针\",{\"1\":{\"221\":1}}],[\"唯一\",{\"1\":{\"220\":2,\"774\":1}}],[\"取值为\",{\"1\":{\"783\":1}}],[\"取值不为1\",{\"1\":{\"717\":1}}],[\"取出记录时\",{\"1\":{\"860\":1}}],[\"取出需要被处理的数据\",{\"1\":{\"751\":1}}],[\"取出消息\",{\"1\":{\"744\":1}}],[\"取消消费的一个回调接口\",{\"1\":{\"698\":1,\"779\":1}}],[\"取消了\",{\"1\":{\"252\":1}}],[\"取消了循环\",{\"1\":{\"219\":1,\"229\":1}}],[\"取走\",{\"1\":{\"693\":1}}],[\"取而代之的是一个叫元空间\",{\"1\":{\"343\":1}}],[\"取而代之是元空间\",{\"1\":{\"338\":1}}],[\"取而代之\",{\"1\":{\"307\":1}}],[\"取余\",{\"1\":{\"246\":1}}],[\"取余的操作来实现\",{\"1\":{\"246\":1}}],[\"取决于\",{\"1\":{\"81\":1}}],[\"声明优先级队列\",{\"1\":{\"780\":1}}],[\"声明报警队列绑定关系\",{\"1\":{\"768\":1}}],[\"声明警告队列\",{\"1\":{\"768\":1}}],[\"声明确认\",{\"1\":{\"768\":1}}],[\"声明确认队列绑定关系\",{\"1\":{\"762\":1,\"768\":1}}],[\"声明确认队列\",{\"1\":{\"762\":1,\"768\":1}}],[\"声明备份队列绑定关系\",{\"1\":{\"768\":1}}],[\"声明备份队列\",{\"1\":{\"768\":1}}],[\"声明备份\",{\"1\":{\"768\":1}}],[\"声明业务\",{\"1\":{\"762\":1}}],[\"声明死信队列\",{\"1\":{\"754\":2}}],[\"声明死信队列交换机\",{\"1\":{\"754\":1}}],[\"声明死信和普通交换机\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"声明\",{\"1\":{\"754\":1}}],[\"声明交换机和队列\",{\"1\":{\"762\":1}}],[\"声明交换机\",{\"1\":{\"747\":1,\"749\":1}}],[\"声明私信队列\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"声明一个交换机\",{\"1\":{\"780\":1}}],[\"声明一个\",{\"1\":{\"734\":1}}],[\"声明当前队列的死信路由\",{\"1\":{\"697\":1,\"754\":2,\"755\":1}}],[\"声明当前队列绑定的死信交换机\",{\"1\":{\"697\":1,\"754\":2,\"755\":1}}],[\"声明队列时\",{\"1\":{\"780\":1}}],[\"声明队列的时候添加优先级\",{\"1\":{\"777\":1}}],[\"声明队列的\",{\"1\":{\"754\":2}}],[\"声明队列\",{\"1\":{\"697\":1,\"708\":1,\"711\":1,\"712\":1,\"747\":1,\"749\":1,\"754\":4,\"755\":2}}],[\"声明数组的时候\",{\"1\":{\"228\":1}}],[\"声明数组时的数据类型也决定了该数组存储的数据的类型\",{\"1\":{\"217\":1}}],[\"声音生成器\",{\"1\":{\"144\":1}}],[\"于是就能找到泄漏对象是通过怎样的路径与gc\",{\"1\":{\"450\":1}}],[\"于是\",{\"1\":{\"217\":1,\"595\":1,\"759\":1,\"821\":1}}],[\"存入一个\",{\"1\":{\"889\":1}}],[\"存到\",{\"1\":{\"693\":1}}],[\"存活率高\",{\"1\":{\"525\":1}}],[\"存活率低\",{\"1\":{\"525\":1}}],[\"存活时间单位\",{\"1\":{\"275\":1}}],[\"存分哪几个区\",{\"1\":{\"465\":1}}],[\"存放服务端地址信息\",{\"1\":{\"874\":1}}],[\"存放新生代中经历多次\",{\"1\":{\"497\":1}}],[\"存放到对象实例数据\",{\"1\":{\"479\":1}}],[\"存放在java栈中\",{\"1\":{\"439\":1}}],[\"存放在方法区\",{\"1\":{\"439\":1}}],[\"存放调用该方法的pc寄存器的值\",{\"1\":{\"424\":1}}],[\"存在于\",{\"1\":{\"612\":1}}],[\"存在自适应的内存分配策略\",{\"1\":{\"488\":1}}],[\"存在通路可以与其相连\",{\"1\":{\"280\":1}}],[\"存在一些被分配的对象\",{\"1\":{\"280\":1}}],[\"存在内存泄漏问题\",{\"1\":{\"280\":1}}],[\"存取高效\",{\"1\":{\"246\":1}}],[\"存储所有可能\",{\"1\":{\"983\":1}}],[\"存储所有可能的状态\",{\"1\":{\"982\":1}}],[\"存储处理过的状态\",{\"1\":{\"982\":1}}],[\"存储provider\",{\"1\":{\"882\":1}}],[\"存储和转发消息数据\",{\"1\":{\"691\":1}}],[\"存储在堆中的java对象可以被划分为两类\",{\"1\":{\"488\":1}}],[\"存储在一个异常处理表\",{\"1\":{\"424\":1}}],[\"存储结构\",{\"1\":{\"249\":1}}],[\"存储键值对\",{\"1\":{\"240\":1}}],[\"存储的数据的类型是多种多样的\",{\"1\":{\"217\":1}}],[\"存储的元素是有序的\",{\"1\":{\"215\":1}}],[\"存储\",{\"1\":{\"215\":1,\"813\":1}}],[\"存档\",{\"1\":{\"106\":1}}],[\"剩余容量\",{\"1\":{\"207\":1}}],[\"状态压缩\",{\"0\":{\"949\":1}}],[\"状态\",{\"1\":{\"877\":1}}],[\"状态中退出\",{\"1\":{\"267\":1}}],[\"状态的转换中\",{\"1\":{\"266\":1}}],[\"状态转移方程\",{\"1\":{\"207\":1}}],[\"状态栏\",{\"1\":{\"38\":1}}],[\"那肯定是以小的为准\",{\"1\":{\"943\":1}}],[\"那如果querywrapper也想用lambda风格的写法\",{\"1\":{\"854\":1}}],[\"那如何解决呢\",{\"1\":{\"756\":1}}],[\"那些找不到映射关系的属性\",{\"1\":{\"808\":1}}],[\"那些还可以分解的数据叫做聚合量\",{\"1\":{\"510\":1}}],[\"那我们一直轮询数据\",{\"1\":{\"751\":1}}],[\"那我们就用回调对象吧\",{\"1\":{\"632\":1}}],[\"那这个时候direct\",{\"1\":{\"740\":1}}],[\"那这个逃逸分析的过程就白白浪费掉了\",{\"1\":{\"511\":1}}],[\"那这个方法的调用计数器就会被减少一半\",{\"1\":{\"369\":1}}],[\"那所有的对象都在一块\",{\"1\":{\"497\":1}}],[\"那java虚拟机将会抛出一个\",{\"1\":{\"409\":1}}],[\"那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定\",{\"1\":{\"409\":1}}],[\"那必须先执行相应的类加载过程\",{\"1\":{\"310\":1}}],[\"那也可以把wait定义在thread类里面啊\",{\"1\":{\"288\":1}}],[\"那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程\",{\"1\":{\"278\":1}}],[\"那就是支付\",{\"1\":{\"771\":1}}],[\"那就是\",{\"1\":{\"505\":1}}],[\"那就应当检查虚拟机的堆参数\",{\"1\":{\"450\":1}}],[\"那就类似于可有可无的生活用品\",{\"1\":{\"326\":1,\"327\":1}}],[\"那就类似于必不可少的生活用品\",{\"1\":{\"325\":1}}],[\"那就会将线程在操作系统层面挂起\",{\"1\":{\"278\":1}}],[\"那就需要返回其本身\",{\"1\":{\"253\":1}}],[\"那为什么要分别进行1\",{\"1\":{\"253\":1}}],[\"那开始为什么要先减1呢\",{\"1\":{\"253\":1}}],[\"那前\",{\"1\":{\"207\":1}}],[\"那么时间复杂度为\",{\"1\":{\"969\":1}}],[\"那么增加的次数就是5+1\",{\"1\":{\"938\":1}}],[\"那么最大值就是\",{\"1\":{\"926\":1}}],[\"那么只能先删除队列\",{\"1\":{\"783\":1}}],[\"那么如何让无法被路由的消息帮我想办法处理一下\",{\"1\":{\"764\":1}}],[\"那么消息会被直接丢弃\",{\"1\":{\"764\":1}}],[\"那么消息就丢失了\",{\"1\":{\"705\":1}}],[\"那么一旦消息过期\",{\"1\":{\"752\":1}}],[\"那么较小的那个值将会被使用\",{\"1\":{\"752\":1}}],[\"那么每天晚上跑个定时任务检查一下所有未支付的账单\",{\"1\":{\"751\":1}}],[\"那么该队列绑定类型就是\",{\"1\":{\"741\":1}}],[\"那么确认消息会在将消息写入磁盘之后发出\",{\"1\":{\"720\":1}}],[\"那么此时\",{\"1\":{\"706\":1}}],[\"那么此时就需要在打印方法前面加一个sleep\",{\"1\":{\"273\":1}}],[\"那么加入事务\",{\"1\":{\"635\":1}}],[\"那么我们怎么办呢\",{\"1\":{\"632\":1}}],[\"那么多线程环境下可能取到的对象就不一致了\",{\"1\":{\"622\":1}}],[\"那么构造方法将不能覆盖由设值方法注入的值\",{\"1\":{\"600\":1}}],[\"那么spring管理的就不是普通的bean\",{\"1\":{\"625\":1}}],[\"那么spring\",{\"1\":{\"596\":1}}],[\"那么实际上传入的是这个接口的实现类对象\",{\"1\":{\"569\":1}}],[\"那么经过jit优化\",{\"1\":{\"510\":1}}],[\"那么对于每层来说\",{\"1\":{\"1035\":1}}],[\"那么对于这个对象的操作可以不考虑同步\",{\"1\":{\"507\":1}}],[\"那么对象的部分\",{\"1\":{\"507\":1}}],[\"那么会抛出异常\",{\"1\":{\"601\":1}}],[\"那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小\",{\"1\":{\"504\":1}}],[\"那么会选择先进行数组扩容\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"那么堆的大小在启动时就己经设定好了\",{\"1\":{\"485\":1}}],[\"那么虚拟机将采用的是空闲列表法来为对象分配内存\",{\"1\":{\"471\":1}}],[\"那么虚拟机将采用的是指针碰撞法\",{\"1\":{\"471\":1}}],[\"那么虚拟机就会认为这次自旋也很有可能再次成功\",{\"1\":{\"278\":1}}],[\"那么在双亲委派模式下\",{\"1\":{\"470\":1}}],[\"那么在不超过maxmetaspacesize时\",{\"1\":{\"448\":1}}],[\"那么在执行构建操作时会报下面的错误\",{\"1\":{\"91\":1}}],[\"那么jit编译器在编译这个同步块的时候就会取消对这部分代码的同步\",{\"1\":{\"509\":1}}],[\"那么java虚拟机将会抛出一个outofmemoryerror异常\",{\"1\":{\"437\":1}}],[\"那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中\",{\"1\":{\"396\":1}}],[\"那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用\",{\"1\":{\"417\":1}}],[\"那么这条消息如果在\",{\"1\":{\"752\":1}}],[\"那么这个队列将接收所有数据\",{\"1\":{\"741\":1}}],[\"那么这个类里面的方法抛出异常\",{\"1\":{\"637\":1}}],[\"那么这个线程就被停掉\",{\"1\":{\"277\":1}}],[\"那么这个线程就会被销毁\",{\"1\":{\"275\":1}}],[\"那么这两个类对象也是不相等的\",{\"1\":{\"395\":1}}],[\"那么将会抛出异常\",{\"1\":{\"598\":1}}],[\"那么将会向即时编译器提交一个该方法的代码编译请求\",{\"1\":{\"369\":1}}],[\"那么将这个任务放入队列\",{\"1\":{\"277\":1}}],[\"那么程序运行的时候\",{\"1\":{\"333\":1}}],[\"那么就会单独发送事先保存好的查询关联\",{\"1\":{\"821\":1}}],[\"那么就需要增加\",{\"1\":{\"754\":1}}],[\"那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制\",{\"1\":{\"289\":1}}],[\"那么就可以让垃圾收集线程和应用程序线程交替执行\",{\"1\":{\"526\":1}}],[\"那么就可以在所引用的对象的内存被回收之前采取必要的行动\",{\"1\":{\"328\":1}}],[\"那么就可能被优化成栈上分配\",{\"1\":{\"505\":1}}],[\"那么它就和没有任何引用一样\",{\"1\":{\"328\":1}}],[\"那么它将首先在字符串常量池中创建\",{\"1\":{\"319\":1}}],[\"那么当线程请求栈的深度超过当前\",{\"1\":{\"302\":1}}],[\"那么同时只能有多少个人去上厕所呢\",{\"1\":{\"292\":1}}],[\"那么锁就进入偏向模式\",{\"1\":{\"278\":1}}],[\"那么线程池会抛出异常rejectexecutionexception\",{\"1\":{\"277\":1}}],[\"那么还是要创建非核心线程立刻运行这个任务\",{\"1\":{\"277\":1}}],[\"那么马上创建线程运行这个任务\",{\"1\":{\"277\":1}}],[\"那么n\",{\"1\":{\"253\":1}}],[\"那么其方法数就是后面这两个方法数之和\",{\"1\":{\"200\":1}}],[\"那么\",{\"1\":{\"200\":1,\"203\":1,\"239\":1,\"315\":2,\"355\":1,\"515\":1,\"601\":1,\"678\":1,\"783\":1}}],[\"那么可以省略\",{\"1\":{\"88\":1}}],[\"两棵树才相等\",{\"1\":{\"1019\":1}}],[\"两根指针来\",{\"1\":{\"1019\":1}}],[\"两条消息都成功被交换机接收\",{\"1\":{\"762\":1}}],[\"两块大小相同的survivor\",{\"1\":{\"497\":1}}],[\"两种模式\",{\"0\":{\"783\":1}}],[\"两种范围\",{\"1\":{\"612\":1}}],[\"两种\",{\"1\":{\"311\":1}}],[\"两种错误\",{\"1\":{\"303\":1}}],[\"两种决策\",{\"1\":{\"207\":1}}],[\"两者区别\",{\"1\":{\"752\":1}}],[\"两者都是通过xml配置文件加载bean\",{\"1\":{\"611\":1}}],[\"两者都是可重入锁\",{\"0\":{\"284\":1}}],[\"两者都具有队列的功能\",{\"1\":{\"231\":1}}],[\"两者的对比图\",{\"1\":{\"249\":1}}],[\"两者在内存中存放的地址\",{\"1\":{\"242\":1}}],[\"两个水壶都没水\",{\"1\":{\"982\":1}}],[\"两个\",{\"1\":{\"939\":1}}],[\"两个框架在开始目标就不一致\",{\"1\":{\"886\":1}}],[\"两个时间选项\",{\"1\":{\"754\":1}}],[\"两个代码块来自下方的案例\",{\"1\":{\"752\":1}}],[\"两个队列的\",{\"1\":{\"754\":1}}],[\"两个队列\",{\"1\":{\"746\":1}}],[\"两个消费者\",{\"1\":{\"738\":1,\"742\":1,\"746\":1}}],[\"两个消费者的消费时间不同\",{\"1\":{\"715\":1}}],[\"两个工作队列都启动后\",{\"1\":{\"701\":1}}],[\"两个参数配置的值包含堆空间中的新生代\",{\"1\":{\"485\":1}}],[\"两个参数配置相同的值\",{\"1\":{\"485\":1}}],[\"两个常见问题\",{\"0\":{\"400\":1}}],[\"两个对象有相同的\",{\"1\":{\"242\":1}}],[\"两个对象相等\",{\"1\":{\"242\":1}}],[\"两个目标\",{\"1\":{\"98\":1}}],[\"两个和编译相关的环节\",{\"1\":{\"98\":1}}],[\"现代垃圾收集器大部分都基于分代收集理论设计\",{\"1\":{\"483\":1}}],[\"现代虚拟机为了提高执行效率\",{\"1\":{\"365\":1}}],[\"现代javascript教程\",{\"1\":{\"119\":1}}],[\"现状\",{\"0\":{\"363\":1,\"436\":1}}],[\"现在是apache下的opensource之一\",{\"1\":{\"879\":1}}],[\"现在可写在配置类中\",{\"1\":{\"754\":1}}],[\"现在可以通过实现webmvcconfifigurer接口然后重写addcorsmappings方法解决跨域问题\",{\"1\":{\"673\":1}}],[\"现在来看\",{\"1\":{\"444\":1}}],[\"现在普遍使用的模板解释器\",{\"1\":{\"362\":1}}],[\"现在\",{\"1\":{\"359\":1}}],[\"现在hotspot内置了此虚拟机\",{\"1\":{\"349\":1}}],[\"现在已使用的容量\",{\"1\":{\"207\":1}}],[\"解码的过程给封装起来\",{\"1\":{\"874\":1}}],[\"解\",{\"1\":{\"836\":1}}],[\"解除sql与程序代码的耦合\",{\"1\":{\"807\":1}}],[\"解压后\",{\"1\":{\"686\":1}}],[\"解压后直接就是包名\",{\"1\":{\"686\":1}}],[\"解析和初始化\",{\"1\":{\"470\":1}}],[\"解析和初始化过\",{\"1\":{\"310\":1}}],[\"解析动作主要针对类或接口\",{\"1\":{\"379\":1}}],[\"解析操作往往会伴随着jvm在执行完初始化之后再执行\",{\"1\":{\"379\":1}}],[\"解析\",{\"1\":{\"379\":2}}],[\"解释字节码\",{\"1\":{\"435\":1}}],[\"解释器会介入执行\",{\"1\":{\"371\":1}}],[\"解释器可以首先发挥作用\",{\"1\":{\"365\":1,\"366\":1}}],[\"解释器可以马上发挥作用\",{\"1\":{\"365\":1}}],[\"解释器和即时编译器能够相互协作\",{\"1\":{\"365\":1}}],[\"解释器主要由\",{\"1\":{\"362\":1}}],[\"解释器分类\",{\"0\":{\"362\":1}}],[\"解释器真正意义上所承担的角色就是一个运行时\",{\"1\":{\"361\":1}}],[\"解释器工作机制\",{\"0\":{\"361\":1}}],[\"解释器\",{\"0\":{\"360\":1},\"1\":{\"358\":1}}],[\"解释执行在编译器进行激进优化不成立的时候\",{\"1\":{\"365\":1}}],[\"解释执行\",{\"1\":{\"343\":1,\"359\":1}}],[\"解释\",{\"1\":{\"207\":2,\"756\":1,\"929\":2,\"937\":2,\"953\":1,\"1028\":1,\"1033\":1,\"1038\":2}}],[\"解决慢提供者接收更少的请求\",{\"1\":{\"916\":1}}],[\"解决单点故障以及分布式部署的问题\",{\"1\":{\"878\":1}}],[\"解决信息孤岛初期常使用的一种通信手段\",{\"1\":{\"872\":1}}],[\"解决思路\",{\"0\":{\"773\":1}}],[\"解决循环依赖有两个前提条件\",{\"1\":{\"621\":1}}],[\"解决方法时\",{\"1\":{\"601\":1}}],[\"解决方法\",{\"1\":{\"579\":1}}],[\"解决方案是在控制器里面不能写字段\",{\"1\":{\"653\":1}}],[\"解决方案\",{\"0\":{\"21\":1}}],[\"解决了很多java8之前使用日期类的痛点\",{\"1\":{\"555\":1}}],[\"解决\",{\"1\":{\"280\":1}}],[\"解决冲突\",{\"1\":{\"222\":1}}],[\"解决取名难问题\",{\"1\":{\"143\":1}}],[\"解决技术问题的社区\",{\"1\":{\"120\":1}}],[\"输出到文件中\",{\"1\":{\"991\":1}}],[\"输出详细的gc处理日志\",{\"1\":{\"503\":1}}],[\"输出的是执行结果\",{\"1\":{\"356\":1}}],[\"输出都是一致的\",{\"1\":{\"356\":1}}],[\"输出\",{\"1\":{\"207\":2,\"241\":1,\"929\":2,\"937\":2,\"953\":2,\"967\":1,\"981\":2,\"1028\":2,\"1033\":1,\"1038\":2}}],[\"输入为\",{\"1\":{\"1028\":1}}],[\"输入本地jar包存放路径即可\",{\"1\":{\"1007\":1}}],[\"输入刚才解压后的路径\",{\"1\":{\"1007\":1}}],[\"输入的格子\",{\"1\":{\"943\":1}}],[\"输入的是字节码二进制流\",{\"1\":{\"356\":1}}],[\"输入git\",{\"1\":{\"585\":1}}],[\"输入\",{\"1\":{\"207\":2,\"929\":2,\"937\":2,\"953\":2,\"967\":1,\"981\":2,\"1028\":2,\"1033\":1,\"1038\":2}}],[\"输入rabbittemplate\",{\"1\":{\"10\":1}}],[\"输入if\",{\"1\":{\"6\":1}}],[\"输入system\",{\"1\":{\"6\":1}}],[\"价值是w\",{\"1\":{\"207\":1}}],[\"件物品的前提是\",{\"1\":{\"207\":1}}],[\"件物品的体积是\",{\"1\":{\"207\":1}}],[\"件物品可用的容量就成了c\",{\"1\":{\"207\":1}}],[\"件物品\",{\"1\":{\"207\":3}}],[\"件物品如何选择即可\",{\"1\":{\"207\":1}}],[\"件物品和一个容量是\",{\"1\":{\"207\":1}}],[\"待补充\",{\"1\":{\"212\":1,\"538\":1,\"542\":1,\"927\":1,\"945\":1,\"951\":1}}],[\"待补充其他\",{\"1\":{\"27\":1}}],[\"待bu\",{\"1\":{\"206\":1}}],[\"限定决策规则\",{\"1\":{\"206\":1}}],[\"轮循选取提供者策略\",{\"1\":{\"916\":1}}],[\"轮询案例\",{\"0\":{\"701\":1}}],[\"轮询消费消息指的是轮流消费消息\",{\"1\":{\"700\":1}}],[\"轮询消费\",{\"0\":{\"700\":1}}],[\"轮可以从编号\",{\"1\":{\"204\":1,\"205\":1}}],[\"轮传递到编号\",{\"1\":{\"204\":2,\"205\":2}}],[\"轮播组件\",{\"1\":{\"158\":1}}],[\"个节点\",{\"1\":{\"1030\":1}}],[\"个人感觉是比较重要的算法题\",{\"1\":{\"985\":1}}],[\"个人认为\",{\"1\":{\"204\":1,\"205\":1}}],[\"个数需要增加\",{\"1\":{\"939\":2}}],[\"个线程\",{\"1\":{\"902\":1}}],[\"个线程的线程池\",{\"1\":{\"291\":1}}],[\"个标签\",{\"1\":{\"811\":1}}],[\"个则为死信\",{\"1\":{\"748\":1,\"749\":1}}],[\"个位正常\",{\"1\":{\"748\":1,\"749\":1}}],[\"个单词\",{\"1\":{\"741\":1,\"742\":1}}],[\"个单词的字符串\",{\"1\":{\"741\":1,\"742\":1}}],[\"个单独确认消息\",{\"1\":{\"722\":1}}],[\"个字节\",{\"1\":{\"740\":1}}],[\"个字符串对象\",{\"1\":{\"319\":1}}],[\"个字符串\",{\"1\":{\"319\":1}}],[\"个批量确认消息\",{\"1\":{\"723\":1}}],[\"个\",{\"1\":{\"718\":1,\"939\":1}}],[\"个消息\",{\"1\":{\"701\":1,\"748\":1,\"749\":1}}],[\"个特征\",{\"1\":{\"591\":1}}],[\"个条件的无用类进行回收\",{\"1\":{\"329\":1}}],[\"个元素中的最长上升子序列的长度\",{\"1\":{\"926\":1}}],[\"个元素都要执行向后位\",{\"1\":{\"229\":1}}],[\"个元素之后的\",{\"1\":{\"229\":1}}],[\"个台阶\",{\"1\":{\"200\":1}}],[\"偶数\",{\"1\":{\"203\":1}}],[\"奇数i的二进制表示中的1\",{\"1\":{\"203\":1}}],[\"奇趣网站收藏家\",{\"1\":{\"143\":1}}],[\"经验\",{\"1\":{\"957\":1}}],[\"经典的dfs题\",{\"1\":{\"935\":1}}],[\"经研究\",{\"1\":{\"497\":1}}],[\"经常会伴随至少一次的minor\",{\"1\":{\"495\":1}}],[\"经常出现致命错误\",{\"1\":{\"462\":1}}],[\"经常能在上面找到很多有创意好看的\",{\"1\":{\"139\":1}}],[\"经过4分钟后感染了橘子\",{\"1\":{\"943\":1}}],[\"经过\",{\"1\":{\"937\":1}}],[\"经过一次\",{\"1\":{\"937\":1}}],[\"经过上面结果显示答案是备份交换机优先级高\",{\"1\":{\"768\":1}}],[\"经过该\",{\"1\":{\"656\":1}}],[\"经过标量替换后\",{\"1\":{\"510\":1}}],[\"经过扰动函数处理过后得到\",{\"1\":{\"244\":1}}],[\"经过分析\",{\"1\":{\"203\":1}}],[\"第x位的值是否为1\",{\"1\":{\"949\":1}}],[\"第十一步\",{\"1\":{\"642\":1}}],[\"第十步\",{\"1\":{\"642\":1}}],[\"第九步\",{\"1\":{\"642\":1}}],[\"第八步\",{\"1\":{\"642\":1}}],[\"第七步\",{\"1\":{\"642\":1}}],[\"第六步\",{\"1\":{\"642\":1}}],[\"第五步\",{\"1\":{\"642\":1}}],[\"第四步\",{\"1\":{\"642\":1}}],[\"第三种\",{\"1\":{\"819\":1}}],[\"第三个来说就是安全性\",{\"1\":{\"872\":1}}],[\"第三个参数表示是否\",{\"1\":{\"706\":1}}],[\"第三个是下拉菜单\",{\"1\":{\"702\":1}}],[\"第三个和第四个参数都是接口\",{\"1\":{\"698\":1}}],[\"第三步\",{\"1\":{\"642\":1}}],[\"第三级缓存\",{\"1\":{\"621\":1}}],[\"第三方的启动器不能以spring\",{\"1\":{\"682\":1}}],[\"第三方框架\",{\"1\":{\"606\":1}}],[\"第三方库\",{\"1\":{\"468\":1}}],[\"第三方汉化版github地址\",{\"1\":{\"111\":1}}],[\"第4行表示改为下一个周日\",{\"1\":{\"569\":1}}],[\"第3行的limit\",{\"1\":{\"548\":1}}],[\"第二种\",{\"1\":{\"819\":1}}],[\"第二种是懒汉式\",{\"1\":{\"890\":1}}],[\"第二种是使用sql列的别名功能\",{\"1\":{\"808\":1}}],[\"第二种是编译执行\",{\"1\":{\"365\":1}}],[\"第二条消息的\",{\"1\":{\"762\":1}}],[\"第二条消息在\",{\"1\":{\"754\":1}}],[\"第二个消息并不会优先得到执行\",{\"1\":{\"755\":1}}],[\"第二个程序是消费者\",{\"1\":{\"734\":1}}],[\"第二个参数是表示否应用于多消息\",{\"1\":{\"706\":1}}],[\"第二个参数表示是否\",{\"1\":{\"706\":1}}],[\"第二个参数表示是否应用于多消息\",{\"1\":{\"706\":1}}],[\"第二个文本框填写参数\",{\"1\":{\"702\":1}}],[\"第二步\",{\"1\":{\"642\":1}}],[\"第二级缓存\",{\"1\":{\"621\":1}}],[\"第二阶段将所有的存活对象压缩到内存的一端\",{\"1\":{\"523\":1}}],[\"第二项则是清除\",{\"1\":{\"521\":1}}],[\"第二版\",{\"1\":{\"242\":1}}],[\"第一时间想到可以用hash表\",{\"1\":{\"947\":1}}],[\"第一种\",{\"1\":{\"819\":1}}],[\"第一种是饿汉式\",{\"1\":{\"890\":1}}],[\"第一种是使用<resultmap>标签\",{\"1\":{\"808\":1}}],[\"第一种是将源代码编译成字节码文件\",{\"1\":{\"365\":1}}],[\"第一条消息的\",{\"1\":{\"762\":1}}],[\"第一条消息在\",{\"1\":{\"754\":1}}],[\"第一个while结束后\",{\"1\":{\"974\":1}}],[\"第一个出现两次的字母\",{\"0\":{\"946\":1}}],[\"第一个单词是\",{\"1\":{\"741\":1,\"742\":1}}],[\"第一个程序将发出日志消息\",{\"1\":{\"734\":1}}],[\"第一个参数是交换机的名称\",{\"1\":{\"729\":1}}],[\"第一个参数是消息的标记\",{\"1\":{\"706\":1}}],[\"第一个参数表示拒绝\",{\"1\":{\"706\":2}}],[\"第一步\",{\"1\":{\"642\":1}}],[\"第一次写的时候漏了这个条件😥\",{\"1\":{\"935\":1}}],[\"第一次查询时候有\",{\"1\":{\"634\":1}}],[\"第一次getbean时才会初始化bean\",{\"1\":{\"611\":1}}],[\"第一级缓存\",{\"1\":{\"621\":1}}],[\"第一阶段和标记清除算法一样\",{\"1\":{\"523\":1}}],[\"第一项则是标记\",{\"1\":{\"521\":1}}],[\"第一款商用java虚拟机\",{\"1\":{\"349\":1}}],[\"第\",{\"1\":{\"207\":1}}],[\"第i行\",{\"1\":{\"201\":1}}],[\"到这里\",{\"1\":{\"944\":1}}],[\"到队列\",{\"1\":{\"709\":1}}],[\"到达\",{\"1\":{\"693\":1}}],[\"到达第i层\",{\"1\":{\"200\":1}}],[\"到底要放弃哪个锁\",{\"1\":{\"288\":1}}],[\"到了\",{\"1\":{\"249\":1}}],[\"到\",{\"1\":{\"246\":1,\"266\":1,\"717\":1,\"939\":1}}],[\"到账语音生成器\",{\"1\":{\"144\":1}}],[\"你允许\",{\"1\":{\"981\":1}}],[\"你能否用两种方法解决这道题\",{\"1\":{\"967\":1}}],[\"你能找到不少配色灵感\",{\"1\":{\"139\":1}}],[\"你知道的还有哪些\",{\"0\":{\"898\":1}}],[\"你知道哪几种垃圾收集器\",{\"1\":{\"518\":1}}],[\"你知道哪几种垃圾回收器\",{\"1\":{\"518\":1}}],[\"你要知道这样做的理由\",{\"1\":{\"893\":1}}],[\"你好\",{\"1\":{\"755\":1}}],[\"你好2\",{\"1\":{\"755\":1}}],[\"你好1\",{\"1\":{\"755\":1}}],[\"你只需要简单的将队列绑定到交换机上\",{\"1\":{\"728\":1}}],[\"你只需要配置好\",{\"1\":{\"595\":1}}],[\"你把你的包裹放到快递站\",{\"1\":{\"691\":1}}],[\"你还不知道springboot真正的启动引导类\",{\"1\":{\"661\":1}}],[\"你可能要每次都要搞清这个\",{\"1\":{\"595\":1}}],[\"你可以迭代或递归地反转链表\",{\"1\":{\"967\":1}}],[\"你可以假设字符串中只包含大小写英文字母\",{\"1\":{\"953\":1}}],[\"你可以假设二维矩阵的四个边缘都被水包围着\",{\"1\":{\"933\":1}}],[\"你可以从底层向上开始说起\",{\"1\":{\"919\":1}}],[\"你可以从原始数据源那里再获得一个新的流来重新遍历一遍\",{\"1\":{\"544\":1}}],[\"你可以把它当做一个快递站点\",{\"1\":{\"691\":1}}],[\"你可以一站式集成spring及其他技术\",{\"1\":{\"682\":1}}],[\"你可以为该指令命名\",{\"1\":{\"671\":1}}],[\"你可以想想java需要与一些底层系统\",{\"1\":{\"435\":1}}],[\"你可以用extern\",{\"1\":{\"434\":1}}],[\"你可以将代码替换成\",{\"1\":{\"241\":1}}],[\"你没有权限访问\",{\"1\":{\"422\":1}}],[\"你一个线程放弃锁的时候\",{\"1\":{\"288\":1}}],[\"你有多少种不同的方法可以爬到楼顶呢\",{\"1\":{\"200\":1}}],[\"变量名\",{\"1\":{\"1007\":2}}],[\"变量名后输入\",{\"1\":{\"10\":1}}],[\"变量n代替长度同理\",{\"1\":{\"954\":1}}],[\"变成偶数\",{\"1\":{\"198\":1}}],[\"力扣\",{\"0\":{\"197\":1}}],[\"力扣插件\",{\"1\":{\"22\":1}}],[\"且idea没有正在运行的后台任务\",{\"1\":{\"1011\":1}}],[\"且长度必须是2\",{\"1\":{\"998\":1}}],[\"且长度必须是\",{\"1\":{\"998\":1}}],[\"且减去x后的水量之前没装过\",{\"1\":{\"983\":2}}],[\"且之前没装过\",{\"1\":{\"983\":2}}],[\"且当前字符是数字\",{\"1\":{\"957\":1}}],[\"且当前订单的数量大于0\",{\"1\":{\"194\":1}}],[\"且\",{\"1\":{\"926\":1}}],[\"且必须满足\",{\"1\":{\"926\":1}}],[\"且字节码生成方便\",{\"1\":{\"894\":1}}],[\"且其可以被匿名访问\",{\"1\":{\"792\":1}}],[\"且其第一个元素的价格小于当前订单的价格\",{\"1\":{\"194\":1}}],[\"且老年代的可用内存小于该对象大小\",{\"1\":{\"496\":1}}],[\"且运行期保持不变时\",{\"1\":{\"419\":1,\"420\":1}}],[\"且状态变量须由该锁保护\",{\"1\":{\"288\":1}}],[\"且已创建的线程数小于maximumpoolsize\",{\"1\":{\"275\":1}}],[\"且可以通过索引来插入替换和删除集合元素的方法\",{\"1\":{\"225\":1}}],[\"且总价值最大\",{\"1\":{\"207\":1}}],[\"且这个值必须小于当前值\",{\"1\":{\"202\":1}}],[\"哈希值\",{\"1\":{\"476\":1}}],[\"哈希\",{\"2\":{\"191\":1}}],[\"滑动窗口\",{\"2\":{\"191\":1}}],[\"滑动窗口专题\",{\"0\":{\"185\":1}}],[\"窗口之外\",{\"1\":{\"190\":1}}],[\"窗口样式\",{\"1\":{\"38\":1}}],[\"找不到则返回\",{\"1\":{\"258\":1}}],[\"找出每个窗口首位两端的分数差\",{\"1\":{\"189\":1}}],[\"找到该树中两个指定节点的最近公共祖先\",{\"1\":{\"1038\":1}}],[\"找到给定的二维数组中最大的岛屿面积\",{\"1\":{\"933\":1}}],[\"找到最长且连续的的递增序列\",{\"1\":{\"929\":1}}],[\"找到远程的服务地址\",{\"1\":{\"874\":1}}],[\"找到需要自动配置的类\",{\"1\":{\"683\":1}}],[\"找到操作数栈顶的第一个元素所执行的对象的实际类型\",{\"1\":{\"422\":1}}],[\"找到\",{\"1\":{\"21\":1}}],[\"求直径\",{\"1\":{\"1023\":1}}],[\"求和等操作\",{\"1\":{\"416\":1}}],[\"求大于等于指定数的最小的二次幂\",{\"0\":{\"253\":1}}],[\"求解将哪些物品装入背包\",{\"1\":{\"207\":1}}],[\"求最大平均值\",{\"1\":{\"187\":1}}],[\"求一组动态数据集合的最大top\",{\"1\":{\"176\":1}}],[\"返回从右侧所能看到的节点值\",{\"1\":{\"1033\":1}}],[\"返回pre即可\",{\"1\":{\"970\":1}}],[\"返回其值即可\",{\"1\":{\"964\":1}}],[\"返回c\",{\"1\":{\"949\":1}}],[\"返回使\",{\"1\":{\"937\":1}}],[\"返回ans\",{\"1\":{\"930\":1,\"1039\":1}}],[\"返回max即可\",{\"1\":{\"925\":1}}],[\"返回map集合列表\",{\"1\":{\"849\":1}}],[\"返回modelandview之前执行\",{\"1\":{\"656\":1}}],[\"返回后\",{\"1\":{\"789\":1}}],[\"返回\",{\"1\":{\"719\":1,\"772\":1,\"933\":1,\"943\":1,\"1018\":2}}],[\"返回数据给前台页面\",{\"1\":{\"643\":1}}],[\"返回它们的长度\",{\"1\":{\"549\":1}}],[\"返回一个扔掉了前n个元素的流\",{\"1\":{\"548\":1}}],[\"返回指令包含\",{\"1\":{\"424\":1}}],[\"返回指定列表支持的同步\",{\"1\":{\"259\":1}}],[\"返回指定\",{\"1\":{\"259\":2}}],[\"返回地址是要通过异常表来确定\",{\"1\":{\"424\":1}}],[\"返回的就是加载过程中创建的那个常量池中的字符串\",{\"1\":{\"319\":1}}],[\"返回的是常量池中这个串的引用\",{\"1\":{\"318\":1}}],[\"返回由指定映射支持的同步\",{\"1\":{\"259\":1}}],[\"返回最大元素\",{\"1\":{\"258\":1}}],[\"返回最大的元素\",{\"1\":{\"258\":1}}],[\"返回索引\",{\"1\":{\"258\":1}}],[\"返回散列值也就是hashcode\",{\"1\":{\"244\":1}}],[\"返回值是\",{\"1\":{\"995\":1}}],[\"返回值必须是page对象\",{\"1\":{\"859\":1}}],[\"返回值\",{\"1\":{\"242\":2}}],[\"返回结果成功\",{\"1\":{\"771\":1}}],[\"返回结果\",{\"1\":{\"194\":1}}],[\"返回false\",{\"1\":{\"186\":1,\"317\":1,\"319\":1,\"957\":1,\"974\":1,\"983\":1}}],[\"返回true\",{\"1\":{\"186\":1,\"957\":1,\"974\":1,\"983\":1}}],[\"遍历当前层的元素\",{\"1\":{\"1035\":1}}],[\"遍历到最左下的时候\",{\"1\":{\"1024\":1}}],[\"遍历格子\",{\"1\":{\"943\":1}}],[\"遍历count\",{\"1\":{\"940\":1}}],[\"遍历a\",{\"1\":{\"940\":1}}],[\"遍历执行springapplicationrunlistener的finished\",{\"1\":{\"678\":1}}],[\"遍历调用所有springapplicationrunlistener的contextloaded\",{\"1\":{\"678\":1}}],[\"遍历调用所有springapplicationrunlistener的contextprepared\",{\"1\":{\"678\":1}}],[\"遍历调用所有springapplicationrunlistener的environmentprepared\",{\"1\":{\"678\":1}}],[\"遍历完0~i\",{\"1\":{\"926\":1}}],[\"遍历完之后\",{\"1\":{\"544\":1}}],[\"遍历完成仍没有结束的\",{\"1\":{\"186\":1}}],[\"遍历结束之后计算剩余的积压订单总数需要o\",{\"1\":{\"194\":1}}],[\"遍历数组\",{\"1\":{\"186\":1,\"930\":1,\"1039\":1}}],[\"`\",{\"1\":{\"184\":1}}],[\"`o\",{\"1\":{\"184\":1}}],[\"`alt+up\",{\"1\":{\"6\":1}}],[\"`alt\",{\"1\":{\"6\":1}}],[\"剑指\",{\"1\":{\"184\":1}}],[\"则右子树上所有节点的值均大于它的根节点的值\",{\"1\":{\"1029\":1}}],[\"则左子树上所有节点的值均小于它的根节点的值\",{\"1\":{\"1029\":1}}],[\"则先遍历左子树\",{\"1\":{\"1024\":1}}],[\"则执行\",{\"1\":{\"983\":2}}],[\"则更新cur\",{\"1\":{\"957\":1}}],[\"则更新失败\",{\"1\":{\"860\":1}}],[\"则需要回溯到它的父节点\",{\"1\":{\"1024\":1}}],[\"则需要考虑这种场景\",{\"1\":{\"983\":2}}],[\"则需要增加到6\",{\"1\":{\"938\":1}}],[\"则需要增加到上一个数+1\",{\"1\":{\"938\":1}}],[\"则需要根据代码被调用执行的频率而定\",{\"1\":{\"368\":1}}],[\"则curlen++\",{\"1\":{\"930\":1,\"1039\":1}}],[\"则dp\",{\"1\":{\"926\":1}}],[\"则状态转移方程为\",{\"1\":{\"926\":1}}],[\"则给dp\",{\"1\":{\"925\":1}}],[\"则querywrapper不会拼接此条件\",{\"1\":{\"852\":1}}],[\"则优先级是最高的\",{\"1\":{\"778\":1}}],[\"则优先使用编译后的本地代码来执行\",{\"1\":{\"369\":1}}],[\"则直接丢弃\",{\"1\":{\"765\":1}}],[\"则接下来无法发送消息到\",{\"1\":{\"762\":1}}],[\"则设置一个定时任务\",{\"1\":{\"761\":1}}],[\"则从缓存里删除该消息\",{\"1\":{\"761\":1}}],[\"则打印到控制台\",{\"1\":{\"757\":1}}],[\"则打印banner\",{\"1\":{\"678\":1}}],[\"则刚好能让消息在延迟多久之后成为死信\",{\"1\":{\"753\":1}}],[\"则表示除非此时可以直接投递该消息到消费者\",{\"1\":{\"752\":1}}],[\"则已过期的消息也许还能存活较长时间\",{\"1\":{\"752\":1}}],[\"则自动发送消息提醒\",{\"1\":{\"751\":1}}],[\"则自己创建一个事务\",{\"1\":{\"635\":1}}],[\"则代表原本\",{\"1\":{\"747\":1}}],[\"则代表预取值\",{\"1\":{\"717\":1}}],[\"则消费消息的次数也不同\",{\"1\":{\"715\":1}}],[\"则消息会重新被投递给自己\",{\"1\":{\"706\":1}}],[\"则不拒绝\",{\"1\":{\"714\":1}}],[\"则丢弃或者进入死信队列\",{\"1\":{\"706\":1}}],[\"则重新入队列\",{\"1\":{\"706\":2}}],[\"则依然调用所有springapplicationrunlistener的finished\",{\"1\":{\"678\":1}}],[\"则遍历执行它们\",{\"1\":{\"678\":1}}],[\"则新建一个事务自己执行\",{\"1\":{\"635\":1}}],[\"则新建新线程\",{\"1\":{\"291\":1}}],[\"则嵌套在当前事务中\",{\"1\":{\"635\":1}}],[\"则挂起当前事务\",{\"1\":{\"635\":1}}],[\"则只根据配置判断是否刷新\",{\"1\":{\"813\":1}}],[\"则只有被标记为\",{\"1\":{\"728\":1}}],[\"则只能通过\",{\"1\":{\"617\":1}}],[\"则只会在堆空间创建一个字符串常量\",{\"1\":{\"319\":1}}],[\"则会更加困难\",{\"1\":{\"989\":1}}],[\"则会自动在\",{\"1\":{\"777\":1}}],[\"则会关闭\",{\"1\":{\"762\":1}}],[\"则会成为\",{\"1\":{\"752\":1}}],[\"则会执行destroy\",{\"1\":{\"614\":1}}],[\"则会执行init\",{\"1\":{\"614\":1}}],[\"则会回调该接口的destroy方法\",{\"1\":{\"614\":1}}],[\"则会回调该接口的postprocessbeforeinitialzation和postprocessafterinitialization方法\",{\"1\":{\"614\":1}}],[\"则会使用\",{\"1\":{\"606\":2}}],[\"则属于编译时增强\",{\"1\":{\"602\":1}}],[\"则默认指定了\",{\"1\":{\"532\":1}}],[\"则还需要调整引用的地址\",{\"1\":{\"523\":1}}],[\"则认为发生逃逸\",{\"1\":{\"506\":1}}],[\"则认为没有发生逃逸\",{\"1\":{\"506\":1}}],[\"则改为进行一次fullgc\",{\"1\":{\"504\":2}}],[\"则尝试进行一次minorgc\",{\"1\":{\"504\":1}}],[\"则虚拟机会查看\",{\"1\":{\"504\":1}}],[\"则此次minorgc是安全的\",{\"1\":{\"504\":1}}],[\"则把它的值加到结果集中\",{\"1\":{\"1035\":1}}],[\"则把它加入到采购队列中\",{\"1\":{\"194\":1}}],[\"则把大的腐烂值更新为当前腐烂值+1\",{\"1\":{\"943\":1}}],[\"则把对应的配置类装载入spring容器\",{\"1\":{\"674\":1}}],[\"则把该对象转存到老年代\",{\"1\":{\"496\":1}}],[\"则触发major\",{\"1\":{\"495\":1}}],[\"则这个比例必然成立\",{\"1\":{\"488\":1}}],[\"则这项必须写\",{\"1\":{\"103\":1}}],[\"则用于表示堆区的最大内存\",{\"1\":{\"485\":1}}],[\"则jvm会抛\",{\"1\":{\"459\":1}}],[\"则适当降低该值\",{\"1\":{\"448\":1}}],[\"则抛出异常\",{\"1\":{\"635\":2}}],[\"则抛出\",{\"1\":{\"470\":1}}],[\"则抛出java\",{\"1\":{\"422\":1}}],[\"则抛出outofmemoryerror异常\",{\"1\":{\"302\":1}}],[\"则返回false\",{\"1\":{\"982\":1,\"1019\":2}}],[\"则返回true\",{\"1\":{\"982\":1,\"1019\":1}}],[\"则返回原先的字符串\",{\"1\":{\"953\":1}}],[\"则返回面积为0\",{\"1\":{\"933\":1}}],[\"则返回一个空流\",{\"1\":{\"548\":1}}],[\"则返回\",{\"1\":{\"422\":1,\"944\":1}}],[\"则返回常量池中该字符串的引用\",{\"1\":{\"318\":1}}],[\"则是未指定值\",{\"1\":{\"399\":1}}],[\"则初始化\",{\"1\":{\"397\":1}}],[\"则进行类加载\",{\"1\":{\"470\":1}}],[\"则进行访问权限校验\",{\"1\":{\"422\":1}}],[\"则进一步向上委托\",{\"1\":{\"391\":1}}],[\"则进入while循环\",{\"1\":{\"194\":1}}],[\"则由执行引擎\",{\"1\":{\"375\":1}}],[\"则证明此对象是不可用的\",{\"1\":{\"322\":1}}],[\"则当前线程获取锁失败\",{\"1\":{\"290\":1}}],[\"则利用cas操作将锁的状态从0置为1成功后\",{\"1\":{\"290\":1}}],[\"则将其回收\",{\"1\":{\"521\":1}}],[\"则将此方法的调用计数器值加1\",{\"1\":{\"369\":1}}],[\"则将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"289\":1}}],[\"则将冲突的值加到链表中即可\",{\"1\":{\"244\":1}}],[\"则线程池会创建新的线程来执行任务\",{\"1\":{\"275\":1}}],[\"则比较的是地址里的内容\",{\"1\":{\"242\":1}}],[\"则该消息是遗弃的消息\",{\"1\":{\"734\":1}}],[\"则该\",{\"1\":{\"242\":1}}],[\"则\",{\"1\":{\"242\":2,\"747\":1,\"954\":1}}],[\"则通过链表来实现\",{\"1\":{\"231\":1}}],[\"则调用indexedbinarysearch\",{\"1\":{\"230\":1}}],[\"则第\",{\"1\":{\"204\":1,\"205\":1}}],[\"则移除它\",{\"1\":{\"194\":1}}],[\"则继续判断\",{\"1\":{\"194\":1}}],[\"则n是奇数\",{\"1\":{\"182\":1}}],[\"回文链表\",{\"0\":{\"971\":1}}],[\"回传给生产者的确认消息中\",{\"1\":{\"720\":1}}],[\"回收策略等等\",{\"1\":{\"531\":1}}],[\"回收器作为补偿措施\",{\"1\":{\"525\":1}}],[\"回收器为例\",{\"1\":{\"525\":1}}],[\"回收不频繁\",{\"1\":{\"525\":1}}],[\"回收频繁\",{\"1\":{\"525\":1}}],[\"回收性价比很高\",{\"1\":{\"522\":1}}],[\"回收算法\",{\"1\":{\"518\":1}}],[\"回收年轻代对象的行为被称为minorgc\",{\"1\":{\"512\":1}}],[\"回收废弃常量与回收\",{\"1\":{\"464\":1}}],[\"回收效率低\",{\"1\":{\"463\":1}}],[\"回收效率不高\",{\"1\":{\"463\":1}}],[\"回边\",{\"1\":{\"370\":1}}],[\"回边计数器\",{\"0\":{\"370\":1}}],[\"回边计数器则用于统计循环体执行的循环次数\",{\"1\":{\"368\":1}}],[\"回溯时深度也会变小\",{\"1\":{\"1034\":1}}],[\"回溯到最近的\",{\"1\":{\"1034\":1}}],[\"回溯\",{\"0\":{\"178\":1}}],[\"回退消息\",{\"0\":{\"763\":1}}],[\"回退\",{\"1\":{\"6\":1}}],[\"利用双指针来完成此题\",{\"1\":{\"955\":1}}],[\"利用字符重复出现的次数\",{\"1\":{\"953\":1}}],[\"利用java\",{\"1\":{\"879\":1}}],[\"利用现成的http协议进行传输\",{\"1\":{\"872\":1}}],[\"利用数据库主键去重\",{\"1\":{\"774\":1}}],[\"利用了回调函数来达到消息可靠性传递的\",{\"1\":{\"724\":1}}],[\"利用starter实现自动化配置只需要两个条件\",{\"1\":{\"683\":1}}],[\"利用\",{\"1\":{\"614\":1,\"758\":2,\"774\":1,\"889\":1}}],[\"利用截取消息的方式\",{\"1\":{\"603\":1}}],[\"利用分治算法求一组数据的逆序对个数\",{\"1\":{\"179\":1}}],[\"利用回溯算法求解0\",{\"1\":{\"178\":1}}],[\"利用回溯算法求解八皇后问题\",{\"1\":{\"178\":1}}],[\"利用优先级队列合并k个有序数组\",{\"1\":{\"176\":1}}],[\"利用零宽度字符实现\",{\"1\":{\"143\":1}}],[\"堆分为新生代和老年代\",{\"1\":{\"525\":1}}],[\"堆空间越大\",{\"1\":{\"527\":1}}],[\"堆空间的参数设置\",{\"0\":{\"503\":1}}],[\"堆空间分代思想\",{\"0\":{\"497\":1}}],[\"堆空间内部结构\",{\"1\":{\"483\":1}}],[\"堆空间细分为\",{\"1\":{\"483\":1}}],[\"堆可以处于物理上不连续\",{\"1\":{\"482\":1}}],[\"堆也是java内存管理的核心区域\",{\"1\":{\"482\":1}}],[\"堆的核心概述\",{\"0\":{\"482\":1}}],[\"堆的核心概念\",{\"0\":{\"481\":1}}],[\"堆的结构\",{\"1\":{\"465\":1}}],[\"堆的限制\",{\"1\":{\"308\":1}}],[\"堆一样\",{\"1\":{\"442\":1}}],[\"堆区是线程共享区域\",{\"1\":{\"501\":1}}],[\"堆区用于存储java对象实例\",{\"1\":{\"485\":1}}],[\"堆区一样都可以是不连续的\",{\"1\":{\"442\":1}}],[\"堆区中的对象实例信息\",{\"1\":{\"356\":1}}],[\"堆区分开来\",{\"1\":{\"305\":1,\"343\":1}}],[\"堆对象的布局中就必须考虑如何放置访问类型数据的相关信息\",{\"1\":{\"315\":1}}],[\"堆中对象被移动时\",{\"1\":{\"479\":1}}],[\"堆中预先分配一小块内存\",{\"1\":{\"471\":1}}],[\"堆中不存在该类及其任何派生子类的实例\",{\"1\":{\"464\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"329\":1}}],[\"堆中将会划分出一块内存来作为句柄池\",{\"1\":{\"315\":1}}],[\"堆中划分出来\",{\"1\":{\"311\":1}}],[\"堆中的对象不会马上被移除\",{\"1\":{\"482\":1}}],[\"堆中的对象非常类似\",{\"1\":{\"464\":1}}],[\"堆中的\",{\"1\":{\"308\":1}}],[\"堆之间来回复制数据\",{\"1\":{\"308\":1}}],[\"堆和\",{\"1\":{\"308\":1}}],[\"堆这里最容易出现的就是\",{\"1\":{\"304\":1}}],[\"堆内存的大小是可以调节的\",{\"1\":{\"482\":1}}],[\"堆内存被通常分为下面三部分\",{\"1\":{\"304\":1}}],[\"堆内存地址\",{\"1\":{\"242\":1}}],[\"堆还可以细分为\",{\"1\":{\"304\":1}}],[\"堆是分配对象的唯一选择吗\",{\"0\":{\"505\":1}}],[\"堆是线程共享的\",{\"1\":{\"482\":1}}],[\"堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定\",{\"1\":{\"311\":1,\"471\":1}}],[\"堆是否规整决定\",{\"1\":{\"311\":1,\"471\":1}}],[\"堆是垃圾收集器管理的主要区域\",{\"1\":{\"304\":1}}],[\"堆是所有线程共享的一块内存区域\",{\"1\":{\"304\":1}}],[\"堆\",{\"0\":{\"176\":1,\"304\":1,\"439\":1,\"480\":1},\"1\":{\"300\":1,\"304\":1,\"343\":1,\"439\":1,\"482\":2,\"535\":1}}],[\"散列表\",{\"0\":{\"173\":1}}],[\"冒泡排序\",{\"1\":{\"171\":1}}],[\"排序规则由comparatator类控制\",{\"1\":{\"258\":1}}],[\"排序操作\",{\"0\":{\"257\":1}}],[\"排序需要的时间为\",{\"1\":{\"189\":1,\"190\":1}}],[\"排序\",{\"0\":{\"171\":1},\"1\":{\"256\":1,\"843\":1}}],[\"排除了pro01\",{\"1\":{\"83\":1}}],[\"排除掉\",{\"1\":{\"82\":1}}],[\"递归最深达到\",{\"1\":{\"1029\":1}}],[\"递归函数在递归过程中需要为每一层递归函数分配栈空间\",{\"1\":{\"1029\":1}}],[\"递归方式\",{\"1\":{\"1024\":1}}],[\"递归深度可能会达到\",{\"1\":{\"969\":1}}],[\"递归\",{\"0\":{\"170\":1,\"969\":1,\"1029\":1},\"1\":{\"970\":1}}],[\"队列大写为100000\",{\"1\":{\"902\":1}}],[\"队列具备两种模式\",{\"1\":{\"783\":1}}],[\"队列中的消息会尽可能的存储在内存之中\",{\"1\":{\"782\":1}}],[\"队列中去\",{\"1\":{\"736\":1}}],[\"队列需要设置为优先级队列\",{\"1\":{\"777\":1}}],[\"队列实现优先级需要做的事情有如下\",{\"1\":{\"777\":1}}],[\"队列ttl\",{\"0\":{\"754\":1}}],[\"队列设置\",{\"1\":{\"752\":1}}],[\"队列内部是有序的\",{\"1\":{\"751\":1}}],[\"队列达到最大长度\",{\"1\":{\"745\":1}}],[\"队列由消费者进行消费\",{\"1\":{\"742\":1}}],[\"队列只对它绑定的交换机的消息感兴趣\",{\"1\":{\"735\":1}}],[\"队列将被自动删除\",{\"1\":{\"730\":1}}],[\"队列声明\",{\"1\":{\"722\":1,\"723\":1}}],[\"队列有可能就会遇到队列被撑满的情况\",{\"1\":{\"714\":1}}],[\"队列还在不停的添加新任务\",{\"1\":{\"714\":1}}],[\"队列持久化\",{\"0\":{\"711\":1}}],[\"队列的最大存活时间位\",{\"1\":{\"752\":1}}],[\"队列的名称我们来说至关重要\",{\"1\":{\"730\":1}}],[\"队列的消息\",{\"1\":{\"698\":1}}],[\"队列的优先级\",{\"1\":{\"697\":1}}],[\"队列里的消息如果没有被消费\",{\"1\":{\"697\":1}}],[\"队列里面的消息是否持久化\",{\"1\":{\"697\":1}}],[\"队列名字\",{\"1\":{\"698\":1}}],[\"队列名\",{\"1\":{\"697\":2,\"702\":2}}],[\"队列名称\",{\"1\":{\"697\":1}}],[\"队列仅受主机的内存和磁盘限制的约束\",{\"1\":{\"692\":1}}],[\"队列是一个虚拟的双向队列\",{\"1\":{\"289\":1}}],[\"队列锁实现的\",{\"1\":{\"289\":1}}],[\"队列满了\",{\"1\":{\"745\":1}}],[\"队列满\",{\"1\":{\"275\":1}}],[\"队列\",{\"0\":{\"169\":1},\"1\":{\"692\":1,\"736\":2,\"738\":2,\"747\":1,\"748\":1,\"749\":1,\"754\":3,\"755\":1,\"762\":1}}],[\"后序遍历\",{\"1\":{\"1024\":3}}],[\"后序以及按层遍历\",{\"1\":{\"175\":1}}],[\"后的字符串没有变短\",{\"1\":{\"953\":1}}],[\"后台记录失败请求\",{\"1\":{\"917\":1}}],[\"后缀\",{\"1\":{\"901\":1}}],[\"后重写为\",{\"1\":{\"817\":1}}],[\"后变成了死信消息\",{\"1\":{\"754\":1}}],[\"后续的消息才能继续发布\",{\"1\":{\"722\":1}}],[\"后续遍历需要\",{\"1\":{\"189\":1,\"190\":1}}],[\"后置通知\",{\"1\":{\"604\":1}}],[\"后来开发人员觉得\",{\"1\":{\"595\":1}}],[\"后发现\",{\"1\":{\"505\":1}}],[\"后进入老年代的平均大小大于老年代的可用内存\",{\"1\":{\"496\":1}}],[\"后进先出\",{\"1\":{\"413\":1}}],[\"后\",{\"1\":{\"365\":1,\"702\":1,\"706\":1,\"719\":1}}],[\"后解决了这个问题\",{\"1\":{\"247\":1}}],[\"后面不允许填入版本和文件后缀\",{\"1\":{\"756\":1}}],[\"后面死信队列\",{\"1\":{\"697\":1}}],[\"后面死信队列延迟队列等会用到\",{\"1\":{\"697\":1}}],[\"后面会介绍到\",{\"1\":{\"531\":1}}],[\"后面会介绍到为什么是\",{\"1\":{\"239\":1}}],[\"后面的值的就可以通过公式得到\",{\"1\":{\"200\":1}}],[\"后面还有一个\",{\"1\":{\"103\":1}}],[\"后退功能\",{\"1\":{\"168\":1}}],[\"栈最多存储\",{\"1\":{\"1030\":1}}],[\"栈就是一个后进先出的数据结构\",{\"1\":{\"1024\":1}}],[\"栈空间被回收\",{\"1\":{\"508\":1}}],[\"栈和堆的区别\",{\"1\":{\"465\":1}}],[\"栈内存分配过大\",{\"1\":{\"429\":1}}],[\"栈越大\",{\"1\":{\"415\":1}}],[\"栈顶栈帧\",{\"1\":{\"413\":1}}],[\"栈运行原理\",{\"0\":{\"413\":1}}],[\"栈帧中还允许携带与java虚拟机实现相关的一些附加信息\",{\"1\":{\"425\":1}}],[\"栈帧中一般不会保存这部分信息\",{\"1\":{\"424\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"322\":1}}],[\"栈帧的内部结构\",{\"0\":{\"414\":1}}],[\"栈帧是一个内存区块\",{\"1\":{\"412\":1}}],[\"栈中变量指向句柄\",{\"1\":{\"479\":1}}],[\"栈中的变量直接指向堆中的对象\",{\"1\":{\"479\":1}}],[\"栈中的任何一个元素都是可以任意的java数据类型\",{\"1\":{\"416\":1}}],[\"栈中的数据都是以栈帧\",{\"1\":{\"412\":1}}],[\"栈中存储什么\",{\"0\":{\"412\":1}}],[\"栈中可能出现的异常\",{\"0\":{\"409\":1}}],[\"栈的相关面试题\",{\"0\":{\"426\":1}}],[\"栈的存储单位\",{\"0\":{\"411\":1}}],[\"栈的大小直接决定了函数调用的最大可达深度\",{\"1\":{\"410\":1}}],[\"栈的特点\",{\"0\":{\"408\":1}}],[\"栈是一种快速有效的分配存储方式\",{\"1\":{\"408\":1}}],[\"栈是运行时的单位\",{\"1\":{\"405\":1}}],[\"栈上分配\",{\"0\":{\"508\":1},\"1\":{\"372\":1,\"505\":1,\"507\":1,\"511\":1}}],[\"栈信息等\",{\"1\":{\"267\":1}}],[\"栈\",{\"0\":{\"168\":1,\"439\":1},\"1\":{\"439\":1,\"1024\":1}}],[\"循环结束条件为\",{\"1\":{\"954\":1}}],[\"循环结束后判断\",{\"1\":{\"194\":1}}],[\"循环结束后\",{\"1\":{\"184\":1,\"194\":1,\"926\":1,\"930\":1,\"1039\":1}}],[\"循环\",{\"1\":{\"301\":1,\"399\":1}}],[\"循环屏障\",{\"1\":{\"292\":1}}],[\"循环等待条件\",{\"1\":{\"269\":1}}],[\"循环内\",{\"1\":{\"194\":1}}],[\"循环链表\",{\"1\":{\"167\":1}}],[\"循环依赖问题\",{\"0\":{\"91\":1}}],[\"数值流\",{\"0\":{\"552\":1}}],[\"数量值\",{\"1\":{\"458\":1}}],[\"数据库中添加version字段\",{\"1\":{\"860\":1}}],[\"数据库中创建状态列is\",{\"1\":{\"840\":1}}],[\"数据库操作\",{\"1\":{\"643\":1}}],[\"数据转换为\",{\"1\":{\"651\":1}}],[\"数据与界面显示分离的方法来组织代码\",{\"1\":{\"645\":1}}],[\"数据绑定\",{\"1\":{\"591\":1}}],[\"数据访问\",{\"1\":{\"591\":2}}],[\"数据卷名称或挂载点\",{\"1\":{\"577\":1}}],[\"数据来操作堆上的具体对象\",{\"1\":{\"315\":1}}],[\"数据\",{\"1\":{\"231\":1,\"651\":1}}],[\"数据范围为0\",{\"1\":{\"198\":1}}],[\"数据结构等\",{\"1\":{\"437\":1}}],[\"数据结构跟\",{\"1\":{\"252\":1}}],[\"数据结构\",{\"1\":{\"229\":1}}],[\"数据结构主要为数组\",{\"1\":{\"185\":1}}],[\"数据结构和算法必知必会的50个代码实现\",{\"0\":{\"165\":1}}],[\"数组类题目\",{\"1\":{\"947\":1}}],[\"数组将变为\",{\"1\":{\"937\":2}}],[\"数组长度不会超过10000\",{\"1\":{\"929\":1,\"1038\":1}}],[\"数组长度是固定的\",{\"1\":{\"227\":1}}],[\"数组里的元素\",{\"1\":{\"251\":1}}],[\"数组结构组成\",{\"1\":{\"251\":1}}],[\"数组结构和\",{\"1\":{\"251\":1}}],[\"数组+链表+红黑树的数据结构来实现\",{\"1\":{\"249\":1}}],[\"数组+链表\",{\"1\":{\"249\":2,\"252\":1}}],[\"数组+链表组成的\",{\"1\":{\"222\":1}}],[\"数组中每一格就是一个链表\",{\"1\":{\"244\":1}}],[\"数组和对象可能永远不会存储在栈上\",{\"1\":{\"482\":1}}],[\"数组和链表\",{\"1\":{\"244\":1}}],[\"数组和长度过短\",{\"1\":{\"228\":1}}],[\"数组地址值\",{\"1\":{\"233\":1}}],[\"数组只能存放类型一样的数据\",{\"1\":{\"228\":1}}],[\"数组的边界\",{\"1\":{\"939\":1}}],[\"数组的数据进行修改时\",{\"1\":{\"251\":1}}],[\"数组的长度过长\",{\"1\":{\"228\":1}}],[\"数组的缺点是一旦声明之后\",{\"1\":{\"217\":1}}],[\"数组在内存中是连续存储的\",{\"1\":{\"228\":1}}],[\"数组array\",{\"1\":{\"228\":1}}],[\"数组array和集合arraylist的区别\",{\"0\":{\"228\":1}}],[\"数组是\",{\"1\":{\"222\":2,\"249\":1}}],[\"数组来实现二叉堆\",{\"1\":{\"221\":1}}],[\"数组存储的数据是有序的\",{\"1\":{\"217\":1}}],[\"数组装的是\",{\"1\":{\"207\":1}}],[\"数组\",{\"0\":{\"166\":1,\"950\":1,\"951\":1},\"1\":{\"207\":1,\"219\":2,\"221\":1,\"229\":1,\"249\":3,\"251\":2}}],[\"框架的雏形就差不多了\",{\"1\":{\"919\":1}}],[\"框架定义好接口\",{\"1\":{\"892\":1}}],[\"框架结构\",{\"0\":{\"828\":1}}],[\"框架中\",{\"1\":{\"673\":1}}],[\"框架集成\",{\"1\":{\"643\":1}}],[\"框架负责动态地生成\",{\"1\":{\"603\":1}}],[\"框架了\",{\"1\":{\"596\":1}}],[\"框架指的都是\",{\"1\":{\"591\":1}}],[\"框架相关的记录\",{\"1\":{\"164\":1}}],[\"框架\",{\"0\":{\"164\":1,\"919\":1},\"1\":{\"643\":1,\"806\":1}}],[\"框架所需jar包\",{\"1\":{\"80\":1}}],[\"刷\",{\"1\":{\"150\":1}}],[\"算法不同\",{\"1\":{\"535\":1}}],[\"算法会导致收集结束时会有大量空间碎片产生\",{\"1\":{\"534\":1}}],[\"算法实现的收集器\",{\"1\":{\"535\":1}}],[\"算法实现的\",{\"1\":{\"534\":1,\"535\":1}}],[\"算法的诞生\",{\"1\":{\"526\":1}}],[\"算法的\",{\"1\":{\"525\":1}}],[\"算法由此诞生\",{\"1\":{\"523\":1}}],[\"算法里位运算的作用\",{\"1\":{\"253\":1}}],[\"算法\",{\"0\":{\"150\":1,\"210\":1,\"951\":1,\"960\":1,\"977\":1,\"979\":1,\"987\":1},\"1\":{\"177\":1,\"523\":1}}],[\"算法笔记\",{\"1\":{\"1\":1}}],[\"应答功能属于消费者\",{\"1\":{\"725\":1}}],[\"应答和发布区别\",{\"0\":{\"725\":1}}],[\"应答与发布\",{\"0\":{\"703\":1}}],[\"应该小心使用具有无限预处理的自动确认模式或手动确认模式\",{\"1\":{\"717\":1}}],[\"应该算的上是\",{\"1\":{\"596\":1}}],[\"应该属于mid难度\",{\"1\":{\"204\":1,\"205\":1}}],[\"应有尽有\",{\"1\":{\"148\":1}}],[\"应用这些第三方库\",{\"1\":{\"667\":1}}],[\"应用最终可以打成jar包的形式独立运行\",{\"1\":{\"665\":1}}],[\"应用对象被声明式地组合\",{\"1\":{\"592\":1}}],[\"应用软件将处于一种\",{\"1\":{\"526\":1}}],[\"应用场景从modelandview出发\",{\"1\":{\"656\":1}}],[\"应用场景\",{\"1\":{\"522\":1,\"656\":1,\"744\":1}}],[\"应用\",{\"1\":{\"183\":1,\"184\":1,\"512\":1}}],[\"应用程序有自己的工厂对象来创建bean\",{\"1\":{\"625\":1}}],[\"应用程序会被挂起很久\",{\"1\":{\"526\":1}}],[\"应用程序所有的线程都会挂起\",{\"1\":{\"526\":1}}],[\"应用程序类必须扩展javafx\",{\"1\":{\"392\":1}}],[\"应用程序类加载器\",{\"0\":{\"384\":1},\"1\":{\"331\":1}}],[\"应用程序的生命周期\",{\"1\":{\"105\":1}}],[\"应用程序\",{\"1\":{\"105\":1}}],[\"应用内窗口切换\",{\"1\":{\"48\":1}}],[\"读书清单\",{\"1\":{\"148\":1}}],[\"稿定设计\",{\"1\":{\"148\":1}}],[\"强大的\",{\"1\":{\"827\":1}}],[\"强大的电子书资源网站\",{\"1\":{\"148\":1}}],[\"强引用\",{\"0\":{\"325\":1}}],[\"强烈建议前端\",{\"1\":{\"143\":1}}],[\"云端办公工具\",{\"1\":{\"148\":1}}],[\"浏览器版本更新提示插件\",{\"1\":{\"148\":1}}],[\"浏览器端图片压缩\",{\"1\":{\"132\":1}}],[\"磨刀\",{\"1\":{\"147\":1}}],[\"教你怎么合理的使用\",{\"1\":{\"146\":1}}],[\"教程\",{\"0\":{\"146\":1,\"660\":1}}],[\"梦境空间\",{\"1\":{\"145\":1}}],[\"允许匿名和带token访问\",{\"1\":{\"788\":1}}],[\"允许从已经提交的并发事务读取\",{\"1\":{\"634\":1}}],[\"允许读取尚未提交的更改\",{\"1\":{\"634\":1}}],[\"允许程序员模块化横向业务逻辑\",{\"1\":{\"604\":1}}],[\"允许我们通过\",{\"1\":{\"599\":1}}],[\"允许将对象打散分配在栈上\",{\"1\":{\"510\":1}}],[\"允许被实现成固定或者是可动态扩展的内存大小\",{\"1\":{\"437\":1}}],[\"允许的创建线程数量为integer\",{\"1\":{\"291\":1}}],[\"允许的请求队列长度为integer\",{\"1\":{\"291\":1}}],[\"允许用户拥有虚拟土地\",{\"1\":{\"145\":1}}],[\"允许xxx\",{\"1\":{\"38\":1}}],[\"支付扣款成功\",{\"1\":{\"771\":1}}],[\"支付宝到账1亿元\",{\"1\":{\"144\":1}}],[\"支持http\",{\"1\":{\"879\":1}}],[\"支持模板引擎\",{\"1\":{\"827\":1}}],[\"支持全局通用方法注入\",{\"1\":{\"827\":1}}],[\"支持自定义全局通用操作\",{\"1\":{\"827\":1}}],[\"支持多种语言之间的rpc方式的通信\",{\"1\":{\"879\":1}}],[\"支持多种云盘存储\",{\"1\":{\"110\":1}}],[\"支持多达\",{\"1\":{\"827\":1}}],[\"支持主键自动生成\",{\"1\":{\"827\":1}}],[\"支持对象关系组件维护\",{\"1\":{\"807\":1}}],[\"支持对象与数据库的orm字段关系映射\",{\"1\":{\"807\":1}}],[\"支持编写动态sql语句\",{\"1\":{\"807\":1}}],[\"支持各种请求资源的映射策略\",{\"1\":{\"644\":1}}],[\"支持当前事务\",{\"1\":{\"635\":3}}],[\"支持两种类型的类加载器\",{\"1\":{\"381\":1}}],[\"支持的同步\",{\"1\":{\"259\":2}}],[\"支持\",{\"1\":{\"229\":1,\"231\":1,\"602\":1,\"827\":4,\"879\":1}}],[\"支持增删操作\",{\"1\":{\"167\":1}}],[\"支持动态增删改操作\",{\"1\":{\"166\":1}}],[\"支持pc端和移动端\",{\"1\":{\"161\":1}}],[\"支持携带版不用安装\",{\"1\":{\"110\":1}}],[\"诺基亚短信图片生成器\",{\"1\":{\"144\":1}}],[\"火车等声音\",{\"1\":{\"144\":1}}],[\"海浪\",{\"1\":{\"144\":1}}],[\"海报制作工具\",{\"1\":{\"148\":1}}],[\"海报\",{\"1\":{\"139\":1}}],[\"咖啡厅\",{\"1\":{\"144\":1}}],[\"卡通头像生成器\",{\"1\":{\"144\":1}}],[\"超出\",{\"1\":{\"939\":1}}],[\"超出的线程会在队列中等待\",{\"1\":{\"291\":1}}],[\"超过\",{\"1\":{\"444\":1}}],[\"超过这个阈值\",{\"1\":{\"369\":1}}],[\"超过这个值将会抛出\",{\"1\":{\"305\":1,\"338\":1}}],[\"超过一定的时间\",{\"1\":{\"277\":1}}],[\"超多名字生成\",{\"1\":{\"143\":1}}],[\"超屌\",{\"1\":{\"143\":1}}],[\"超链接\",{\"1\":{\"47\":1}}],[\"加满y\",{\"1\":{\"982\":1}}],[\"加满x\",{\"1\":{\"982\":1}}],[\"加上动态\",{\"1\":{\"811\":1}}],[\"加入依赖即可\",{\"1\":{\"680\":1}}],[\"加一千年\",{\"1\":{\"568\":1}}],[\"加一个筛选即可\",{\"1\":{\"549\":1}}],[\"加载驱动\",{\"1\":{\"806\":1}}],[\"加载或运行时完成\",{\"1\":{\"604\":1}}],[\"加载类的时候进行织入\",{\"1\":{\"602\":1}}],[\"加载时织入\",{\"1\":{\"602\":1}}],[\"加载这个类的\",{\"1\":{\"395\":1}}],[\"加载扩展类和应用程序类加载器\",{\"1\":{\"382\":1}}],[\"加载\",{\"0\":{\"376\":1,\"378\":1},\"1\":{\"375\":1,\"381\":1}}],[\"加载的类信息存放于一块称为方法区的内存空间\",{\"1\":{\"375\":1}}],[\"加载的时候\",{\"1\":{\"332\":1}}],[\"加载该类的类加载器己经被回收\",{\"1\":{\"464\":1}}],[\"加载该类的\",{\"1\":{\"329\":1}}],[\"加了一层判断hasqueuedpredecessors\",{\"1\":{\"290\":1}}],[\"加密信息分享\",{\"1\":{\"143\":1}}],[\"加粗\",{\"1\":{\"47\":1}}],[\"隐形水印\",{\"1\":{\"143\":1}}],[\"特性\",{\"0\":{\"827\":1}}],[\"特别是当生产者所在的服务有多台机器的时候\",{\"1\":{\"767\":1}}],[\"特别是在消费者连接等待时间较长的环境\",{\"1\":{\"717\":1}}],[\"特别是消费者连接延迟很严重的情况下\",{\"1\":{\"717\":1}}],[\"特别的\",{\"1\":{\"522\":1}}],[\"特有的\",{\"1\":{\"673\":1}}],[\"特殊情况处理\",{\"1\":{\"954\":1}}],[\"特殊情况第1行已经判断过\",{\"1\":{\"925\":1}}],[\"特殊情况\",{\"0\":{\"491\":1}}],[\"特殊情况2\",{\"1\":{\"317\":1}}],[\"特殊情况1\",{\"1\":{\"317\":1}}],[\"特殊\",{\"1\":{\"143\":1}}],[\"特点单一\",{\"1\":{\"217\":1}}],[\"特点\",{\"0\":{\"95\":1},\"1\":{\"518\":1}}],[\"客户端不需要启动多线程即可完成并行调用多个远程服务\",{\"1\":{\"896\":1}}],[\"客户端如何发现这些暴露的服务\",{\"1\":{\"876\":1}}],[\"客户端存根\",{\"1\":{\"874\":4,\"878\":1}}],[\"客户端\",{\"1\":{\"143\":1,\"873\":1,\"874\":1}}],[\"动作\",{\"1\":{\"535\":1}}],[\"动机\",{\"1\":{\"462\":1}}],[\"动态配置等集群支持\",{\"1\":{\"885\":1}}],[\"动态扩展等\",{\"1\":{\"872\":1}}],[\"动态表名sql解析器\",{\"0\":{\"861\":1}}],[\"动态\",{\"0\":{\"812\":2},\"1\":{\"812\":1}}],[\"动态决定应该创建哪一个产品类\",{\"1\":{\"624\":1}}],[\"动态的将横切逻辑与业务逻辑织在一起\",{\"1\":{\"603\":1}}],[\"动态语言\",{\"1\":{\"591\":1}}],[\"动态对象年龄判断\",{\"1\":{\"498\":1}}],[\"动态生成\",{\"1\":{\"464\":1}}],[\"动态代理模式\",{\"0\":{\"907\":1}}],[\"动态代理为\",{\"1\":{\"816\":1}}],[\"动态代理更加灵活\",{\"1\":{\"607\":1}}],[\"动态代理跟静态代理的区别\",{\"0\":{\"607\":1}}],[\"动态代理主要是针对类实现了某个接口\",{\"1\":{\"606\":1}}],[\"动态代理\",{\"1\":{\"464\":1,\"606\":1,\"607\":1,\"816\":1,\"878\":1,\"894\":1}}],[\"动态代理技术\",{\"1\":{\"378\":1}}],[\"动态加载的类过多\",{\"1\":{\"306\":1}}],[\"动态链接\",{\"0\":{\"417\":1,\"419\":1},\"1\":{\"302\":1,\"303\":1,\"414\":1,\"419\":1}}],[\"动态规划的重点\",{\"1\":{\"926\":1}}],[\"动态规划专题\",{\"0\":{\"196\":1}}],[\"动态规划\",{\"0\":{\"180\":1,\"925\":1,\"926\":1},\"1\":{\"208\":1},\"2\":{\"209\":1}}],[\"动漫图生成真人图像\",{\"1\":{\"144\":1}}],[\"动漫化\",{\"1\":{\"132\":1}}],[\"动画库\",{\"1\":{\"158\":1}}],[\"动画\",{\"1\":{\"143\":1}}],[\"点我测试一下\",{\"1\":{\"143\":2}}],[\"点击下方的\",{\"1\":{\"777\":1}}],[\"点击跳转\",{\"1\":{\"756\":1}}],[\"点击查看代码\",{\"1\":{\"754\":1}}],[\"点击绿色箭头运行即可\",{\"1\":{\"671\":1}}],[\"点击保存将会在idea项目运行部位出现\",{\"1\":{\"671\":1}}],[\"点击左上角的\",{\"1\":{\"671\":1}}],[\"点击推送\",{\"1\":{\"583\":1}}],[\"点击确定\",{\"1\":{\"583\":1}}],[\"点击a分支需要合并的提交\",{\"1\":{\"583\":1}}],[\"点击这里\",{\"1\":{\"440\":1}}],[\"点击\",{\"1\":{\"18\":1,\"19\":1,\"702\":4,\"777\":2}}],[\"点击idea左上角project窗口右上角的齿轮\",{\"1\":{\"12\":1}}],[\"童年回忆\",{\"1\":{\"143\":1}}],[\"收到消息后进行解码\",{\"1\":{\"874\":1}}],[\"收到延时队列的消息\",{\"1\":{\"757\":1}}],[\"收到死信队列信息\",{\"1\":{\"754\":1}}],[\"收集算法\",{\"1\":{\"531\":1}}],[\"收集器之间的搭配关系\",{\"0\":{\"539\":1}}],[\"收集器在有限时间内可以尽可能高的收集效率\",{\"1\":{\"535\":1}}],[\"收集器在后台维护了一个优先列表\",{\"1\":{\"535\":1}}],[\"收集器仍然可以通过并发的方式让\",{\"1\":{\"535\":1}}],[\"收集器是一种\",{\"1\":{\"534\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"534\":1}}],[\"收集器是最基本\",{\"1\":{\"530\":1}}],[\"收集器搭配使用\",{\"1\":{\"533\":1}}],[\"收集器关注点是吞吐量\",{\"1\":{\"532\":1}}],[\"收集器也是使用标记\",{\"1\":{\"532\":1}}],[\"收集器外\",{\"1\":{\"531\":1}}],[\"收集器完全一样\",{\"1\":{\"531\":1}}],[\"收集器的运作大致分为以下几个步骤\",{\"1\":{\"535\":1}}],[\"收集器的后备方案\",{\"1\":{\"533\":1}}],[\"收集器的老年代版本\",{\"1\":{\"533\":1}}],[\"收集器的多线程版本\",{\"1\":{\"531\":1}}],[\"收集器的收集策略里就有直接进行major的策略选择过程\",{\"1\":{\"495\":1}}],[\"收集器其实就是\",{\"1\":{\"531\":1}}],[\"收集器\",{\"0\":{\"531\":1,\"532\":1,\"533\":1,\"534\":1,\"535\":1,\"536\":1},\"1\":{\"531\":1,\"540\":1}}],[\"收集器对堆内存从头到尾进行线性的遍历\",{\"1\":{\"521\":1}}],[\"收集器从引用根节点开始遍历\",{\"1\":{\"521\":1}}],[\"收集器就不支持类卸载\",{\"1\":{\"464\":1}}],[\"收集整个java堆和方法区的垃圾收集\",{\"1\":{\"493\":1}}],[\"收集整个新生代以及部分老年代的垃圾收集\",{\"1\":{\"493\":1}}],[\"收集了不少有意思的\",{\"1\":{\"149\":1}}],[\"收集了一些恶搞小网页\",{\"1\":{\"143\":1}}],[\"收集了许多有用的代码小片段\",{\"1\":{\"129\":1}}],[\"收集了很多网站\",{\"1\":{\"120\":1}}],[\"收藏了很多有趣的网站\",{\"1\":{\"143\":1}}],[\"黑客界面等\",{\"1\":{\"143\":1}}],[\"黑白修复\",{\"1\":{\"132\":1}}],[\"电子邮件\",{\"1\":{\"591\":1}}],[\"电子书\",{\"0\":{\"124\":1}}],[\"电脑恶搞\",{\"1\":{\"143\":1}}],[\"值一样会触发回调方法\",{\"1\":{\"762\":1}}],[\"值经测试有两种效果\",{\"1\":{\"762\":1}}],[\"值是发布消息成功到交换器后会触发回调方法\",{\"1\":{\"762\":1}}],[\"值是禁用发布确认模式\",{\"1\":{\"762\":1}}],[\"值来完成的\",{\"1\":{\"717\":1}}],[\"值得一提的是\",{\"1\":{\"698\":1}}],[\"值得学习\",{\"1\":{\"142\":1}}],[\"值栈里的对象\",{\"1\":{\"648\":1}}],[\"值为1\",{\"1\":{\"943\":1}}],[\"值为1表示新生代与老年代所占比值为1\",{\"1\":{\"337\":1}}],[\"值为maven程序的地址\",{\"1\":{\"62\":1}}],[\"值的范围值\",{\"1\":{\"246\":1}}],[\"值的对象\",{\"1\":{\"242\":1}}],[\"值以及\",{\"1\":{\"244\":1}}],[\"值作比较\",{\"1\":{\"242\":1}}],[\"值\",{\"1\":{\"239\":1,\"240\":1,\"242\":1,\"244\":1,\"816\":2,\"821\":1,\"1007\":2}}],[\"壁纸网站\",{\"1\":{\"140\":1}}],[\"虎克\",{\"1\":{\"140\":1}}],[\"国际版\",{\"1\":{\"143\":1}}],[\"国内优秀的设计作品展示\",{\"1\":{\"140\":1}}],[\"国外的一家优秀的公共\",{\"1\":{\"135\":1}}],[\"站酷\",{\"1\":{\"140\":1}}],[\"搞定设计\",{\"1\":{\"140\":1}}],[\"免抠元素\",{\"1\":{\"140\":1}}],[\"免费的矢量插画\",{\"1\":{\"139\":1}}],[\"免费的\",{\"1\":{\"139\":1}}],[\"免费的电子书资源网站\",{\"1\":{\"124\":1}}],[\"免费开源可自己搭建网站\",{\"1\":{\"110\":1}}],[\"觅元素一天免费下载十张\",{\"1\":{\"140\":1}}],[\"渐变色生成工具\",{\"1\":{\"140\":1}}],[\"渐变色网站\",{\"1\":{\"139\":1}}],[\"画的\",{\"1\":{\"139\":1}}],[\"矢量图标库\",{\"1\":{\"139\":1}}],[\"阿里\",{\"1\":{\"518\":1}}],[\"阿里开源的java诊断工具\",{\"1\":{\"513\":1}}],[\"阿里巴巴\",{\"1\":{\"235\":1,\"788\":1}}],[\"阿里巴巴矢量图标库\",{\"1\":{\"139\":1}}],[\"阿里云的仓库地址已发生变更\",{\"1\":{\"61\":1}}],[\"阿里云oss\",{\"1\":{\"39\":1}}],[\"北欧性冷淡风主题配色\",{\"1\":{\"139\":1}}],[\"颜色梯度\",{\"1\":{\"139\":1}}],[\"色表\",{\"1\":{\"139\":2}}],[\"帮你百度一下\",{\"1\":{\"143\":1}}],[\"帮你快速用\",{\"1\":{\"139\":1}}],[\"帮你在线配色的网站\",{\"1\":{\"139\":1}}],[\"帮助客\",{\"1\":{\"693\":1}}],[\"帮助\",{\"1\":{\"43\":1}}],[\"制作网站\",{\"1\":{\"139\":3}}],[\"质量还不错\",{\"1\":{\"139\":1}}],[\"质量还不错的短视频教程\",{\"1\":{\"126\":1}}],[\"做到了灵活的替换具体的实现类\",{\"1\":{\"892\":1}}],[\"做定制的二次开发\",{\"1\":{\"883\":1}}],[\"做一个简简单单的消息队列\",{\"1\":{\"776\":1}}],[\"做一些业务逻辑判断等\",{\"1\":{\"648\":1}}],[\"做了什么修改\",{\"1\":{\"465\":1}}],[\"做了哪些努力\",{\"1\":{\"280\":1}}],[\"做出深度优化==\",{\"1\":{\"368\":1}}],[\"做出各种形状的图形\",{\"1\":{\"139\":1}}],[\"做出三角形\",{\"1\":{\"139\":1}}],[\"做出来的\",{\"1\":{\"139\":1}}],[\"做\",{\"1\":{\"139\":1}}],[\"插入时可能存在扩容过程\",{\"1\":{\"231\":1}}],[\"插入和删除元素的话\",{\"1\":{\"229\":2}}],[\"插入和删除是否受元素位置的影响\",{\"1\":{\"229\":1}}],[\"插入排序\",{\"1\":{\"171\":1}}],[\"插画\",{\"1\":{\"139\":3}}],[\"插件可快速生成\",{\"1\":{\"827\":1}}],[\"插件实战\",{\"0\":{\"757\":1}}],[\"插件热部署\",{\"1\":{\"672\":1}}],[\"插件来执行的\",{\"1\":{\"97\":1,\"98\":1}}],[\"插件完成的\",{\"1\":{\"97\":1}}],[\"插件和目标\",{\"0\":{\"96\":1}}],[\"插件\",{\"0\":{\"22\":1,\"53\":1,\"97\":1,\"855\":1},\"1\":{\"615\":1,\"756\":1}}],[\"抠图算法很厉害\",{\"1\":{\"139\":1}}],[\"学习成本低效率高\",{\"1\":{\"875\":1}}],[\"学习笔记\",{\"2\":{\"223\":1,\"236\":1,\"254\":1,\"260\":1}}],[\"学习教程\",{\"1\":{\"140\":1}}],[\"学习正则的小手册\",{\"1\":{\"137\":1}}],[\"学习版在云盘\",{\"1\":{\"112\":1}}],[\"学习版安装包\",{\"1\":{\"49\":1}}],[\"正如从名称中猜到的那样\",{\"1\":{\"733\":1}}],[\"正是由于注释对象的不同\",{\"1\":{\"599\":1}}],[\"正常队列\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"正常队列设置死信\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"正常队列设置死信交换机\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"正常队列绑定死信队列信息\",{\"1\":{\"747\":1,\"748\":1,\"749\":1}}],[\"正常情况下消息生产者发送两个消息\",{\"1\":{\"709\":1}}],[\"正常情况下\",{\"1\":{\"678\":1}}],[\"正常完成出口和异常完成出口的区别\",{\"1\":{\"424\":1}}],[\"正常执行完成\",{\"1\":{\"424\":1}}],[\"正则迷你书\",{\"1\":{\"137\":1}}],[\"正则搜索\",{\"1\":{\"137\":1}}],[\"正则可视化\",{\"1\":{\"137\":1}}],[\"正则\",{\"0\":{\"137\":1}}],[\"正在迭代过程中\",{\"1\":{\"65\":1}}],[\"好产品推荐\",{\"1\":{\"147\":1}}],[\"好用的网站托管服务\",{\"1\":{\"136\":1}}],[\"好处\",{\"0\":{\"90\":1}}],[\"kthtolast\",{\"1\":{\"965\":1}}],[\"kafka\",{\"1\":{\"758\":1}}],[\"kotlin\",{\"1\":{\"591\":1}}],[\"kou\",{\"1\":{\"241\":1}}],[\"kbt\",{\"1\":{\"695\":1,\"697\":1,\"698\":1,\"701\":8,\"708\":6,\"711\":4,\"717\":1,\"722\":3,\"723\":3,\"734\":4,\"738\":3,\"741\":1,\"742\":3,\"747\":9,\"748\":1,\"749\":2,\"753\":2,\"754\":8,\"755\":3,\"757\":3,\"762\":9,\"765\":1,\"768\":3,\"779\":6}}],[\"kb\",{\"1\":{\"335\":1,\"410\":3}}],[\"keep\",{\"1\":{\"879\":1}}],[\"keepalivetime\",{\"1\":{\"275\":1,\"277\":1}}],[\"key存储服务名和类型\",{\"1\":{\"897\":1}}],[\"keyproperty=\",{\"1\":{\"815\":1}}],[\"key2\",{\"1\":{\"762\":2}}],[\"key1\",{\"1\":{\"762\":4,\"768\":1}}],[\"key弱引用并不是导致内存泄漏的原因\",{\"1\":{\"280\":1}}],[\"key\",{\"1\":{\"215\":2,\"230\":3,\"239\":2,\"240\":1,\"241\":1,\"242\":1,\"244\":6,\"258\":1,\"470\":1,\"595\":1,\"693\":2,\"697\":3,\"702\":3,\"729\":1,\"735\":1,\"737\":1,\"738\":1,\"740\":1,\"747\":4,\"748\":4,\"749\":4,\"754\":4,\"755\":2,\"757\":4,\"765\":1,\"815\":1,\"816\":1}}],[\"keybinding\",{\"1\":{\"42\":1}}],[\"keys\",{\"1\":{\"35\":2}}],[\"k+1\",{\"1\":{\"189\":1,\"190\":1,\"943\":2}}],[\"k之前的元素都要加起来才是第一个max的值\",{\"1\":{\"187\":1}}],[\"k\",{\"1\":{\"176\":1,\"186\":4,\"187\":4,\"189\":3,\"190\":3,\"204\":4,\"205\":4,\"242\":1,\"335\":1,\"943\":3,\"965\":2}}],[\"know\",{\"1\":{\"134\":1}}],[\"y最大公约数的倍数\",{\"1\":{\"984\":1}}],[\"y中会有剩余\",{\"1\":{\"982\":1}}],[\"y空\",{\"1\":{\"982\":1}}],[\"y往x中倒水\",{\"1\":{\"982\":1}}],[\"y满\",{\"1\":{\"982\":1}}],[\"y是当前两桶水之和\",{\"1\":{\"982\":1}}],[\"y升\",{\"1\":{\"981\":1}}],[\"yy和是否访问过以外\",{\"1\":{\"935\":1}}],[\"yy\",{\"1\":{\"934\":7,\"935\":1,\"943\":7,\"944\":7}}],[\"yyyy\",{\"1\":{\"573\":1}}],[\"yd\",{\"1\":{\"697\":1,\"754\":3,\"755\":1}}],[\"yexchange\",{\"1\":{\"754\":5}}],[\"yemengying\",{\"1\":{\"614\":1}}],[\"yearmonth\",{\"0\":{\"564\":1}}],[\"year\",{\"0\":{\"563\":1}}],[\"ygc\",{\"1\":{\"490\":1}}],[\"y\",{\"1\":{\"207\":2,\"510\":9,\"697\":1,\"754\":6,\"755\":3,\"943\":1,\"944\":4,\"981\":2,\"982\":5,\"983\":10,\"984\":8}}],[\"younggen\",{\"1\":{\"488\":1}}],[\"young\",{\"1\":{\"304\":1,\"336\":1,\"483\":4,\"493\":1,\"525\":1,\"695\":1,\"701\":3,\"708\":2,\"711\":2,\"717\":1,\"722\":1,\"723\":1,\"734\":2,\"738\":1,\"741\":1,\"742\":1,\"747\":3,\"748\":1,\"749\":2,\"753\":1,\"754\":4,\"755\":2,\"757\":2,\"762\":4,\"765\":1,\"768\":2,\"779\":2}}],[\"youzan\",{\"1\":{\"139\":1}}],[\"you\",{\"1\":{\"134\":1}}],[\"yml<\",{\"1\":{\"99\":1}}],[\"yml\",{\"1\":{\"99\":1,\"668\":1,\"685\":2,\"753\":1}}],[\"花瓣\",{\"1\":{\"140\":1}}],[\"花纹背景\",{\"1\":{\"134\":1}}],[\"花纹背景生成器\",{\"1\":{\"134\":1}}],[\"花裤衩\",{\"1\":{\"118\":1}}],[\"贝塞尔曲线生成器\",{\"1\":{\"134\":1}}],[\"阴影\",{\"1\":{\"134\":1}}],[\"各有什么优劣\",{\"1\":{\"518\":1}}],[\"各自的优缺点\",{\"1\":{\"518\":3}}],[\"各自取长补短\",{\"1\":{\"365\":1}}],[\"各线程之间计数器互不影响\",{\"1\":{\"301\":1}}],[\"各种类型\",{\"1\":{\"148\":1}}],[\"各种炫酷的css动画组件\",{\"1\":{\"134\":1}}],[\"各种css生成器和js代码片段\",{\"1\":{\"134\":1}}],[\"各个名词介绍\",{\"0\":{\"693\":1}}],[\"各个数组并不是分别映射成一个流\",{\"1\":{\"549\":1}}],[\"各个线程被调用的方法中使用到的参数\",{\"1\":{\"519\":1}}],[\"各个环节\",{\"1\":{\"94\":1}}],[\"各个模块工程会在总工程中展示一个列表\",{\"1\":{\"90\":1}}],[\"各个配置有什么用\",{\"1\":{\"69\":1}}],[\"绘制知识图谱\",{\"1\":{\"133\":1}}],[\"原来的验证码失效\",{\"1\":{\"771\":1}}],[\"原来的restart\",{\"1\":{\"670\":1}}],[\"原先配置队列信息\",{\"1\":{\"754\":1}}],[\"原则上如何实现方法区属于虚拟机实现细节\",{\"1\":{\"461\":1}}],[\"原则\",{\"1\":{\"413\":1}}],[\"原理\",{\"1\":{\"608\":1,\"670\":1}}],[\"原理和存在的问题\",{\"1\":{\"292\":1}}],[\"原理不同\",{\"1\":{\"273\":1}}],[\"原因是dubbo的jar包依赖问题很多大型工程无法解决\",{\"1\":{\"798\":1}}],[\"原因\",{\"1\":{\"762\":1,\"765\":3}}],[\"原因有\",{\"1\":{\"462\":1}}],[\"原因二\",{\"1\":{\"288\":1}}],[\"原因一\",{\"1\":{\"288\":1}}],[\"原型\",{\"1\":{\"147\":1}}],[\"原型图等\",{\"1\":{\"133\":1}}],[\"原版github地址\",{\"1\":{\"111\":1}}],[\"又有两个需要增加到\",{\"1\":{\"939\":1}}],[\"又不想增加生产者的复杂性\",{\"1\":{\"767\":1}}],[\"又叫做静态工厂方法\",{\"1\":{\"624\":1}}],[\"又想对他增强的话\",{\"1\":{\"602\":1}}],[\"又称任务队列\",{\"1\":{\"699\":1}}],[\"又称为from\",{\"1\":{\"497\":1}}],[\"又称即时编译\",{\"1\":{\"278\":1}}],[\"又被划分为eden区和survivor区\",{\"1\":{\"483\":2}}],[\"又分为七种情况\",{\"1\":{\"397\":1}}],[\"又一个提供免费图标\",{\"1\":{\"139\":1}}],[\"又一个\",{\"1\":{\"139\":2}}],[\"又一个抠图的\",{\"1\":{\"132\":1}}],[\"又能够将以往的经验沉淀下来\",{\"1\":{\"85\":1}}],[\"铅笔画等\",{\"1\":{\"132\":1}}],[\"神器\",{\"1\":{\"132\":1,\"140\":1}}],[\"转成数组\",{\"1\":{\"954\":1}}],[\"转而执行\",{\"1\":{\"816\":1}}],[\"转而去实例化b\",{\"1\":{\"621\":1}}],[\"转变成\",{\"1\":{\"599\":1}}],[\"转换为红黑树\",{\"1\":{\"252\":1}}],[\"转换为数组\",{\"0\":{\"235\":1}}],[\"转换矢量图\",{\"1\":{\"132\":1}}],[\"转\",{\"1\":{\"132\":1,\"140\":1}}],[\"谷歌出品在线免费图片压缩工具\",{\"1\":{\"132\":1}}],[\"微交互\",{\"1\":{\"142\":1}}],[\"微图\",{\"1\":{\"132\":1}}],[\"微信抢红包方案\",{\"0\":{\"298\":1}}],[\"微信\",{\"0\":{\"2\":1}}],[\"空字符串表示默认或无名称交换机\",{\"1\":{\"729\":1}}],[\"空闲的内存在另外一边\",{\"1\":{\"471\":1}}],[\"空闲列表\",{\"1\":{\"311\":1}}],[\"空位都以0补齐\",{\"1\":{\"244\":1}}],[\"空格分隔\",{\"1\":{\"619\":1}}],[\"空格\",{\"1\":{\"131\":1}}],[\"空间整合\",{\"1\":{\"535\":1}}],[\"空间开销\",{\"1\":{\"524\":1}}],[\"空间使用率高\",{\"1\":{\"523\":1}}],[\"空间碎片\",{\"1\":{\"521\":1}}],[\"空间和\",{\"1\":{\"488\":1}}],[\"空间复杂度为1\",{\"1\":{\"199\":1}}],[\"空间复杂度\",{\"1\":{\"194\":1,\"948\":1,\"949\":1,\"957\":1,\"968\":1,\"969\":1,\"1029\":1,\"1030\":1}}],[\"空间\",{\"1\":{\"80\":2,\"186\":1,\"189\":1,\"190\":1,\"488\":1,\"931\":1,\"1040\":1}}],[\"驱动的评论系统\",{\"1\":{\"128\":1}}],[\"由备份交换机来进行转发和处理\",{\"1\":{\"767\":1}}],[\"由spring框架来处理\",{\"1\":{\"650\":1}}],[\"由spring提供\",{\"1\":{\"609\":1}}],[\"由jsr\",{\"1\":{\"609\":2}}],[\"由jvm直接提供\",{\"1\":{\"435\":1}}],[\"由eden区\",{\"1\":{\"496\":1}}],[\"由字节码中是否跟随有\",{\"1\":{\"474\":1}}],[\"由执行引擎读取下一条指令\",{\"1\":{\"399\":1}}],[\"由其他文件生成\",{\"1\":{\"378\":1}}],[\"由c1编译器和c2编译器相互协作共同来执行编译任务\",{\"1\":{\"372\":1}}],[\"由comparator控制排序逻辑\",{\"1\":{\"257\":1}}],[\"由调用线程\",{\"1\":{\"275\":1}}],[\"由数组+链表组成的\",{\"1\":{\"222\":1}}],[\"由题目给出的信息我们可以知道\",{\"1\":{\"1029\":1}}],[\"由题目可得出\",{\"1\":{\"198\":1}}],[\"由题意可易得\",{\"1\":{\"201\":1,\"202\":1}}],[\"由于使用递归\",{\"1\":{\"969\":1}}],[\"由于使用的是jwt\",{\"1\":{\"788\":1}}],[\"由于公司之前有组织培训及考试\",{\"1\":{\"942\":1}}],[\"由于我们的参数超过了两个\",{\"1\":{\"819\":1}}],[\"由于mybatis专注于sql本身\",{\"1\":{\"806\":1}}],[\"由于之前写过\",{\"1\":{\"768\":1}}],[\"由于只需要重新读取被修改的类\",{\"1\":{\"670\":1}}],[\"由于应用于模型的代码只需写一次就可以被多个视图重用\",{\"1\":{\"645\":1}}],[\"由于项目的需要\",{\"1\":{\"628\":1}}],[\"由于把实例化和初始化的流程分开了\",{\"1\":{\"621\":1}}],[\"由于在垃圾回收过程中\",{\"1\":{\"526\":1}}],[\"由于其不变类的特性\",{\"1\":{\"525\":1}}],[\"由于存活对象较多\",{\"1\":{\"523\":1}}],[\"由于对象实例的创建在jvm中非常频繁\",{\"1\":{\"501\":1}}],[\"由于类的元数据分配在本地内存中\",{\"1\":{\"462\":1}}],[\"由于明确了被调用的目标方法究竟是哪一个\",{\"1\":{\"420\":1}}],[\"由于这种引用转换过程具备动态性\",{\"1\":{\"419\":1}}],[\"由于这种编译方式发生在方法的执行过程中\",{\"1\":{\"368\":1}}],[\"由于局部变量表是建立在线程的栈上\",{\"1\":{\"415\":1}}],[\"由于跨平台性的设计\",{\"1\":{\"405\":1}}],[\"由于cpu时间片轮限制\",{\"1\":{\"402\":1}}],[\"由于解释器在设计和实现上非常简单\",{\"1\":{\"363\":1}}],[\"由于垃圾回收器是一个优先级很低的线程\",{\"1\":{\"327\":1}}],[\"由于现在收集器基本都采用分代垃圾收集算法\",{\"1\":{\"304\":1}}],[\"由于所有类都继承于object\",{\"1\":{\"288\":1}}],[\"由于sleep不会释放锁标志\",{\"1\":{\"273\":1}}],[\"由于sleep\",{\"1\":{\"273\":1}}],[\"由于下标是从0开始\",{\"1\":{\"201\":1}}],[\"由于dp\",{\"1\":{\"200\":1}}],[\"由于刚入门时使用的是eclipse\",{\"1\":{\"6\":1}}],[\"由\",{\"1\":{\"128\":1,\"331\":1,\"383\":1,\"384\":1}}],[\"评论系统\",{\"0\":{\"128\":1}}],[\"展示一个项目\",{\"1\":{\"127\":1}}],[\"展示类的uml图\",{\"1\":{\"22\":1}}],[\"徽章图标\",{\"1\":{\"127\":1}}],[\"心理学等专业免费课程\",{\"1\":{\"126\":1}}],[\"涵盖计算机\",{\"1\":{\"126\":1}}],[\"涵盖多种语言的初级教程\",{\"1\":{\"119\":1}}],[\"比原字符串长度更长\",{\"1\":{\"953\":1}}],[\"比方说我们想接收的日志类型有\",{\"1\":{\"740\":1}}],[\"比方说\",{\"1\":{\"717\":1}}],[\"比方说有两个消费者在处理任务\",{\"1\":{\"714\":1}}],[\"比我们晚8小时\",{\"1\":{\"557\":1}}],[\"比\",{\"0\":{\"286\":1},\"1\":{\"894\":1}}],[\"比较ans和curlen\",{\"1\":{\"930\":1,\"1039\":1}}],[\"比较麻烦\",{\"1\":{\"894\":1}}],[\"比较关键的一些方面包括\",{\"1\":{\"873\":1}}],[\"比较少见\",{\"1\":{\"378\":1}}],[\"比较的是两个引用是否指向同一个对象地址\",{\"1\":{\"242\":1}}],[\"比较的是值是否相等\",{\"1\":{\"242\":1}}],[\"比较系统的前端入门视频教程\",{\"1\":{\"126\":1}}],[\"比格\",{\"1\":{\"148\":1}}],[\"比如新增记录\",{\"1\":{\"917\":1}}],[\"比如上面的流程你要插入\",{\"1\":{\"890\":1}}],[\"比如上文所说到过的程序计数器\",{\"1\":{\"267\":1}}],[\"比如谷歌的protobuf序列化框架\",{\"1\":{\"877\":1}}],[\"比如一般选择netty作为网络通信框架\",{\"1\":{\"877\":1}}],[\"比如一个线程获得了某个对象的锁\",{\"1\":{\"271\":1,\"284\":1}}],[\"比如调用\",{\"1\":{\"821\":1}}],[\"比如调用了\",{\"1\":{\"267\":1}}],[\"比如$\",{\"1\":{\"810\":1}}],[\"比如消费者下线\",{\"1\":{\"782\":1}}],[\"比如像苹果\",{\"1\":{\"776\":1}}],[\"比如利用\",{\"1\":{\"758\":1}}],[\"比如说下面这张图告诉我们的就是\",{\"1\":{\"731\":1}}],[\"比如说用\",{\"1\":{\"724\":1}}],[\"比如说\",{\"1\":{\"706\":1,\"740\":1}}],[\"比如说将时间调整到下个周的周日\",{\"1\":{\"569\":1}}],[\"比如第三方jar包等\",{\"1\":{\"670\":1}}],[\"比如菜单导航\",{\"1\":{\"656\":1}}],[\"比如身份认证\",{\"1\":{\"656\":1}}],[\"比如struts在struts\",{\"1\":{\"648\":1}}],[\"比如由html元素组成的网页界面\",{\"1\":{\"645\":1}}],[\"比如同一个事务\",{\"1\":{\"634\":1}}],[\"比如jdkdynamicaopproxy和cglib2aopproxy\",{\"1\":{\"629\":1}}],[\"比如apache\",{\"1\":{\"628\":1}}],[\"比如不同的数据库\",{\"1\":{\"628\":1}}],[\"比如当我们引用第三方库中的类需要装配到\",{\"1\":{\"617\":1}}],[\"比如这个\",{\"1\":{\"612\":1}}],[\"比如你依赖了第三方的类库\",{\"1\":{\"602\":1}}],[\"比如某个实际\",{\"1\":{\"462\":1}}],[\"比如通过java程序驱动打印机或者java系统管理生产设备\",{\"1\":{\"436\":1}}],[\"比如在c++中\",{\"1\":{\"434\":1}}],[\"比如c\",{\"1\":{\"434\":1}}],[\"比如collections\",{\"1\":{\"230\":1}}],[\"比如invokedynamic指令\",{\"1\":{\"417\":1}}],[\"比如我们编写一个称为\",{\"1\":{\"333\":1}}],[\"比如我们需要根据键值获取到元素值时就选用\",{\"1\":{\"216\":1}}],[\"比如可以使用zookeeper来注册服务等等\",{\"1\":{\"877\":1}}],[\"比如可以使用socket通信\",{\"1\":{\"436\":1}}],[\"比如可以实现多路通知功能也就是在一个lock对象中可以创建多个condition实例\",{\"1\":{\"286\":1}}],[\"比如可以先将线程池大小设置为参考值\",{\"1\":{\"277\":1}}],[\"比如100个循环\",{\"1\":{\"278\":1}}],[\"比如请求\",{\"1\":{\"267\":1}}],[\"比如大于等于给定值的第一个元素\",{\"1\":{\"172\":1}}],[\"比如xp系统蓝屏\",{\"1\":{\"143\":1}}],[\"比如\",{\"1\":{\"6\":1,\"80\":3,\"85\":1,\"229\":1,\"363\":1,\"397\":1,\"416\":1,\"417\":1,\"488\":1,\"519\":3,\"525\":2,\"582\":1,\"591\":1,\"634\":1,\"751\":1,\"810\":1,\"953\":1}}],[\"妙味课堂\",{\"1\":{\"126\":1}}],[\"慕课网\",{\"1\":{\"126\":1}}],[\"视频在线解析下载\",{\"1\":{\"148\":1}}],[\"视频\",{\"0\":{\"126\":1}}],[\"视图解析器viewresolver\",{\"1\":{\"646\":1}}],[\"视图解析器\",{\"1\":{\"644\":1}}],[\"视图解析器向前端控制器返回视图对象view\",{\"1\":{\"642\":1}}],[\"视图渲染将模型数据\",{\"1\":{\"642\":1}}],[\"视图\",{\"0\":{\"48\":1},\"1\":{\"43\":1,\"645\":1,\"646\":1}}],[\"作为服务器时默认实现\",{\"1\":{\"888\":1}}],[\"作为单个参数传递给mapper\",{\"1\":{\"819\":1}}],[\"作为一个半orm框架\",{\"1\":{\"806\":1}}],[\"作为轻量级的\",{\"1\":{\"693\":1}}],[\"作为方法区这个类的各种数据的访问入口\",{\"1\":{\"377\":1}}],[\"作为编译器的\",{\"1\":{\"365\":1}}],[\"作为父类加载器\",{\"1\":{\"332\":1}}],[\"作为threadlocalmap的key\",{\"1\":{\"280\":1}}],[\"作为值可以有多个\",{\"1\":{\"239\":1}}],[\"作为键只能有一个\",{\"1\":{\"239\":1}}],[\"作者对系统架构的方法论总结\",{\"1\":{\"125\":1}}],[\"作用域\",{\"1\":{\"619\":1}}],[\"作用是给日期加上指定的年月日\",{\"1\":{\"559\":1}}],[\"作用是主管java程序的运行\",{\"1\":{\"407\":1}}],[\"作用是\",{\"1\":{\"85\":1}}],[\"作用\",{\"0\":{\"85\":1},\"1\":{\"94\":1,\"106\":1,\"399\":1}}],[\"我好自己处理啊\",{\"1\":{\"764\":1}}],[\"我是可乐\",{\"1\":{\"754\":1}}],[\"我做系统架构的一些原则\",{\"1\":{\"125\":1}}],[\"我们很容易想到stack\",{\"1\":{\"1024\":1}}],[\"我们应该先遍历完左右孩子再进行根节点的打印\",{\"1\":{\"1024\":1}}],[\"我们应该是用一个容器来保存\",{\"1\":{\"217\":1}}],[\"我们一开始准备打印a的左孩子b\",{\"1\":{\"1024\":1}}],[\"我们一般使用\",{\"1\":{\"618\":1}}],[\"我们一般说\",{\"1\":{\"591\":1}}],[\"我们又需要做一次\",{\"1\":{\"1019\":1}}],[\"我们强烈建议静态导入这些\",{\"1\":{\"997\":1}}],[\"我们看看reverselist\",{\"1\":{\"970\":1}}],[\"我们先打印a\",{\"1\":{\"1024\":1}}],[\"我们先打印根节点\",{\"1\":{\"1024\":1}}],[\"我们先定义3个指针\",{\"1\":{\"970\":1}}],[\"我们先看最小的数\",{\"1\":{\"939\":1}}],[\"我们只需遍历一遍字符串即可\",{\"1\":{\"957\":1}}],[\"我们只需要把数据操作放入事务中即可\",{\"1\":{\"771\":1}}],[\"我们只需要考虑第\",{\"1\":{\"207\":1}}],[\"我们可能需要动态设置要查的表名\",{\"1\":{\"861\":1}}],[\"我们可以把某个节点及其左右孩子向下遍历的路径拼接起来得到结果\",{\"1\":{\"1023\":1}}],[\"我们可以把变化的东西抽出来作为一个参数传入jdbctemplate的方法中\",{\"1\":{\"632\":1}}],[\"我们可以利用telnet命令进行调试\",{\"1\":{\"912\":1}}],[\"我们可以使用递归函数help\",{\"1\":{\"1029\":1}}],[\"我们可以使用带condition参数的重载方法构建查询条件\",{\"1\":{\"852\":1}}],[\"我们可以使用\",{\"1\":{\"617\":1}}],[\"我们可以通过with方法修改日期时间对象中封装的数据\",{\"1\":{\"569\":1}}],[\"我们可以看到\",{\"1\":{\"524\":1,\"736\":1}}],[\"我们可以得知\",{\"1\":{\"203\":1}}],[\"我们可以给其创建书签\",{\"1\":{\"11\":1}}],[\"我们通常会采用分库分表\",{\"1\":{\"861\":1}}],[\"我们这里不需要csrf\",{\"1\":{\"788\":1}}],[\"我们使用自定义注解\",{\"1\":{\"788\":1}}],[\"我们使用继承这个机制\",{\"1\":{\"85\":1}}],[\"我们还可以建立一个报警队列\",{\"1\":{\"767\":1}}],[\"我们提到\",{\"1\":{\"767\":1}}],[\"我们开始思考\",{\"1\":{\"759\":1}}],[\"我们在这里定义的是一个延迟交换机\",{\"1\":{\"757\":1}}],[\"我们在开发过程中\",{\"1\":{\"68\":1}}],[\"我们来看看他们之间数据接收情况是怎么样的\",{\"1\":{\"741\":1}}],[\"我们没有使用只能进行随意广播的\",{\"1\":{\"740\":1}}],[\"我们改进了日志记录系统\",{\"1\":{\"740\":1}}],[\"我们再次来回顾一下什么是\",{\"1\":{\"735\":1}}],[\"我们能够向许多接收者广播日志消息\",{\"1\":{\"735\":1}}],[\"我们能不能在spring的框架下通过少量修改得到解决\",{\"1\":{\"628\":1}}],[\"我们构建了一个简单的日志记录系统\",{\"1\":{\"735\":1}}],[\"我们将构建一个简单的日志系统\",{\"1\":{\"734\":1}}],[\"我们将丢失正在处理的消息\",{\"1\":{\"704\":1}}],[\"我们必须将整个批处理保存在内存中\",{\"1\":{\"723\":1}}],[\"我们把任务封装为消息并将其发送到队列\",{\"1\":{\"699\":1}}],[\"我们常用的\",{\"1\":{\"638\":1}}],[\"我们去实现这个方法\",{\"1\":{\"632\":1}}],[\"我们以往在spring和hibernate框架中总是配置一个数据源\",{\"1\":{\"628\":1}}],[\"我们自己定义的各个\",{\"1\":{\"612\":1}}],[\"我们自己考虑这些规则会很麻烦\",{\"1\":{\"90\":1}}],[\"我们就可以发现spring中存在的配置错误\",{\"1\":{\"611\":1}}],[\"我们就不能发现一些存在的spring的配置问题\",{\"1\":{\"611\":1}}],[\"我们就说这个流已经被消费掉了\",{\"1\":{\"544\":1}}],[\"我们不要用设值的方法注入\",{\"1\":{\"600\":1}}],[\"我们需要把下界\",{\"1\":{\"1029\":1}}],[\"我们需要把上界\",{\"1\":{\"1029\":1}}],[\"我们需要能够知道上一个最近访问的节点是哪个\",{\"1\":{\"1024\":1}}],[\"我们需要指定我们的消费者去消费哪个队列的消息\",{\"1\":{\"730\":1}}],[\"我们需要将队列和消息都标记为持久化\",{\"1\":{\"710\":1}}],[\"我们需要增加新功能时也方便\",{\"1\":{\"596\":1}}],[\"我们需要给新对象分配内存时\",{\"1\":{\"523\":1}}],[\"我们说\",{\"1\":{\"495\":1}}],[\"我们说java虚拟机的解释引擎是基于栈的执行引擎\",{\"1\":{\"416\":1}}],[\"我们也要使用本地方法\",{\"1\":{\"435\":1}}],[\"我们得用java实现了jre的与底层系统的交互\",{\"1\":{\"435\":1}}],[\"我们要尽量避免通过\",{\"1\":{\"318\":1}}],[\"我们的客户在天猫下的订单\",{\"1\":{\"776\":1}}],[\"我们的一些规则或者时间戳加别的服务给到的唯一信息码\",{\"1\":{\"774\":1}}],[\"我们的dao在访问sessionfactory的时候都不得不在多个数据源中不断切换\",{\"1\":{\"628\":1}}],[\"我们的项目需要连接多个数据库\",{\"1\":{\"628\":1}}],[\"我们的\",{\"1\":{\"315\":1}}],[\"我们称这类内存区域为\",{\"1\":{\"301\":1}}],[\"我们完全可以把wait方法定义在object类中\",{\"1\":{\"288\":1}}],[\"我们知道bean的生命周期\",{\"1\":{\"621\":1}}],[\"我们知道普通的对象会被分配在tlab上\",{\"1\":{\"512\":1}}],[\"我们知道\",{\"1\":{\"259\":1}}],[\"我们假设\",{\"1\":{\"253\":1}}],[\"我们首先可能会想到采用\",{\"1\":{\"246\":1}}],[\"我们上面也讲到了过了\",{\"1\":{\"246\":1}}],[\"我们是通过传入匿名内部类的方式实现的\",{\"1\":{\"241\":1}}],[\"我们都需要一个全新的空队列\",{\"1\":{\"730\":1}}],[\"我们都需要找到之前元素中的最小值\",{\"1\":{\"202\":1}}],[\"我们都知道\",{\"1\":{\"685\":1}}],[\"我们都能看到使用randomaccess的例子\",{\"1\":{\"230\":1}}],[\"我们有\",{\"1\":{\"207\":1}}],[\"优缺点\",{\"1\":{\"518\":1}}],[\"优点就是简单\",{\"1\":{\"872\":1}}],[\"优点\",{\"1\":{\"479\":2,\"522\":1,\"523\":1,\"530\":1,\"534\":1,\"665\":1,\"807\":1}}],[\"优点是跨平台\",{\"1\":{\"405\":1}}],[\"优点是提高了响应速度\",{\"1\":{\"290\":1}}],[\"优势就是实现简单就一个拼接\",{\"1\":{\"774\":1}}],[\"优势\",{\"0\":{\"393\":1},\"1\":{\"352\":1}}],[\"优化后代码如下\",{\"1\":{\"203\":1}}],[\"优化\",{\"1\":{\"200\":1}}],[\"优先获取\",{\"1\":{\"778\":1}}],[\"优先级最高\",{\"1\":{\"779\":1}}],[\"优先级为\",{\"1\":{\"777\":1}}],[\"优先级\",{\"0\":{\"769\":1},\"1\":{\"697\":1,\"779\":2}}],[\"优先级队列\",{\"0\":{\"775\":1},\"1\":{\"176\":1}}],[\"优先选择回收价值最大的\",{\"1\":{\"535\":1}}],[\"优先分配到eden\",{\"1\":{\"498\":1}}],[\"优先队列\",{\"2\":{\"195\":1}}],[\"优先队列需要o\",{\"1\":{\"194\":1}}],[\"优先队列专题\",{\"0\":{\"192\":1}}],[\"优品\",{\"1\":{\"148\":1}}],[\"优秀文章\",{\"0\":{\"125\":1}}],[\"优质利器\",{\"1\":{\"120\":1}}],[\"高级消息发布\",{\"1\":{\"762\":1}}],[\"高级确认发布\",{\"1\":{\"762\":1,\"768\":1}}],[\"高级发布确认\",{\"0\":{\"759\":1},\"1\":{\"762\":1}}],[\"高级设置\",{\"1\":{\"37\":1}}],[\"高频面试题\",{\"1\":{\"621\":1}}],[\"高效率的利用\",{\"1\":{\"532\":1}}],[\"高清免费图片\",{\"1\":{\"148\":2}}],[\"高等教育出版社的书籍\",{\"1\":{\"124\":1}}],[\"高教书苑\",{\"1\":{\"124\":1}}],[\"博客\",{\"0\":{\"123\":1}}],[\"博客常用资源\",{\"0\":{\"52\":1}}],[\"趋势\",{\"1\":{\"122\":1}}],[\"技术\",{\"1\":{\"879\":1}}],[\"技术实现off\",{\"1\":{\"505\":1}}],[\"技术胖\",{\"1\":{\"118\":1}}],[\"技巧\",{\"0\":{\"122\":1}}],[\"兔小巢\",{\"1\":{\"121\":1}}],[\"码力全开资源库\",{\"1\":{\"120\":1}}],[\"鱼塘热榜\",{\"1\":{\"120\":1}}],[\"创造师导航\",{\"1\":{\"139\":1}}],[\"创意工作者们的社区\",{\"1\":{\"120\":1}}],[\"创建目标对象的代理对象\",{\"1\":{\"821\":1}}],[\"创建statement等繁杂的过程\",{\"1\":{\"806\":1}}],[\"创建两个队列\",{\"1\":{\"754\":1}}],[\"创建两个工作队列\",{\"1\":{\"701\":1}}],[\"创建出队列\",{\"1\":{\"747\":1}}],[\"创建多个\",{\"1\":{\"738\":1}}],[\"创建绑定我们用代码\",{\"1\":{\"735\":1}}],[\"创建临时队列的方式如下\",{\"1\":{\"730\":1}}],[\"创建好一个工作队列\",{\"1\":{\"701\":1}}],[\"创建信道\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"创建连接\",{\"1\":{\"697\":1,\"698\":1,\"701\":1,\"806\":1}}],[\"创建连接工厂\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"创建单独的\",{\"1\":{\"693\":1}}],[\"创建\",{\"1\":{\"693\":1,\"697\":3,\"753\":1}}],[\"创建并配置当前spring\",{\"1\":{\"678\":1}}],[\"创建对象a\",{\"1\":{\"621\":1}}],[\"创建对象是非常频繁的操作\",{\"1\":{\"471\":1}}],[\"创建对象的步骤\",{\"0\":{\"469\":1}}],[\"创建对象的方式\",{\"0\":{\"468\":1}}],[\"创建的对象存放在堆中\",{\"1\":{\"439\":1}}],[\"创建类的实例\",{\"1\":{\"397\":1}}],[\"创建了几个对象\",{\"0\":{\"319\":1}}],[\"创建了很多个\",{\"1\":{\"85\":1}}],[\"创建一个死信队列\",{\"1\":{\"754\":1}}],[\"创建一个生产者\",{\"1\":{\"701\":1}}],[\"创建一个类作为消费者\",{\"1\":{\"698\":1}}],[\"创建一个类作为生产者\",{\"1\":{\"697\":1}}],[\"创建一个\",{\"1\":{\"614\":1,\"753\":1}}],[\"创建一个bean对象\",{\"1\":{\"614\":1}}],[\"创建一个初始类\",{\"1\":{\"345\":1}}],[\"创建一个可缓存线程池\",{\"1\":{\"291\":1}}],[\"创建一个可扩容的线程池\",{\"1\":{\"291\":1}}],[\"创建一个单线程化的线程池\",{\"1\":{\"291\":1}}],[\"创建一个只有1个线程的\",{\"1\":{\"291\":1}}],[\"创建一个定长线程池\",{\"1\":{\"291\":1}}],[\"创建一个拥有\",{\"1\":{\"291\":1}}],[\"创建时如果给定了容量初始值\",{\"1\":{\"239\":1}}],[\"创建时如果不指定容量初始值\",{\"1\":{\"239\":1}}],[\"创建2个优先队列\",{\"1\":{\"194\":1}}],[\"创建web工程\",{\"0\":{\"78\":1}}],[\"创建quick\",{\"0\":{\"13\":1}}],[\"促进软件开发及相关领域知识与创新的传播\",{\"1\":{\"120\":1}}],[\"外部for执行完毕后\",{\"1\":{\"925\":1}}],[\"外文\",{\"1\":{\"515\":1}}],[\"外层orders的循环中\",{\"1\":{\"194\":1}}],[\"外网\",{\"1\":{\"126\":1}}],[\"外网的\",{\"1\":{\"120\":1}}],[\"外语\",{\"1\":{\"126\":1}}],[\"外观\",{\"0\":{\"38\":1}}],[\"同理递归调用右子树时\",{\"1\":{\"1029\":1}}],[\"同于普通\",{\"1\":{\"827\":1}}],[\"同样创建对象b\",{\"1\":{\"621\":1}}],[\"同域信息一样包括声明顺序\",{\"1\":{\"454\":1}}],[\"同步遍历\",{\"1\":{\"1019\":1}}],[\"同步移动\",{\"1\":{\"1019\":1}}],[\"同步\",{\"1\":{\"888\":1}}],[\"同步传输\",{\"1\":{\"888\":2}}],[\"同步转异步\",{\"1\":{\"883\":1,\"885\":1}}],[\"同步等待确认\",{\"1\":{\"724\":1}}],[\"同步的后果是降低并发性和性能\",{\"1\":{\"509\":1}}],[\"同步省略\",{\"0\":{\"509\":1},\"1\":{\"507\":1}}],[\"同步消除\",{\"1\":{\"372\":1}}],[\"同步方法是由方法调用指令读取运行时常量池中方法的\",{\"1\":{\"278\":1}}],[\"同步代码块是显式同步\",{\"1\":{\"278\":1}}],[\"同步控制\",{\"0\":{\"259\":1},\"1\":{\"256\":1}}],[\"同一个应用程序既可以是生产者又是可以是消费者\",{\"1\":{\"692\":1}}],[\"同一个记录的数据内容被修改了\",{\"1\":{\"634\":1}}],[\"同一个全局http\",{\"1\":{\"615\":1}}],[\"同一个线程每次获取锁\",{\"1\":{\"271\":1,\"284\":1}}],[\"同一时间段\",{\"1\":{\"268\":1}}],[\"同一把锁\",{\"1\":{\"249\":1}}],[\"同时使用反射给对象的属性逐一赋值并返回\",{\"1\":{\"808\":1}}],[\"同时使用http协议一般会使用json报文\",{\"1\":{\"798\":1}}],[\"同时会给数据库带来很大压力\",{\"1\":{\"751\":1}}],[\"同时仍然能够在控制台上打印所有日志消息\",{\"1\":{\"735\":1}}],[\"同时还可以进行逻辑判断\",{\"1\":{\"648\":1}}],[\"同时还能够提升内存分配的吞吐量\",{\"1\":{\"500\":1}}],[\"同时把a放入一级缓存\",{\"1\":{\"621\":1}}],[\"同时删除三级缓存中的a\",{\"1\":{\"621\":1}}],[\"同时开启\",{\"1\":{\"534\":1,\"764\":1}}],[\"同时工作\",{\"1\":{\"534\":1}}],[\"同时作为计算过程中变量临时的存储空间\",{\"1\":{\"416\":1}}],[\"同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证\",{\"1\":{\"416\":1}}],[\"同时在\",{\"1\":{\"343\":1}}],[\"同时也更易于阅读\",{\"1\":{\"318\":1}}],[\"同时也会与其他加入的对象的\",{\"1\":{\"242\":1}}],[\"同时只能有5个人能够占用\",{\"1\":{\"292\":1}}],[\"同时通过对链表进行相应的操作\",{\"1\":{\"222\":1}}],[\"同时\",{\"1\":{\"206\":1,\"217\":1,\"365\":1,\"534\":1}}],[\"同时减轻服务器的负担\",{\"1\":{\"80\":1}}],[\"同帮我百度一下\",{\"1\":{\"143\":1}}],[\"同上面相比只会应答\",{\"1\":{\"706\":1}}],[\"同上\",{\"1\":{\"120\":1,\"122\":1,\"142\":1}}],[\"思路没啥可说的\",{\"1\":{\"935\":1}}],[\"思路\",{\"0\":{\"930\":1,\"935\":1,\"940\":1,\"955\":1,\"964\":1,\"970\":1,\"974\":1,\"985\":1,\"1019\":1,\"1023\":1,\"1031\":1,\"1036\":1,\"1039\":1},\"1\":{\"957\":1}}],[\"思路2\",{\"0\":{\"927\":1}}],[\"思路1\",{\"0\":{\"926\":1}}],[\"思维导图\",{\"0\":{\"133\":1},\"1\":{\"133\":2}}],[\"思维导图工具\",{\"1\":{\"112\":1}}],[\"思否\",{\"1\":{\"120\":1}}],[\"掘金\",{\"1\":{\"120\":1}}],[\"社区互动\",{\"0\":{\"121\":1}}],[\"社区\",{\"0\":{\"120\":1}}],[\"腾讯云开发者手册\",{\"1\":{\"119\":1}}],[\"腾讯云等\",{\"1\":{\"61\":1}}],[\"菜鸟教程\",{\"1\":{\"119\":1}}],[\"菜单栏\",{\"0\":{\"43\":1}}],[\"菜单\",{\"1\":{\"41\":1,\"702\":2,\"777\":1}}],[\"阮一峰编写\",{\"1\":{\"119\":1}}],[\"阮一峰的网络日志\",{\"1\":{\"123\":1}}],[\"阮一峰的es6教程\",{\"1\":{\"119\":1}}],[\"阮一峰的js教程\",{\"1\":{\"119\":1}}],[\"脚本教程\",{\"1\":{\"119\":1}}],[\"脚本文件\",{\"1\":{\"99\":1}}],[\"程序猿dd\",{\"1\":{\"660\":1}}],[\"程序继续执行\",{\"1\":{\"535\":1}}],[\"程序运行的过程中\",{\"1\":{\"525\":1}}],[\"程序运行起来\",{\"1\":{\"355\":1}}],[\"程序又需要创建对象\",{\"1\":{\"490\":1}}],[\"程序试图访问或修改一个属性或调用一个方法\",{\"1\":{\"422\":1}}],[\"程序对类的使用方式分为\",{\"1\":{\"397\":1}}],[\"程序解释执行\",{\"1\":{\"372\":1}}],[\"程序一较高下的地步\",{\"1\":{\"365\":1}}],[\"程序实现跨平台特性\",{\"1\":{\"360\":1}}],[\"程序异常或错误而异常终止\",{\"1\":{\"347\":1}}],[\"程序正常执行结束\",{\"1\":{\"347\":1}}],[\"程序结束时他就停止\",{\"1\":{\"346\":1}}],[\"程序开始执行时他才运行\",{\"1\":{\"346\":1}}],[\"程序的视角看来\",{\"1\":{\"474\":1}}],[\"程序的视角来看\",{\"1\":{\"314\":1}}],[\"程序的运行性能早己脱胎换骨\",{\"1\":{\"365\":1}}],[\"程序的稳定运行\",{\"1\":{\"333\":1}}],[\"程序如果发现某个虚引用已经被加入到引用队列\",{\"1\":{\"328\":1}}],[\"程序可以通过判断引用队列中是否已经加入了虚引用\",{\"1\":{\"328\":1}}],[\"程序通过栈上的\",{\"1\":{\"315\":1}}],[\"程序能访问到这些字段的数据类型所对应的零值\",{\"1\":{\"312\":1,\"472\":1}}],[\"程序计数器在各个线程之间互不影响\",{\"1\":{\"402\":1}}],[\"程序计数器会存储当前线程正在执行的java方法的jvm指令地址\",{\"1\":{\"399\":1}}],[\"程序计数器是唯一一个不会出现\",{\"1\":{\"301\":1}}],[\"程序计数器是一块较小的内存空间\",{\"1\":{\"301\":1}}],[\"程序计数器\",{\"0\":{\"301\":1,\"398\":1},\"1\":{\"300\":1}}],[\"程序员泥瓦匠\",{\"1\":{\"660\":1}}],[\"程序员所调侃\",{\"1\":{\"363\":1}}],[\"程序员同性交友社区\",{\"1\":{\"120\":1}}],[\"程序员鱼皮\",{\"1\":{\"118\":1}}],[\"程序羊\",{\"1\":{\"118\":1}}],[\"侵删\",{\"1\":{\"117\":1,\"155\":1,\"213\":1,\"870\":1}}],[\"侵权可以联系我\",{\"1\":{\"1\":1}}],[\"网络的传输毕竟都是二进制流传输的\",{\"1\":{\"919\":1}}],[\"网络通信框架\",{\"1\":{\"885\":1}}],[\"网络传输层\",{\"1\":{\"883\":1}}],[\"网络id或名称\",{\"1\":{\"577\":1}}],[\"网络获取一个对象的二进制流\",{\"1\":{\"468\":1}}],[\"网络安全学习网站\",{\"1\":{\"146\":1}}],[\"网站\",{\"1\":{\"139\":1},\"2\":{\"154\":1}}],[\"网站托管\",{\"0\":{\"136\":1}}],[\"网站资源\",{\"0\":{\"117\":1}}],[\"网页版地址\",{\"1\":{\"110\":1}}],[\"zs\",{\"1\":{\"993\":1}}],[\"zset\",{\"1\":{\"758\":1}}],[\"z\",{\"1\":{\"981\":2,\"982\":4,\"983\":4,\"984\":5}}],[\"z升\",{\"1\":{\"981\":2}}],[\"zaxxer\",{\"1\":{\"831\":1}}],[\"zookeeper注册中心\",{\"1\":{\"897\":1}}],[\"zookeeper\",{\"1\":{\"800\":1,\"878\":1}}],[\"zoneddatetime\",{\"1\":{\"562\":2,\"571\":3}}],[\"zoneid\",{\"1\":{\"562\":5,\"571\":1}}],[\"zoneid对象可以通过zoneid\",{\"1\":{\"555\":1}}],[\"zoneid替代原有的java\",{\"1\":{\"555\":1}}],[\"zrtqsk\",{\"1\":{\"614\":1}}],[\"zgc\",{\"0\":{\"536\":1},\"1\":{\"464\":1,\"536\":3}}],[\"zetcode\",{\"1\":{\"146\":1}}],[\"zetasp\",{\"1\":{\"111\":1}}],[\"zero\",{\"1\":{\"143\":1}}],[\"zen\",{\"0\":{\"112\":1}}],[\"zhangsan\",{\"1\":{\"747\":2,\"748\":2,\"749\":1,\"996\":2}}],[\"zhihu\",{\"1\":{\"293\":1,\"595\":1}}],[\"zh\",{\"1\":{\"110\":1}}],[\"zip复制到该目录下\",{\"1\":{\"1006\":1}}],[\"zip<\",{\"1\":{\"99\":1}}],[\"zip下载\",{\"1\":{\"60\":1}}],[\"zip\",{\"1\":{\"38\":1,\"49\":1,\"99\":4,\"378\":1,\"1006\":2}}],[\"之间是或的关系\",{\"1\":{\"1019\":1}}],[\"之间是完全隔离的\",{\"1\":{\"693\":1}}],[\"之间的桥梁\",{\"1\":{\"731\":1}}],[\"之间的虚拟连接\",{\"1\":{\"693\":1}}],[\"之间的\",{\"1\":{\"693\":1}}],[\"之间取最大值\",{\"1\":{\"207\":1}}],[\"之后我们准备打印b的右孩子就是e\",{\"1\":{\"1024\":1}}],[\"之后我们以b为根节点再进行一次跟左右遍历\",{\"1\":{\"1024\":1}}],[\"之后我们可以把一些通用功能抽象出来\",{\"1\":{\"596\":1}}],[\"之后先移动fast\",{\"1\":{\"964\":1}}],[\"之后使用slow\",{\"1\":{\"964\":1}}],[\"之后进入下一个循环\",{\"1\":{\"954\":1}}],[\"之后服务提供方元数据变更的话注册中心会把变更推送给服务消费者\",{\"1\":{\"882\":1}}],[\"之后在数据库\",{\"1\":{\"839\":1}}],[\"之后在解决哈希冲突时有了较大的变化\",{\"1\":{\"245\":1}}],[\"之后查询不到此条被删除的数据\",{\"1\":{\"839\":1}}],[\"之后变成了死信消息\",{\"1\":{\"754\":1}}],[\"之后容器调用bean中的setter方法完成setter方法依赖注入\",{\"1\":{\"597\":1}}],[\"之后学习的类型转换中\",{\"1\":{\"557\":1}}],[\"之后清除正在使用的内存块中的所有对象\",{\"1\":{\"522\":1}}],[\"之后发现依然无法进行对象的保存\",{\"1\":{\"490\":1}}],[\"之后己不再建议用户去覆盖\",{\"1\":{\"387\":1}}],[\"之后该类的内部信息就被存储在方法区\",{\"1\":{\"380\":1}}],[\"之后是元空间\",{\"1\":{\"300\":1}}],[\"之后才有的\",{\"1\":{\"286\":1}}],[\"之后的while就简单了\",{\"1\":{\"974\":1}}],[\"之后的\",{\"1\":{\"245\":1}}],[\"之后\",{\"0\":{\"245\":1},\"1\":{\"278\":2,\"523\":1,\"813\":1,\"882\":1,\"964\":2}}],[\"之后每次扩充\",{\"1\":{\"239\":2}}],[\"之前我们创建的队列都是非持久化的\",{\"1\":{\"711\":1}}],[\"之前有介绍\",{\"1\":{\"457\":1}}],[\"之前永久代还没被彻底移除的时候\",{\"1\":{\"338\":1}}],[\"之前运行时常量池逻辑包含字符串常量池存放在方法区\",{\"1\":{\"307\":1,\"317\":1}}],[\"之前的值已经得到\",{\"1\":{\"926\":1}}],[\"之前的版本无需做任何变更\",{\"1\":{\"783\":1}}],[\"之前的章节我们使用的是具有特定名称的队列\",{\"1\":{\"730\":1}}],[\"之前的\",{\"1\":{\"249\":1}}],[\"之前为循环链表\",{\"1\":{\"219\":1,\"229\":1}}],[\"之前\",{\"0\":{\"244\":1},\"1\":{\"106\":1,\"222\":1,\"244\":1,\"318\":1,\"387\":1}}],[\"之所以这么设计其实就是为了提高构建过程的自动化程度\",{\"1\":{\"95\":1}}],[\"瘦身\",{\"1\":{\"106\":1}}],[\"并进行解码\",{\"1\":{\"874\":1}}],[\"并得到返回的结果\",{\"1\":{\"873\":1}}],[\"并支持多数据源\",{\"1\":{\"826\":1}}],[\"并可重用\",{\"1\":{\"807\":1}}],[\"并通过网络发送至消费方\",{\"1\":{\"874\":1}}],[\"并通过java对象和\",{\"1\":{\"806\":1}}],[\"并通过反射机制调用目标类的代码\",{\"1\":{\"603\":1}}],[\"并给消息设置优先级\",{\"1\":{\"780\":1}}],[\"并给方法形参赋值\",{\"1\":{\"654\":1}}],[\"并实现方法\",{\"1\":{\"765\":1}}],[\"并实现该接口中提供的三个方法\",{\"1\":{\"648\":1}}],[\"并使其在设置的\",{\"1\":{\"756\":1}}],[\"并使用c2编译器\",{\"1\":{\"372\":1}}],[\"并使用c1编译器\",{\"1\":{\"372\":1}}],[\"并使用max来记录不同下标处的和的最大值即可\",{\"1\":{\"187\":1}}],[\"并绑定到对应的死信交换机\",{\"1\":{\"754\":2}}],[\"并拒绝签收该消息\",{\"1\":{\"749\":1}}],[\"并注入到\",{\"1\":{\"674\":1}}],[\"并提供一个访问它的全局访问点\",{\"1\":{\"626\":1}}],[\"并加载到\",{\"1\":{\"607\":1}}],[\"并加载下一个将要占用\",{\"1\":{\"267\":1}}],[\"并顺势织入横切逻辑\",{\"1\":{\"603\":1}}],[\"并回调了目标对象的方法\",{\"1\":{\"603\":1}}],[\"并将其递增\",{\"1\":{\"937\":1}}],[\"并将对其重新排队\",{\"1\":{\"707\":1}}],[\"并将对象年龄设为1\",{\"1\":{\"498\":1}}],[\"并将该对象可作为目标对象使用\",{\"1\":{\"603\":1}}],[\"并装配给该对象的属性\",{\"1\":{\"601\":1}}],[\"并有利于未来的可拓展性和可维护性\",{\"1\":{\"596\":1}}],[\"并由\",{\"1\":{\"595\":1}}],[\"并返回相应的数据和视图信息\",{\"1\":{\"646\":1}}],[\"并返回这个字符串流\",{\"1\":{\"549\":1}}],[\"并返回一个包含了符合该条件的元素的流\",{\"1\":{\"548\":1}}],[\"并返回常量池中创建的字符串的引用\",{\"1\":{\"318\":1}}],[\"并能生成结果\",{\"1\":{\"547\":1}}],[\"并记录下直接与\",{\"1\":{\"534\":1}}],[\"并非每次都对上面三个内存区域\",{\"1\":{\"493\":1}}],[\"并把刚才下载的gradle\",{\"1\":{\"1006\":1}}],[\"并把堆内对象的首地址赋值给引用变量\",{\"1\":{\"474\":1}}],[\"并把最终输出的jar包放在了指定位置\",{\"1\":{\"106\":1}}],[\"并更新列表上的内容\",{\"1\":{\"471\":1}}],[\"并更新pc寄存器中下一条需要执行的字节码指令\",{\"1\":{\"416\":1}}],[\"并生成对应的\",{\"1\":{\"470\":1}}],[\"并被植入jvm内部\",{\"1\":{\"435\":1}}],[\"并在文件中添加如下配置\",{\"1\":{\"1008\":1}}],[\"并在代理类的方法前\",{\"1\":{\"627\":1}}],[\"并在子类中采用方法拦截的技术拦截所有父类的调用方法\",{\"1\":{\"603\":1}}],[\"并在后续对其进行\",{\"1\":{\"431\":1}}],[\"并在必要时改变其行为\",{\"1\":{\"230\":1}}],[\"并保存在方法的code属性的maximum\",{\"1\":{\"415\":1}}],[\"并参与方法的调用和返回\",{\"1\":{\"407\":1}}],[\"并指定为他们的父类加载器\",{\"1\":{\"382\":1}}],[\"并缓存起来\",{\"1\":{\"349\":1}}],[\"并不能实现一个优先级的场景\",{\"1\":{\"776\":1}}],[\"并不知道这种情况它依然很公平的进行分发\",{\"1\":{\"714\":1}}],[\"并不成熟\",{\"0\":{\"511\":1}}],[\"并不要求统一\",{\"1\":{\"461\":1}}],[\"并不提供实现体\",{\"1\":{\"434\":1}}],[\"并不继承自\",{\"1\":{\"382\":1}}],[\"并不是消费者消费了消息\",{\"1\":{\"722\":1}}],[\"并不是所有的jvm都支持本地方法\",{\"1\":{\"437\":1}}],[\"并不是继承关系\",{\"1\":{\"381\":1}}],[\"并不是字符串常量池中存在的对象\",{\"1\":{\"317\":1}}],[\"并不代表extclassloader没有父类加载器\",{\"1\":{\"332\":1}}],[\"并需要以它的一个对象作为锁时\",{\"1\":{\"288\":1}}],[\"并没有一种算法可以完全替代其他算法\",{\"1\":{\"525\":1}}],[\"并没有直接暴露给我们\",{\"1\":{\"285\":1}}],[\"并没有对方法进行加同步锁\",{\"1\":{\"276\":1}}],[\"并没有列举所有关系\",{\"1\":{\"214\":1}}],[\"并允许他去获得锁\",{\"1\":{\"273\":1}}],[\"并行调用多个服务器\",{\"1\":{\"917\":1}}],[\"并行与并发\",{\"1\":{\"535\":1}}],[\"并行垃圾收集器\",{\"1\":{\"339\":1}}],[\"并行\",{\"1\":{\"268\":1,\"539\":2}}],[\"并发收集\",{\"1\":{\"534\":1}}],[\"并发清除\",{\"1\":{\"534\":1}}],[\"并发标记\",{\"1\":{\"534\":1,\"535\":1}}],[\"并发标记清除\",{\"0\":{\"534\":1}}],[\"并发\",{\"1\":{\"268\":1,\"539\":2}}],[\"并发控制使用\",{\"1\":{\"249\":1}}],[\"并发环境下推荐使用\",{\"1\":{\"247\":1}}],[\"并且订阅提供者\",{\"1\":{\"890\":1}}],[\"并且能够平滑添加或删除服务提供者\",{\"1\":{\"884\":1}}],[\"并且能被survivor容纳的话\",{\"1\":{\"498\":1}}],[\"并且可用作静态final常量\",{\"1\":{\"993\":1}}],[\"并且可自定义存储源\",{\"1\":{\"813\":1}}],[\"并且可以不需要针对每个目标类都创建一个代理类\",{\"1\":{\"607\":1}}],[\"并且可以在不需要更大的方法区域时收缩\",{\"1\":{\"441\":1}}],[\"并且可以是由一个线程获得了\",{\"1\":{\"292\":1}}],[\"并且可以调用notify\",{\"1\":{\"273\":1}}],[\"并且初始化时\",{\"1\":{\"764\":1}}],[\"并且将消息通过网络发送给服务端\",{\"1\":{\"874\":1}}],[\"并且将交换机和队列进行绑定\",{\"1\":{\"762\":1}}],[\"并且将共享资源设置为锁定状态\",{\"1\":{\"289\":1}}],[\"并且时效性较强的场景\",{\"1\":{\"751\":1}}],[\"并且时常被一些\",{\"1\":{\"363\":1}}],[\"并且不会给消费者带来太大的风险\",{\"1\":{\"717\":1}}],[\"并且通道的预取计数设置为\",{\"1\":{\"717\":1}}],[\"并且尽可能的将之前\",{\"1\":{\"706\":1}}],[\"并且是按照有序的一个接收一次消息\",{\"1\":{\"701\":1}}],[\"并且启动\",{\"1\":{\"701\":1}}],[\"并且获取的次数按照顺序依次往下轮流\",{\"1\":{\"700\":1}}],[\"并且它天生与\",{\"1\":{\"643\":1}}],[\"并且它的实际的物理内存空间中和\",{\"1\":{\"442\":1}}],[\"并且使它们可相互替换\",{\"1\":{\"631\":1}}],[\"并且并行和并发兼备\",{\"1\":{\"528\":1}}],[\"并且gc不能管理gcih内部的java对象\",{\"1\":{\"505\":1}}],[\"并且由于内存分配算法与内存回收算法密切相关\",{\"1\":{\"490\":1}}],[\"并且检查这个符号引用代表的类是否己经被加载\",{\"1\":{\"470\":1}}],[\"并且检查这个符号引用代表的类是否已被加载过\",{\"1\":{\"310\":1}}],[\"并且习惯于不配置永久代\",{\"1\":{\"462\":1}}],[\"并且这个异常没有在方法内进行处理\",{\"1\":{\"424\":1}}],[\"并且在尝试扩展的时候无法申请到足够的内存\",{\"1\":{\"409\":1,\"437\":1}}],[\"并且随着程序运行时间的推移\",{\"1\":{\"366\":1}}],[\"并且java安全管理器也允许这次exit或halt操作\",{\"1\":{\"347\":1}}],[\"并且没有手动删除对应key\",{\"1\":{\"280\":1}}],[\"并且持有锁的线程正在运行中\",{\"1\":{\"278\":1}}],[\"并且线程达到最大线程数量的时候\",{\"1\":{\"275\":1}}],[\"并且\",{\"1\":{\"246\":1,\"745\":1}}],[\"并且判断了一下返回值以确保是否有重复元素\",{\"1\":{\"242\":1}}],[\"并且其内部是通过\",{\"1\":{\"220\":1}}],[\"并且支持插入\",{\"1\":{\"175\":1}}],[\"并为每个知识点制作精美的小卡片\",{\"1\":{\"123\":1}}],[\"并引入了null\",{\"1\":{\"106\":1}}],[\"来递归判断\",{\"1\":{\"1029\":1}}],[\"来看二叉树的前序遍历的特点\",{\"1\":{\"1024\":1}}],[\"来看它是如何实现的\",{\"1\":{\"285\":1}}],[\"来算了一次\",{\"1\":{\"1023\":1}}],[\"来检查\",{\"1\":{\"1019\":1}}],[\"来指定抛出的异常类型\",{\"1\":{\"998\":1}}],[\"来指定比例\",{\"1\":{\"488\":1}}],[\"来考验候选人的设计能力\",{\"1\":{\"919\":1}}],[\"来包装\",{\"1\":{\"890\":1}}],[\"来创建\",{\"1\":{\"889\":1}}],[\"来进行状态处理\",{\"1\":{\"983\":1}}],[\"来进行远程通信\",{\"1\":{\"890\":1}}],[\"来进行动态代理\",{\"1\":{\"889\":1}}],[\"来进行设置\",{\"1\":{\"485\":1}}],[\"来完成\",{\"1\":{\"823\":1}}],[\"来完成的\",{\"1\":{\"345\":1}}],[\"来存放的定时轮询\",{\"1\":{\"776\":1}}],[\"来判断之前是否处理过这种状态\",{\"1\":{\"983\":1}}],[\"来判断\",{\"1\":{\"773\":1}}],[\"来表示也可称该参数为\",{\"1\":{\"735\":1}}],[\"来消费该消息\",{\"1\":{\"709\":1}}],[\"来决定是否应该创建一个为web应用使用的applicationcontext类型\",{\"1\":{\"678\":1}}],[\"来解决跨域问题\",{\"1\":{\"673\":2}}],[\"来解决\",{\"1\":{\"673\":1}}],[\"来增强被代理类的功能\",{\"1\":{\"627\":1}}],[\"来提取流中菜肴的名称\",{\"1\":{\"549\":1}}],[\"来执行一个查询\",{\"1\":{\"547\":1}}],[\"来缩短\",{\"1\":{\"535\":1}}],[\"来禁用该功能\",{\"1\":{\"532\":1}}],[\"来为对象分配内存\",{\"1\":{\"471\":1}}],[\"来设置最大并行数\",{\"1\":{\"917\":1}}],[\"来设置永久代初始分配空间\",{\"1\":{\"447\":1}}],[\"来设定永久代最大可分配空间\",{\"1\":{\"447\":1}}],[\"来源同一个class文件\",{\"1\":{\"395\":1}}],[\"来关热度衰减\",{\"1\":{\"369\":1}}],[\"来人为设定\",{\"1\":{\"369\":1}}],[\"来了解被引用的对象是否将要被垃圾回收\",{\"1\":{\"328\":1}}],[\"来保证并发安全\",{\"1\":{\"252\":1}}],[\"来保证线程安全\",{\"1\":{\"249\":1}}],[\"来保存元素\",{\"1\":{\"220\":1}}],[\"来操作\",{\"1\":{\"249\":1}}],[\"来说\",{\"1\":{\"242\":1}}],[\"来实现延时队列可以很好的利用\",{\"1\":{\"758\":1}}],[\"来实现\",{\"1\":{\"423\":1,\"919\":1}}],[\"来实现锁的分配\",{\"1\":{\"289\":1}}],[\"来实现这个机制\",{\"1\":{\"286\":1}}],[\"来实现队列要比\",{\"1\":{\"231\":1}}],[\"来实现的\",{\"1\":{\"220\":1}}],[\"来获取元素\",{\"1\":{\"230\":1}}],[\"来动态移除先前加进去的元素\",{\"1\":{\"186\":1}}],[\"来画视频\",{\"1\":{\"148\":1}}],[\"来排除这个group下的所有jar\",{\"1\":{\"106\":1}}],[\"来管理\",{\"1\":{\"105\":1}}],[\"因而sessionfactory的datasource属性总是指向这个数据源并且恒定不变\",{\"1\":{\"628\":1}}],[\"因对象的设值方法是在对象被创建之前被调用的\",{\"1\":{\"600\":1}}],[\"因其每次需要保存信息恢复信息\",{\"1\":{\"267\":1}}],[\"因为左子树里所有节点的值均小于它的根节点的值\",{\"1\":{\"1029\":1}}],[\"因为奇数个节点\",{\"1\":{\"974\":1}}],[\"因为要获取目标节点的前一个节点\",{\"1\":{\"964\":1}}],[\"因为要存放直接后继和直接前驱以及数据\",{\"1\":{\"229\":1}}],[\"因为疫情和工作上的事情\",{\"1\":{\"942\":1}}],[\"因为对这个数进行增加后\",{\"1\":{\"939\":1}}],[\"因为排序\",{\"1\":{\"938\":1}}],[\"因为岛屿只能包含水平或垂直的四个方向的\",{\"1\":{\"933\":1}}],[\"因为5和7在原数组里被4隔开\",{\"1\":{\"929\":1,\"1038\":1}}],[\"因为子序列长度至少为1\",{\"1\":{\"925\":1}}],[\"因为服务调用方设置超时时间控制性更灵活\",{\"1\":{\"918\":1}}],[\"因为服务提供者比消费者更清楚自己提供的服务特性\",{\"1\":{\"918\":1}}],[\"因为源码里\",{\"1\":{\"892\":1}}],[\"因为已经从注册中心获取提供者的地址\",{\"1\":{\"882\":1}}],[\"因为mybatis使用jdbc来连接数据库\",{\"1\":{\"807\":1}}],[\"因为第二条消息的\",{\"1\":{\"762\":1}}],[\"因为官网也是跳转去该插件的\",{\"1\":{\"756\":1}}],[\"因为里面的消息都是希望被立即处理的消息\",{\"1\":{\"753\":1}}],[\"因为消息是否过期是在即将投递到消费者之前判定的\",{\"1\":{\"752\":1}}],[\"因为消费者\",{\"1\":{\"718\":1}}],[\"因为参数改变了\",{\"1\":{\"748\":1}}],[\"因为如果没有确认发布的消息就会阻塞所有后续消息的发布\",{\"1\":{\"722\":1}}],[\"因为自身内部错误导致消息丢失\",{\"1\":{\"720\":1}}],[\"因为base\",{\"1\":{\"670\":1}}],[\"因为当多个线程操作同一个对象的时候\",{\"1\":{\"638\":1}}],[\"因为三级缓存中放的是生成具体对象的匿名内部类\",{\"1\":{\"622\":1}}],[\"因为构造方法尽在对象被创建时调用\",{\"1\":{\"600\":1}}],[\"因为在b对象被创建之前a对象是不能被创建的\",{\"1\":{\"600\":1}}],[\"因为在调用构造方法中必须传入正确的构造参数\",{\"1\":{\"600\":1}}],[\"因为在进行上述操作的时候集合中第\",{\"1\":{\"229\":1}}],[\"因为getname方法返回一个string\",{\"1\":{\"549\":1}}],[\"因为用户线程可能会不断的更新引用域\",{\"1\":{\"534\":1}}],[\"因为线程切换和上下文转换的消耗\",{\"1\":{\"526\":1}}],[\"因为线程安全的问题\",{\"1\":{\"239\":1}}],[\"因为复制算法需要复制的存活对象数量并不会太大\",{\"1\":{\"522\":1}}],[\"因为不断地分配内存空间而不进行回收\",{\"1\":{\"516\":1}}],[\"因为不用创建对象了\",{\"1\":{\"510\":1}}],[\"因为他可以分解成其他聚合量和标量\",{\"1\":{\"510\":1}}],[\"因为java对象大多都具备朝生夕灭的特性\",{\"1\":{\"494\":1}}],[\"因为java虚拟机规范并没有明确要求本地方法栈的使用语言\",{\"1\":{\"437\":1}}],[\"因为栈帧中保存引用\",{\"1\":{\"482\":1}}],[\"因为永久代的回收效率很低\",{\"1\":{\"463\":1}}],[\"因为功能点比较多\",{\"1\":{\"462\":1}}],[\"因为加载类的信息都在方法区\",{\"1\":{\"456\":1}}],[\"因为它无法接收到\",{\"1\":{\"704\":1}}],[\"因为它通常是通过完全锁定当前事务所涉及的数据表来完成的\",{\"1\":{\"634\":1}}],[\"因为它们不能被覆写\",{\"1\":{\"603\":1}}],[\"因为它们是合一的\",{\"1\":{\"437\":1}}],[\"因为它可能是指一个前端编译器\",{\"1\":{\"367\":1}}],[\"因为现在的异构领域间的通信很发达\",{\"1\":{\"436\":1}}],[\"因为其实现体是由非java语言在外面实现的\",{\"1\":{\"434\":1}}],[\"因为这样可以知道是否到达了当前层的最后一个元素\",{\"1\":{\"1035\":1}}],[\"因为这样才有机会对消息进行排序\",{\"1\":{\"777\":1}}],[\"因为这样场合极有可能每次申请锁的线程都是不相同的\",{\"1\":{\"278\":1}}],[\"因为这种模式如果消息在接收到之前\",{\"1\":{\"705\":1}}],[\"因为这个类的方法太多\",{\"1\":{\"632\":1}}],[\"因为这个入参有可能被多个线程调用\",{\"1\":{\"431\":1}}],[\"因为cpu需要不停的切换各个线程\",{\"1\":{\"401\":1}}],[\"因为字节码指令并非等价于本地机器指令\",{\"1\":{\"355\":1}}],[\"因为str3是编译器在程序编译期就可以确定值的常量\",{\"1\":{\"317\":1}}],[\"因为避免了在\",{\"1\":{\"308\":1}}],[\"因为监视器锁\",{\"1\":{\"278\":1}}],[\"因为操作系统要防止一个线程或者进程长时间占用cpu导致其他线程或者进程饿死\",{\"1\":{\"267\":1}}],[\"因为多线程下使用\",{\"1\":{\"247\":1}}],[\"因为二叉查找树在某些情况下会退化成一个线性结构\",{\"1\":{\"245\":1}}],[\"因为毕竟扰动了\",{\"1\":{\"244\":1}}],[\"因为除了\",{\"1\":{\"240\":1}}],[\"因为\",{\"1\":{\"239\":1,\"332\":1,\"379\":1,\"462\":1,\"724\":1,\"755\":1,\"893\":1,\"1018\":1}}],[\"因为需要先移动到指定位置再插入\",{\"1\":{\"229\":1}}],[\"因为我们在实际开发中\",{\"1\":{\"217\":1}}],[\"因为可能出现访问可执行jar中的一些配置文件找不到的问题\",{\"1\":{\"104\":1}}],[\"因此时间复杂度为\",{\"1\":{\"1029\":1,\"1030\":1}}],[\"因此如果小于2就不必压缩\",{\"1\":{\"954\":1}}],[\"因此需要额外的\",{\"1\":{\"1030\":1}}],[\"因此需要减去2\",{\"1\":{\"943\":1}}],[\"因此需要有不同的实现\",{\"1\":{\"892\":1}}],[\"因此要给\",{\"1\":{\"939\":1}}],[\"因此的要服务发现\",{\"1\":{\"919\":1}}],[\"因此可以通过负载均衡选择一个\",{\"1\":{\"882\":1}}],[\"因此可以不受物理条件制约地定制指令集与执行引擎的结构体系\",{\"1\":{\"355\":1}}],[\"因此无法使用死信队列来保存消息\",{\"1\":{\"767\":1}}],[\"因此无法被直接引用\",{\"1\":{\"686\":1}}],[\"因此希望开发人员能限制此缓冲区的大小\",{\"1\":{\"717\":1}}],[\"因此这里就存在一个未确认的消息缓冲区\",{\"1\":{\"717\":1}}],[\"因此这种场合下不应该使用偏向锁\",{\"1\":{\"278\":1}}],[\"因此我们需要异步的io\",{\"1\":{\"878\":1}}],[\"因此我们使用map集合来装载我们的参数\",{\"1\":{\"819\":1}}],[\"因此我们推荐在后端通过\",{\"1\":{\"673\":1}}],[\"因此我们可以将这种内存分配方式称之为快速分配筻略\",{\"1\":{\"500\":1}}],[\"因此是线程安全的\",{\"1\":{\"638\":1}}],[\"因此异常发生了\",{\"1\":{\"599\":1}}],[\"因此很适用于年轻代的回收\",{\"1\":{\"525\":1}}],[\"因此生命周期比较长\",{\"1\":{\"525\":1}}],[\"因此在并发环境下从堆区中划分内存空间是线程不安全的\",{\"1\":{\"501\":1}}],[\"因此在计算\",{\"1\":{\"204\":1,\"205\":1}}],[\"因此一般来说\",{\"1\":{\"474\":1}}],[\"因此一般情况下\",{\"1\":{\"273\":1}}],[\"因此都可以通过jit编译器编译为本地机器指令\",{\"1\":{\"368\":1}}],[\"因此除了\",{\"1\":{\"363\":1}}],[\"因此避免采用静态编译的方式直接生成本地机器指令\",{\"1\":{\"360\":1}}],[\"因此jrock内部不包含解析器实现\",{\"1\":{\"352\":1}}],[\"因此所有的请求最终都应该传送到顶层的启动类加载器\",{\"1\":{\"332\":1}}],[\"因此不需要设置哑节点\",{\"1\":{\"964\":1}}],[\"因此不存在数据安全问题\",{\"1\":{\"415\":1}}],[\"因此不一定会很快发现那些只具有弱引用的对象\",{\"1\":{\"327\":1}}],[\"因此不能优化\",{\"1\":{\"317\":1}}],[\"因此返回true\",{\"1\":{\"319\":1}}],[\"因此会把堆中s2对象的引用放在常量池中\",{\"1\":{\"319\":1}}],[\"因此将创建总共\",{\"1\":{\"319\":1}}],[\"因此d不能优化\",{\"1\":{\"317\":1}}],[\"因此d也会被放入常量池\",{\"1\":{\"317\":1}}],[\"因此c\",{\"1\":{\"317\":1}}],[\"因此也就可以使用静态链接的方式将符号引用转换为直接引用\",{\"1\":{\"420\":1}}],[\"因此也就被称之为动态链接\",{\"1\":{\"419\":1}}],[\"因此也被称之为栈上替换\",{\"1\":{\"368\":1}}],[\"因此也被称作gc\",{\"1\":{\"304\":1}}],[\"因此也切换到了默认的\",{\"1\":{\"6\":1}}],[\"因此虚拟机会让当前想要获取锁的线程做几个空循环\",{\"1\":{\"278\":1}}],[\"因此自旋锁会假设在不久将来\",{\"1\":{\"278\":1}}],[\"因此为了减少同一线程获取锁\",{\"1\":{\"278\":1}}],[\"因此\",{\"1\":{\"273\":1,\"278\":1,\"280\":1,\"317\":1,\"319\":1,\"423\":1,\"462\":1,\"523\":2,\"525\":1,\"621\":1,\"728\":1,\"893\":1,\"1024\":1}}],[\"因此算法这样设计\",{\"1\":{\"253\":1}}],[\"因此调用这些方法时会报错\",{\"1\":{\"233\":1}}],[\"因此上行使用out\",{\"1\":{\"201\":1}}],[\"官方文档\",{\"1\":{\"1001\":1}}],[\"官方文档地址\",{\"1\":{\"104\":1}}],[\"官方题解中还有一个bfs的解法\",{\"1\":{\"935\":1}}],[\"官方对从\",{\"1\":{\"278\":1}}],[\"官网的说明\",{\"1\":{\"865\":1}}],[\"官网推荐\",{\"1\":{\"697\":1,\"777\":1,\"779\":1}}],[\"官网列出的\",{\"1\":{\"591\":1}}],[\"官网描述\",{\"1\":{\"462\":1,\"867\":1}}],[\"官网中的相关介绍\",{\"1\":{\"440\":1}}],[\"官网\",{\"1\":{\"59\":1,\"101\":1,\"103\":1,\"110\":1,\"113\":1,\"690\":1,\"921\":1}}],[\"版本开始引入了惰性队列的概念\",{\"1\":{\"782\":1}}],[\"版本根据需求选择\",{\"1\":{\"696\":1}}],[\"版本仲裁中心和不同的场景启动器\",{\"1\":{\"665\":1}}],[\"版本之前\",{\"1\":{\"304\":1}}],[\"版本\",{\"1\":{\"103\":1,\"753\":1}}],[\"版本号不同的服务相互间不引用\",{\"1\":{\"900\":1}}],[\"版本号\",{\"1\":{\"65\":1}}],[\"即二叉树的高度\",{\"1\":{\"1029\":1}}],[\"即二叉树的直径\",{\"1\":{\"1023\":1}}],[\"即调用\",{\"1\":{\"1029\":2}}],[\"即调用该方法的指令的下一条指令的地址\",{\"1\":{\"424\":1}}],[\"即它们都相等时\",{\"1\":{\"1019\":1}}],[\"即任何一个满足即可\",{\"1\":{\"1019\":1}}],[\"即让两个指针一开始先指向该节点和\",{\"1\":{\"1019\":1}}],[\"即开始考察\",{\"1\":{\"954\":1}}],[\"即表示c这个字符出现过\",{\"1\":{\"949\":1}}],[\"即表示最终结果\",{\"1\":{\"253\":1}}],[\"即上面说的下一层\",{\"1\":{\"944\":1}}],[\"即将传染的橘子是好橘子\",{\"1\":{\"943\":1}}],[\"即将暂时获取不到锁的线程加入到队列中\",{\"1\":{\"289\":1}}],[\"即grid\",{\"1\":{\"943\":1}}],[\"即dp数组中的最大值\",{\"1\":{\"926\":1}}],[\"即dll\",{\"1\":{\"435\":1}}],[\"即优先级更高\",{\"1\":{\"918\":1}}],[\"即运行notifylistener的notify方法\",{\"1\":{\"906\":1}}],[\"即nio\",{\"1\":{\"878\":1}}],[\"即非阻塞io\",{\"1\":{\"872\":1}}],[\"即sql为\",{\"1\":{\"848\":1}}],[\"即支持更多的消息存储\",{\"1\":{\"782\":1}}],[\"即每个工作队列都会获取一个消息进行消费\",{\"1\":{\"700\":1}}],[\"即每个线程在\",{\"1\":{\"471\":1}}],[\"即前端控制器\",{\"1\":{\"654\":1}}],[\"即controller控制器\",{\"1\":{\"645\":1}}],[\"即model模型\",{\"1\":{\"645\":1}}],[\"即view视图\",{\"1\":{\"645\":1}}],[\"即提供了全局的访问点beanfactory\",{\"1\":{\"626\":1}}],[\"即应用程序将对象的创建及初始化职责交给工厂对象\",{\"1\":{\"625\":1}}],[\"即只有在使用到某个bean时\",{\"1\":{\"611\":1}}],[\"即只有当前正在执行的方法的栈帧\",{\"1\":{\"413\":1}}],[\"即扁平化为一个流\",{\"1\":{\"549\":1}}],[\"即对实时垃圾收集算法的研究直接导致了增量收集\",{\"1\":{\"526\":1}}],[\"即对象监视器\",{\"1\":{\"286\":1}}],[\"即直接覆盖\",{\"1\":{\"521\":1}}],[\"即老年代中垃圾回收发生的频率大大低于年轻代\",{\"1\":{\"512\":1}}],[\"即类的元数据信息\",{\"1\":{\"473\":1}}],[\"即4个字节大小\",{\"1\":{\"471\":1}}],[\"即判断类元信息是否存在\",{\"1\":{\"470\":1}}],[\"即这些类对应的类加载器不再存活\",{\"1\":{\"448\":1}}],[\"即没有限制\",{\"1\":{\"448\":1}}],[\"即入栈\",{\"1\":{\"416\":1}}],[\"即不可能在一个栈帧之中引用另外一个线程的栈帧\",{\"1\":{\"413\":1}}],[\"即把请求交由父类处理\",{\"1\":{\"390\":1}}],[\"即把第三方依赖从最终jar中移除\",{\"1\":{\"103\":1}}],[\"即系统的入口点所使用的classloader\",{\"1\":{\"389\":1}}],[\"即由\",{\"1\":{\"381\":1}}],[\"即一个类只需被clinit一次\",{\"1\":{\"380\":1}}],[\"即一段时间之内方法被调用的次数\",{\"1\":{\"369\":1}}],[\"即零值\",{\"1\":{\"379\":1}}],[\"即时编译的目的是避函数被解释执行\",{\"1\":{\"363\":1}}],[\"即时编译器逐渐发挥作用\",{\"1\":{\"366\":1}}],[\"即时编译器\",{\"1\":{\"343\":1,\"451\":1}}],[\"即时编译器编译后的代码等数据\",{\"1\":{\"305\":1}}],[\"即古老的字节码解释器\",{\"1\":{\"362\":1}}],[\"即在调用阶段动态地根据参数决定调用哪个实现类\",{\"1\":{\"907\":1}}],[\"即在类加载的时候\",{\"1\":{\"332\":1}}],[\"即在有向图中\",{\"1\":{\"280\":1}}],[\"即使是持久化的消息\",{\"1\":{\"782\":1}}],[\"即使我们收到了一样的消息\",{\"1\":{\"774\":1}}],[\"即使某个消费者偶尔死亡\",{\"1\":{\"707\":1}}],[\"即使依赖了也无法使用其中的类\",{\"1\":{\"686\":1}}],[\"即使没有类实例时你也可以访问它\",{\"1\":{\"455\":1}}],[\"即使这两个类对象\",{\"1\":{\"395\":1}}],[\"即使这两个对象指向相同的数据\",{\"1\":{\"242\":1}}],[\"即使在可达性分析法中不可达的对象\",{\"1\":{\"323\":1}}],[\"即程序以后不会再使用这些对象\",{\"1\":{\"280\":1}}],[\"即获取锁的过程\",{\"1\":{\"278\":1}}],[\"即便此时存在空闲线程\",{\"1\":{\"275\":1}}],[\"即等于二次幂\",{\"1\":{\"253\":1}}],[\"即剩余容量\",{\"1\":{\"207\":1}}],[\"即最大价值为\",{\"1\":{\"207\":1}}],[\"即最终包中不包含任何第三方依赖的jar\",{\"1\":{\"106\":1}}],[\"即下方代码处应使用累加的方式计算\",{\"1\":{\"204\":1,\"205\":1}}],[\"即\",{\"1\":{\"190\":1,\"381\":1,\"523\":1,\"627\":1,\"792\":1,\"919\":1}}],[\"即排序需要的栈空间\",{\"1\":{\"189\":1,\"190\":1}}],[\"即用于集成测试\",{\"1\":{\"105\":1}}],[\"即可指定该类或方法使用的数据源\",{\"1\":{\"866\":1}}],[\"即可拥有一些简单的增删改查方法\",{\"1\":{\"832\":1}}],[\"即可添加优先级队列成功\",{\"1\":{\"777\":1}}],[\"即可添加成功\",{\"1\":{\"55\":1}}],[\"即可\",{\"1\":{\"679\":1}}],[\"即可将这个方法与所属的类型进行绑定\",{\"1\":{\"420\":1}}],[\"即可得\",{\"1\":{\"207\":1}}],[\"即可打包成功\",{\"1\":{\"99\":1}}],[\"即可在创建书签的同时添加助记符\",{\"1\":{\"11\":1}}],[\"即可在多个位置生成光标\",{\"1\":{\"6\":1}}],[\"即可创建成功\",{\"1\":{\"11\":1}}],[\"即可完成批量替换\",{\"1\":{\"6\":1}}],[\"用javase\",{\"0\":{\"992\":1}}],[\"用分隔符将一系列字符串连接在一起可能会不必要地复杂\",{\"1\":{\"989\":1}}],[\"用sb接收并返回结果\",{\"1\":{\"954\":1}}],[\"用独立的消费者来进行监测和报警\",{\"1\":{\"767\":1}}],[\"用逗号\",{\"1\":{\"619\":1}}],[\"用法参考\",{\"1\":{\"568\":1}}],[\"用谓词切片\",{\"1\":{\"548\":1}}],[\"用一个闭包结构去记录可达对象\",{\"1\":{\"534\":1}}],[\"用户感觉上像调用本地服务一样的调用远程服务\",{\"1\":{\"874\":1}}],[\"用户未输入\",{\"1\":{\"853\":1}}],[\"用户查询余额发现多扣钱了\",{\"1\":{\"771\":1}}],[\"用户再次点击按钮\",{\"1\":{\"771\":1}}],[\"用户购买商品后支付\",{\"1\":{\"771\":1}}],[\"用户对于同一操作发起的一次请求或者多次请求的结果是一致的\",{\"1\":{\"771\":1}}],[\"用户发起退款\",{\"1\":{\"751\":1}}],[\"用户注册成功后\",{\"1\":{\"751\":1}}],[\"用户在商城下单成功并点击去支付后在指定时间未支付时自动失效\",{\"1\":{\"744\":1}}],[\"用户越来越多\",{\"1\":{\"516\":1}}],[\"用户线程才恢复运行\",{\"1\":{\"494\":1}}],[\"用户自定义类加载器\",{\"0\":{\"385\":1}}],[\"用户自定义的类是由系统类加载器加载的\",{\"1\":{\"381\":1}}],[\"用标量值替换聚合对象的属性值\",{\"1\":{\"372\":1}}],[\"用这些参数来调节方法区大小\",{\"1\":{\"338\":1}}],[\"用到了java的继承\",{\"1\":{\"288\":1}}],[\"用到过的插件\",{\"0\":{\"100\":1}}],[\"用reentrantlock类结合condition实例可以实现\",{\"1\":{\"286\":1}}],[\"用新元素替换旧元素\",{\"1\":{\"258\":1}}],[\"用指定的元素代替指定list中的所有元素\",{\"1\":{\"258\":1}}],[\"用于判断vis这个数字的二进制表示中\",{\"1\":{\"949\":1}}],[\"用于设置更新条件\",{\"1\":{\"847\":1}}],[\"用于设置填充的内容\",{\"1\":{\"847\":1}}],[\"用于lambda语法使用的查询wrapper\",{\"1\":{\"842\":1}}],[\"用于查询条件封装\",{\"1\":{\"842\":1}}],[\"用于查看所有\",{\"1\":{\"340\":1}}],[\"用于新增队列\",{\"1\":{\"755\":1}}],[\"用于新生代\",{\"0\":{\"522\":1}}],[\"用于否定确认\",{\"1\":{\"706\":1}}],[\"用于\",{\"1\":{\"693\":1}}],[\"用于根据特定条件来控制bean的创建行为\",{\"1\":{\"674\":1}}],[\"用于身份认证\",{\"1\":{\"656\":1}}],[\"用于将请求参数映射到控制器方法的形参上\",{\"1\":{\"651\":1}}],[\"用于接收uri地址传过来的参数\",{\"1\":{\"651\":1}}],[\"用于请求\",{\"1\":{\"651\":1}}],[\"用于创建二级缓存中的对象\",{\"1\":{\"621\":1}}],[\"用于创建新线程\",{\"1\":{\"275\":1}}],[\"用于老年代\",{\"0\":{\"523\":1}}],[\"用于表示堆区的起始内存\",{\"1\":{\"485\":1}}],[\"用于提供\",{\"1\":{\"382\":1}}],[\"用于管理\",{\"1\":{\"362\":1}}],[\"用于分析\",{\"1\":{\"340\":1}}],[\"用于收集\",{\"1\":{\"340\":1}}],[\"用于存放编译期生成的各种字面量与符号引用\",{\"1\":{\"459\":1}}],[\"用于存放编译期生成的各种字面量和符号引用\",{\"1\":{\"307\":1}}],[\"用于存放该本地方法的局部变量表\",{\"1\":{\"303\":1}}],[\"用于存储已被虚拟机加载的类信息\",{\"1\":{\"305\":1}}],[\"用于存储键值对数据\",{\"1\":{\"251\":1}}],[\"用于传输和保存等待执行任务的阻塞队列\",{\"1\":{\"275\":1}}],[\"用于线程间通信\",{\"1\":{\"273\":1}}],[\"用于指示它们支持快速\",{\"1\":{\"230\":1}}],[\"用之前还要先做对数组的长度取模运算\",{\"1\":{\"246\":1}}],[\"用链表实现一个链式队列\",{\"1\":{\"169\":1}}],[\"用链表实现一个链式栈\",{\"1\":{\"168\":1}}],[\"用数组实现一个顺序队列\",{\"1\":{\"169\":1}}],[\"用数组实现一个顺序栈\",{\"1\":{\"168\":1}}],[\"用\",{\"1\":{\"150\":1,\"695\":1,\"756\":1,\"894\":1}}],[\"用来拆分字符串的工具\",{\"1\":{\"995\":1}}],[\"用来封装请求响应模型\",{\"1\":{\"883\":1}}],[\"用来调用service的\",{\"1\":{\"882\":1}}],[\"用来运行服务的\",{\"1\":{\"882\":1}}],[\"用来加载那些不会改变的类\",{\"1\":{\"670\":1}}],[\"用来保存一个对象工厂\",{\"1\":{\"621\":1}}],[\"用来保存实例化完成\",{\"1\":{\"621\":1}}],[\"用来保存实例化\",{\"1\":{\"621\":1}}],[\"用来实现\",{\"1\":{\"595\":1}}],[\"用来解决之前的日期类相关的问题\",{\"1\":{\"574\":1}}],[\"用来提取某些对象中的信息\",{\"1\":{\"549\":1}}],[\"用来写注释\",{\"1\":{\"143\":1}}],[\"用来减少jar的体积\",{\"1\":{\"106\":1}}],[\"用来被其他项目引用\",{\"1\":{\"106\":1}}],[\"用来指定jar的依赖路径的前缀\",{\"1\":{\"103\":1}}],[\"用来指定现在使用的\",{\"1\":{\"78\":1}}],[\"$$\",{\"1\":{\"207\":2}}],[\"$\",{\"1\":{\"99\":5,\"754\":4,\"810\":1,\"814\":1}}],[\"放入handlermethodmap\",{\"1\":{\"789\":1}}],[\"放行options请求\",{\"1\":{\"788\":1}}],[\"放置到\",{\"1\":{\"756\":1}}],[\"放回队列重新消费\",{\"1\":{\"708\":1,\"711\":1}}],[\"放在栈的顶端\",{\"1\":{\"413\":1}}],[\"放在此目录下\",{\"1\":{\"383\":1}}],[\"放代码块里\",{\"1\":{\"282\":1}}],[\"放到堆里\",{\"1\":{\"463\":1}}],[\"放到了堆空间中\",{\"1\":{\"463\":1}}],[\"放到\",{\"1\":{\"99\":3,\"754\":1}}],[\"放大\",{\"1\":{\"48\":1}}],[\"等效于求路径经过的节点数的最大值减去1\",{\"1\":{\"1023\":1}}],[\"等硬件负载均衡器\",{\"1\":{\"884\":1}}],[\"等多种数据库\",{\"1\":{\"827\":1}}],[\"等事务管理相关的方法\",{\"1\":{\"633\":1}}],[\"等等\",{\"1\":{\"612\":1}}],[\"等垃圾收集器的关注点更多的是用户线程的停顿时间\",{\"1\":{\"532\":1}}],[\"等垃圾回收结束\",{\"1\":{\"494\":1}}],[\"等价于\",{\"1\":{\"485\":2}}],[\"等字节码框架\",{\"1\":{\"464\":1}}],[\"等开头的类\",{\"1\":{\"382\":1}}],[\"等问题的产生\",{\"1\":{\"328\":1}}],[\"等空间\",{\"1\":{\"304\":1}}],[\"等待服务端的响应\",{\"1\":{\"891\":1}}],[\"等待\",{\"1\":{\"749\":1}}],[\"等待接收死信消息\",{\"1\":{\"747\":1,\"749\":1}}],[\"等待接收消息处理时间较\",{\"1\":{\"708\":1,\"714\":1,\"717\":1}}],[\"等待接收消息\",{\"1\":{\"698\":1,\"747\":1,\"748\":1,\"749\":1}}],[\"等待垃圾回收的完成\",{\"1\":{\"526\":1}}],[\"等待可中断\",{\"1\":{\"286\":1}}],[\"等待队列中的第一个线程\",{\"1\":{\"273\":1}}],[\"等到计时时间一到\",{\"1\":{\"273\":1}}],[\"等方法\",{\"1\":{\"233\":1}}],[\"等于它的左右孩子的深度之和\",{\"1\":{\"1023\":1}}],[\"等于执行以下sql\",{\"1\":{\"847\":1}}],[\"等于我们只考虑前\",{\"1\":{\"207\":1}}],[\"等于其除以2的数的二进制表示中的1的个数\",{\"1\":{\"203\":1}}],[\"等于前面那个数的二进制表示中的1的个数+1\",{\"1\":{\"203\":1}}],[\"等\",{\"1\":{\"99\":1,\"267\":1,\"363\":1,\"379\":1,\"568\":1,\"693\":1,\"811\":1}}],[\"等工具\",{\"1\":{\"1\":1}}],[\"希望将项目的说明文档\",{\"1\":{\"99\":1}}],[\"目的就是要和堆分开\",{\"1\":{\"441\":1}}],[\"目的在于确保\",{\"1\":{\"379\":1}}],[\"目的应该是与\",{\"1\":{\"305\":1,\"343\":1}}],[\"目前暂时不支持\",{\"1\":{\"910\":1}}],[\"目前比较高效的开源序列化框架\",{\"1\":{\"878\":2}}],[\"目前支持的过滤器\",{\"1\":{\"577\":1}}],[\"目前来看\",{\"1\":{\"537\":1}}],[\"目前还在发展中的前沿\",{\"1\":{\"528\":1}}],[\"目前几乎所有的垃圾回收器都采用分代收集算法执行垃圾回收的\",{\"1\":{\"525\":1}}],[\"目前的jdk版本采用什么回收算法\",{\"1\":{\"518\":1}}],[\"目前很多书籍还是基于jdk7以前的版本\",{\"1\":{\"511\":1}}],[\"目前该方法使用的越来越少了\",{\"1\":{\"436\":1}}],[\"目前hotspot\",{\"1\":{\"368\":1}}],[\"目前\",{\"1\":{\"353\":1,\"493\":2}}],[\"目前主流的访问方式有使用句柄和直接指针两种\",{\"1\":{\"315\":1}}],[\"目标对象和代理对象都要进行修改\",{\"1\":{\"607\":1}}],[\"目标对象\",{\"1\":{\"604\":1}}],[\"目标官网\",{\"1\":{\"106\":1}}],[\"目标概述\",{\"0\":{\"105\":1}}],[\"目标\",{\"0\":{\"98\":1}}],[\"目录里创建一个以服务接口命名的文件\",{\"1\":{\"892\":1}}],[\"目录默认分别位于\",{\"1\":{\"756\":1}}],[\"目录中所有文件取出\",{\"1\":{\"99\":1}}],[\"目录取出来\",{\"1\":{\"99\":2}}],[\"目录下才是我们的代码\",{\"1\":{\"686\":1}}],[\"目录下的\",{\"1\":{\"331\":1}}],[\"目录下的源代码\",{\"1\":{\"94\":1}}],[\"目录下再重新打包成docker镜像\",{\"1\":{\"106\":1}}],[\"目录下\",{\"1\":{\"99\":1}}],[\"目录下则为\",{\"1\":{\"99\":1}}],[\"目录\",{\"1\":{\"72\":1,\"73\":1,\"99\":1,\"756\":1}}],[\"目录专门存放构建操作输出的结果\",{\"1\":{\"71\":1}}],[\"让他们感觉不到本地调用和远程调用的区别\",{\"1\":{\"919\":1}}],[\"让所有的服务都用\",{\"1\":{\"919\":1}}],[\"让\",{\"1\":{\"874\":1}}],[\"让某个消费者订阅发布的部分消息\",{\"1\":{\"735\":1}}],[\"让队列持久化\",{\"1\":{\"711\":1}}],[\"让调用者方法继续执行下去\",{\"1\":{\"424\":1}}],[\"让方法计数器统计方注调用的绝对次数\",{\"1\":{\"369\":1}}],[\"让用户可以在浏览器上查看分析结果\",{\"1\":{\"340\":1}}],[\"让多个线程在这个屏障前等到\",{\"1\":{\"292\":1}}],[\"让使用者只关心最终要干的即可\",{\"1\":{\"95\":1}}],[\"让项目中的各个模块一目了然\",{\"1\":{\"90\":1}}],[\"直径为3\",{\"1\":{\"1023\":1}}],[\"直径为2\",{\"1\":{\"1023\":1}}],[\"直径为0\",{\"1\":{\"1023\":3}}],[\"直连远程引入\",{\"1\":{\"890\":1}}],[\"直至第一次使用调用getbean方法才会抛出异常\",{\"1\":{\"611\":1}}],[\"直到所有元素都考察一遍\",{\"1\":{\"1034\":1}}],[\"直到所有线程都到达了这个屏障时\",{\"1\":{\"292\":1}}],[\"直到装满或者倒空\",{\"1\":{\"981\":1}}],[\"直到全部比较完\",{\"1\":{\"974\":1}}],[\"直到fast指向null\",{\"1\":{\"964\":1}}],[\"直到fast指向最后一个节点\",{\"1\":{\"964\":1}}],[\"直到大于上一个元素\",{\"1\":{\"938\":1}}],[\"直到成功发布到交换机\",{\"1\":{\"761\":1}}],[\"直到它收集结束\",{\"1\":{\"530\":1}}],[\"直到垃圾收集完成\",{\"1\":{\"526\":1}}],[\"直到最后一个线程运行到await时才同时返回\",{\"1\":{\"292\":1}}],[\"直到count变为0\",{\"1\":{\"292\":1}}],[\"直到线程池中的线程数小于等于核心线程数\",{\"1\":{\"275\":1}}],[\"直到已创建的线程数大于或等于corepoolsize时\",{\"1\":{\"275\":1}}],[\"直到其他线程调用notify\",{\"1\":{\"273\":1}}],[\"直到指定的地方\",{\"1\":{\"95\":1}}],[\"直接返回max即可\",{\"1\":{\"926\":1}}],[\"直接忽略\",{\"1\":{\"917\":1}}],[\"直接答就行\",{\"1\":{\"892\":1}}],[\"直接调用\",{\"1\":{\"882\":1}}],[\"直接面向对象操作\",{\"1\":{\"827\":1}}],[\"直接\",{\"1\":{\"728\":1,\"872\":1}}],[\"直接使用\",{\"1\":{\"602\":1}}],[\"直接使用递推公式模拟即可\",{\"1\":{\"198\":1}}],[\"直接从本地内存的堆中分配任意数量的内存\",{\"1\":{\"437\":1}}],[\"直接引用就是直接指向目标的指针\",{\"1\":{\"379\":1}}],[\"直接把slow移到节点4\",{\"1\":{\"974\":1}}],[\"直接把\",{\"1\":{\"367\":1}}],[\"直接编译成机器码\",{\"1\":{\"365\":1}}],[\"直接在堆内存空间创建一个新的对象\",{\"1\":{\"317\":2}}],[\"直接指针\",{\"1\":{\"315\":1,\"479\":1}}],[\"直接将本地方法栈和虚拟机栈合二为一\",{\"1\":{\"303\":1,\"437\":1}}],[\"直接内存并不是虚拟机运行时数据区的一部分\",{\"1\":{\"308\":1}}],[\"直接内存\",{\"0\":{\"308\":1},\"1\":{\"300\":1}}],[\"直接覆盖\",{\"1\":{\"244\":1}}],[\"直接看一下hashset中的源码\",{\"1\":{\"242\":1}}],[\"直接模拟\",{\"1\":{\"199\":1}}],[\"直接粘贴图片即可\",{\"1\":{\"47\":1}}],[\"都有哪些动态\",{\"0\":{\"812\":1}}],[\"都有哪些映射形式\",{\"0\":{\"808\":1}}],[\"都有不同的会话\",{\"1\":{\"615\":1}}],[\"都建立一个\",{\"1\":{\"693\":1}}],[\"都能够调用它的任意一个方法和属性\",{\"1\":{\"608\":1}}],[\"都能够知道这个类的所有属性和方法\",{\"1\":{\"608\":1}}],[\"都应用arrays\",{\"1\":{\"549\":1}}],[\"都一样\",{\"1\":{\"532\":1}}],[\"都维护一个常量池\",{\"1\":{\"459\":1}}],[\"都没有父类\",{\"1\":{\"452\":1}}],[\"都会被解析为一个\",{\"1\":{\"816\":1}}],[\"都会写一个\",{\"1\":{\"816\":1}}],[\"都会调用该类的\",{\"1\":{\"762\":1}}],[\"都会导致栈帧被弹出\",{\"1\":{\"413\":1}}],[\"都会产生自己的程序计数器和栈帧\",{\"1\":{\"402\":1}}],[\"都会回收它的内存\",{\"1\":{\"327\":1}}],[\"都不会导致类的初始化\",{\"1\":{\"397\":1}}],[\"都需要在\",{\"1\":{\"721\":1}}],[\"都需要经过上图中的各个步骤\",{\"1\":{\"357\":1}}],[\"都需要配置自己的依赖信息\",{\"1\":{\"85\":1}}],[\"都来自常量池\",{\"1\":{\"318\":1}}],[\"都继承自abstractmap\",{\"1\":{\"241\":1}}],[\"都实现了\",{\"1\":{\"231\":1}}],[\"都将图片转化为\",{\"1\":{\"143\":1}}],[\"都是一系列得到支持的管理传递性依赖\",{\"1\":{\"682\":1}}],[\"都是用来创建对象的\",{\"1\":{\"610\":1}}],[\"都是复合算法\",{\"1\":{\"528\":1}}],[\"都是对\",{\"1\":{\"445\":1}}],[\"都是线程不安全的\",{\"1\":{\"259\":1}}],[\"都是不同步的\",{\"1\":{\"229\":1}}],[\"都是纯\",{\"1\":{\"139\":1}}],[\"都是从本周期最初的位置开始执行\",{\"1\":{\"95\":1}}],[\"前中后遍历\",{\"1\":{\"1024\":1}}],[\"前序遍历的遍历顺序是\",{\"1\":{\"1024\":1}}],[\"前序遍历\",{\"1\":{\"1024\":3}}],[\"前增加两行配置\",{\"1\":{\"1009\":1}}],[\"前置准备\",{\"0\":{\"1003\":1}}],[\"前置通知\",{\"1\":{\"604\":1}}],[\"前缀命名方式区分\",{\"1\":{\"833\":1}}],[\"前缀\",{\"1\":{\"788\":1}}],[\"前\",{\"1\":{\"757\":1,\"926\":1}}],[\"前一小节我们介绍了死信队列\",{\"1\":{\"753\":1}}],[\"前言\",{\"0\":{\"555\":1}}],[\"前3种都会导致有任务丢弃\",{\"1\":{\"275\":1}}],[\"前后加起来大概\",{\"1\":{\"246\":1}}],[\"前者效率是要高一些的\",{\"1\":{\"230\":1}}],[\"前提\",{\"1\":{\"207\":1}}],[\"前面在设置死信队列的文章中\",{\"1\":{\"767\":1}}],[\"前面所有这些算法中\",{\"1\":{\"525\":1}}],[\"前面提到的基于openjdk深度定制的taobaovm\",{\"1\":{\"505\":1}}],[\"前面我们也讲到了\",{\"1\":{\"285\":1}}],[\"前面的元素中的最小值\",{\"1\":{\"202\":1}}],[\"前面三个生命周期彼此是独立的\",{\"1\":{\"95\":1}}],[\"前驱节点\",{\"1\":{\"175\":1}}],[\"前端控制器dispatcherservlet\",{\"1\":{\"646\":1}}],[\"前端控制器\",{\"1\":{\"644\":1}}],[\"前端控制器向用户响应结果\",{\"1\":{\"642\":1}}],[\"前端控制器进行视图渲染\",{\"1\":{\"642\":1}}],[\"前端控制器请求视图解析器\",{\"1\":{\"642\":1}}],[\"前端控制器请求handlermapping查找处理器handler\",{\"1\":{\"642\":1}}],[\"前端控制器调用处理器适配器去执行handler\",{\"1\":{\"642\":1}}],[\"前端编译器\",{\"1\":{\"367\":1}}],[\"前端\",{\"2\":{\"163\":1}}],[\"前端资源\",{\"0\":{\"155\":1}}],[\"前端小工具\",{\"0\":{\"129\":1}}],[\"前端知识图谱+b站资源整合\",{\"1\":{\"118\":1}}],[\"前进\",{\"1\":{\"6\":1}}],[\"需求\",{\"1\":{\"749\":1,\"849\":1,\"850\":1}}],[\"需借助插件\",{\"1\":{\"94\":1}}],[\"需要加到结果集中\",{\"1\":{\"1034\":1}}],[\"需要idea\",{\"1\":{\"1003\":1}}],[\"需要记住\",{\"1\":{\"985\":1}}],[\"需要判断z是否为x\",{\"1\":{\"984\":1}}],[\"需要多关注提示\",{\"1\":{\"957\":1}}],[\"需要注意的是\",{\"1\":{\"939\":1}}],[\"需要与注册中心交互\",{\"1\":{\"906\":1}}],[\"需要分析出实际调用的实现类\",{\"1\":{\"904\":1}}],[\"需要分别获取两个优先队列中\",{\"1\":{\"194\":1}}],[\"需要手工生成\",{\"1\":{\"894\":1}}],[\"需要手动编写\",{\"1\":{\"823\":1}}],[\"需要手动编写sql来完成\",{\"1\":{\"806\":1}}],[\"需要手动处理和恢复\",{\"1\":{\"759\":1}}],[\"需要给应用程序和浏览器js调用\",{\"1\":{\"888\":1}}],[\"需要会画上面这个图\",{\"1\":{\"882\":1}}],[\"需要对这些参数进行序列化和反序列化操作\",{\"1\":{\"878\":1}}],[\"需要有一个增加到\",{\"1\":{\"939\":1}}],[\"需要有比较高效的序列化框架\",{\"1\":{\"877\":1}}],[\"需要有非常高效的网络通信\",{\"1\":{\"877\":1}}],[\"需要有强有力的行政措施来限制接口无序升级\",{\"1\":{\"798\":1}}],[\"需要这样添加\",{\"1\":{\"836\":1}}],[\"需要中实体类上加\",{\"1\":{\"835\":1}}],[\"需要释放内存的时候\",{\"1\":{\"782\":1}}],[\"需要删掉\",{\"1\":{\"768\":1}}],[\"需要一个备份交换机\",{\"1\":{\"768\":1}}],[\"需要一定的执行时间\",{\"1\":{\"365\":1}}],[\"需要添加处理这些被退回的消息的逻辑\",{\"1\":{\"767\":1}}],[\"需要解决告诉生产者消息传送失败\",{\"1\":{\"762\":1}}],[\"需要20秒再进入延时队列\",{\"1\":{\"757\":1}}],[\"需要将一个队列绑定到交换机上\",{\"1\":{\"728\":1}}],[\"需要告诉生产者已经收到消息\",{\"1\":{\"725\":1}}],[\"需要把原先队列先删除\",{\"1\":{\"711\":1}}],[\"需要把自动应答改为手动应答\",{\"1\":{\"708\":1}}],[\"需要此方法拦截不再向下执行\",{\"1\":{\"656\":1}}],[\"需要springmvc对multipart类型的数据进行解析\",{\"1\":{\"655\":1}}],[\"需要用到\",{\"1\":{\"618\":1}}],[\"需要传入一个temporaladjuster对象\",{\"1\":{\"569\":1}}],[\"需要更高的精确性\",{\"1\":{\"558\":1}}],[\"需要返回倒数第k个节点的值\",{\"1\":{\"964\":1}}],[\"需要返回\",{\"1\":{\"549\":1}}],[\"需要付出很多的代价\",{\"1\":{\"534\":1}}],[\"需要造成系统长时间的停顿\",{\"1\":{\"526\":1}}],[\"需要全程暂停用户应用程序\",{\"1\":{\"523\":1}}],[\"需要两倍的内存空间\",{\"1\":{\"522\":1}}],[\"需要维护一个空闲列表\",{\"1\":{\"521\":1}}],[\"需要停止整个应用程序\",{\"1\":{\"521\":1}}],[\"需要具体分辨是老年代回收还是整堆回收\",{\"1\":{\"493\":1}}],[\"需要额外空间\",{\"1\":{\"479\":1}}],[\"需要详细到每个区放什么\",{\"1\":{\"465\":1}}],[\"需要同时满足下面三个条件\",{\"1\":{\"464\":1}}],[\"需要理解清楚\",{\"1\":{\"456\":2}}],[\"需要恢复上层方法的局部变量表\",{\"1\":{\"424\":1}}],[\"需要被回收\",{\"1\":{\"322\":1}}],[\"需要了解的是\",{\"1\":{\"278\":1}}],[\"需要线程安全的集合类型时请考虑使用\",{\"1\":{\"256\":1,\"259\":1}}],[\"需要保证这两个类型的类加载器是相同的\",{\"1\":{\"396\":1}}],[\"需要保证元素唯一时选择实现\",{\"1\":{\"216\":1}}],[\"需要保证线程安全就选用\",{\"1\":{\"216\":1}}],[\"需要排序时选择\",{\"1\":{\"216\":1}}],[\"需要考虑可以传递到dst的所有玩家\",{\"1\":{\"204\":1,\"205\":1}}],[\"需要使用栈来辅助进行\",{\"1\":{\"1024\":1}}],[\"需要使用到\",{\"1\":{\"744\":1}}],[\"需要使用其他的算法\",{\"1\":{\"523\":1}}],[\"需要使用逃逸分析手段\",{\"1\":{\"506\":1}}],[\"需要使用加锁等机制\",{\"1\":{\"501\":1}}],[\"需要使用上一行列表的除了最后一个的数\",{\"1\":{\"201\":1}}],[\"需要使用一个专门的\",{\"1\":{\"78\":1}}],[\"需要\",{\"1\":{\"200\":1,\"285\":1,\"695\":1,\"719\":1}}],[\"需要遍历数组orders一次\",{\"1\":{\"194\":1}}],[\"需要经过长期摸索和反复调试\",{\"1\":{\"85\":1}}],[\"需要经常改的代码\",{\"1\":{\"11\":1}}],[\"需要在类里面代表id的字段上方添加此注\",{\"1\":{\"836\":1}}],[\"需要在某个事件发生之后或者之前的指定时间点完成某一项任务\",{\"1\":{\"751\":1}}],[\"需要在预定的时间点前十分钟通知各个与会人员参加会议\",{\"1\":{\"751\":1}}],[\"需要在消息生产者发布消息的时候\",{\"1\":{\"712\":1}}],[\"需要在\",{\"1\":{\"82\":1}}],[\"接下来就是漫长的build了\",{\"1\":{\"1011\":1}}],[\"接下来执行reverselist\",{\"1\":{\"970\":1}}],[\"接下来执行完之后\",{\"1\":{\"970\":1}}],[\"接下来我们就去解决该问题\",{\"1\":{\"756\":1}}],[\"接下来只需要将它们进行融合\",{\"1\":{\"753\":1}}],[\"接下来虚拟机将为新生对象分配内存\",{\"1\":{\"311\":1}}],[\"接受到队列\",{\"1\":{\"762\":1}}],[\"接受到的消息\",{\"1\":{\"698\":1}}],[\"接受编译好的代码\",{\"1\":{\"94\":1}}],[\"接收客户端发送过来的请求消息并进行解包\",{\"1\":{\"874\":1}}],[\"接收一次\",{\"1\":{\"741\":1,\"742\":1}}],[\"接收一个返回boolean值的函数作为参数\",{\"1\":{\"548\":1}}],[\"接收到调用请求后负责将方法\",{\"1\":{\"874\":1}}],[\"接收到\",{\"1\":{\"741\":4,\"742\":4}}],[\"接收到了\",{\"1\":{\"709\":1}}],[\"接收到消息\",{\"1\":{\"701\":1,\"708\":1,\"714\":1,\"717\":1,\"747\":2,\"748\":1,\"749\":3,\"874\":1}}],[\"接收和分发消息的应用\",{\"1\":{\"693\":1}}],[\"接着深度++\",{\"1\":{\"1034\":1}}],[\"接着完成\",{\"1\":{\"821\":1}}],[\"接着继续创建a\",{\"1\":{\"621\":1}}],[\"接着切换到应用程序线程\",{\"1\":{\"526\":1}}],[\"接着再去\",{\"1\":{\"490\":1}}],[\"接着再根据pc寄存器中记录的下一条需要被执行的字节码指令执行解释操作\",{\"1\":{\"361\":1}}],[\"接着在堆中划分一块内存给新对象\",{\"1\":{\"471\":1}}],[\"接着\",{\"1\":{\"413\":1}}],[\"接近\",{\"1\":{\"353\":1}}],[\"接口名称+mock\",{\"1\":{\"901\":1}}],[\"接口非常多的情况下\",{\"1\":{\"872\":1}}],[\"接口并复写\",{\"1\":{\"818\":1}}],[\"接口生成代理\",{\"1\":{\"816\":1}}],[\"接口全限名+方法名拼接字符串作为\",{\"1\":{\"816\":1}}],[\"接口是没有实现类的\",{\"1\":{\"816\":1}}],[\"接口里的方法\",{\"1\":{\"816\":1}}],[\"接口与之对应\",{\"1\":{\"816\":1}}],[\"接口类\",{\"1\":{\"698\":2}}],[\"接口中提供三个方法\",{\"1\":{\"656\":1}}],[\"接口定制实例化\",{\"1\":{\"610\":1}}],[\"接口一旦新增加方法\",{\"1\":{\"607\":1}}],[\"接口interface\",{\"1\":{\"452\":1}}],[\"接口初始化中使用的特殊方法\",{\"1\":{\"441\":1}}],[\"接口方法内的参数\",{\"1\":{\"816\":1}}],[\"接口方法\",{\"1\":{\"379\":1}}],[\"接口等描述信息外\",{\"1\":{\"307\":1}}],[\"接口默认提供的\",{\"1\":{\"286\":1}}],[\"接口让\",{\"1\":{\"241\":1}}],[\"接口的工作原理是jdk\",{\"1\":{\"816\":1}}],[\"接口的工作原理是什么\",{\"1\":{\"816\":1}}],[\"接口的方法名\",{\"1\":{\"816\":1}}],[\"接口的全限名\",{\"1\":{\"816\":1}}],[\"接口的4个实现类\",{\"1\":{\"275\":1}}],[\"接口的注释\",{\"1\":{\"230\":1}}],[\"接口的比如\",{\"1\":{\"216\":1}}],[\"接口的集合比如\",{\"1\":{\"216\":1}}],[\"接口的集合\",{\"1\":{\"216\":1}}],[\"接口的实现类\",{\"1\":{\"6\":1}}],[\"接口下的集合\",{\"1\":{\"216\":1}}],[\"接口\",{\"0\":{\"230\":1,\"567\":1},\"1\":{\"214\":2,\"231\":1,\"240\":2,\"241\":1,\"305\":1,\"434\":1,\"457\":1,\"468\":1,\"568\":1,\"614\":4,\"764\":1,\"765\":1,\"816\":2,\"873\":1,\"888\":1}}],[\"准备考察下层元素\",{\"1\":{\"1034\":1}}],[\"准备阶段会显式初始化\",{\"1\":{\"379\":1}}],[\"准备\",{\"1\":{\"379\":2}}],[\"准备打包\",{\"1\":{\"94\":1}}],[\"准确式内存管理\",{\"1\":{\"350\":1}}],[\"准确的\",{\"1\":{\"85\":1}}],[\"生产端有可能就会重复发生了消息\",{\"1\":{\"774\":1}}],[\"生产多个消息到交换机\",{\"1\":{\"742\":1}}],[\"生产消息到\",{\"1\":{\"725\":1}}],[\"生产消息\",{\"1\":{\"701\":1,\"747\":1}}],[\"生产者只发消息\",{\"1\":{\"754\":1}}],[\"生产者只能将消息发送到交换机\",{\"1\":{\"727\":1}}],[\"生产者代码\",{\"1\":{\"747\":1,\"757\":1,\"779\":1}}],[\"生产者emitlog\",{\"1\":{\"734\":1}}],[\"生产者生产消息完成\",{\"1\":{\"747\":1}}],[\"生产者生产消息后\",{\"1\":{\"734\":1}}],[\"生产者生产的消息从不会直接发送到队列\",{\"1\":{\"727\":1}}],[\"生产者生产多个消息\",{\"1\":{\"715\":1}}],[\"生产者可以消息重发\",{\"1\":{\"722\":1}}],[\"生产者应用程序同样可以在回调方法中处理该\",{\"1\":{\"720\":1}}],[\"生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息\",{\"1\":{\"720\":1}}],[\"生产者应用便可以通过回调方法来处理该确认消息\",{\"1\":{\"720\":1}}],[\"生产者将信道设置成\",{\"1\":{\"720\":1}}],[\"生产者发布消息到\",{\"1\":{\"719\":1,\"736\":1}}],[\"生产者发送十个消息\",{\"1\":{\"778\":1}}],[\"生产者发送消息\",{\"1\":{\"747\":1,\"748\":1}}],[\"生产者发送\",{\"1\":{\"718\":1}}],[\"生产者发出消息\",{\"1\":{\"708\":1,\"711\":1,\"712\":1,\"734\":1,\"738\":1,\"742\":1}}],[\"生产者\",{\"1\":{\"692\":1,\"734\":1,\"738\":2,\"742\":2,\"747\":1,\"779\":1,\"780\":1}}],[\"生态系统中最完整的\",{\"1\":{\"596\":1}}],[\"生活\",{\"0\":{\"152\":1}}],[\"生成代理类的代码是extensionloader的createadaptiveextensionclasscode方法\",{\"1\":{\"907\":1}}],[\"生成client\",{\"1\":{\"878\":1}}],[\"生成\",{\"1\":{\"777\":1,\"842\":1}}],[\"生成视图对象\",{\"1\":{\"642\":1}}],[\"生成被代理类的代理类\",{\"1\":{\"627\":1}}],[\"生成一个队列\",{\"1\":{\"697\":2}}],[\"生成一个实现同样接口的一个代理类\",{\"1\":{\"606\":1}}],[\"生成一个被代理对象的子类来作为代理\",{\"1\":{\"596\":1}}],[\"生成目标类的代理对象\",{\"1\":{\"603\":1}}],[\"生成虚拟机当前时刻的线程快照\",{\"1\":{\"340\":1}}],[\"生成堆转储快照\",{\"1\":{\"340\":1}}],[\"生成波浪分隔线\",{\"1\":{\"148\":1}}],[\"生成下雨\",{\"1\":{\"144\":1}}],[\"生成器\",{\"0\":{\"144\":1},\"1\":{\"827\":1}}],[\"生成插画\",{\"1\":{\"139\":1}}],[\"生成好看的代码图片\",{\"1\":{\"138\":1}}],[\"生成仓库的动态数据统计图\",{\"1\":{\"127\":1}}],[\"生成可供执行器使用的构建信息\",{\"1\":{\"105\":1}}],[\"生成站点相关\",{\"1\":{\"94\":1}}],[\"生成的pom\",{\"1\":{\"78\":1}}],[\"生命周期\",{\"1\":{\"614\":1}}],[\"生命周期简单概括为4个阶段\",{\"1\":{\"614\":1}}],[\"生命周期和线程一致\",{\"1\":{\"407\":1}}],[\"生命周期与线程的生命周期保持一致\",{\"1\":{\"399\":1}}],[\"生命周期中有\",{\"1\":{\"98\":1}}],[\"生命周期中的每一个环节对应构建过程中的一个操作\",{\"1\":{\"94\":1}}],[\"生命周期名称\",{\"1\":{\"94\":1}}],[\"设值注入不会重写构造方法的值\",{\"1\":{\"600\":1}}],[\"设新生代中eden和s0\",{\"1\":{\"503\":1}}],[\"设计者们的初衷仅仅只是单纯地为了满足\",{\"1\":{\"360\":1}}],[\"设计师网址导航\",{\"1\":{\"139\":1}}],[\"设计\",{\"0\":{\"139\":1}}],[\"设计干货\",{\"1\":{\"120\":1}}],[\"设定了三个生命周期\",{\"1\":{\"94\":1}}],[\"设置默认的数据源或者数据源组\",{\"1\":{\"866\":1}}],[\"设置默认值为0\",{\"1\":{\"840\":1}}],[\"设置过滤表前缀\",{\"1\":{\"864\":1}}],[\"设置需要生成的表名\",{\"1\":{\"864\":1}}],[\"设置mapperxml生成路径\",{\"1\":{\"864\":1}}],[\"设置父包模块名\",{\"1\":{\"864\":1}}],[\"设置父包名\",{\"1\":{\"864\":1}}],[\"设置作者\",{\"1\":{\"864\":1}}],[\"设置该交换机的备份交换机\",{\"1\":{\"768\":1}}],[\"设置回退消息交给谁处理\",{\"1\":{\"765\":1}}],[\"设置的时间内没有被消费\",{\"1\":{\"752\":1}}],[\"设置为\",{\"1\":{\"749\":1,\"752\":1,\"764\":1}}],[\"设置正常队列长度的限制\",{\"1\":{\"748\":1,\"749\":1}}],[\"设置消息的优先级\",{\"1\":{\"780\":1}}],[\"设置消息的\",{\"1\":{\"747\":1,\"748\":1}}],[\"设置了预取值为\",{\"1\":{\"718\":1}}],[\"设置了主启动类\",{\"1\":{\"106\":1}}],[\"设置参数\",{\"1\":{\"714\":1}}],[\"设置队列的最大优先级\",{\"1\":{\"697\":1,\"777\":1,\"779\":1}}],[\"设置开启热部署\",{\"1\":{\"670\":1}}],[\"设置拦截器\",{\"1\":{\"627\":1}}],[\"设置属性所对应的字段名\",{\"1\":{\"837\":1}}],[\"设置属性的值\",{\"1\":{\"619\":1}}],[\"设置属性值\",{\"1\":{\"613\":1}}],[\"设置beanfactory\",{\"1\":{\"613\":1}}],[\"设置值是否允许担保失败\",{\"1\":{\"504\":1}}],[\"设置tlab空间所占用eden空间的百分比大小\",{\"1\":{\"502\":1}}],[\"设置是否开启tlab空间\",{\"1\":{\"502\":1}}],[\"设置堆内存大小与oom\",{\"0\":{\"484\":1}}],[\"设置对象转移到老年代的年龄\",{\"1\":{\"490\":1}}],[\"设置对象的对象头\",{\"0\":{\"473\":1}}],[\"设置对象头\",{\"0\":{\"313\":1}}],[\"设置初始的元空间大小\",{\"1\":{\"448\":1}}],[\"设置示例\",{\"1\":{\"410\":1}}],[\"设置线程的最大栈空间\",{\"1\":{\"410\":1}}],[\"设置栈内存大小\",{\"0\":{\"410\":1}}],[\"设置要使用的垃圾回收器\",{\"0\":{\"339\":1}}],[\"设置方法区大小与oom\",{\"0\":{\"446\":1}}],[\"设置方法区\",{\"0\":{\"338\":1}}],[\"设置方法参数列表类型自动提示\",{\"0\":{\"16\":1}}],[\"设置新生代垃圾的最大年龄\",{\"1\":{\"503\":1}}],[\"设置新生代的大小\",{\"1\":{\"503\":1}}],[\"设置新生代和老年代内存的比值\",{\"0\":{\"337\":1}}],[\"设置新生代内存大小\",{\"0\":{\"336\":1}}],[\"设置内存大小\",{\"0\":{\"335\":1}}],[\"设置分为两类\",{\"1\":{\"17\":1}}],[\"设置\",{\"0\":{\"14\":1,\"485\":1},\"1\":{\"305\":2,\"338\":2,\"424\":1,\"427\":1}}],[\"98\",{\"0\":{\"1027\":1}}],[\"9gb\",{\"1\":{\"1011\":1}}],[\"945\",{\"0\":{\"936\":1}}],[\"994\",{\"0\":{\"941\":1},\"1\":{\"942\":1}}],[\"99\",{\"1\":{\"497\":1}}],[\"9932047a89be\",{\"1\":{\"279\":1}}],[\"9606\",{\"1\":{\"247\":1}}],[\"9\",{\"0\":{\"93\":1,\"94\":1,\"95\":1},\"1\":{\"339\":1,\"537\":1,\"590\":1,\"678\":1,\"701\":3,\"708\":2,\"711\":1,\"722\":1,\"723\":1,\"756\":4,\"811\":1,\"812\":1,\"874\":1,\"913\":1}}],[\"聚合是将多个模块的工程汇聚到一起\",{\"1\":{\"89\":1}}],[\"聚合是在父项目\",{\"1\":{\"89\":1}}],[\"聚合和继承通常是结合使用的\",{\"1\":{\"89\":1}}],[\"聚合和继承\",{\"0\":{\"89\":1}}],[\"相等呢\",{\"1\":{\"1019\":1}}],[\"相等\",{\"1\":{\"1019\":1}}],[\"相等的对象是否真的相同\",{\"1\":{\"242\":1}}],[\"相当灵活\",{\"1\":{\"807\":1}}],[\"相当于在mybatis中配置\",{\"1\":{\"837\":1}}],[\"相当于\",{\"1\":{\"810\":1}}],[\"相当于清除了内容的地址\",{\"1\":{\"724\":1}}],[\"相当于之前的消费者\",{\"1\":{\"701\":1}}],[\"相当于排除所有maven依赖jar\",{\"1\":{\"106\":1}}],[\"相反\",{\"1\":{\"727\":1}}],[\"相反我们安排任务在之后执行\",{\"1\":{\"699\":1}}],[\"相反的\",{\"1\":{\"278\":1}}],[\"相连的对象\",{\"1\":{\"534\":1}}],[\"相同宽度的字段总是被分配在一起\",{\"1\":{\"477\":1}}],[\"相同的类文件被不同的类加载器加载产生的是两个不同的类\",{\"1\":{\"333\":1}}],[\"相互引用的对象\",{\"1\":{\"321\":1}}],[\"相互独立\",{\"1\":{\"89\":1}}],[\"相比synchronized\",{\"1\":{\"286\":1}}],[\"相比于之前的版本\",{\"1\":{\"245\":1}}],[\"相比于\",{\"1\":{\"244\":2}}],[\"相比于hashmap来说\",{\"1\":{\"241\":1}}],[\"相对多线程开销较小\",{\"1\":{\"896\":1}}],[\"相对来说http请求会有更大的报文\",{\"1\":{\"887\":1}}],[\"相对的\",{\"1\":{\"510\":1}}],[\"相对悠闲\",{\"1\":{\"490\":1}}],[\"相对偏移量或一个间接定位到目标的句柄\",{\"1\":{\"379\":1}}],[\"相对于\",{\"1\":{\"246\":1,\"535\":1}}],[\"相对时间\",{\"1\":{\"159\":1}}],[\"相关工具\",{\"0\":{\"662\":1}}],[\"相关资料和教程\",{\"0\":{\"659\":1}}],[\"相关资料\",{\"1\":{\"555\":1}}],[\"相关参考文章🍉\",{\"1\":{\"238\":1}}],[\"相关\",{\"0\":{\"787\":1},\"1\":{\"200\":1}}],[\"相关信息\",{\"1\":{\"185\":1,\"192\":1,\"196\":1,\"206\":1,\"996\":1}}],[\"相关代码实现为本人实现or整理自网络\",{\"1\":{\"165\":1}}],[\"相关总结\",{\"1\":{\"1\":1}}],[\"继续往下\",{\"1\":{\"1034\":1}}],[\"继续check二者的左子树和右子树\",{\"1\":{\"1019\":1}}],[\"继续循环\",{\"1\":{\"970\":1}}],[\"继续在调用栈内执行\",{\"1\":{\"508\":1}}],[\"继续按就切换到其它错误行\",{\"1\":{\"6\":1}}],[\"继承\",{\"1\":{\"833\":1}}],[\"继承自spring\",{\"1\":{\"685\":1}}],[\"继承自\",{\"1\":{\"222\":1}}],[\"继承是在子项目中操作\",{\"1\":{\"89\":1}}],[\"继承和聚合\",{\"1\":{\"89\":1}}],[\"指的就是一对多查询\",{\"1\":{\"821\":1}}],[\"指的就是一对一\",{\"1\":{\"821\":1}}],[\"指的是在\",{\"1\":{\"602\":1}}],[\"指的是代码已经被编译成\",{\"1\":{\"602\":1}}],[\"指的是增强的代码和源代码我们都有\",{\"1\":{\"602\":1}}],[\"指的是它的热点代码探测技术\",{\"1\":{\"351\":1}}],[\"指的是自己可以再次获取自己的内部锁\",{\"1\":{\"271\":1,\"284\":1}}],[\"指的是数组的长度\",{\"1\":{\"244\":1}}],[\"指纹码\",{\"1\":{\"774\":1}}],[\"指纹码机制\",{\"1\":{\"774\":1}}],[\"指同一个事务内多次查询返回的结果集不一样\",{\"1\":{\"634\":1}}],[\"指方法\",{\"1\":{\"604\":1}}],[\"指发生在老年代的gc\",{\"1\":{\"495\":1}}],[\"指classloader实例对象\",{\"1\":{\"395\":1}}],[\"指针碰撞\",{\"1\":{\"311\":1}}],[\"指令之后会接着就是执行方法\",{\"1\":{\"474\":1}}],[\"指令之后会接着执行\",{\"1\":{\"314\":1}}],[\"指令所决定\",{\"1\":{\"474\":1}}],[\"指令集小\",{\"1\":{\"405\":1}}],[\"指令集和操作系统层面上的\",{\"1\":{\"355\":1}}],[\"指令时\",{\"1\":{\"310\":1}}],[\"指令\",{\"1\":{\"278\":1,\"470\":1}}],[\"指向的是哪个类\",{\"1\":{\"612\":1}}],[\"指向类元数据instanceclass\",{\"1\":{\"476\":1}}],[\"指向复制\",{\"1\":{\"416\":1}}],[\"指向最后一个节点\",{\"1\":{\"229\":1}}],[\"指向\",{\"1\":{\"229\":1}}],[\"指向后一个节点\",{\"1\":{\"229\":1}}],[\"指向前一个节点\",{\"1\":{\"229\":1}}],[\"指向父工程\",{\"1\":{\"88\":1}}],[\"指定输出目录\",{\"1\":{\"864\":1}}],[\"指定主键生成策略\",{\"1\":{\"836\":1}}],[\"指定主启动类\",{\"1\":{\"106\":2}}],[\"指定表里的主键对应的实体类里的字段\",{\"1\":{\"836\":1}}],[\"指定要拦截哪一个接口的哪些方法即可\",{\"1\":{\"818\":1}}],[\"指定要排除的依赖的坐标\",{\"1\":{\"83\":1}}],[\"指定消息\",{\"1\":{\"762\":1}}],[\"指定\",{\"1\":{\"696\":1}}],[\"指定构造参数\",{\"1\":{\"619\":1}}],[\"指定返回值的模板文件\",{\"1\":{\"577\":1}}],[\"指定路径下的类库\",{\"1\":{\"384\":1}}],[\"指定java虚拟机运行在server模式下\",{\"1\":{\"372\":1}}],[\"指定java虚拟机运行在client模式下\",{\"1\":{\"372\":1}}],[\"指定该插件打的包最终会放到这个属性对应的路径下\",{\"1\":{\"106\":1}}],[\"指定配置文件的路径\",{\"1\":{\"99\":1}}],[\"修改\",{\"1\":{\"1009\":1}}],[\"修改spring源码内gradle的镜像地址\",{\"0\":{\"1009\":1}}],[\"修改distributionurl\",{\"0\":{\"1006\":1}}],[\"修改更新的优先级\",{\"0\":{\"848\":1}}],[\"修改高级确认发布\",{\"1\":{\"768\":1}}],[\"修改生产者\",{\"1\":{\"765\":1}}],[\"修改回调接口\",{\"1\":{\"765\":1}}],[\"修改配置文件\",{\"1\":{\"765\":1}}],[\"修改tomcat的配置文件server\",{\"1\":{\"649\":1}}],[\"修改完毕后暂存\",{\"1\":{\"585\":1}}],[\"修改文件\",{\"1\":{\"585\":1}}],[\"修改提交时的注释\",{\"1\":{\"585\":1}}],[\"修改时间格式\",{\"1\":{\"562\":1}}],[\"修改类加载的方式\",{\"1\":{\"386\":1}}],[\"修改起来比较麻烦\",{\"1\":{\"87\":1}}],[\"修饰的\",{\"1\":{\"379\":1}}],[\"修饰\",{\"1\":{\"239\":1}}],[\"修饰符等内容\",{\"1\":{\"6\":1}}],[\"每3个元素一份\",{\"1\":{\"996\":1}}],[\"每走一步\",{\"1\":{\"943\":1}}],[\"每确定一个dp\",{\"1\":{\"926\":1}}],[\"每发送完毕一个\",{\"1\":{\"902\":1}}],[\"每条消息大概占\",{\"1\":{\"784\":1}}],[\"每条线程都需要有一个独立的程序计数器\",{\"1\":{\"301\":1}}],[\"每秒查一次\",{\"1\":{\"751\":1}}],[\"每台子网内的主机都获得了一份复制的消息\",{\"1\":{\"728\":1}}],[\"每当执行这\",{\"1\":{\"818\":1}}],[\"每当执行完一项指令操作后\",{\"1\":{\"356\":1}}],[\"每当我们连接到\",{\"1\":{\"730\":1}}],[\"每当你要想使用发布确认\",{\"1\":{\"721\":1}}],[\"每当有一个地方引用它\",{\"1\":{\"321\":1}}],[\"每次计算都把最大深度存入res中\",{\"1\":{\"1023\":1}}],[\"每次重新进入外层的while时\",{\"1\":{\"954\":1}}],[\"每次循环的最后\",{\"1\":{\"930\":1,\"1039\":1}}],[\"每次遍历中\",{\"1\":{\"930\":1,\"1039\":1}}],[\"每次调用时\",{\"1\":{\"915\":1}}],[\"每次消费消息时用该\",{\"1\":{\"773\":1}}],[\"每次http请求都会创建一个新的bean\",{\"1\":{\"615\":1}}],[\"每次请求都会创建一个新的\",{\"1\":{\"615\":1,\"638\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"535\":1}}],[\"每次合理地回收若干个小区间\",{\"1\":{\"527\":1}}],[\"每次\",{\"1\":{\"526\":1,\"937\":1}}],[\"每次只使用其中一块\",{\"1\":{\"522\":1}}],[\"每次minor\",{\"1\":{\"494\":1}}],[\"每次函数执行时\",{\"1\":{\"363\":1}}],[\"每次方法调用的数据都是通过栈传递的\",{\"1\":{\"302\":1}}],[\"每次从fifo队列的队头取出线程获取锁\",{\"1\":{\"290\":1}}],[\"每次你可以爬\",{\"1\":{\"200\":1}}],[\"每一层的作用如下\",{\"1\":{\"883\":1}}],[\"每一秒钟打印出一个时间\",{\"1\":{\"273\":1}}],[\"每一把锁只锁容器其中一部分数据\",{\"1\":{\"249\":1}}],[\"每一个小区间都独立使用\",{\"1\":{\"527\":1}}],[\"每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用\",{\"1\":{\"417\":1}}],[\"每一个独立的栈帧中除了包含局部变量表以外\",{\"1\":{\"416\":1}}],[\"每一个操作数栈都会拥有一个明确的栈深度用于存储数值\",{\"1\":{\"416\":1}}],[\"每一个类都有一个对应它的类加载器\",{\"1\":{\"332\":1}}],[\"每一个\",{\"1\":{\"85\":1,\"816\":1,\"822\":1}}],[\"每件物品有且只有一件\",{\"1\":{\"207\":1}}],[\"每个方法有三种变体\",{\"1\":{\"997\":1}}],[\"每个方法执行\",{\"1\":{\"408\":1}}],[\"每个schema都会对应一个自己的namespacehandler\",{\"1\":{\"908\":1}}],[\"每个用户在自己的\",{\"1\":{\"693\":1}}],[\"每个参数代表注入的对象\",{\"1\":{\"597\":1}}],[\"每个gc都有所不同\",{\"1\":{\"498\":1}}],[\"每个区的作用是什么\",{\"1\":{\"465\":2}}],[\"每个异常处理的开始位置\",{\"1\":{\"454\":1}}],[\"每个类中都有一个虚方法表\",{\"1\":{\"423\":1}}],[\"每个线程都有自己的栈\",{\"1\":{\"412\":1}}],[\"每个线程都有它自己的程序计数器\",{\"1\":{\"399\":1}}],[\"每个线程在创建时都会创建一个虚拟机栈\",{\"1\":{\"407\":1}}],[\"每个线程在创建后\",{\"1\":{\"402\":1}}],[\"每个线程获取锁的概率都是相等的\",{\"1\":{\"290\":1}}],[\"每个\",{\"1\":{\"251\":2,\"615\":1}}],[\"每个键最多映射到一个值\",{\"1\":{\"215\":1}}],[\"每个订单的数量之和\",{\"1\":{\"194\":1}}],[\"每个坐标都要单独维护版本信息\",{\"1\":{\"87\":1}}],[\"每计算一次sum+1\",{\"1\":{\"184\":1}}],[\"父类中定义的变量会出现在子类之前\",{\"1\":{\"477\":1}}],[\"父类方法都是非虚方法\",{\"1\":{\"421\":1}}],[\"父类加载器为扩展类加载器\",{\"1\":{\"384\":1}}],[\"父类加载器为启动类加载器\",{\"1\":{\"383\":1}}],[\"父类的<clinit>\",{\"1\":{\"380\":1}}],[\"父工程的\",{\"1\":{\"87\":1}}],[\"父工程的pom\",{\"0\":{\"87\":1}}],[\"父工程的打包方式\",{\"1\":{\"85\":1}}],[\"父子工程的pom\",{\"0\":{\"86\":1}}],[\"只考虑水的总量\",{\"0\":{\"983\":1}}],[\"只循环处理<max的情况\",{\"1\":{\"939\":1}}],[\"只发起一次调用\",{\"1\":{\"917\":1}}],[\"只做增强不做改变\",{\"1\":{\"827\":1}}],[\"只不过这种情况下会将异常信息一并传入处理\",{\"1\":{\"678\":1}}],[\"只不过之前我们是在\",{\"1\":{\"673\":1}}],[\"只不过方法区的实现从永久代变成了元空间\",{\"1\":{\"307\":1}}],[\"只可以发送\",{\"1\":{\"673\":1}}],[\"只需用字符串拼接就可以生成字节码\",{\"1\":{\"894\":1}}],[\"只需简单配置\",{\"1\":{\"884\":1}}],[\"只需增加\",{\"1\":{\"649\":1}}],[\"只需要在classpath下增加个文件就可以了\",{\"1\":{\"904\":1}}],[\"只需要以多线程方式启动两次该\",{\"1\":{\"701\":1}}],[\"只需要调用getobject就可以返回具体的对象\",{\"1\":{\"610\":1}}],[\"只需要配置好配置文件\",{\"1\":{\"595\":1}}],[\"只需要修改一处即可\",{\"1\":{\"87\":1}}],[\"只初始化一次\",{\"1\":{\"648\":1}}],[\"只支持编译前后和类加载时织入\",{\"1\":{\"602\":1}}],[\"只显示容器编号\",{\"1\":{\"577\":1}}],[\"只针对老年代\",{\"1\":{\"534\":1}}],[\"只负责\",{\"1\":{\"375\":1}}],[\"只执行编译后的机器码即可\",{\"1\":{\"363\":1}}],[\"只在solaris平台短暂使用\",{\"1\":{\"350\":1}}],[\"只提供了解释器\",{\"1\":{\"349\":1}}],[\"只具有弱引用的对象拥有更短暂的生命周期\",{\"1\":{\"327\":1}}],[\"只会拦截那些你指定需要拦截的方法\",{\"1\":{\"818\":1}}],[\"只会检查第一个消息是否过期\",{\"1\":{\"755\":1}}],[\"只会匹配到\",{\"1\":{\"728\":1}}],[\"只会转发\",{\"1\":{\"728\":1}}],[\"只会改变句柄处记录的值\",{\"1\":{\"479\":1}}],[\"只会有一个活动的栈帧\",{\"1\":{\"413\":1}}],[\"只会执行某个线程中的一条指令\",{\"1\":{\"402\":1}}],[\"只会唤醒注册在该condition实例中的所有等待线程\",{\"1\":{\"286\":1}}],[\"只会清除线程或进程数据的操作\",{\"1\":{\"280\":1}}],[\"只有通过kill\",{\"1\":{\"913\":1}}],[\"只有层次分明\",{\"1\":{\"883\":1}}],[\"只有当你的web应用停止或重新部署的时候才能销毁\",{\"1\":{\"648\":1}}],[\"只有在使用\",{\"1\":{\"577\":1}}],[\"只有在server模式下才可以启用逃逸分析\",{\"1\":{\"505\":1}}],[\"只有它能与\",{\"1\":{\"531\":1}}],[\"只有最合适的算法\",{\"1\":{\"524\":1}}],[\"只有cms\",{\"1\":{\"493\":1}}],[\"只有g1\",{\"1\":{\"493\":1}}],[\"只有两种方式可以退出这个方法\",{\"1\":{\"424\":1}}],[\"只有\",{\"1\":{\"374\":1,\"461\":1}}],[\"只有自己使用完毕后才释放资源\",{\"1\":{\"269\":1}}],[\"只有打包方式为\",{\"1\":{\"85\":1}}],[\"只锁定当前链表或红黑二叉树的首节点\",{\"1\":{\"252\":1}}],[\"只是实现类的获取采用了jdkspi的机制\",{\"1\":{\"904\":1}}],[\"只是创建通信双方的通信通道\",{\"1\":{\"872\":1}}],[\"只是老年代的垃圾收集\",{\"1\":{\"493\":1}}],[\"只是新生代的垃圾收集\",{\"1\":{\"493\":1}}],[\"只是管理起来更加复杂\",{\"1\":{\"288\":1}}],[\"只是为了兼容旧版本\",{\"1\":{\"249\":1}}],[\"只是会在add\",{\"1\":{\"242\":1}}],[\"只要下标pos在范围内\",{\"1\":{\"957\":1}}],[\"只要一个成功即返回\",{\"1\":{\"917\":1}}],[\"只要广播地址\",{\"1\":{\"897\":1}}],[\"只要简单的配置即可实现分页功能\",{\"1\":{\"856\":1}}],[\"只要生产者发布消息\",{\"1\":{\"762\":1}}],[\"只要加入spring\",{\"1\":{\"682\":1}}],[\"只要你在web\",{\"1\":{\"648\":1}}],[\"只要常量池中的常量没有被任何地方引用\",{\"1\":{\"464\":1}}],[\"只要被局部变量表中直接或间接引用的对象都不会被回收\",{\"1\":{\"415\":1}}],[\"只要系统运行时间足够长\",{\"1\":{\"369\":1}}],[\"只要垃圾回收器没有回收它\",{\"1\":{\"326\":1}}],[\"只要哈希函数映射得比较均匀松散\",{\"1\":{\"246\":1}}],[\"只要正确配置了\",{\"1\":{\"72\":1}}],[\"只选第一件物品\",{\"1\":{\"207\":1}}],[\"只和\",{\"1\":{\"200\":1}}],[\"只能用\",{\"1\":{\"776\":1}}],[\"只能用于两个线程\",{\"1\":{\"292\":1}}],[\"只能用于链表的情况\",{\"1\":{\"249\":1}}],[\"只能输入一次\",{\"1\":{\"771\":1}}],[\"只能设计为多例\",{\"1\":{\"654\":1}}],[\"只能实现接口的类生成代理\",{\"1\":{\"603\":1}}],[\"只能在运行时织入\",{\"1\":{\"602\":1}}],[\"只能在commit后\",{\"1\":{\"585\":1}}],[\"只能和parnew配合使用\",{\"1\":{\"534\":1}}],[\"只能调用无参构造器\",{\"1\":{\"468\":1}}],[\"只能够在程序运行期根据实际的类型绑定相关的方法\",{\"1\":{\"420\":1}}],[\"只能够在程序运行期将调用方法的符号引用转换为直接引用\",{\"1\":{\"419\":1}}],[\"只能从i\",{\"1\":{\"200\":1}}],[\"只能说很\",{\"1\":{\"142\":1}}],[\"只包含a～z这26个英文字母的trie树\",{\"1\":{\"174\":1}}],[\"只排除\",{\"1\":{\"99\":1}}],[\"|world|||\",{\"1\":{\"996\":1}}],[\"|hello|world|||\",{\"1\":{\"996\":1}}],[\"|=\",{\"1\":{\"239\":5,\"253\":10,\"949\":2}}],[\"||\",{\"1\":{\"230\":1,\"239\":1,\"925\":1,\"934\":2,\"943\":1,\"954\":1,\"963\":1,\"969\":1,\"982\":2,\"983\":1,\"984\":1,\"1020\":4,\"1024\":3,\"1030\":1}}],[\"|\",{\"0\":{\"649\":1},\"1\":{\"85\":2,\"119\":1,\"996\":3}}],[\"将较大者赋给ans\",{\"1\":{\"930\":1,\"1039\":1}}],[\"将curlen重置为1\",{\"1\":{\"930\":1,\"1039\":1}}],[\"将文件中的统计数据画成图表\",{\"1\":{\"902\":1}}],[\"将queue中的数据写入文件\",{\"1\":{\"902\":1}}],[\"将返回结果重新打包成消息\",{\"1\":{\"874\":1}}],[\"将返回值压入调用者栈帧的操作数栈\",{\"1\":{\"424\":1}}],[\"将客户端的请求参数数据信息打包成网络消息\",{\"1\":{\"874\":1}}],[\"将用户名中包含有a并且\",{\"1\":{\"848\":1}}],[\"将对应数据中代表是否被删除字段的状态修改为\",{\"1\":{\"839\":1}}],[\"将对应数据从数据库中删除\",{\"1\":{\"839\":1}}],[\"将对象之间的相互依赖关系交给\",{\"1\":{\"595\":1}}],[\"将对象的所属类\",{\"1\":{\"473\":1}}],[\"将所有\",{\"1\":{\"822\":1}}],[\"将所有版本信息统一在父工程中进行管理\",{\"1\":{\"85\":1}}],[\"将列的别名书写为对象属性名\",{\"1\":{\"808\":1}}],[\"将插件放到\",{\"1\":{\"756\":1}}],[\"将无法收到队列的消息\",{\"1\":{\"747\":1}}],[\"将接收到的消息打印在控制台\",{\"1\":{\"734\":1}}],[\"将路由键和某模式进行匹配\",{\"1\":{\"728\":1}}],[\"将发布的消息存入\",{\"1\":{\"724\":1}}],[\"将会使用隐式栈空间\",{\"1\":{\"969\":1}}],[\"将会把这条消息转发到备份交换机中\",{\"1\":{\"767\":1}}],[\"将会感知这个情况到并再发送一条消息\",{\"1\":{\"717\":1}}],[\"将会抛出\",{\"1\":{\"485\":1}}],[\"将不会在该通道上再传递任何消息\",{\"1\":{\"717\":1}}],[\"将停止在通道上传递更多消息\",{\"1\":{\"717\":1}}],[\"将消息投入死信队列中\",{\"1\":{\"744\":1}}],[\"将消息投递到\",{\"1\":{\"744\":1}}],[\"将消息保存到磁盘\",{\"1\":{\"712\":1}}],[\"将消息标记为持久化并不能完全保证不会丢失消息\",{\"1\":{\"712\":1}}],[\"将了解到消息未完全处理\",{\"1\":{\"707\":1}}],[\"将之前通过\",{\"1\":{\"678\":1}}],[\"将之前准备好的environment设置给创建好的applicationcontext使用\",{\"1\":{\"678\":1}}],[\"将公用的模型数据\",{\"1\":{\"656\":1}}],[\"将数据序列化成二进制流\",{\"1\":{\"883\":1}}],[\"将数据和视图封装成modelandview对象\",{\"1\":{\"654\":1}}],[\"将数组转换为集合\",{\"0\":{\"234\":1}}],[\"将其封装至modelandview对象中\",{\"1\":{\"646\":1}}],[\"将其直接编译为对应平台的本地机器指令\",{\"1\":{\"368\":1}}],[\"将众多的业务逻辑聚集到一个部件里面\",{\"1\":{\"645\":1}}],[\"将需要的可变成员变量保存在\",{\"1\":{\"638\":1}}],[\"将datasource属性设置成不同的数据源\",{\"1\":{\"628\":1}}],[\"将切面和其他应用类型或对象连接起来创建一个通知对象的过程\",{\"1\":{\"604\":1}}],[\"将原本在程序中手动创建对象的控制权\",{\"1\":{\"595\":1}}],[\"将每个数组都转成字符串流stream<string>的内容\",{\"1\":{\"549\":1}}],[\"将每条字节码文件中的内容\",{\"1\":{\"358\":1}}],[\"将一个类声明为\",{\"0\":{\"618\":1}}],[\"将一块大的内存区域分割成多个小块\",{\"1\":{\"527\":1}}],[\"将一批请求放进消息队列中\",{\"1\":{\"298\":1}}],[\"将严重影响用户体验或者系统的稳定性\",{\"1\":{\"526\":1}}],[\"将采用\",{\"1\":{\"525\":1}}],[\"将内存空间分为两块\",{\"1\":{\"522\":1}}],[\"将程序员从繁重的内存管理中释放出来\",{\"1\":{\"517\":1}}],[\"将堆分配转化为栈分配\",{\"1\":{\"507\":1}}],[\"将生命周期较长的java对象从heap中移至heap外\",{\"1\":{\"505\":1}}],[\"将被移动到survivor空间中\",{\"1\":{\"498\":1}}],[\"将eden区中的不再被其他对象所引用的对象进行销毁\",{\"1\":{\"490\":1}}],[\"将抛出oom异常\",{\"1\":{\"445\":1}}],[\"将符号引用转换为调用方法的直接引用与方法的绑定机制相关\",{\"1\":{\"419\":1}}],[\"将常量池内的符号引用转换为直接引用的过程\",{\"1\":{\"379\":1}}],[\"将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\",{\"1\":{\"377\":1}}],[\"将字节码编译成机器码\",{\"1\":{\"372\":1}}],[\"将字节码文件中的内容\",{\"1\":{\"361\":1}}],[\"将引用函数代码编译到引用点处\",{\"1\":{\"372\":1}}],[\"将引用分为强引用\",{\"1\":{\"324\":1}}],[\"将有价值的字节码编译为本地机器指令\",{\"1\":{\"366\":1}}],[\"将方法编译成机器码后再执行\",{\"1\":{\"365\":1}}],[\"将锁的持有者置为当前线程\",{\"1\":{\"290\":1}}],[\"将list后distance个元素整体移到前面\",{\"1\":{\"257\":1}}],[\"将链表和数组相结合\",{\"1\":{\"244\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"将链表转换成红黑树前会判断\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"将集合\",{\"0\":{\"235\":1}}],[\"将普通字母转化为\",{\"1\":{\"143\":1}}],[\"将\",{\"1\":{\"99\":3,\"257\":1,\"359\":1,\"651\":1,\"686\":1,\"708\":1,\"806\":1}}],[\"将xx项目标记为需要聚合的项目\",{\"1\":{\"89\":1}}],[\"将你的个人介绍和档案放置在此处\",{\"1\":{\"3\":1}}],[\"为二叉树的节点个数\",{\"1\":{\"1029\":2,\"1030\":2}}],[\"为根的子树\",{\"1\":{\"1029\":1}}],[\"为1\",{\"1\":{\"926\":1}}],[\"为前\",{\"1\":{\"926\":1}}],[\"为效率而生\",{\"1\":{\"867\":1}}],[\"为任意实体对象\",{\"1\":{\"833\":1}}],[\"为需要拦截的接口生成代理对象以实现接口方法拦截功能\",{\"1\":{\"818\":1}}],[\"为不支持自增的主键生成策略标签\",{\"1\":{\"811\":1}}],[\"为收到消息的原因\",{\"1\":{\"762\":1,\"765\":1}}],[\"为一个小时的队列\",{\"1\":{\"754\":1}}],[\"为一个类创建子类\",{\"1\":{\"603\":1}}],[\"为此我们可以创建一个具有随机名称的队列\",{\"1\":{\"730\":1}}],[\"为spring\",{\"1\":{\"665\":1}}],[\"为其他对象提供一种代理以控制对这个对象的访问\",{\"1\":{\"629\":1}}],[\"为属性赋值\",{\"1\":{\"614\":1}}],[\"为避免多个线程操作同一地址\",{\"1\":{\"501\":1}}],[\"为新对象分配内存是一件非常严谨和复杂的任务\",{\"1\":{\"490\":1}}],[\"为永久代设置空间大小是很难确定的\",{\"1\":{\"462\":1}}],[\"为每个己加载的类型\",{\"1\":{\"459\":1}}],[\"为max\",{\"1\":{\"416\":1}}],[\"为类变量分配内存并且设置该类变量的默认初始值\",{\"1\":{\"379\":1}}],[\"为对象分配内存\",{\"0\":{\"471\":1,\"499\":1}}],[\"为对象分配空间的任务等同于把一块确定大小的内存从\",{\"1\":{\"311\":1}}],[\"为对应平台的本地机器指令执行\",{\"1\":{\"358\":1,\"361\":1}}],[\"为512\",{\"1\":{\"253\":1}}],[\"为什么用普通for循环\",{\"1\":{\"1035\":1}}],[\"为什么呢\",{\"1\":{\"1034\":1}}],[\"为什么采用\",{\"1\":{\"1024\":1}}],[\"为什么默认用\",{\"0\":{\"894\":1}}],[\"为什么\",{\"0\":{\"893\":1},\"1\":{\"540\":1}}],[\"为什么有tlab\",{\"0\":{\"501\":1}}],[\"为什么两个\",{\"1\":{\"465\":1}}],[\"为什么需要gc\",{\"0\":{\"516\":1}}],[\"为什么需要java堆分代\",{\"1\":{\"497\":1}}],[\"为什么需要常量池\",{\"0\":{\"457\":1}}],[\"为什么需要自定义类加载器\",{\"0\":{\"386\":1}}],[\"为什么还需要使用解释器拖累性能呢\",{\"1\":{\"365\":1}}],[\"为什么说\",{\"0\":{\"359\":1,\"823\":1}}],[\"为什么要加上上条的最后一个条件呢\",{\"1\":{\"943\":1}}],[\"为什么要用dubbo\",{\"0\":{\"881\":1}}],[\"为什么要用spring\",{\"0\":{\"665\":1}}],[\"为什么要三级缓存\",{\"0\":{\"622\":1}}],[\"为什么要停顿两次\",{\"1\":{\"518\":1}}],[\"为什么要有rpc\",{\"0\":{\"872\":1}}],[\"为什么要有gc\",{\"1\":{\"518\":1}}],[\"为什么要有新生代和老年代\",{\"1\":{\"465\":2}}],[\"为什么要调整\",{\"0\":{\"463\":1}}],[\"为什么要使用\",{\"0\":{\"435\":1}}],[\"为什么要使用集合\",{\"0\":{\"217\":1}}],[\"为什么要将永久代替换为元空间\",{\"0\":{\"306\":1}}],[\"为什么是对象的方法\",{\"0\":{\"288\":1}}],[\"为什么实现\",{\"0\":{\"230\":1}}],[\"为\",{\"1\":{\"207\":1,\"285\":1,\"738\":2,\"754\":4,\"755\":2,\"762\":5,\"765\":2,\"811\":1,\"816\":1,\"826\":1}}],[\"为经过\",{\"1\":{\"204\":1,\"205\":1}}],[\"为偶数\",{\"1\":{\"203\":1}}],[\"为了不再最后遍历dp数组来获取最大值\",{\"1\":{\"926\":1}}],[\"为了保证一致性\",{\"1\":{\"800\":1}}],[\"为了保证了可用性\",{\"1\":{\"800\":1}}],[\"为了保证订单业务的消息数据不丢失\",{\"1\":{\"744\":1}}],[\"为了保证消息在发送过程中不丢失\",{\"1\":{\"704\":1}}],[\"为了说明这种模式\",{\"1\":{\"734\":1}}],[\"为了确保还有剩余没有确认消息\",{\"1\":{\"723\":1}}],[\"为了避免这种情况\",{\"1\":{\"714\":1}}],[\"为了避免频繁地gc\",{\"1\":{\"448\":1}}],[\"为了将对象的创建和使用相分离\",{\"1\":{\"625\":1}}],[\"为了得到cms那一点好处\",{\"1\":{\"534\":1}}],[\"为了更好地控制\",{\"1\":{\"527\":1}}],[\"为了解决这个问题\",{\"1\":{\"526\":1}}],[\"为了解决这个问題\",{\"1\":{\"363\":1}}],[\"为了提高数据访问的速度\",{\"1\":{\"911\":1}}],[\"为了提高性能\",{\"1\":{\"423\":1}}],[\"为了提升性能和减少内存消耗针对字符串\",{\"1\":{\"317\":1}}],[\"为了线程切换后能恢复到正确的执行位置\",{\"1\":{\"301\":1}}],[\"为了能够准确地记录各个线程正在执行的当前字节码指令地址\",{\"1\":{\"402\":1}}],[\"为了能够对这些\",{\"1\":{\"85\":1}}],[\"为了能让\",{\"1\":{\"246\":1}}],[\"为了便于计算\",{\"1\":{\"198\":1}}],[\"为了让构建过程自动化完成\",{\"1\":{\"94\":1}}],[\"为子工程\",{\"1\":{\"85\":1}}],[\"它拥有功能强大的代码生成引擎\",{\"1\":{\"879\":1}}],[\"它有什么优点\",{\"1\":{\"875\":1}}],[\"它里面的逻辑优先运算\",{\"1\":{\"848\":1}}],[\"它里面的gc按照回收区域又分为两大种类型\",{\"1\":{\"493\":1}}],[\"它与全自动的区别在哪里\",{\"0\":{\"823\":1}}],[\"它内部封装了jdbc\",{\"1\":{\"806\":1}}],[\"它内部包含的仅仅只是一些能够被\",{\"1\":{\"355\":1}}],[\"它并不一定是我们系统生成的\",{\"1\":{\"774\":1}}],[\"它并不会自己先去加载\",{\"1\":{\"391\":1}}],[\"它消费死信队列里面的消息\",{\"1\":{\"747\":1}}],[\"它必须是一个单词列表\",{\"1\":{\"740\":1}}],[\"它告诉我们\",{\"1\":{\"731\":1}}],[\"它忽视队列和消息\",{\"1\":{\"710\":1}}],[\"它将由两个程序组成\",{\"1\":{\"734\":1}}],[\"它将很快将其重新分发给另一个消费者\",{\"1\":{\"707\":1}}],[\"它将多个类的通用行为封装为可重用的模块\",{\"1\":{\"604\":1}}],[\"它已经处理了\",{\"1\":{\"704\":1}}],[\"它不处理快件而是接收\",{\"1\":{\"691\":1}}],[\"它接受并转发消息\",{\"1\":{\"691\":1}}],[\"它包含了一系列可以集成到应用里面的依赖包\",{\"1\":{\"682\":1}}],[\"它包含在eden空间内\",{\"1\":{\"500\":1}}],[\"它主要有哪些优点\",{\"0\":{\"664\":1}}],[\"它主要有两大用途\",{\"1\":{\"533\":1}}],[\"它都会帮你拦截到请求\",{\"1\":{\"648\":1}}],[\"它通常是一个代理对象\",{\"1\":{\"604\":1}}],[\"它运行期间生成的代理对象是目标类的扩展子类\",{\"1\":{\"603\":1}}],[\"它还支持属性级别的\",{\"1\":{\"602\":1}}],[\"它还会尝试使用一种称为轻量级锁的优化手段\",{\"1\":{\"278\":1}}],[\"它就是终端操作\",{\"1\":{\"546\":1}}],[\"它就进入了一个全新的并且不再受虚拟机限制的世界\",{\"1\":{\"437\":1}}],[\"它允许你以声明性方式处理数据集合\",{\"1\":{\"544\":1}}],[\"它具备以下特点\",{\"1\":{\"535\":1}}],[\"它具有很好的灵活性\",{\"1\":{\"286\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"534\":1}}],[\"它非常符合在注重用户体验的应用上使用\",{\"1\":{\"534\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"533\":1}}],[\"它看上去几乎和\",{\"1\":{\"532\":1}}],[\"它被外部方法所引用\",{\"1\":{\"506\":1}}],[\"它被包含在进程之中\",{\"1\":{\"264\":1}}],[\"它存储每个类的结构\",{\"1\":{\"441\":1}}],[\"它甚至可以直接使用本地处理器中的寄存器\",{\"1\":{\"437\":1}}],[\"它和虚拟机拥有同样的权限\",{\"1\":{\"437\":1}}],[\"它也通过一些本地方法与外界交互\",{\"1\":{\"435\":1}}],[\"它经常依于一些底层系統的支持\",{\"1\":{\"435\":1}}],[\"它毕竟不是一个完整的系统\",{\"1\":{\"435\":1}}],[\"它由一个解释器\",{\"1\":{\"435\":1}}],[\"它为我们提供了一个非常简洁的接口\",{\"1\":{\"435\":1}}],[\"它保存方法的局部变量\",{\"1\":{\"407\":1}}],[\"它是针对\",{\"1\":{\"817\":1}}],[\"它是将接收到的所有消息广播到它知道的所有队列中\",{\"1\":{\"733\":1}}],[\"它是随你的web应用启动而启动的\",{\"1\":{\"648\":1}}],[\"它是用一种业务逻辑\",{\"1\":{\"645\":1}}],[\"它是在容器启动时\",{\"1\":{\"611\":1}}],[\"它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理\",{\"1\":{\"603\":1}}],[\"它是很多模块的集合\",{\"1\":{\"591\":1}}],[\"它是对象真正存储的有效信息\",{\"1\":{\"477\":1}}],[\"它是java程序赖以生存的平台\",{\"1\":{\"435\":1}}],[\"它是唯一一个在java虚拟机规范中没有规定任何\",{\"1\":{\"399\":1}}],[\"它是程序控制流的指示器\",{\"1\":{\"399\":1}}],[\"它是一种通过网络从远程计算机程序上请求服务\",{\"1\":{\"873\":1}}],[\"它是一种同步确认发布的方式\",{\"1\":{\"722\":1}}],[\"它是一种任务委派模式\",{\"1\":{\"390\":1}}],[\"它是一块很小的内存空间\",{\"1\":{\"399\":1}}],[\"它是专门管理其他\",{\"1\":{\"85\":1}}],[\"它负责加载环境变量\",{\"1\":{\"384\":1}}],[\"它用来加载\",{\"1\":{\"382\":1}}],[\"它采用解释器与即时编译器并存的架构\",{\"1\":{\"365\":1}}],[\"它会无时无刻提供服务\",{\"1\":{\"800\":1}}],[\"它会提前做几件事情\",{\"1\":{\"678\":1}}],[\"它会建立一个\",{\"1\":{\"340\":1}}],[\"它会从队列中取下一个任务来执行\",{\"1\":{\"277\":1}}],[\"它节省了一次指针定位的时间开销\",{\"1\":{\"315\":1}}],[\"它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署\",{\"1\":{\"875\":1}}],[\"它可以用于标签属性值和\",{\"1\":{\"810\":1}}],[\"它可以进行国际化处理\",{\"1\":{\"611\":1}}],[\"它可以不太关注程序启动速度\",{\"1\":{\"352\":1}}],[\"它可以直接使用\",{\"1\":{\"308\":1}}],[\"它可以协同多个线程\",{\"1\":{\"292\":1}}],[\"它的左右子树也为二叉搜索树\",{\"1\":{\"1029\":1}}],[\"它的左右孩子的深度+1\",{\"1\":{\"1023\":1}}],[\"它的实现类主要包括各种流\",{\"1\":{\"994\":1}}],[\"它的实现原理是什么\",{\"0\":{\"821\":1}}],[\"它的时间复杂度可以认为是o\",{\"1\":{\"940\":1}}],[\"它的关注点主要在于服务的调用\",{\"1\":{\"886\":1}}],[\"它的原理是\",{\"1\":{\"821\":1}}],[\"它的一个重要的设计目标是能够支持更长的队列\",{\"1\":{\"782\":1}}],[\"它的作用相当于一个转发器或中央处理器\",{\"1\":{\"646\":1}}],[\"它的作用是统计一个方法中循环体代码执行的次数\",{\"1\":{\"370\":1}}],[\"它的作用是\",{\"1\":{\"318\":1}}],[\"它的运作过程相比于前面几种垃圾收集器来说更加复杂一些\",{\"1\":{\"534\":1}}],[\"它的\",{\"1\":{\"530\":1}}],[\"它的具体做法是native\",{\"1\":{\"437\":1}}],[\"它的初衷是融合c\",{\"1\":{\"434\":1}}],[\"它的栈帧就越大\",{\"1\":{\"415\":1}}],[\"它的参数和局部变量越多\",{\"1\":{\"415\":1}}],[\"它的默认阈值在client模式下是1500次\",{\"1\":{\"369\":1}}],[\"它的生命周期和线程相同\",{\"1\":{\"302\":1}}],[\"它的生命周期随着线程的创建而创建\",{\"1\":{\"301\":1}}],[\"它的背景是\",{\"1\":{\"85\":1}}],[\"它创建的参数就是countdown的数量\",{\"1\":{\"292\":1}}],[\"它只允许\",{\"1\":{\"997\":1}}],[\"它只能进行无意识的广播\",{\"1\":{\"736\":1}}],[\"它只是接收请求并决定调用哪个模型构件去处理请求\",{\"1\":{\"645\":1}}],[\"它只是作为一种输出数据并允许用户操纵的方式\",{\"1\":{\"645\":1}}],[\"它只有await方法\",{\"1\":{\"292\":1}}],[\"它只会用唯一的工作线程来执行任务\",{\"1\":{\"291\":1}}],[\"它最终会收缩到\",{\"1\":{\"277\":1}}],[\"它背后的需求是\",{\"1\":{\"85\":1}}],[\"它们采用了基本数据类型和object参数的组合\",{\"1\":{\"997\":1}}],[\"它们的优缺点有哪些\",{\"0\":{\"888\":1}}],[\"它们的绑定关系如下\",{\"1\":{\"754\":1}}],[\"它们的类型都是\",{\"1\":{\"754\":1}}],[\"它们的引用计数器都不为\",{\"1\":{\"321\":1}}],[\"它们能快速持续的运行\",{\"1\":{\"682\":1}}],[\"它们基于\",{\"1\":{\"615\":1}}],[\"它们中有plus\",{\"1\":{\"565\":1}}],[\"它们就是中间操作\",{\"1\":{\"546\":1}}],[\"它们是进程私有的\",{\"1\":{\"482\":1}}],[\"它们是名字发生了改变\",{\"1\":{\"77\":1}}],[\"它们成为类数据在逻辑上的一部分\",{\"1\":{\"455\":1}}],[\"它们都只提供了一个\",{\"1\":{\"687\":1}}],[\"它们都被spring\",{\"1\":{\"682\":1}}],[\"它们都具有自己独特的优势和特点\",{\"1\":{\"525\":1}}],[\"它们都将无法再向前推进\",{\"1\":{\"269\":1}}],[\"它们都是模型化思想的具体体现\",{\"1\":{\"67\":1}}],[\"它们也不一定是相等的\",{\"1\":{\"242\":1}}],[\"它们应该是同一个版本\",{\"1\":{\"85\":1}}],[\"称之为半自动\",{\"1\":{\"823\":1}}],[\"称mybatis是半自动orm映射工具\",{\"1\":{\"806\":1}}],[\"称为restart\",{\"1\":{\"670\":1}}],[\"称为一站式解决方案\",{\"1\":{\"664\":1}}],[\"称为句柄池\",{\"1\":{\"479\":1}}],[\"称为本地线程分配缓冲区\",{\"1\":{\"471\":1}}],[\"称为常量折叠\",{\"1\":{\"317\":1}}],[\"称\",{\"1\":{\"85\":1}}],[\"74\",{\"1\":{\"753\":1,\"762\":1,\"765\":1}}],[\"75\",{\"1\":{\"649\":1}}],[\"75m\",{\"1\":{\"447\":1}}],[\"70\",{\"1\":{\"497\":1}}],[\"7bac\",{\"1\":{\"483\":1}}],[\"7版本使用\",{\"1\":{\"449\":1}}],[\"7之前运行时常量池逻辑包含字符串常量池存放在方法区\",{\"1\":{\"343\":1}}],[\"7和1\",{\"1\":{\"305\":1}}],[\"7的concurrenthashmap\",{\"1\":{\"249\":1}}],[\"7\",{\"0\":{\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":1,\"89\":1,\"90\":1,\"91\":1,\"251\":1,\"465\":1,\"527\":1,\"529\":1},\"1\":{\"106\":1,\"219\":1,\"229\":1,\"244\":4,\"248\":1,\"249\":3,\"292\":1,\"305\":1,\"307\":2,\"317\":2,\"318\":3,\"338\":3,\"339\":1,\"343\":1,\"442\":1,\"461\":1,\"483\":1,\"534\":1,\"535\":1,\"537\":1,\"678\":1,\"706\":2,\"717\":1,\"792\":2,\"874\":1,\"878\":1,\"929\":2,\"937\":2,\"939\":1,\"1038\":3}}],[\"引导类加载器\",{\"0\":{\"382\":1}}],[\"引入的三种方式\",{\"1\":{\"890\":1}}],[\"引入依赖\",{\"0\":{\"863\":1}}],[\"引入它不会对现有工程产生影响\",{\"1\":{\"827\":1}}],[\"引入消息应答机制\",{\"1\":{\"704\":1}}],[\"引入maven实质上就是导入jar包\",{\"1\":{\"683\":1}}],[\"引入允许我们在已有的类上添加新的方法或属性\",{\"1\":{\"604\":1}}],[\"引入特定的语法创建\",{\"1\":{\"603\":1}}],[\"引入了一种基于通道\",{\"1\":{\"308\":1}}],[\"引入\",{\"0\":{\"830\":1},\"1\":{\"82\":1,\"604\":1}}],[\"引用的对象\",{\"1\":{\"519\":1}}],[\"引用强度逐渐减弱\",{\"1\":{\"324\":1}}],[\"引用计数法\",{\"0\":{\"321\":1}}],[\"引用类型\",{\"1\":{\"228\":1}}],[\"引用\",{\"1\":{\"46\":1}}],[\"里新增一个方法\",{\"1\":{\"757\":1}}],[\"里了\",{\"1\":{\"744\":1}}],[\"里的引用\",{\"1\":{\"519\":1}}],[\"里面有很好的设计方法\",{\"1\":{\"996\":1}}],[\"里面有一行\",{\"1\":{\"674\":1}}],[\"里面没有一个线程\",{\"1\":{\"277\":1}}],[\"里面收集了很多有趣的代码注释\",{\"1\":{\"143\":1}}],[\"里面收集了市面上很多很好的微交互例子\",{\"1\":{\"142\":1}}],[\"里包含一个\",{\"1\":{\"251\":1}}],[\"里\",{\"1\":{\"82\":1,\"724\":1,\"754\":1}}],[\"当执行reverselist\",{\"1\":{\"970\":1}}],[\"当出现失败\",{\"1\":{\"917\":1}}],[\"当出现如下情况的时候\",{\"1\":{\"267\":1}}],[\"当当网基于dubbo做的一个扩展项目\",{\"1\":{\"914\":1}}],[\"当数据量特别大的时候\",{\"1\":{\"861\":1}}],[\"当生产者将消息发送到\",{\"1\":{\"782\":1}}],[\"当生产者生产消息到\",{\"1\":{\"738\":1}}],[\"当消费者由于各种各样的原因\",{\"1\":{\"782\":1}}],[\"当消费者从队列获取消息的时候\",{\"1\":{\"778\":1}}],[\"当消息无法路由的时候的回调方法\",{\"1\":{\"765\":2}}],[\"当消息消费发生异常时\",{\"1\":{\"744\":1}}],[\"当消息发送到rabbitmq\",{\"1\":{\"728\":1}}],[\"当消息最终得到确认之后\",{\"1\":{\"720\":1}}],[\"当更改配置了\",{\"1\":{\"768\":1}}],[\"当交换机接收到一条不可路由消息时\",{\"1\":{\"767\":1}}],[\"当达到投递时间时\",{\"1\":{\"757\":1}}],[\"当发生故障导致发布出现问题时\",{\"1\":{\"723\":1}}],[\"当发送者发送消息\",{\"1\":{\"709\":1}}],[\"当值不等于\",{\"1\":{\"717\":1}}],[\"当有多个工作线程时\",{\"1\":{\"699\":1}}],[\"当多个不同的用户使用同一个\",{\"1\":{\"693\":1}}],[\"当你要发送一个包裹时\",{\"1\":{\"691\":1}}],[\"当你把对象加入hashset时\",{\"1\":{\"242\":1}}],[\"当制定的class在容器中只有一个bean\",{\"1\":{\"675\":1}}],[\"当指定的云平台激活时才可开启配置\",{\"1\":{\"675\":1}}],[\"当指定的jndi存在时才开启配置\",{\"1\":{\"675\":1}}],[\"当指定的属性有指定的值时才可开启配置\",{\"1\":{\"675\":1}}],[\"当类路径下有指定的资源才开启配置\",{\"1\":{\"675\":1}}],[\"当类路径上的文件发生更改时\",{\"1\":{\"670\":1}}],[\"当运行的java\",{\"1\":{\"675\":1}}],[\"当spel表达式为true时才可开启配置\",{\"1\":{\"675\":1}}],[\"当set中没有包含add的元素时返回真\",{\"1\":{\"242\":1}}],[\"当容器中没有指定class才可开启配置\",{\"1\":{\"675\":1}}],[\"当容器中没有值当bean才可开启配置\",{\"1\":{\"675\":1}}],[\"当容器中有指定class才可开启配置\",{\"1\":{\"675\":1}}],[\"当容器中有指定bean才开启配置\",{\"1\":{\"675\":1}}],[\"当容器扫描到\",{\"1\":{\"601\":1}}],[\"当内部事务回滚时不会影响外部事物的提交\",{\"1\":{\"635\":1}}],[\"当内存回收不佳\",{\"1\":{\"525\":1}}],[\"当内存空间不足\",{\"1\":{\"325\":1}}],[\"当我需要用它的时候还给我\",{\"1\":{\"617\":1}}],[\"当我们为某一个交换机声明一个对应的备份交换机时\",{\"1\":{\"767\":1}}],[\"当我们需要创建一个对象的时候\",{\"1\":{\"595\":1}}],[\"当我们需要给新对象分配内存时\",{\"1\":{\"523\":1}}],[\"当我们需要保存一组类型相同的数据的时候\",{\"1\":{\"217\":1}}],[\"当我们定义一个新类\",{\"1\":{\"288\":1}}],[\"当我们只需要存放元素值时\",{\"1\":{\"216\":1}}],[\"当我们将项目打包时\",{\"1\":{\"99\":1}}],[\"当要销毁\",{\"1\":{\"614\":2}}],[\"当某一个作用域\",{\"1\":{\"813\":1}}],[\"当某连接点退出的时候执行的通知\",{\"1\":{\"604\":1}}],[\"当某个线程调用一个本地方法时\",{\"1\":{\"437\":1}}],[\"当不能确定\",{\"1\":{\"599\":1}}],[\"当向一个bean中自动装配一个属性时\",{\"1\":{\"598\":2}}],[\"当堆中的有效内存空间\",{\"1\":{\"521\":1}}],[\"当gc发生在老年代时则被称为majorgc或者fullgc\",{\"1\":{\"512\":1}}],[\"当gc只发生在年轻代中\",{\"1\":{\"512\":1}}],[\"当gc的时候先把这块存储\",{\"1\":{\"497\":1}}],[\"当它的年龄增加到一定程度\",{\"1\":{\"498\":1}}],[\"当年轻代空间不足时\",{\"1\":{\"494\":1}}],[\"当年使用永久代\",{\"1\":{\"444\":1}}],[\"当养老区内存不足时\",{\"1\":{\"490\":1}}],[\"当eden的空间填满时\",{\"1\":{\"490\":1}}],[\"当创建类或接口的运行时常量池时\",{\"1\":{\"459\":1}}],[\"当jvm加载的类信息容量超过了这个值\",{\"1\":{\"447\":1}}],[\"当java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行\",{\"1\":{\"358\":1}}],[\"当返回值是boolean\",{\"1\":{\"424\":1}}],[\"当方法调用结束后\",{\"1\":{\"415\":1}}],[\"当解析一个类型到另一个类型的引用的时候\",{\"1\":{\"396\":1}}],[\"当显式指定了\",{\"1\":{\"372\":1}}],[\"当超过一定的时间限度\",{\"1\":{\"369\":1}}],[\"当虚拟机启动的时候\",{\"1\":{\"366\":1}}],[\"当程序启动后\",{\"1\":{\"365\":1}}],[\"当一条字节码指令被解释执行完成后\",{\"1\":{\"361\":1}}],[\"当一个队列绑定键是\",{\"1\":{\"741\":1}}],[\"当一个对象的状态发生改变时\",{\"1\":{\"630\":1}}],[\"当一个对象在方法中被定义后\",{\"1\":{\"506\":2}}],[\"当一个对象到\",{\"1\":{\"322\":1}}],[\"当一个字节码文件被装载进jvm内部时\",{\"1\":{\"419\":1}}],[\"当一个方法开始执行后\",{\"1\":{\"424\":1}}],[\"当一个方法刚开始执行的时候\",{\"1\":{\"416\":1}}],[\"当一个方法被调用时\",{\"1\":{\"369\":1}}],[\"当一个线程运行到exchange\",{\"1\":{\"292\":1}}],[\"当一个线程无事可做\",{\"1\":{\"277\":1}}],[\"当一个线程完成任务时\",{\"1\":{\"277\":1}}],[\"当一个线程占用锁访问其中一个段数据时\",{\"1\":{\"251\":1}}],[\"当一个线程访问同步方法时\",{\"1\":{\"249\":1}}],[\"当父类加载器为\",{\"1\":{\"332\":1}}],[\"当父类加载器无法处理时\",{\"1\":{\"332\":1}}],[\"当垃圾回收器准备回收一个对象时\",{\"1\":{\"328\":1}}],[\"当引用失效\",{\"1\":{\"321\":1}}],[\"当常量池无法再申请到内存时会抛出\",{\"1\":{\"307\":1}}],[\"当5个人中\",{\"1\":{\"292\":1}}],[\"当countdownlatch的count计数>0时\",{\"1\":{\"292\":1}}],[\"当这个线程再次请求锁时\",{\"1\":{\"278\":1}}],[\"当然细节还是需要屏蔽的\",{\"1\":{\"919\":1}}],[\"当然也做反序列化\",{\"1\":{\"883\":1}}],[\"当然也可以自定义\",{\"1\":{\"754\":1}}],[\"当然如果\",{\"1\":{\"737\":1}}],[\"当然对于某些应用程序来说这可能已经足够了\",{\"1\":{\"722\":1}}],[\"当然这个单词列表最多不能超过\",{\"1\":{\"740\":1}}],[\"当然这种方案仍然是同步的\",{\"1\":{\"723\":1}}],[\"当然这种方式的缺点就是\",{\"1\":{\"723\":1}}],[\"当然这将使吞吐量变得很低\",{\"1\":{\"717\":1}}],[\"当然这样有可能使得消费者这边由于接收太多还来不及处理的消息\",{\"1\":{\"705\":1}}],[\"当然另一方面这种模式消费者那边可以传递过载的消息\",{\"1\":{\"705\":1}}],[\"当然你也可以使用\",{\"1\":{\"596\":1}}],[\"当然我们可以通过选项\",{\"1\":{\"502\":1}}],[\"当然开发人员可以根据具体的应用场景\",{\"1\":{\"371\":1}}],[\"当然是否需要启动jit编译器将字节码直接编译为对应平台的本地机器指令\",{\"1\":{\"368\":1}}],[\"当然方法在执行的过程中\",{\"1\":{\"356\":1}}],[\"当然了\",{\"1\":{\"288\":1}}],[\"当然就要把wait定义在这个对象所属的类中\",{\"1\":{\"288\":1}}],[\"当然\",{\"1\":{\"277\":1,\"512\":1,\"678\":1,\"758\":1,\"767\":1,\"818\":1,\"836\":1}}],[\"当调用目标方法时\",{\"1\":{\"821\":1}}],[\"当调用接口方法时\",{\"1\":{\"816\":1}}],[\"当调用\",{\"1\":{\"277\":1}}],[\"当调用wait\",{\"1\":{\"273\":1}}],[\"当线程池中线程数大于核心线程数时\",{\"1\":{\"275\":1}}],[\"当线程执行报时功能时\",{\"1\":{\"273\":1}}],[\"当线程执行wait\",{\"1\":{\"273\":1}}],[\"当队列满了\",{\"1\":{\"275\":1}}],[\"当任务到达时\",{\"1\":{\"274\":1}}],[\"当其再次想要获取这个对象的锁的时候还是可以获取的\",{\"1\":{\"271\":1,\"284\":1}}],[\"当进程处于这种僵持状态时\",{\"1\":{\"269\":1}}],[\"当distance为负数时\",{\"1\":{\"257\":1}}],[\"当distance为正数时\",{\"1\":{\"257\":1}}],[\"当对象没有覆盖\",{\"1\":{\"323\":1}}],[\"当对\",{\"1\":{\"251\":1,\"599\":1}}],[\"当冲突链表达到一定长度时\",{\"1\":{\"249\":1}}],[\"当传入一个原生数据类型数组时\",{\"1\":{\"233\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"当天热门文章\",{\"1\":{\"120\":1}}],[\"当\",{\"1\":{\"82\":1,\"365\":1,\"710\":1,\"757\":1,\"782\":1,\"813\":1}}],[\"当前节点的直径\",{\"1\":{\"1023\":1}}],[\"当前节点的深度\",{\"1\":{\"1023\":1}}],[\"当前总水量+x\",{\"1\":{\"983\":2}}],[\"当前数字\",{\"1\":{\"957\":1}}],[\"当前的腐烂值\",{\"1\":{\"943\":1}}],[\"当前的线程可以获得锁\",{\"1\":{\"278\":1}}],[\"当前是3\",{\"1\":{\"938\":1}}],[\"当前是采购订单\",{\"1\":{\"194\":1}}],[\"当前已经得到了各个厂商的支持\",{\"1\":{\"875\":1}}],[\"当前时间\",{\"1\":{\"754\":2,\"755\":2,\"757\":1,\"780\":1}}],[\"当前\",{\"1\":{\"706\":1}}],[\"当前springboot应用使用的environment准备好了咯\",{\"1\":{\"678\":1}}],[\"当前项目类型不是web项目才可开启配置\",{\"1\":{\"675\":1}}],[\"当前项目类型是web项目才可开启配置\",{\"1\":{\"675\":1}}],[\"当前项目的设置\",{\"0\":{\"18\":1},\"1\":{\"17\":1}}],[\"当前必须不能有事务\",{\"1\":{\"635\":1}}],[\"当前必须有事务\",{\"1\":{\"635\":1}}],[\"当前栈帧会传回此方法的执行结果给前一个栈帧\",{\"1\":{\"413\":1}}],[\"当前线程获取到锁\",{\"1\":{\"290\":1}}],[\"当前线程又创建了threadlocal对象\",{\"1\":{\"280\":1}}],[\"当前最大价值就为w\",{\"1\":{\"207\":1}}],[\"当前剩余的背包容量>=物品体积\",{\"1\":{\"207\":1}}],[\"当前容量为\",{\"1\":{\"207\":1}}],[\"当前枚举到哪件物品\",{\"1\":{\"207\":1}}],[\"当前工程的打包信息\",{\"1\":{\"70\":1}}],[\"当前工程的坐标信息\",{\"1\":{\"70\":1}}],[\"当前使用的是drake\",{\"1\":{\"38\":1}}],[\"当前配置\",{\"1\":{\"1\":1}}],[\"或二者的值不同\",{\"1\":{\"1019\":1}}],[\"或个人认为比较重要的类和api\",{\"1\":{\"1001\":1}}],[\"或腐烂值>=当前橘子的腐烂值\",{\"1\":{\"943\":1}}],[\"或注解来配置和映射原生信息\",{\"1\":{\"806\":1}}],[\"或信息\",{\"1\":{\"736\":1}}],[\"或超时时间内未返回\",{\"1\":{\"722\":1}}],[\"或定义核心部分的功能\",{\"1\":{\"604\":1}}],[\"或全部\",{\"1\":{\"507\":1}}],[\"或void\",{\"1\":{\"454\":1}}],[\"或方法正常退出或者异常退出的定义\",{\"1\":{\"414\":1}}],[\"或指向运行时常量池的方法引用\",{\"0\":{\"417\":1},\"1\":{\"414\":1}}],[\"或表达式栈\",{\"1\":{\"414\":1}}],[\"或系统属性\",{\"1\":{\"384\":1}}],[\"或从\",{\"1\":{\"383\":1}}],[\"或从常量池中查找\",{\"1\":{\"317\":1}}],[\"或简称为osr\",{\"1\":{\"368\":1}}],[\"或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点\",{\"1\":{\"365\":1}}],[\"或工作任务\",{\"0\":{\"361\":1}}],[\"或runtime类的halt方法\",{\"1\":{\"347\":1}}],[\"或被\",{\"1\":{\"331\":1}}],[\"或notifyall\",{\"1\":{\"288\":1}}],[\"或lockinterruptibly\",{\"1\":{\"282\":1}}],[\"或遍历时的下班与k比较\",{\"1\":{\"186\":1}}],[\"或对比某两项技术的热度\",{\"1\":{\"122\":1}}],[\"或\",{\"1\":{\"81\":1,\"200\":1,\"216\":2,\"275\":1,\"319\":1,\"323\":1,\"382\":1,\"495\":1,\"577\":1,\"676\":1,\"745\":1,\"762\":1,\"813\":1}}],[\"或者看一些知识点\",{\"1\":{\"893\":1}}],[\"或者自己思考过\",{\"1\":{\"893\":1}}],[\"或者类里的方法上加上\",{\"1\":{\"866\":1}}],[\"或者需求变化较多的项目\",{\"1\":{\"806\":1}}],[\"或者可按自己的规则生成一个全局唯一\",{\"1\":{\"773\":1}}],[\"或者可以根据计算的需要进行扩展\",{\"1\":{\"441\":1}}],[\"或者订单消费者消费\",{\"1\":{\"773\":1}}],[\"或者写个唯一标识比如时间戳\",{\"1\":{\"773\":1}}],[\"或者都开启😸\",{\"1\":{\"764\":1}}],[\"或者利用\",{\"1\":{\"758\":1}}],[\"或者直接到queue\",{\"1\":{\"744\":1}}],[\"或者能让服务器为我们选择一个随机队列名称那就更好了\",{\"1\":{\"730\":1}}],[\"或者改变其他存储任务的策略\",{\"1\":{\"714\":1}}],[\"或者重新创建一个持久化的队列\",{\"1\":{\"711\":1}}],[\"或者同时有多个但为首选时才开启配置\",{\"1\":{\"675\":1}}],[\"或者使用threadlocal\",{\"1\":{\"653\":1}}],[\"或者使用快捷键alt\",{\"1\":{\"11\":1}}],[\"或者做其它业务逻辑的操作\",{\"1\":{\"648\":1}}],[\"或者在网络重连后再次发送给该消费者\",{\"1\":{\"772\":1}}],[\"或者在代码里手动开启\",{\"1\":{\"764\":1}}],[\"或者在方法后调用一个方法比如动态代理就是拦截器的简单实现\",{\"1\":{\"648\":1}}],[\"或者在创建新的线程时没有足够的内存去创建对应的本地方法栈\",{\"1\":{\"437\":1}}],[\"或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈\",{\"1\":{\"409\":1}}],[\"或者软件的客户端界面\",{\"1\":{\"645\":1}}],[\"或者上一次的commit\",{\"1\":{\"585\":1}}],[\"或者本月中的某一天\",{\"1\":{\"569\":1}}],[\"或者我们对程序的效率很在意时\",{\"1\":{\"435\":1}}],[\"或者\",{\"1\":{\"399\":1,\"442\":1,\"535\":1,\"655\":1,\"687\":2,\"702\":1,\"773\":1,\"954\":1}}],[\"或者对该静态变量賦值\",{\"1\":{\"397\":1}}],[\"或者一个循环体宄竟需要执行多少次循环才可以达到这个标准\",{\"1\":{\"368\":1}}],[\"或者是一个方注体内部循环次数较多的循环体都可以被称之为\",{\"1\":{\"368\":1}}],[\"或者更快地分配内存\",{\"1\":{\"304\":1}}],[\"或者分配\",{\"1\":{\"280\":1}}],[\"或者说非常低才行\",{\"1\":{\"522\":1}}],[\"或者说是虚拟机栈中局部变量表部分\",{\"1\":{\"302\":1}}],[\"或者说进程之内独立执行的一个单元\",{\"1\":{\"264\":1}}],[\"或者说依赖信息组合\",{\"1\":{\"85\":1}}],[\"或者图片\",{\"1\":{\"139\":1}}],[\"或者部署到服务器上运行\",{\"1\":{\"94\":1}}],[\"或者ctrl\",{\"1\":{\"16\":1}}],[\"时长主要取决于网速和本地磁盘性能\",{\"1\":{\"1011\":1}}],[\"时网络中断\",{\"1\":{\"772\":1}}],[\"时会取到该消息的\",{\"1\":{\"728\":1}}],[\"时会产生二次行为\",{\"1\":{\"230\":1}}],[\"时指定一组键值对\",{\"1\":{\"728\":1}}],[\"时也不报错\",{\"1\":{\"599\":1}}],[\"时所需要的时间就越长\",{\"1\":{\"527\":1}}],[\"时期的\",{\"1\":{\"464\":1}}],[\"时代我们一般通过\",{\"1\":{\"595\":1}}],[\"时代\",{\"1\":{\"359\":1}}],[\"时才醒来\",{\"1\":{\"273\":1}}],[\"时才能释放锁\",{\"1\":{\"271\":1,\"284\":1}}],[\"时将链表\",{\"1\":{\"252\":1}}],[\"时就已经存在\",{\"1\":{\"231\":1}}],[\"时\",{\"1\":{\"184\":1,\"204\":1,\"205\":1,\"222\":1,\"239\":1,\"245\":1,\"277\":1,\"292\":1,\"332\":1,\"372\":1,\"496\":1,\"498\":1,\"525\":1,\"599\":1,\"730\":1,\"757\":1,\"913\":1,\"915\":1}}],[\"时使用\",{\"1\":{\"81\":2}}],[\"时使用的依赖范围\",{\"1\":{\"81\":1}}],[\"时间和空间均为o\",{\"1\":{\"1034\":1,\"1035\":1}}],[\"时间及时死亡\",{\"1\":{\"756\":1}}],[\"时间api的格式化与解析不需要再创建转换器对象了\",{\"1\":{\"573\":1}}],[\"时间单位\",{\"0\":{\"568\":1}}],[\"时间对象\",{\"1\":{\"565\":1}}],[\"时间表示为纳秒精度\",{\"1\":{\"561\":1}}],[\"时间日期类包含localdate\",{\"1\":{\"555\":1}}],[\"时间成本相对较高\",{\"1\":{\"278\":2}}],[\"时间一到则自动恢复\",{\"1\":{\"273\":1}}],[\"时间片用完\",{\"1\":{\"267\":1}}],[\"时间复杂度是\",{\"1\":{\"968\":1}}],[\"时间复杂度近似为\",{\"1\":{\"229\":1}}],[\"时间复杂度就为\",{\"1\":{\"229\":1}}],[\"时间复杂度为n\",{\"1\":{\"199\":1}}],[\"时间复杂度\",{\"1\":{\"184\":1,\"194\":1,\"948\":1,\"949\":1,\"957\":1,\"968\":1,\"969\":1,\"1029\":1,\"1030\":1}}],[\"时间复杂度内找到一组数据的第k大元素\",{\"1\":{\"171\":1}}],[\"时间\",{\"1\":{\"80\":2,\"186\":1,\"189\":1,\"190\":1,\"747\":1,\"748\":1,\"755\":3,\"931\":1,\"1040\":1}}],[\"而通过root得到的直径\",{\"1\":{\"1023\":1}}],[\"而通过异常退出的\",{\"1\":{\"424\":1}}],[\"而该问题可以使用gcd算法\",{\"1\":{\"984\":1}}],[\"而当前这条路径3分钟即可感染橘子\",{\"1\":{\"943\":1}}],[\"而当前线程持有读锁来保证数据的可见性\",{\"1\":{\"279\":1}}],[\"而像classloaderfilter则只是在主功能上添加了功能\",{\"1\":{\"905\":1}}],[\"而分\",{\"1\":{\"883\":1}}],[\"而rpc框架的实现目标则是将上面的第2\",{\"1\":{\"874\":1}}],[\"而要实现rpc的功能\",{\"1\":{\"872\":1}}],[\"而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了\",{\"1\":{\"464\":1}}],[\"而表中的字段使用的是下划线命名风格\",{\"1\":{\"837\":1}}],[\"而实体类里注解名为id\",{\"1\":{\"836\":1}}],[\"而实例变量是会随着对象一起分配到java堆中\",{\"1\":{\"379\":1}}],[\"而方法中只有一个object参数收集\",{\"1\":{\"819\":1}}],[\"而非物理分页\",{\"1\":{\"817\":1}}],[\"而惰性队列仅仅占用\",{\"1\":{\"784\":1}}],[\"而致使长时间内不能消费消息造成堆积时\",{\"1\":{\"782\":1}}],[\"而曾经我们的后端系统是使用\",{\"1\":{\"776\":1}}],[\"而第二个消息的延时时长很短\",{\"1\":{\"755\":1}}],[\"而第二种方式\",{\"1\":{\"752\":1}}],[\"而处理慢的那个消费者一直在干活\",{\"1\":{\"714\":1}}],[\"而另外一个消费者\",{\"1\":{\"714\":1}}],[\"而后给消费者\",{\"1\":{\"708\":1}}],[\"而后者使用list\",{\"1\":{\"230\":1}}],[\"而过滤器只能在容器初始化时被调用一次\",{\"1\":{\"648\":1}}],[\"而过滤器不能\",{\"1\":{\"648\":1}}],[\"而过滤器则可以对几乎所有的请求起作用\",{\"1\":{\"648\":1}}],[\"而过滤器是基于函数回调\",{\"1\":{\"648\":1}}],[\"而拦截器不依赖与servlet容器\",{\"1\":{\"648\":1}}],[\"而将一些步骤延迟到子类中\",{\"1\":{\"632\":1}}],[\"而decorator是增加职责\",{\"1\":{\"629\":1}}],[\"而applicationcontext则是自动注册\",{\"1\":{\"611\":1}}],[\"而applicationcontext则相反\",{\"1\":{\"611\":1}}],[\"而applicationcontext则在初始化自身是检验\",{\"1\":{\"611\":1}}],[\"而使用factorybean\",{\"1\":{\"610\":1}}],[\"而动态代理是在运行时动态生成类字节码\",{\"1\":{\"607\":1}}],[\"而如果某个类没有实现接口\",{\"1\":{\"606\":1}}],[\"而proxy利用invocationhandler动态创建一个符合某一接口的实例\",{\"1\":{\"603\":1}}],[\"而在消费者消费到相应的消息时才会被加载到内存中\",{\"1\":{\"782\":1}}],[\"而在另一种情况下\",{\"1\":{\"600\":1}}],[\"而在hashmap的putval\",{\"1\":{\"242\":1}}],[\"而flatmap\",{\"1\":{\"549\":1}}],[\"而复制算法内存利用率不高的问题\",{\"1\":{\"525\":1}}],[\"而未被标记的内存会被清理掉\",{\"1\":{\"523\":1}}],[\"而经常造成stw的gc又跟不上实际的需求\",{\"1\":{\"516\":1}}],[\"而很多对象都是朝生夕死的\",{\"1\":{\"497\":1}}],[\"而并不是和对象一样\",{\"1\":{\"464\":1}}],[\"而并不是和对象一样不使用了就会必然被回收\",{\"1\":{\"329\":1}}],[\"而符号引用则属于编译原理方面的概念\",{\"1\":{\"464\":1}}],[\"而我们开发中会有大量的字符串被创建\",{\"1\":{\"463\":1}}],[\"而元空间和永久代之间最大的区别在于\",{\"1\":{\"462\":1}}],[\"而javassist\",{\"1\":{\"894\":1}}],[\"而java中的字节码需要数据支持\",{\"1\":{\"457\":1}}],[\"而java栈\",{\"1\":{\"343\":1}}],[\"而本地方法栈用于管理本地方法的调用\",{\"1\":{\"437\":1}}],[\"而本地方法栈则为虚拟机使用到的\",{\"1\":{\"303\":1}}],[\"而堆是存储的单位\",{\"1\":{\"405\":1}}],[\"而引导类加载器在加载的过程中会先加载jdk自带的文件\",{\"1\":{\"392\":1}}],[\"而永久代己经被元数据区取代\",{\"1\":{\"511\":1}}],[\"而永久代\",{\"1\":{\"374\":1}}],[\"而不需要了解底层网络技术的协议\",{\"1\":{\"873\":1}}],[\"而不需要到处找示例代码和依赖包\",{\"1\":{\"682\":1}}],[\"而不存储哪些警告\",{\"1\":{\"736\":1}}],[\"而不得不等待它完成\",{\"1\":{\"699\":1}}],[\"而不仅仅局限于jsp\",{\"1\":{\"644\":1}}],[\"而不能针对类\",{\"1\":{\"603\":1}}],[\"而不必等待即时编译器全部编译完成再执行\",{\"1\":{\"366\":1}}],[\"而不必等待即时编译器全部编译完成后再执行\",{\"1\":{\"365\":1}}],[\"而不是参数数组\",{\"1\":{\"997\":1}}],[\"而不是目标节点\",{\"1\":{\"964\":1}}],[\"而不是自己再次消费\",{\"1\":{\"706\":1}}],[\"而不是临时编写一个实现\",{\"1\":{\"544\":1}}],[\"而不是整个堆空间\",{\"1\":{\"527\":1}}],[\"而不是堆分配\",{\"1\":{\"507\":1}}],[\"而不是基本类型\",{\"1\":{\"233\":1}}],[\"而不是转换为红黑树\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"而模板解释器将每一条字节码和一个模板函数相关联\",{\"1\":{\"362\":1}}],[\"而虚拟机的执行引擎则是由软件自行实现的\",{\"1\":{\"355\":1}}],[\"而soap可以看着是一个重量级的协议\",{\"1\":{\"875\":1}}],[\"而spring\",{\"1\":{\"667\":2,\"886\":1}}],[\"而springmvc在spring与springmvc整合的配置文件中配置\",{\"1\":{\"648\":1}}],[\"而struts2入口是一个filter过虑器\",{\"1\":{\"654\":1}}],[\"而s2\",{\"1\":{\"319\":1}}],[\"而s1指向堆\",{\"1\":{\"319\":1}}],[\"而synchronized关键字就相当于整个\",{\"1\":{\"286\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"286\":1}}],[\"而对于左子树\",{\"1\":{\"1024\":1}}],[\"而对于面试题\",{\"1\":{\"964\":1}}],[\"而对于没有实现接口的对象\",{\"1\":{\"596\":1}}],[\"而对于碎片问题\",{\"1\":{\"525\":1}}],[\"而对于str4\",{\"1\":{\"317\":1}}],[\"而对应的状态变量也是由该对象锁保护的\",{\"1\":{\"288\":1}}],[\"而句柄中包含了对象实例数据与类型数据各自的具体地址信息\",{\"1\":{\"315\":1}}],[\"而每个栈帧中都拥有\",{\"1\":{\"302\":1}}],[\"而每一个目标都和生命周期中的某一个环节对应\",{\"1\":{\"98\":1}}],[\"而countdownlatch是使用countdown\",{\"1\":{\"292\":1}}],[\"而condition实例的signalall\",{\"1\":{\"286\":1}}],[\"而固有锁对象与固有条件队列对象又是同一个对象\",{\"1\":{\"288\":1}}],[\"而交给用户分析就违反了jvm的设计初衷\",{\"1\":{\"278\":1}}],[\"而操作系统实现线程之间的切换时需要从用户态转换到核心态\",{\"1\":{\"278\":1}}],[\"而wait\",{\"1\":{\"273\":3}}],[\"而把执行机会让给其他线程\",{\"1\":{\"273\":1}}],[\"而是要自己实现\",{\"0\":{\"893\":1}}],[\"而是存储在\",{\"1\":{\"757\":1}}],[\"而是存储在cpu寄存器\",{\"1\":{\"507\":1}}],[\"而是宽松意义上的一周\",{\"1\":{\"751\":1}}],[\"而是使用了\",{\"1\":{\"740\":1}}],[\"而是使用本地内存\",{\"1\":{\"445\":1,\"462\":1}}],[\"而是根据发送的消息内容中的headers属性进行匹配\",{\"1\":{\"728\":1}}],[\"而是工厂bean\",{\"1\":{\"625\":1}}],[\"而是映射成流的内容\",{\"1\":{\"549\":1}}],[\"而是把需要清除的对象地址保存在空闲的地址列表里\",{\"1\":{\"521\":1}}],[\"而是把这个请求委托给父类的加载器去执行\",{\"1\":{\"391\":1}}],[\"而是只能通过标准的入栈\",{\"1\":{\"416\":1}}],[\"而是建议把自定义的类加载逻辑写在\",{\"1\":{\"387\":1}}],[\"而是一个相对的执行频率\",{\"1\":{\"369\":1}}],[\"而是将所有派生于抽象类\",{\"1\":{\"381\":1}}],[\"而是将整个函数体编译成为机器码\",{\"1\":{\"363\":1}}],[\"而是将堆中这个对象的引用直接放到常量池中\",{\"1\":{\"318\":1}}],[\"而是每个类加载器加载自己的话就会出现一些问题\",{\"1\":{\"333\":1}}],[\"而是花费在执行代码上\",{\"1\":{\"290\":1}}],[\"而是直接在堆上分配\",{\"1\":{\"511\":1}}],[\"而是直接调用父类的wait\",{\"1\":{\"288\":1}}],[\"而是直接用\",{\"1\":{\"249\":1}}],[\"而是因为threadlocalmap的生命周期与当前线程一样长\",{\"1\":{\"280\":1}}],[\"而是作为一个key来让线程从threadlocal获取value\",{\"1\":{\"280\":1}}],[\"而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定\",{\"1\":{\"278\":1}}],[\"而是\",{\"1\":{\"249\":1,\"332\":1}}],[\"而是数组对象本身\",{\"1\":{\"233\":1}}],[\"而linkedlist\",{\"1\":{\"231\":1}}],[\"而\",{\"0\":{\"285\":1},\"1\":{\"229\":3,\"231\":1,\"239\":1,\"281\":1,\"311\":1,\"315\":2,\"463\":1,\"471\":1,\"599\":1,\"602\":1,\"617\":1,\"686\":1,\"728\":1,\"823\":1,\"892\":1,\"894\":1}}],[\"而行号从1开始\",{\"1\":{\"201\":1}}],[\"而这些配置类上\",{\"1\":{\"674\":1}}],[\"而这个注册表的缓存是hashmap对象\",{\"1\":{\"616\":1}}],[\"而这个范围的\",{\"1\":{\"80\":1}}],[\"而这段时间就称为此方法统计的半衰周期\",{\"1\":{\"369\":1}}],[\"而这两个目标都是由\",{\"1\":{\"98\":1}}],[\"而继承则是指明某个模块工程要继承另一个模块功能\",{\"1\":{\"89\":1}}],[\"而往往这种情况都是为了避免\",{\"1\":{\"82\":1}}],[\"而且设置\",{\"1\":{\"767\":1}}],[\"而且这段代码会用到jdbctemplate中的变量\",{\"1\":{\"632\":1}}],[\"而且这项技术到如今也并不是十分成熟的\",{\"1\":{\"511\":1}}],[\"而且不同的客户在每次访问中根据需要会去访问不同的数据库\",{\"1\":{\"628\":1}}],[\"而且很多地方我们只能通过\",{\"1\":{\"617\":1}}],[\"而且重载形式对边\",{\"1\":{\"565\":1}}],[\"而且在执行完内存回收后还会产生内存碎片\",{\"1\":{\"523\":1}}],[\"而且我们无需去了解java应用之外的繁琐的细节\",{\"1\":{\"435\":1}}],[\"而且加载某个类的\",{\"1\":{\"390\":1}}],[\"而且也可能导致\",{\"1\":{\"308\":1}}],[\"而且是新鲜橘子\",{\"1\":{\"944\":1}}],[\"而且是\",{\"1\":{\"286\":1}}],[\"而且总是由同一线程多次获得\",{\"1\":{\"278\":1}}],[\"而且正在运行的线程数量大于或等于\",{\"1\":{\"277\":1}}],[\"而且正在运行的线程数量小于\",{\"1\":{\"277\":1}}],[\"而且赋值与修改元素也很简单\",{\"1\":{\"228\":1}}],[\"而且长度可变\",{\"1\":{\"225\":1,\"227\":1}}],[\"而且会自动按照正确的顺序执行\",{\"1\":{\"90\":1}}],[\"而且\",{\"1\":{\"82\":1,\"217\":1,\"892\":1}}],[\"而构建相关的命令要在\",{\"1\":{\"72\":1}}],[\"范围内\",{\"1\":{\"953\":1}}],[\"范围内的值通常可提供最佳的吞吐量\",{\"1\":{\"717\":1}}],[\"范围\",{\"1\":{\"81\":2}}],[\"范围依赖的jar包不会放入war包\",{\"1\":{\"80\":1}}],[\"范围依赖进来\",{\"1\":{\"80\":2}}],[\"范围进行依赖的\",{\"1\":{\"80\":1}}],[\"以相同的方式遍历右子树\",{\"1\":{\"1024\":1}}],[\"以当前这种状态进行格式转化\",{\"1\":{\"982\":1}}],[\"以消费者端为主\",{\"1\":{\"918\":1}}],[\"以减少用户加缓存的工作量\",{\"1\":{\"911\":1}}],[\"以减少搜索时间\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"以实现更多的功能\",{\"1\":{\"872\":1}}],[\"以标签的形式编写动态\",{\"1\":{\"812\":1}}],[\"以点号分隔开\",{\"1\":{\"740\":1}}],[\"以节省磁盘空间\",{\"1\":{\"735\":1}}],[\"以记录重要的信息而后重新发布消息\",{\"1\":{\"723\":1}}],[\"以避免缓冲区里面无限制的未确认消息问题\",{\"1\":{\"717\":1}}],[\"以避免浪费处理器资源\",{\"1\":{\"278\":1}}],[\"以java应用程序进行执行\",{\"1\":{\"666\":1}}],[\"以jdk代理为例\",{\"1\":{\"603\":1}}],[\"以降低组件之间的耦合性\",{\"1\":{\"646\":1}}],[\"以降低耦合性\",{\"1\":{\"600\":1}}],[\"以非事务方式执行\",{\"1\":{\"635\":1}}],[\"以非事务方式执行操作\",{\"1\":{\"635\":1}}],[\"以到达切换数据源的目的\",{\"1\":{\"628\":1}}],[\"以取代原有对象行为的执行\",{\"1\":{\"603\":1}}],[\"以上的代码量\",{\"1\":{\"807\":1}}],[\"以上\",{\"1\":{\"724\":1,\"1003\":1}}],[\"以上说的bean\",{\"1\":{\"599\":1}}],[\"以上缺点\",{\"1\":{\"534\":1}}],[\"以极高概率满足\",{\"1\":{\"535\":1}}],[\"以达到对老年代内存的整理\",{\"1\":{\"525\":1}}],[\"以达到更快的编译速度\",{\"1\":{\"372\":1}}],[\"以提高垃圾回收的效率\",{\"1\":{\"525\":1}}],[\"以提供良好的性能\",{\"1\":{\"230\":1}}],[\"以此类推\",{\"1\":{\"939\":1,\"1024\":1}}],[\"以此来完成动态\",{\"1\":{\"812\":1}}],[\"以此达到降低gc的回收频率和提升gc的回收效率的目的\",{\"1\":{\"505\":1}}],[\"以此提升java程序的执行性能\",{\"1\":{\"368\":1}}],[\"以保证不会对方法区造成过大的内存压力\",{\"1\":{\"464\":1}}],[\"以保证可接受的性能\",{\"1\":{\"230\":1}}],[\"以满足方法调用所需传递的信息增大的需求\",{\"1\":{\"415\":1}}],[\"以满足一些特殊的需求\",{\"1\":{\"387\":1}}],[\"以换取更高的程序执行效率\",{\"1\":{\"366\":1}}],[\"以reentrantlock为例\",{\"0\":{\"289\":1}}],[\"以前sun公司的bug列表中\",{\"1\":{\"464\":1}}],[\"以前我们使用的大部分引用实际上都是强引用\",{\"1\":{\"325\":1}}],[\"以前\",{\"1\":{\"278\":1}}],[\"以便提高回收效率\",{\"1\":{\"525\":1}}],[\"以便jvm将整理出的内存分配给新的对象\",{\"1\":{\"516\":1}}],[\"以便让自己每隔一秒执行一次\",{\"1\":{\"273\":1}}],[\"以便它们可以\",{\"1\":{\"106\":1}}],[\"以下为控制台中持久化与非持久化队列的\",{\"1\":{\"711\":1}}],[\"以下列出的文章均来自网络\",{\"1\":{\"262\":1}}],[\"以下内容摘自我的\",{\"1\":{\"242\":1}}],[\"以下内容出自javaguide\",{\"1\":{\"238\":1}}],[\"以下内容中题目为转载\",{\"1\":{\"165\":1}}],[\"以及通过判断它的返回值\",{\"1\":{\"983\":1}}],[\"以及通过对象头中的元数据指针定位到目标对象的类型信息\",{\"1\":{\"356\":1}}],[\"以及消费者远大于提供者\",{\"1\":{\"888\":1}}],[\"以及软负载均衡\",{\"1\":{\"885\":1}}],[\"以及如何编写一个插件\",{\"0\":{\"818\":1}}],[\"以及新版本中该类被弃用后的替代品的使用方法\",{\"1\":{\"787\":1}}],[\"以及后续发送给该消费这的消息\",{\"1\":{\"704\":1}}],[\"以及本地化样式\",{\"1\":{\"573\":1}}],[\"以及以前的版本中与\",{\"1\":{\"533\":1}}],[\"以及gc\",{\"1\":{\"450\":1}}],[\"以及方法和构造函数的代码\",{\"1\":{\"441\":1}}],[\"以及returnaddress类型\",{\"1\":{\"415\":1}}],[\"以及激进优化\",{\"1\":{\"372\":1}}],[\"以及其他辅助信息\",{\"1\":{\"355\":1}}],[\"以及\",{\"1\":{\"245\":1,\"464\":2}}],[\"以后就可以拦截相关的请求\",{\"1\":{\"648\":1}}],[\"以后\",{\"1\":{\"249\":1,\"324\":1}}],[\"以后的\",{\"1\":{\"239\":1}}],[\"以后在解决哈希冲突时有了较大的变化\",{\"1\":{\"222\":1}}],[\"以最新标准为基准的js教程\",{\"1\":{\"119\":1}}],[\"以让其它开发人员共享\",{\"1\":{\"94\":1}}],[\"以让其它项目依赖\",{\"1\":{\"94\":1}}],[\"以\",{\"1\":{\"80\":1,\"90\":1,\"525\":1,\"701\":1,\"905\":1,\"996\":1}}],[\"以树形结构查看当前\",{\"1\":{\"78\":1}}],[\"通讯\",{\"1\":{\"888\":1}}],[\"通讯协议\",{\"1\":{\"873\":1}}],[\"通信协议\",{\"1\":{\"881\":1}}],[\"通知将在这些位置执行\",{\"1\":{\"604\":1}}],[\"通知表示在方法执行前后需要执行的动作\",{\"1\":{\"604\":1}}],[\"通知\",{\"1\":{\"604\":1,\"627\":1}}],[\"通知机制\",{\"1\":{\"286\":1}}],[\"通过流\",{\"1\":{\"991\":1}}],[\"通过执行\",{\"1\":{\"983\":1}}],[\"通过执行拦截器重的内容增强了代理方法的功能\",{\"1\":{\"627\":1}}],[\"通过记录每个数字出现的次数来计算结果\",{\"1\":{\"939\":1}}],[\"通过dubbo隐式传参的功能\",{\"1\":{\"910\":1}}],[\"通过名字去文件里面找到对应的实现类全限定名然后加载实例化\",{\"1\":{\"893\":1}}],[\"通过注册中心引入\",{\"1\":{\"890\":1}}],[\"通过注解或者xml配置\",{\"1\":{\"646\":1}}],[\"通过调用本地服务的方式调用需要消费的服务\",{\"1\":{\"874\":1}}],[\"通过xml\",{\"1\":{\"806\":1}}],[\"通过哪个路由\",{\"1\":{\"765\":1}}],[\"通过设置\",{\"1\":{\"764\":1}}],[\"通过参数来自定义一个类型\",{\"1\":{\"757\":1}}],[\"通过空字符串\",{\"1\":{\"729\":1}}],[\"通过程序执行发现生产者总共发送\",{\"1\":{\"701\":1}}],[\"通过监控类路径资源\",{\"1\":{\"670\":1}}],[\"通过ognl存取数据\",{\"1\":{\"654\":1}}],[\"通过开启\",{\"1\":{\"652\":1}}],[\"通过maven导入各种jar包\",{\"1\":{\"664\":1}}],[\"通过modelandview对象中的view信息将逻辑视图名解析成真正的视图view\",{\"1\":{\"646\":1}}],[\"通过minor\",{\"1\":{\"496\":1}}],[\"通过三级缓存提前拿到未初始化的对象\",{\"1\":{\"621\":1}}],[\"通过不同类型的aware接口拿到spring容器的资源\",{\"1\":{\"614\":1}}],[\"通过代理一个bean对象\",{\"1\":{\"610\":1}}],[\"通过修改字节码生成成成一个子类\",{\"1\":{\"606\":1}}],[\"通过时间日期对象的parse\",{\"1\":{\"573\":1}}],[\"通过查看发现temporaladjuster是一个接口\",{\"1\":{\"569\":1}}],[\"通过查询语句来表达\",{\"1\":{\"544\":1}}],[\"通过逃逸分析\",{\"1\":{\"506\":1}}],[\"通过栈上\",{\"1\":{\"479\":1}}],[\"通过垃圾回收器的日志可以观察到full\",{\"1\":{\"448\":1}}],[\"通过使用本地方法\",{\"1\":{\"435\":1}}],[\"通过异常完成出口退出的不会给他的上层调用者产生任何的返回值\",{\"1\":{\"424\":1}}],[\"通过网络获取\",{\"1\":{\"378\":1}}],[\"通过一个类的全限定名获取定义此类的二进制字节流\",{\"1\":{\"377\":1}}],[\"通过一系列的称为\",{\"1\":{\"322\":1}}],[\"通过命令显式地为jvm指定在运行时到底是完全采用解释器执行\",{\"1\":{\"371\":1}}],[\"通过编译器与解释器协同工作\",{\"1\":{\"351\":1}}],[\"通过计数器找到最具编译价值的代码\",{\"1\":{\"351\":1}}],[\"通过上方参数设置\",{\"1\":{\"338\":1}}],[\"通过这种方式消除没有必要的锁\",{\"1\":{\"278\":1}}],[\"通过对运行上下文的扫描\",{\"1\":{\"278\":1}}],[\"通过重复利用已创建的线程降低线程创建和销毁造成的消耗\",{\"1\":{\"274\":1}}],[\"通过set的大小\",{\"1\":{\"186\":1}}],[\"通过下标判断窗口大小\",{\"1\":{\"186\":1}}],[\"通过卷积网络放大图片\",{\"1\":{\"132\":1}}],[\"通过坐标\",{\"1\":{\"88\":1}}],[\"通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范\",{\"1\":{\"85\":1}}],[\"通过\",{\"1\":{\"80\":1,\"131\":1,\"244\":1,\"286\":1,\"384\":1,\"427\":1,\"447\":2,\"525\":1,\"651\":1,\"758\":1,\"811\":1,\"827\":1,\"970\":1}}],[\"通常用于通知所有提供者更新缓存或日志等本地资源信息\",{\"1\":{\"917\":1}}],[\"通常用于实时性要求较高的读操作\",{\"1\":{\"917\":1}}],[\"通常用于消息通知操作\",{\"1\":{\"917\":1}}],[\"通常用于写入审计日志等操作\",{\"1\":{\"917\":1}}],[\"通常用于非幂等性的写操作\",{\"1\":{\"917\":1}}],[\"通常用于读操作\",{\"1\":{\"917\":1}}],[\"通常配合select\",{\"1\":{\"849\":1}}],[\"通常一个\",{\"1\":{\"816\":1}}],[\"通常备份交换机的类型为\",{\"1\":{\"767\":1}}],[\"通常生产者甚至都不知道这些消息传递传递到了哪些队列中\",{\"1\":{\"727\":1}}],[\"通常\",{\"1\":{\"717\":1}}],[\"通常每个\",{\"1\":{\"693\":1}}],[\"通常由应用程序直接使用new创建新的对象\",{\"1\":{\"625\":1}}],[\"通常使用temporaladjusters来生成\",{\"1\":{\"569\":1}}],[\"通常使用的第三方框架的\",{\"1\":{\"80\":1}}],[\"通常被视为年\",{\"1\":{\"562\":1}}],[\"通常被视为年月日\",{\"1\":{\"560\":1}}],[\"通常被看作是小时\",{\"1\":{\"561\":1}}],[\"通常需要活对象的2倍空间\",{\"1\":{\"524\":1}}],[\"通常说的本地方法\",{\"1\":{\"519\":1}}],[\"通常会将\",{\"1\":{\"485\":1}}],[\"通常都是从survivor区域筛选拷贝过来的java对象\",{\"1\":{\"512\":1}}],[\"通常都需要\",{\"1\":{\"464\":1}}],[\"通常都会将解释执行与编译执行二者结合起来进行\",{\"1\":{\"359\":1}}],[\"通常这种数据会很大以至于不能直接存到字节码里\",{\"1\":{\"457\":1}}],[\"通常指synchronized\",{\"1\":{\"372\":1}}],[\"通常为常数时间\",{\"1\":{\"230\":1}}],[\"通常是组合使用的\",{\"1\":{\"89\":1}}],[\"通常以\",{\"1\":{\"80\":1}}],[\"通用service\",{\"0\":{\"833\":1}}],[\"通用的注解\",{\"1\":{\"618\":1}}],[\"通用\",{\"0\":{\"37\":1},\"1\":{\"827\":1,\"833\":1}}],[\"有两个容量分别为\",{\"1\":{\"981\":1}}],[\"有两种情况\",{\"1\":{\"974\":1}}],[\"有两种变形\",{\"1\":{\"468\":1}}],[\"有两种方式设置\",{\"1\":{\"752\":1}}],[\"有两种方式\",{\"1\":{\"424\":1}}],[\"有几个细节\",{\"1\":{\"935\":1}}],[\"有利于动态调整提供者权重\",{\"1\":{\"916\":1}}],[\"有利于组件之间的拓展\",{\"1\":{\"646\":1}}],[\"有何区别呢\",{\"1\":{\"875\":1}}],[\"有丰富的监控管理\",{\"1\":{\"872\":1}}],[\"有可能为null\",{\"1\":{\"853\":1}}],[\"有可能被其他对象调用他的interrupt\",{\"1\":{\"273\":1}}],[\"有一种备份交换机的机制存在\",{\"1\":{\"767\":1}}],[\"有一种特殊情况\",{\"1\":{\"505\":1}}],[\"有则打印到控制台\",{\"1\":{\"754\":1}}],[\"有死信自然就有了死信队列\",{\"1\":{\"744\":1}}],[\"有点类似了\",{\"1\":{\"737\":1}}],[\"有点类似于linkedhashmap\",{\"1\":{\"220\":1}}],[\"有下列两种类型\",{\"1\":{\"728\":1}}],[\"有真正写入磁盘\",{\"1\":{\"712\":1}}],[\"有如下三个属性\",{\"1\":{\"651\":1}}],[\"有没有权限访问该页面等等工作\",{\"1\":{\"648\":1}}],[\"有什么区别\",{\"0\":{\"686\":1}}],[\"有什么用\",{\"0\":{\"685\":1}}],[\"有什么问题\",{\"0\":{\"620\":1,\"653\":1}}],[\"有什么好处和坏处\",{\"1\":{\"893\":1}}],[\"有什么好处\",{\"1\":{\"510\":1}}],[\"有关\",{\"1\":{\"527\":1}}],[\"有的对象可能不需要作为一个连续的内存结构存在也可以被访问到\",{\"1\":{\"507\":1}}],[\"有的人会说\",{\"1\":{\"288\":1}}],[\"有eden\",{\"1\":{\"497\":1}}],[\"有时提交过代码之后\",{\"1\":{\"585\":1}}],[\"有时也叫做from区\",{\"1\":{\"488\":1}}],[\"有时java应用需要与java外面的环境交互\",{\"1\":{\"435\":1}}],[\"有参构造器\",{\"1\":{\"468\":1}}],[\"有些之前没想到的思路\",{\"1\":{\"1036\":1}}],[\"有些情况下这是提升算法效率的关键\",{\"1\":{\"957\":1}}],[\"有些对象甚至只用一次即可回收\",{\"1\":{\"525\":1}}],[\"有些人认为方法区\",{\"1\":{\"464\":1}}],[\"有些像定义一个java\",{\"1\":{\"434\":1}}],[\"有永久代\",{\"1\":{\"461\":2}}],[\"有影响力的三大商用虚拟机之一\",{\"1\":{\"353\":1}}],[\"有以下几种代理\",{\"1\":{\"604\":1}}],[\"有以下几种情况\",{\"1\":{\"347\":1}}],[\"有以下注意事项\",{\"1\":{\"233\":1}}],[\"有哪些区\",{\"1\":{\"465\":1}}],[\"有哪些获取方法\",{\"0\":{\"291\":1}}],[\"有哪几种常见的遍历方式\",{\"0\":{\"248\":1}}],[\"有明确的\",{\"1\":{\"278\":1}}],[\"有赞\",{\"1\":{\"278\":1}}],[\"有赞设计原则\",{\"1\":{\"139\":1}}],[\"有了列名与属性名的映射关系后\",{\"1\":{\"808\":1}}],[\"有了对集合中的元素根据键排序的能力\",{\"1\":{\"241\":1}}],[\"有了对集合内元素的搜索的能力\",{\"1\":{\"241\":1}}],[\"有了数组为什么还需要list集合\",{\"0\":{\"227\":1}}],[\"有序\",{\"1\":{\"220\":1}}],[\"有序列表\",{\"1\":{\"46\":1}}],[\"有\",{\"1\":{\"207\":1,\"676\":1,\"939\":2}}],[\"有权图\",{\"1\":{\"177\":1}}],[\"有趣\",{\"0\":{\"143\":1}}],[\"有很多频道的创作社区\",{\"1\":{\"120\":1}}],[\"有个小细节就是\",{\"1\":{\"103\":1}}],[\"有依赖的工程时\",{\"1\":{\"90\":1}}],[\"有效\",{\"1\":{\"80\":9}}],[\"部分其他收集器原本需要停顿\",{\"1\":{\"535\":1}}],[\"部分收集\",{\"1\":{\"493\":1}}],[\"部分结果\",{\"1\":{\"407\":1}}],[\"部分\",{\"1\":{\"379\":1}}],[\"部分之前总结过的题可以点击进入对应文章链接\",{\"1\":{\"165\":1}}],[\"部分设置成功后\",{\"1\":{\"14\":1}}],[\"部署到服务器\",{\"1\":{\"80\":1}}],[\"开放\",{\"1\":{\"695\":1}}],[\"开头命名的\",{\"1\":{\"682\":1}}],[\"开启一个listener\",{\"1\":{\"906\":1}}],[\"开启手动应答\",{\"1\":{\"749\":1}}],[\"开启发布确认\",{\"1\":{\"721\":1,\"722\":1,\"723\":1}}],[\"开启发布确认的方法\",{\"1\":{\"721\":1}}],[\"开启成功\",{\"1\":{\"714\":1}}],[\"开启消息的持久化\",{\"1\":{\"712\":1}}],[\"开启用户线程\",{\"1\":{\"534\":1}}],[\"开启了标量替换\",{\"1\":{\"510\":1}}],[\"开始传染\",{\"1\":{\"943\":1}}],[\"开始\",{\"1\":{\"444\":1,\"720\":1}}],[\"开始提供的动态语言支持\",{\"1\":{\"397\":1}}],[\"开源在线\",{\"1\":{\"159\":1}}],[\"开源地址\",{\"1\":{\"110\":1}}],[\"开发方便\",{\"1\":{\"872\":1}}],[\"开发者无需关心具体操作\",{\"1\":{\"827\":1}}],[\"开发者开发时只需要关注如何编写sql语句\",{\"1\":{\"806\":1}}],[\"开发者需要自行在bean定义中用标签明确的设置依赖关系\",{\"1\":{\"598\":1}}],[\"开发者武器库\",{\"1\":{\"118\":1}}],[\"开发人员则可以通过\",{\"1\":{\"506\":1}}],[\"开发人员可以通过选项\",{\"1\":{\"502\":1}}],[\"开发人员可以通过继承抽象类\",{\"1\":{\"387\":1}}],[\"开发中能使用局部变量的\",{\"1\":{\"506\":1}}],[\"开发中避免死锁的八种方法\",{\"1\":{\"270\":1}}],[\"开发中如何避免死锁呢\",{\"0\":{\"270\":1}}],[\"开发手册\",{\"1\":{\"235\":1}}],[\"开发的同学玩下\",{\"1\":{\"143\":1}}],[\"开发技术文档\",{\"1\":{\"119\":1}}],[\"开发过程\",{\"1\":{\"80\":1}}],[\"开关打开\",{\"1\":{\"21\":1}}],[\"对二叉树进行层次遍历\",{\"1\":{\"1035\":1}}],[\"对每个\",{\"1\":{\"926\":1}}],[\"对每个加载的类型\",{\"1\":{\"452\":1}}],[\"对调用方来说是无感知\",{\"1\":{\"872\":1}}],[\"对开发人员编写sql语句的功底有一定要求\",{\"1\":{\"807\":1}}],[\"对这道题来说\",{\"1\":{\"935\":1}}],[\"对这么庞大的数据量仍旧使用轮询的方式显然是不可取的\",{\"1\":{\"751\":1}}],[\"对这个对象的成员变量的写操作会存在线程安全问题\",{\"1\":{\"638\":1}}],[\"对此我们想做一些改变\",{\"1\":{\"736\":1}}],[\"对各个组件进行统一调度\",{\"1\":{\"646\":1}}],[\"对相同字段的多次读取的结果是一致的\",{\"1\":{\"634\":1}}],[\"对类进行方法级别的切面增强\",{\"1\":{\"627\":1}}],[\"对类加载器的引用\",{\"0\":{\"396\":1}}],[\"对该消息进行装饰\",{\"1\":{\"603\":1}}],[\"对该算法做了重大改进\",{\"1\":{\"536\":1}}],[\"对字符串数组流中的每个数组\",{\"1\":{\"549\":1}}],[\"对流中每个字符串元素\",{\"1\":{\"549\":1}}],[\"对流中每个元素应用函数\",{\"1\":{\"549\":1}}],[\"对流的操作可以分为两类\",{\"1\":{\"546\":1}}],[\"对常规应用的垃圾回收\",{\"1\":{\"522\":1}}],[\"对java而言\",{\"1\":{\"507\":1}}],[\"对eden区域继续进行划分\",{\"1\":{\"500\":1}}],[\"对齐填充\",{\"0\":{\"478\":1}}],[\"对方法前后做一些操作\",{\"1\":{\"610\":1}}],[\"对方法区的约束是非常宽松的\",{\"1\":{\"464\":1}}],[\"对方法加了同步锁或者对调用的方法加了同步锁\",{\"1\":{\"276\":1}}],[\"对dump内存中的对象是否是必要的\",{\"1\":{\"450\":1}}],[\"对如何实现方法区\",{\"1\":{\"444\":1}}],[\"对程序调试提供支持的信息\",{\"1\":{\"425\":1}}],[\"对一个函数而言\",{\"1\":{\"415\":1}}],[\"对一个比较大型的项目进行了模块拆分\",{\"1\":{\"85\":1}}],[\"对唯一的实现类进行内联\",{\"1\":{\"372\":1}}],[\"对垃圾内存的回收速度\",{\"1\":{\"328\":1}}],[\"对引用的概念进行了扩充\",{\"1\":{\"324\":1}}],[\"对象进行分页\",{\"1\":{\"817\":1}}],[\"对象关系映射\",{\"1\":{\"806\":1}}],[\"对象生命周期长\",{\"1\":{\"525\":1}}],[\"对象生命周期短\",{\"1\":{\"525\":1}}],[\"对象实例都是分配在堆上\",{\"1\":{\"511\":1}}],[\"对象可能是栈分配的候选\",{\"1\":{\"507\":1}}],[\"对象可以被回收\",{\"0\":{\"323\":1}}],[\"对象只在方法内部使用\",{\"1\":{\"506\":1}}],[\"对象是在java堆中分配内存的\",{\"1\":{\"505\":1}}],[\"对象晋升老年代的年龄阈值\",{\"1\":{\"498\":1}}],[\"对象大小大于to\",{\"1\":{\"496\":1}}],[\"对象从老年代消失时\",{\"1\":{\"495\":1}}],[\"对象分配过程\",{\"0\":{\"489\":1}}],[\"对象移动时需要修改栈中存放的对象地址\",{\"1\":{\"479\":1}}],[\"对象访问方式主要有两种\",{\"1\":{\"479\":1}}],[\"对象时候的线程安全性\",{\"1\":{\"471\":1}}],[\"对象头\",{\"0\":{\"476\":1}}],[\"对象头里有什么\",{\"1\":{\"467\":1}}],[\"对象头信息里面有哪些东西\",{\"1\":{\"467\":1}}],[\"对象头会有不同的设置方式\",{\"1\":{\"313\":1}}],[\"对象在survivor区中每熬过一次minorgc\",{\"1\":{\"498\":1}}],[\"对象在\",{\"1\":{\"467\":1}}],[\"对象引用\",{\"1\":{\"415\":1}}],[\"对象没有在任何地方被引用\",{\"1\":{\"329\":1,\"464\":1}}],[\"对象已经死亡\",{\"0\":{\"320\":1}}],[\"对象内容的字符串\",{\"1\":{\"318\":1}}],[\"对象\",{\"1\":{\"317\":1,\"318\":1,\"377\":1,\"604\":2,\"610\":1,\"614\":2,\"651\":1,\"816\":2,\"822\":6,\"908\":1}}],[\"对象创建才刚开始\",{\"1\":{\"314\":1}}],[\"对象的区域进行回收\",{\"1\":{\"497\":1}}],[\"对象的内存布局\",{\"0\":{\"475\":1}}],[\"对象的实例化\",{\"0\":{\"466\":1,\"467\":1}}],[\"对象的引用地址\",{\"1\":{\"407\":1}}],[\"对象的访问定位\",{\"0\":{\"479\":1}}],[\"对象的访问定位的两种方式\",{\"0\":{\"315\":1}}],[\"对象的访问方式由虚拟机实现而定\",{\"1\":{\"315\":1}}],[\"对象的\",{\"1\":{\"313\":1,\"473\":1,\"810\":1,\"821\":1}}],[\"对象的哈希码\",{\"1\":{\"313\":1}}],[\"对象的创建过程\",{\"0\":{\"309\":1}}],[\"对象所需的内存大小在类加载完成后便可确定\",{\"1\":{\"311\":1}}],[\"对象作为这块内存的引用进行操作\",{\"1\":{\"308\":1}}],[\"对象中只有一个condition实例\",{\"1\":{\"286\":1}}],[\"对永久代进行调优是很困难的\",{\"1\":{\"306\":1,\"462\":1}}],[\"对锁的实现引入了大量的优化\",{\"1\":{\"278\":1}}],[\"对锁的处理机制不同\",{\"1\":{\"273\":1}}],[\"对新任务的拒绝策略\",{\"1\":{\"275\":1}}],[\"对已获得的资源保持不放\",{\"1\":{\"269\":1}}],[\"对list进行二分查找\",{\"1\":{\"258\":1}}],[\"对整个桶数组进行了分割分段\",{\"1\":{\"249\":1}}],[\"对两个\",{\"1\":{\"242\":1}}],[\"对\",{\"1\":{\"239\":1,\"249\":1,\"534\":1,\"909\":1}}],[\"对应\",{\"1\":{\"618\":1}}],[\"对应服务层\",{\"1\":{\"618\":1}}],[\"对应持久层即\",{\"1\":{\"618\":1}}],[\"对应的xml中\",{\"1\":{\"819\":1}}],[\"对应的消息\",{\"1\":{\"706\":2}}],[\"对应的方法的绑定机制为\",{\"1\":{\"420\":1}}],[\"对应的新的栈帧会被创建出来\",{\"1\":{\"413\":1}}],[\"对应的配置文件\",{\"0\":{\"69\":1}}],[\"对应着一次次的java方法调用\",{\"1\":{\"407\":1}}],[\"对应常量池中的\",{\"1\":{\"379\":1}}],[\"对应于get\",{\"1\":{\"229\":1}}],[\"对于有根树\",{\"1\":{\"1038\":1}}],[\"对于上面这个给定的矩阵\",{\"1\":{\"933\":1}}],[\"对于上面这个给定矩阵应返回\",{\"1\":{\"933\":1}}],[\"对于缓存数据更新机制\",{\"1\":{\"813\":1}}],[\"对于大多数应用来说\",{\"1\":{\"717\":1}}],[\"对于任意一个对象\",{\"1\":{\"608\":1}}],[\"对于任意一个类\",{\"1\":{\"608\":1}}],[\"对于基本类型\",{\"1\":{\"600\":1}}],[\"对于基本类型来说\",{\"1\":{\"242\":1}}],[\"对于对象的回收效率很高\",{\"1\":{\"525\":1}}],[\"对于g1这种分拆成为大量region的gc\",{\"1\":{\"522\":1}}],[\"对于高级语言来说\",{\"1\":{\"516\":1}}],[\"对于interface或是java\",{\"1\":{\"452\":1}}],[\"对于一个64位的服务器端jvm来说\",{\"1\":{\"448\":1}}],[\"对于栈来说不存在垃圾回收问题\",{\"1\":{\"408\":1}}],[\"对于用户定义的类来说\",{\"1\":{\"381\":1}}],[\"对于未逃逸的对象分配对象在栈而不是堆\",{\"1\":{\"372\":1}}],[\"对于服务端应用来说\",{\"1\":{\"365\":1}}],[\"对于\",{\"1\":{\"317\":1,\"441\":1,\"751\":1}}],[\"对于编译期可以确定值的字符串\",{\"1\":{\"317\":1}}],[\"对于无界队列\",{\"1\":{\"275\":1}}],[\"对于引用类型\",{\"1\":{\"242\":1}}],[\"对于引用类型来说\",{\"1\":{\"242\":1}}],[\"对于两个对象来说\",{\"1\":{\"240\":1}}],[\"对于collection\",{\"1\":{\"214\":1}}],[\"对于第\",{\"1\":{\"207\":1}}],[\"对于传信息的关系\",{\"1\":{\"204\":1,\"205\":1}}],[\"对于每个元素处理优先队列的时间是o\",{\"1\":{\"194\":1}}],[\"对销售类订单的循环和采购类类似\",{\"1\":{\"194\":1}}],[\"对前端小知识点的总结\",{\"1\":{\"123\":1}}],[\"对比三种算法\",{\"0\":{\"524\":1}}],[\"对比一下\",{\"1\":{\"244\":1}}],[\"对比它们的地址是否相等\",{\"1\":{\"242\":1}}],[\"对比\",{\"1\":{\"80\":1}}],[\"标准序列化机制\",{\"1\":{\"888\":1}}],[\"标准性的云计算的数据交换和存储的protocol\",{\"1\":{\"879\":1}}],[\"标准通用标记语言的子集\",{\"1\":{\"875\":1}}],[\"标志参数被hibernate\",{\"1\":{\"651\":1}}],[\"标志来隐式实现的\",{\"1\":{\"278\":1}}],[\"标记整理\",{\"1\":{\"539\":3}}],[\"标记压缩\",{\"1\":{\"524\":1}}],[\"标记清除\",{\"1\":{\"524\":1,\"539\":1}}],[\"标记的存活对象将会被整理\",{\"1\":{\"523\":1}}],[\"标记一清除算法的确可以应用在老年代中\",{\"1\":{\"523\":1}}],[\"标记所有被引用的对象\",{\"1\":{\"521\":1}}],[\"标记\",{\"0\":{\"521\":1,\"523\":1},\"1\":{\"520\":2,\"521\":1,\"523\":4,\"525\":1,\"534\":2,\"535\":3}}],[\"标记xx项目为父项目\",{\"1\":{\"89\":1}}],[\"标量\",{\"1\":{\"510\":1}}],[\"标量替换为栈上分配提供了很好的基础\",{\"1\":{\"510\":1}}],[\"标量替换优化技术将会导致一些微妙的变化\",{\"1\":{\"505\":1}}],[\"标量替换\",{\"0\":{\"510\":1},\"1\":{\"372\":1}}],[\"标签内的\",{\"1\":{\"822\":1}}],[\"标签均会被解析为\",{\"1\":{\"822\":1}}],[\"标签会被解析为\",{\"1\":{\"822\":2}}],[\"标签引入\",{\"1\":{\"811\":1}}],[\"标签之外\",{\"0\":{\"811\":1}}],[\"标签中可以定义哪些属性\",{\"0\":{\"619\":1}}],[\"标签\",{\"1\":{\"88\":1,\"89\":2,\"812\":1,\"816\":1}}],[\"标签的可选值\",{\"1\":{\"80\":1}}],[\"标签的位置\",{\"1\":{\"80\":1}}],[\"标题批量添加序号\",{\"1\":{\"55\":1}}],[\"标题加编号\",{\"1\":{\"47\":1}}],[\"标题\",{\"1\":{\"46\":1,\"728\":1}}],[\"695\",{\"0\":{\"932\":1}}],[\"674\",{\"0\":{\"928\":1}}],[\"6<\",{\"1\":{\"696\":1}}],[\"6才有实现\",{\"1\":{\"511\":1}}],[\"6及之前\",{\"1\":{\"461\":1}}],[\"61fcdc9220af\",{\"1\":{\"388\":1}}],[\"6d06d69c\",{\"1\":{\"381\":1}}],[\"659e0bfd\",{\"1\":{\"381\":2}}],[\"6之前\",{\"1\":{\"278\":1}}],[\"6之后加入的\",{\"1\":{\"278\":1}}],[\"6842045\",{\"1\":{\"249\":2}}],[\"64位机器模式是82m\",{\"1\":{\"447\":1}}],[\"64\",{\"1\":{\"222\":1,\"239\":1,\"245\":1,\"410\":3,\"486\":1,\"503\":1}}],[\"64bit\",{\"1\":{\"49\":1,\"416\":1}}],[\"6\",{\"0\":{\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"372\":1,\"459\":1,\"464\":1,\"520\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"525\":1,\"526\":2,\"527\":1,\"528\":1},\"1\":{\"142\":1,\"219\":1,\"229\":1,\"231\":1,\"249\":1,\"278\":4,\"285\":1,\"591\":1,\"665\":1,\"671\":1,\"678\":1,\"706\":2,\"717\":1,\"748\":2,\"749\":2,\"782\":1,\"783\":1,\"788\":1,\"792\":2,\"874\":1,\"879\":1,\"933\":1,\"937\":2,\"981\":1,\"996\":1,\"1028\":2,\"1038\":1}}],[\"依据该文件\",{\"1\":{\"879\":1}}],[\"依赖客户端\",{\"1\":{\"696\":1}}],[\"依赖性安全漏洞扫描工具\",{\"1\":{\"662\":1}}],[\"依赖了哪些\",{\"1\":{\"612\":1}}],[\"依赖注入\",{\"1\":{\"591\":1,\"762\":1,\"765\":1}}],[\"依赖于框架\",{\"1\":{\"648\":1}}],[\"依赖于servlet\",{\"1\":{\"648\":1}}],[\"依赖于\",{\"0\":{\"285\":2}}],[\"依赖boxed的装箱操作\",{\"1\":{\"234\":1}}],[\"依赖项路径为以jar包路径为参考系的相对路径\",{\"1\":{\"103\":1}}],[\"依赖项列表\",{\"1\":{\"103\":1}}],[\"依赖\",{\"1\":{\"81\":5,\"82\":2,\"753\":1}}],[\"依赖的排除\",{\"0\":{\"82\":1}}],[\"依赖的传递性\",{\"0\":{\"81\":1}}],[\"依赖的范围\",{\"1\":{\"78\":1}}],[\"依赖范围<scope>\",{\"0\":{\"80\":1}}],[\"依赖相关\",{\"0\":{\"79\":1}}],[\"依次比较pre和slow节点的值\",{\"1\":{\"974\":1}}],[\"依次类推\",{\"1\":{\"970\":1}}],[\"依次从一级到三级缓存查询a\",{\"1\":{\"621\":1}}],[\"依次反复\",{\"1\":{\"526\":1}}],[\"依次递归\",{\"1\":{\"391\":1}}],[\"依次点击\",{\"1\":{\"15\":1}}],[\"依次点击view\",{\"1\":{\"11\":1}}],[\"依次进入settings\",{\"1\":{\"7\":1}}],[\"参数错误\",{\"1\":{\"998\":2}}],[\"参数选择对应的协议来进行\",{\"1\":{\"889\":1}}],[\"参数2\",{\"1\":{\"847\":1}}],[\"参数1\",{\"1\":{\"847\":1}}],[\"参数不同时\",{\"1\":{\"816\":1}}],[\"参数对象中计算表达式的值\",{\"1\":{\"812\":1}}],[\"参数来设置队列的模式\",{\"1\":{\"783\":1}}],[\"参数来设定\",{\"1\":{\"471\":1}}],[\"参数与备份交换机可以一起使用的时候\",{\"1\":{\"768\":1}}],[\"参数会增加生产者的复杂性\",{\"1\":{\"767\":1}}],[\"参数可以在当消息传递过程中不可达目的地时将消息返回给生产者\",{\"1\":{\"764\":1}}],[\"参数设置为true\",{\"1\":{\"711\":1}}],[\"参数设置半衰周期的时间\",{\"1\":{\"369\":1}}],[\"参数是是否\",{\"1\":{\"706\":1}}],[\"参数说明\",{\"0\":{\"504\":1}}],[\"参数名\",{\"1\":{\"503\":1,\"651\":1}}],[\"参数为\",{\"1\":{\"477\":1}}],[\"参数进行控制\",{\"1\":{\"464\":1}}],[\"参数类型\",{\"1\":{\"458\":1}}],[\"参数\",{\"1\":{\"78\":1,\"510\":1,\"532\":1,\"747\":2,\"748\":2,\"749\":2,\"764\":1}}],[\"参考代码注释\",{\"1\":{\"955\":1}}],[\"参考文章\",{\"0\":{\"802\":1}}],[\"参考内容\",{\"0\":{\"590\":1}}],[\"参考链接\",{\"0\":{\"513\":1}}],[\"参考之前的内容\",{\"1\":{\"427\":1}}],[\"参考值可以设置为2\",{\"1\":{\"277\":1}}],[\"参考值可以设为\",{\"1\":{\"277\":1}}],[\"参考这里\",{\"1\":{\"232\":1,\"889\":1}}],[\"参考资料\",{\"1\":{\"206\":1}}],[\"参考\",{\"0\":{\"23\":1,\"208\":1,\"824\":1,\"921\":1},\"1\":{\"92\":1,\"97\":1,\"103\":1,\"229\":1,\"270\":1,\"278\":1,\"421\":1,\"517\":1,\"594\":1,\"636\":1,\"673\":1,\"674\":1,\"802\":1,\"817\":1,\"910\":1,\"979\":1}}],[\"仓库中生成的路径如下\",{\"1\":{\"77\":1}}],[\"仓库中的路径是根据它的坐标生成的\",{\"1\":{\"77\":1}}],[\"安装命令不能出现插件版本和后缀\",{\"1\":{\"756\":1}}],[\"安装\",{\"1\":{\"756\":1}}],[\"安装目录\",{\"1\":{\"756\":1}}],[\"安装延时队列插件\",{\"1\":{\"756\":1}}],[\"安装的效果是将本地构建过程中生成的\",{\"1\":{\"77\":1}}],[\"安装操作还会将\",{\"1\":{\"77\":1}}],[\"安装操作\",{\"0\":{\"77\":1}}],[\"安装和配置\",{\"0\":{\"60\":1}}],[\"测试查询功能\",{\"1\":{\"840\":1}}],[\"测试删除功能\",{\"1\":{\"840\":1}}],[\"测试\",{\"0\":{\"858\":1,\"1012\":1},\"1\":{\"591\":2,\"840\":1}}],[\"测试自定义java\",{\"1\":{\"392\":1}}],[\"测试过程中使用的\",{\"1\":{\"80\":1}}],[\"测试的报告存放的目录\",{\"1\":{\"75\":1}}],[\"测试操作\",{\"0\":{\"75\":1}}],[\"测试程序编译结果存放的目录\",{\"1\":{\"74\":1}}],[\"测试程序编译\",{\"1\":{\"74\":1}}],[\"删除倒数第n个节点\",{\"0\":{\"961\":1}}],[\"删除条件\",{\"1\":{\"843\":1}}],[\"删除二级缓存中的a\",{\"1\":{\"621\":1}}],[\"删除\",{\"1\":{\"73\":1,\"175\":1,\"833\":1}}],[\"删除线\",{\"1\":{\"47\":1}}],[\"清空任意一个水壶\",{\"1\":{\"981\":1}}],[\"清晰的角色分配\",{\"1\":{\"644\":1}}],[\"清理\",{\"1\":{\"535\":1}}],[\"清理或复制工作\",{\"1\":{\"526\":1}}],[\"清理边界外所有的空间\",{\"1\":{\"523\":1}}],[\"清理操作相关\",{\"1\":{\"94\":1}}],[\"清理操作\",{\"0\":{\"73\":1},\"1\":{\"73\":1}}],[\"清除和复制算法\",{\"1\":{\"526\":1}}],[\"清除与标记\",{\"1\":{\"525\":1}}],[\"清除或者是标记\",{\"1\":{\"525\":1}}],[\"清除\",{\"1\":{\"521\":1,\"523\":1,\"525\":1,\"534\":2}}],[\"清除算法当中\",{\"1\":{\"523\":1}}],[\"清除算法是一种非移动式的回收算法\",{\"1\":{\"523\":1}}],[\"清除算法执行完成后\",{\"1\":{\"523\":1}}],[\"清除算法\",{\"0\":{\"521\":1},\"1\":{\"520\":1}}],[\"清除同步操作\",{\"1\":{\"372\":1}}],[\"清除样式\",{\"1\":{\"47\":1}}],[\"就这样一路回溯\",{\"1\":{\"1034\":1}}],[\"就这样为分布式系统的服务治理框架就出现了\",{\"1\":{\"881\":1}}],[\"就返回true\",{\"1\":{\"1019\":1}}],[\"就进行感染\",{\"1\":{\"944\":1}}],[\"就进入这个工程的\",{\"1\":{\"72\":1}}],[\"就多了\",{\"1\":{\"939\":1}}],[\"就需要增加当前元素\",{\"1\":{\"938\":1}}],[\"就需要尽量压榨cpu\",{\"1\":{\"277\":1}}],[\"就更新一次max\",{\"1\":{\"926\":1}}],[\"就重置当前的statistics的atomicreference\",{\"1\":{\"902\":1}}],[\"就能进行服务注册和发现\",{\"1\":{\"897\":1}}],[\"就能保证不出现溢出吗\",{\"0\":{\"428\":1}}],[\"就自己实现了一个\",{\"1\":{\"893\":1}}],[\"就通过定义一个特定的位置\",{\"1\":{\"892\":1}}],[\"就像调用本地方法一样调用远程方法\",{\"1\":{\"884\":1}}],[\"就像迭代器一样\",{\"1\":{\"544\":1}}],[\"就用\",{\"1\":{\"883\":2}}],[\"就将清空\",{\"1\":{\"813\":1}}],[\"就将该bean装配给\",{\"1\":{\"601\":1}}],[\"就相当于是\",{\"1\":{\"792\":1}}],[\"就在调用处配置对应接口的放行规则\",{\"1\":{\"789\":1}}],[\"就无法设计成一个通用的延时队列\",{\"1\":{\"756\":1}}],[\"就无法使用\",{\"1\":{\"596\":1}}],[\"就介绍过如果使用在消息属性上设置\",{\"1\":{\"755\":1}}],[\"就要新增一个队列\",{\"1\":{\"754\":1}}],[\"就要进行外挂\",{\"1\":{\"349\":1}}],[\"就变成了死信\",{\"1\":{\"744\":1}}],[\"就有点像\",{\"1\":{\"741\":1}}],[\"就办不到了\",{\"1\":{\"740\":1}}],[\"就跟广播差不多\",{\"1\":{\"737\":1}}],[\"就开始执行run方法的逻辑了\",{\"1\":{\"678\":1}}],[\"就已经准备好了一切资源\",{\"1\":{\"674\":1}}],[\"就已经开始了\",{\"1\":{\"338\":1}}],[\"就显得非常鸡肋\",{\"1\":{\"673\":1}}],[\"就把变化的东西集中到这里了\",{\"1\":{\"632\":1}}],[\"就没法分离这个操作\",{\"1\":{\"621\":1}}],[\"就调用相应的方法\",{\"1\":{\"614\":1}}],[\"就装配这个属性\",{\"1\":{\"598\":2}}],[\"就传递多个标志\",{\"1\":{\"577\":1}}],[\"就存放\",{\"1\":{\"521\":1}}],[\"就好像不停地生产生活垃圾而从来不打扫\",{\"1\":{\"516\":1}}],[\"就不现实了\",{\"1\":{\"909\":1}}],[\"就不要使用在方法外定义\",{\"1\":{\"506\":1}}],[\"就不会发生越界\",{\"1\":{\"939\":1}}],[\"就不会有<clinit>\",{\"1\":{\"380\":1}}],[\"就不会产生并发\",{\"1\":{\"252\":1}}],[\"就不会存在锁竞争\",{\"1\":{\"249\":1}}],[\"就不会让加入操作成功\",{\"1\":{\"242\":1}}],[\"就如同把一个学校的人都关在一个教室\",{\"1\":{\"497\":1}}],[\"就报oom了\",{\"1\":{\"495\":1}}],[\"就可能被优化成栈上分配\",{\"1\":{\"508\":1}}],[\"就可能引发内存泄漏\",{\"1\":{\"280\":1}}],[\"就可以保证每层都是最先访问最右边的节点\",{\"1\":{\"1034\":1}}],[\"就可以调用对应的映射文件中的sql\",{\"1\":{\"819\":1}}],[\"就可以在xml像下面这样使用\",{\"1\":{\"819\":1}}],[\"就可以通过\",{\"1\":{\"673\":1}}],[\"就可以通过这种方式\",{\"1\":{\"602\":1}}],[\"就可以被回收\",{\"1\":{\"464\":1}}],[\"就可以比较准确地定位出泄漏代码的位置\",{\"1\":{\"450\":1}}],[\"就说明一个类发生了不兼容的改变\",{\"1\":{\"422\":1}}],[\"就得知道接着从哪开始继续执行\",{\"1\":{\"401\":1}}],[\"就成功返回\",{\"1\":{\"391\":1}}],[\"就代表一定会被回收吗\",{\"0\":{\"323\":1}}],[\"就抛出\",{\"1\":{\"302\":1}}],[\"就算线程结束了\",{\"1\":{\"280\":1}}],[\"就算队列里面有任务\",{\"1\":{\"277\":1}}],[\"就顺利进入临界区\",{\"1\":{\"278\":1}}],[\"就会很乱\",{\"1\":{\"890\":1}}],[\"就会进入拦截方法\",{\"1\":{\"818\":1}}],[\"就会都进\",{\"1\":{\"767\":1}}],[\"就会被队列丢弃\",{\"1\":{\"752\":1}}],[\"就会被晋升到老年代中\",{\"1\":{\"498\":1}}],[\"就会发送一条\",{\"1\":{\"720\":1}}],[\"就会发送一个确认给生产者\",{\"1\":{\"720\":1}}],[\"就会回滚\",{\"1\":{\"637\":1}}],[\"就会回收这些对象的内存\",{\"1\":{\"326\":1}}],[\"就会在ioc容器自动查找需要的bean\",{\"1\":{\"601\":1}}],[\"就会在回收对象的内存之前\",{\"1\":{\"328\":1}}],[\"就会停止整个程序\",{\"1\":{\"521\":1}}],[\"就会把这个对象拆解成若干个其中包含的若干个成员变量来代替\",{\"1\":{\"510\":1}}],[\"就会触发minor\",{\"1\":{\"494\":1}}],[\"就会触发jit编译\",{\"1\":{\"369\":1}}],[\"就会产生oom异常\",{\"1\":{\"490\":1}}],[\"就会放到\",{\"1\":{\"490\":1}}],[\"就会创建对应的运行时常量池\",{\"1\":{\"459\":1}}],[\"就会释放这个区域的内存\",{\"1\":{\"442\":1}}],[\"就会导致方法退出\",{\"1\":{\"424\":1}}],[\"就会导致轻量级锁膨胀为重量级锁\",{\"1\":{\"278\":1}}],[\"就会造成死锁\",{\"1\":{\"271\":1,\"284\":1}}],[\"就判断该元素与要存入的元素的\",{\"1\":{\"244\":1}}],[\"就出现了\",{\"1\":{\"217\":1}}],[\"就选择实现collection\",{\"1\":{\"216\":1}}],[\"就等于\",{\"1\":{\"203\":1}}],[\"就必须在需要的地方明确配置依赖才可以\",{\"1\":{\"81\":1}}],[\"就是打印的顺序不同\",{\"1\":{\"1024\":1}}],[\"就是dp\",{\"1\":{\"926\":1}}],[\"就是找到状态转移方程\",{\"1\":{\"926\":1}}],[\"就是快\",{\"1\":{\"894\":1}}],[\"就是咱们开发的业务逻辑层\",{\"1\":{\"883\":1}}],[\"就是传递给\",{\"1\":{\"816\":1}}],[\"就是映射文件中\",{\"1\":{\"816\":1}}],[\"就是映射文件中的\",{\"1\":{\"816\":1}}],[\"就是人们常说的\",{\"1\":{\"816\":1}}],[\"就是为它创建一个备胎\",{\"1\":{\"767\":1}}],[\"就是在你的service或者一个方法前调用一个方法\",{\"1\":{\"648\":1}}],[\"就是编译后织入\",{\"1\":{\"602\":1}}],[\"就是经过逃逸分析之后\",{\"1\":{\"511\":1}}],[\"就是栈\",{\"1\":{\"507\":1}}],[\"就是一个java调用非java代码的接囗\",{\"1\":{\"434\":1}}],[\"就是通过常量池中指向方法的符号引用来表示的\",{\"1\":{\"417\":1}}],[\"就是对栈帧的压栈和出栈\",{\"1\":{\"413\":1}}],[\"就是因为加载的是rt\",{\"1\":{\"392\":1}}],[\"就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言\",{\"1\":{\"358\":1}}],[\"就是形同虚设\",{\"1\":{\"328\":1}}],[\"就是\",{\"1\":{\"244\":1,\"595\":1,\"602\":1,\"685\":1,\"693\":1,\"702\":1}}],[\"就是我们\",{\"1\":{\"207\":1}}],[\"就是选模板之后微调\",{\"1\":{\"139\":1}}],[\"就是避免和服务器上已有的同类\",{\"1\":{\"80\":1}}],[\"就是学这个文件怎么配置\",{\"1\":{\"69\":1}}],[\"所代表的\",{\"1\":{\"816\":1}}],[\"所产生的停顿\",{\"1\":{\"527\":1}}],[\"所使用的内存回收算法必须结合年轻代和老年代各自的特点\",{\"1\":{\"525\":1}}],[\"所指定的最大内存时\",{\"1\":{\"485\":1}}],[\"所识别的字节码指令\",{\"1\":{\"355\":1}}],[\"所谓吞吐量就是\",{\"1\":{\"532\":1}}],[\"所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法\",{\"1\":{\"402\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"286\":1}}],[\"所谓死锁\",{\"1\":{\"269\":1}}],[\"所谓\",{\"1\":{\"244\":1}}],[\"所谓扰动函数指的就是\",{\"1\":{\"244\":1}}],[\"所有左子树和右子树自身必须也是二叉搜索树\",{\"1\":{\"1028\":1}}],[\"所有数都是\",{\"1\":{\"939\":1}}],[\"所有数据行的记录就变多或者变少了\",{\"1\":{\"634\":1}}],[\"所有类型的接口都放行\",{\"1\":{\"788\":1}}],[\"所有第二条消息被直接丢弃了\",{\"1\":{\"762\":1}}],[\"所有就丢失了\",{\"1\":{\"738\":1}}],[\"所有在该信道上面发布的消息都将会被指派一个唯一的\",{\"1\":{\"720\":1}}],[\"所有功能使用注解进行开发\",{\"1\":{\"667\":1}}],[\"所有依赖于它的对象都得到通知并被自动更新\",{\"1\":{\"630\":1}}],[\"所有dao在使用sessionfactory的时候都是通过这个数据源访问数据库\",{\"1\":{\"628\":1}}],[\"所有底层类的构造函数\",{\"1\":{\"595\":1}}],[\"所有组件的核心\",{\"1\":{\"591\":1}}],[\"所有使用arrays\",{\"1\":{\"549\":1}}],[\"所有被同步锁synchronized持有的对象\",{\"1\":{\"519\":1}}],[\"所有被同步锁持有的对象\",{\"1\":{\"322\":1}}],[\"所有openjdk衍生出来的jvm都提供了tlab的设计\",{\"1\":{\"500\":1}}],[\"所有的节点都被当做\",{\"1\":{\"1023\":1}}],[\"所有的数据都将会被转化为字节进行传送\",{\"1\":{\"878\":1}}],[\"所有的对象都分配到堆上也渐渐变得不那么\",{\"1\":{\"505\":1}}],[\"所有的对象实例都在这里\",{\"1\":{\"482\":1}}],[\"所有的对象实例以及数组都应当在运行时分配在堆上\",{\"1\":{\"482\":1}}],[\"所有的线程共享java堆\",{\"1\":{\"482\":1}}],[\"所有的线程都注册在它一个身上\",{\"1\":{\"286\":1}}],[\"所有的变量和方法引用都作为符号引用\",{\"1\":{\"417\":1}}],[\"所有的字段都还为零\",{\"1\":{\"314\":1}}],[\"所有的\",{\"1\":{\"139\":1,\"356\":1}}],[\"所有微服务构建输出jar文件统一输出到与lib同一个目录\",{\"1\":{\"106\":1}}],[\"所以无需关注它\",{\"1\":{\"974\":1}}],[\"所以无法通知final\",{\"1\":{\"603\":1}}],[\"所以框架需要把上述的细节对使用者进行屏蔽\",{\"1\":{\"919\":1}}],[\"所以只希望加载某个的实现\",{\"1\":{\"909\":1}}],[\"所以只要jdbc支持的数据库mybatis都支持\",{\"1\":{\"807\":1}}],[\"所以采用先生成代理类的方法\",{\"1\":{\"907\":1}}],[\"所以很可能会问你为什么要用这个代理\",{\"1\":{\"894\":1}}],[\"所以就可以通过接口找到对应的文件\",{\"1\":{\"892\":1}}],[\"所以请求和响应是如何对应上的\",{\"1\":{\"891\":1}}],[\"所以面试的时候是需要删减的\",{\"1\":{\"890\":1}}],[\"所以会构建\",{\"1\":{\"890\":1}}],[\"所以会有\",{\"1\":{\"718\":1}}],[\"所以为了能够使参数对象在网络中进行传输\",{\"1\":{\"878\":1}}],[\"所以比较适合对性能的要求很高\",{\"1\":{\"806\":1}}],[\"所以不需要session\",{\"1\":{\"788\":1}}],[\"所以不能设计为基于寄存器的\",{\"1\":{\"405\":1}}],[\"所以订单量大了后采用\",{\"1\":{\"776\":1}}],[\"所以理应当然\",{\"1\":{\"776\":1}}],[\"所以清除了缓存区\",{\"1\":{\"724\":1}}],[\"所以找到合适的预取值是一个反复试验的过程\",{\"1\":{\"717\":1}}],[\"所以本质上是异步的\",{\"1\":{\"717\":1}}],[\"所以需要对整数中最大的数单独处理\",{\"1\":{\"939\":1}}],[\"所以需要注册中心\",{\"1\":{\"919\":1}}],[\"所以需要代理实现\",{\"1\":{\"919\":1}}],[\"所以需要把原先队列删除\",{\"1\":{\"748\":1}}],[\"所以需要实现该接口的方法\",{\"1\":{\"698\":1}}],[\"所以需要这样的\",{\"1\":{\"81\":1}}],[\"所以要比冷启动快\",{\"1\":{\"670\":1}}],[\"所以要等到锁的计数器下降为\",{\"1\":{\"271\":1,\"284\":1}}],[\"所以如果使用kill\",{\"1\":{\"913\":1}}],[\"所以如果是问\",{\"1\":{\"892\":1}}],[\"所以如果需要熟练的掌握该框架\",{\"1\":{\"665\":1}}],[\"所以如果都是用构造器的话\",{\"1\":{\"621\":1}}],[\"所以在任何时候\",{\"1\":{\"717\":1}}],[\"所以在多线程访问的时候有线程安全问题\",{\"1\":{\"653\":1}}],[\"所以在java代码里获取不到\",{\"1\":{\"332\":1}}],[\"所以减少了代码的重复性\",{\"1\":{\"645\":1}}],[\"所以都是构造器的话就无法解决循环依赖的问题了\",{\"1\":{\"621\":1}}],[\"所以通常情况下我们选择使用applicationcontext\",{\"1\":{\"611\":1}}],[\"所以spring用设值注入的方法解决了循环依赖的问题\",{\"1\":{\"600\":1}}],[\"所以map方法输出的流的类型就是stream<string>\",{\"1\":{\"549\":1}}],[\"所以作为默认gc\",{\"1\":{\"534\":1}}],[\"所以能减少系统的停顿时间\",{\"1\":{\"526\":1}}],[\"所以jvm的设计者需要在此基础之上进行改进\",{\"1\":{\"523\":1}}],[\"所以jvm在垃圾回收时如果外部没有强引用来引用它\",{\"1\":{\"280\":1}}],[\"所以才会不断地尝试对gc进行优化\",{\"1\":{\"516\":1}}],[\"所以这里需要额外的空间且该空间取决于递归的深度\",{\"1\":{\"1029\":1}}],[\"所以这种模式仅适用在消费者可以高效并以\",{\"1\":{\"705\":1}}],[\"所以这一点同样符合前面一点的结论\",{\"1\":{\"511\":1}}],[\"所以这个题目没什么套路\",{\"1\":{\"892\":1}}],[\"所以这个算法里会跟踪记录这些发生引用更新的地方\",{\"1\":{\"534\":1}}],[\"所以这个散列值是不能直接拿来用的\",{\"1\":{\"246\":1}}],[\"所以这个\",{\"1\":{\"69\":1}}],[\"所以可以明确所有的对象实例都是创建在堆上\",{\"1\":{\"511\":1}}],[\"所以还需要考虑\",{\"1\":{\"490\":1}}],[\"所以一般来说\",{\"1\":{\"314\":1}}],[\"所以我们一开始打印的是d这个节点\",{\"1\":{\"1024\":1}}],[\"所以我们这边又以e作为根节点\",{\"1\":{\"1024\":1}}],[\"所以我们要想实现消息消费过程中不丢失\",{\"1\":{\"708\":1}}],[\"所以我们可以通过查看它的源代码\",{\"1\":{\"285\":1}}],[\"所以我们在写依赖时才不需要写版本号\",{\"1\":{\"685\":1}}],[\"所以我们在\",{\"1\":{\"77\":1}}],[\"所以volatile\",{\"1\":{\"281\":1}}],[\"所以现在的商业虚拟机都是用这种收集算法回收新生代\",{\"1\":{\"522\":1}}],[\"所以现在的\",{\"1\":{\"278\":1}}],[\"所以线程池的所有任务完成后\",{\"1\":{\"277\":1}}],[\"所以是非线程安全的\",{\"1\":{\"276\":1}}],[\"所以是线程安全的\",{\"1\":{\"276\":1}}],[\"所以equals\",{\"1\":{\"240\":1}}],[\"所以它是全自动的\",{\"1\":{\"823\":1}}],[\"所以它只是一个标识\",{\"1\":{\"230\":1}}],[\"所以它的索引速度是非常的快\",{\"1\":{\"228\":1}}],[\"所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成\",{\"1\":{\"222\":1}}],[\"所以\",{\"1\":{\"229\":1,\"251\":1,\"304\":1,\"365\":1,\"494\":1,\"534\":1,\"599\":2,\"693\":1,\"823\":1}}],[\"所以插入和删除元素的时间复杂度受元素位置的影响\",{\"1\":{\"229\":1}}],[\"所以整个项目中使用的框架版本需要统一\",{\"1\":{\"85\":1}}],[\"所在目录\",{\"1\":{\"756\":1}}],[\"所在目录下运行\",{\"1\":{\"72\":1}}],[\"所在的目录\",{\"1\":{\"72\":1}}],[\"的深度尽可能大\",{\"1\":{\"1038\":1}}],[\"的祖先且\",{\"1\":{\"1038\":1}}],[\"的两个结点\",{\"1\":{\"1038\":1}}],[\"的两个对象无论如何都不会相等\",{\"1\":{\"242\":1}}],[\"的顺序访问\",{\"1\":{\"1034\":1}}],[\"的根\",{\"1\":{\"1019\":1}}],[\"的一个子树拥有相同的结构和节点值\",{\"1\":{\"1018\":1}}],[\"的一个子树包括\",{\"1\":{\"1018\":1}}],[\"的一个节点和这个节点的所有子孙\",{\"1\":{\"1018\":1}}],[\"的水\",{\"1\":{\"981\":1}}],[\"的水壶以及无限多的水\",{\"1\":{\"981\":1}}],[\"的腐烂时间\",{\"1\":{\"944\":1}}],[\"的范围内说明不满足条件直接返回\",{\"1\":{\"1029\":1}}],[\"的范围内\",{\"1\":{\"1029\":1}}],[\"的范围\",{\"1\":{\"939\":1}}],[\"的判断\",{\"1\":{\"935\":1}}],[\"的长度和宽度都不超过\",{\"1\":{\"933\":1}}],[\"的长度为什么是\",{\"0\":{\"246\":1},\"1\":{\"246\":2}}],[\"的buildinvokerchain完成的\",{\"1\":{\"905\":1}}],[\"的线程池每隔5min钟\",{\"1\":{\"902\":1}}],[\"的线程池每隔1min钟\",{\"1\":{\"902\":1}}],[\"的线程上下文\",{\"1\":{\"267\":1}}],[\"的临时节点原理\",{\"1\":{\"899\":1}}],[\"的影子\",{\"1\":{\"892\":1}}],[\"的rpc调用\",{\"1\":{\"877\":1}}],[\"的快速开发插件\",{\"1\":{\"867\":1}}],[\"的用户信息修改\",{\"1\":{\"848\":1}}],[\"的动态代理\",{\"1\":{\"818\":1,\"894\":1}}],[\"的插件运行原理\",{\"0\":{\"818\":1}}],[\"的插件目录\",{\"1\":{\"756\":1}}],[\"的进行了c\",{\"1\":{\"813\":1}}],[\"的执行原理\",{\"0\":{\"812\":1}}],[\"的执行方式\",{\"0\":{\"366\":1}}],[\"的取值方式为使用反射从参数对象中获取\",{\"1\":{\"810\":1}}],[\"的parametertype的类型相同\",{\"1\":{\"809\":1}}],[\"的详细解读\",{\"1\":{\"797\":1}}],[\"的开发者们一直在升级相关的算法\",{\"1\":{\"782\":1}}],[\"的开销\",{\"1\":{\"693\":1}}],[\"的开销将是巨大的\",{\"1\":{\"693\":1}}],[\"的优先级为\",{\"1\":{\"779\":1}}],[\"的原子性\",{\"1\":{\"774\":1}}],[\"的该\",{\"1\":{\"773\":1}}],[\"的回调对象\",{\"1\":{\"762\":1,\"765\":1}}],[\"的发布确认机制\",{\"1\":{\"760\":1}}],[\"的特性\",{\"1\":{\"758\":1}}],[\"的安装目录下的\",{\"1\":{\"756\":1}}],[\"的安装目录的\",{\"1\":{\"383\":1}}],[\"的队列\",{\"1\":{\"754\":2,\"755\":2}}],[\"的队列里\",{\"1\":{\"697\":1}}],[\"的第三个参数改为\",{\"1\":{\"748\":1}}],[\"的第一个文本框弹出对应的参数\",{\"1\":{\"702\":1}}],[\"的第一站\",{\"1\":{\"693\":1}}],[\"的运行\",{\"1\":{\"747\":1}}],[\"的死信队列机制\",{\"1\":{\"744\":1}}],[\"的多个单词\",{\"1\":{\"741\":1,\"742\":1}}],[\"的多线程版本\",{\"1\":{\"539\":1}}],[\"的要求\",{\"1\":{\"740\":1}}],[\"的绑定类型是direct\",{\"1\":{\"737\":1}}],[\"的路由键都需要要字符串形式的\",{\"1\":{\"728\":1}}],[\"的这些还未应答的消息都会被确认收到消息应答\",{\"1\":{\"706\":1}}],[\"的解释\",{\"1\":{\"706\":1}}],[\"的所有消息\",{\"1\":{\"706\":1}}],[\"的消息可靠投递呢\",{\"1\":{\"759\":1}}],[\"的消息会被发布到队列\",{\"1\":{\"736\":1}}],[\"的消息才被转发\",{\"1\":{\"728\":1}}],[\"的消息投递给其他消费者消费\",{\"1\":{\"706\":1}}],[\"的消息\",{\"1\":{\"706\":3,\"740\":1,\"762\":1,\"765\":1}}],[\"的参数来进行本地或者远程调用\",{\"1\":{\"889\":1}}],[\"的参数设置方法\",{\"1\":{\"810\":1}}],[\"的参数占位符\",{\"1\":{\"810\":1}}],[\"的参数\",{\"1\":{\"702\":3,\"816\":1}}],[\"的参数中\",{\"1\":{\"698\":1}}],[\"的工具类\",{\"1\":{\"701\":1}}],[\"的工厂\",{\"1\":{\"610\":1}}],[\"的信息根据自己的需求进行配置\",{\"1\":{\"697\":1}}],[\"的分发依据\",{\"1\":{\"693\":1}}],[\"的基本组件划分到一个虚拟的分组中\",{\"1\":{\"693\":1}}],[\"的基础上只做增强不做改变\",{\"1\":{\"826\":1}}],[\"的基础上\",{\"1\":{\"352\":1}}],[\"的资源过滤\",{\"1\":{\"685\":1}}],[\"的思想\",{\"1\":{\"667\":1}}],[\"的控制器是不是单例模式\",{\"0\":{\"653\":1}}],[\"的缩写\",{\"1\":{\"645\":1,\"745\":1}}],[\"的作用域为\",{\"1\":{\"638\":1}}],[\"的声明式事务管理\",{\"1\":{\"633\":2}}],[\"的注解有哪些\",{\"0\":{\"618\":1}}],[\"的名字\",{\"1\":{\"614\":1}}],[\"的名称是指bean中的id\",{\"1\":{\"599\":1}}],[\"的名称\",{\"1\":{\"599\":2,\"734\":1}}],[\"的定义\",{\"1\":{\"614\":1}}],[\"的扩展\",{\"1\":{\"612\":1}}],[\"的扩容机制\",{\"0\":{\"232\":1}}],[\"的实例\",{\"1\":{\"612\":1,\"614\":1}}],[\"的实现原理\",{\"1\":{\"603\":1}}],[\"的实现\",{\"1\":{\"493\":1}}],[\"的逻辑\",{\"1\":{\"610\":1}}],[\"的父类\",{\"1\":{\"610\":1}}],[\"的代码\",{\"1\":{\"603\":1}}],[\"的代价而引入偏向锁\",{\"1\":{\"278\":1}}],[\"的标注对象是成员变量\",{\"1\":{\"599\":1}}],[\"的地方可以使用\",{\"1\":{\"599\":1}}],[\"的自动装配\",{\"0\":{\"598\":1}}],[\"的话\",{\"1\":{\"595\":1}}],[\"的载体\",{\"1\":{\"595\":1}}],[\"的容器框架\",{\"1\":{\"592\":1}}],[\"的容量\",{\"1\":{\"207\":1}}],[\"的由来\",{\"1\":{\"535\":1}}],[\"的另一个大优势\",{\"1\":{\"535\":1}}],[\"的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作\",{\"1\":{\"530\":1}}],[\"的状态\",{\"1\":{\"526\":1}}],[\"的设计得到缓解\",{\"1\":{\"525\":1}}],[\"的速度一般会比\",{\"1\":{\"495\":1}}],[\"的比例默认是8\",{\"1\":{\"488\":1}}],[\"的比例分配\",{\"1\":{\"465\":1}}],[\"的常量池中定位到一个类的符号引用\",{\"1\":{\"470\":1}}],[\"的静态方法\",{\"1\":{\"468\":1}}],[\"的重加载等\",{\"1\":{\"464\":1}}],[\"的值加上这些数量\",{\"1\":{\"939\":1}}],[\"的值和在\",{\"1\":{\"925\":1}}],[\"的值\",{\"0\":{\"449\":1},\"1\":{\"816\":1}}],[\"的规定\",{\"1\":{\"445\":1}}],[\"的方法\",{\"1\":{\"424\":1,\"678\":1}}],[\"的方式具备更高的优先级\",{\"1\":{\"783\":1}}],[\"的方式设置\",{\"1\":{\"783\":1}}],[\"的方式\",{\"1\":{\"755\":1}}],[\"的方式创建字符串\",{\"1\":{\"318\":1}}],[\"的方式拼接\",{\"1\":{\"317\":1}}],[\"的方式来遍历获取元素\",{\"1\":{\"230\":1}}],[\"的各个父类进行第2步的搜索和验证过程\",{\"1\":{\"422\":1}}],[\"的类型\",{\"1\":{\"734\":1}}],[\"的类型占用两个栈单位深度\",{\"1\":{\"416\":1}}],[\"的类型占用一个栈单位深度\",{\"1\":{\"416\":1}}],[\"的类\",{\"1\":{\"618\":1}}],[\"的类加载器都划分为自定义类加载器\",{\"1\":{\"381\":1}}],[\"的格式存在\",{\"1\":{\"412\":1}}],[\"的途径\",{\"0\":{\"389\":1}}],[\"的使用说明\",{\"0\":{\"388\":1}}],[\"的过程\",{\"1\":{\"380\":1}}],[\"的class文件格式中\",{\"1\":{\"379\":1}}],[\"的操作数栈\",{\"1\":{\"416\":1}}],[\"的操作过程\",{\"1\":{\"367\":1}}],[\"的操作内容\",{\"1\":{\"131\":1}}],[\"的任务就是将字节码指令解释\",{\"1\":{\"355\":1}}],[\"的任何一个人让开后\",{\"1\":{\"292\":1}}],[\"的主要思想是避免立即执行资源密集型任务\",{\"1\":{\"699\":1}}],[\"的主要任务是负责装载字节码到其内部\",{\"1\":{\"355\":1}}],[\"的主体\",{\"1\":{\"222\":2,\"249\":1}}],[\"的区域\",{\"1\":{\"343\":1}}],[\"的区别是什么\",{\"0\":{\"617\":1,\"810\":1}}],[\"的区别主要体现在实现线程安全的方式上不同\",{\"1\":{\"249\":1}}],[\"的区别\",{\"0\":{\"229\":1,\"231\":1,\"239\":1,\"249\":1},\"1\":{\"242\":1}}],[\"的永久代中会发生垃圾回收吗\",{\"1\":{\"465\":1}}],[\"的永久代\",{\"1\":{\"338\":1}}],[\"的核心库\",{\"1\":{\"382\":1}}],[\"的核心\",{\"1\":{\"333\":1}}],[\"的核心程序仅仅负责宏观调度\",{\"1\":{\"97\":1}}],[\"的对象\",{\"1\":{\"821\":1}}],[\"的对象是临时对象\",{\"1\":{\"497\":1}}],[\"的对象先放eden区\",{\"1\":{\"490\":1}}],[\"的对象都是\",{\"1\":{\"488\":1}}],[\"的对象作为起点\",{\"1\":{\"322\":1}}],[\"的对象就是不可能再被使用的\",{\"1\":{\"321\":1}}],[\"的处理方式是在常量池中创建与此\",{\"1\":{\"318\":1}}],[\"的最大值\",{\"1\":{\"943\":1}}],[\"的最大大小\",{\"1\":{\"305\":1,\"338\":1}}],[\"的最佳算法在应用于顺序访问列表\",{\"1\":{\"230\":1}}],[\"的初始\",{\"1\":{\"305\":1,\"338\":1}}],[\"的内存空间\",{\"1\":{\"522\":1}}],[\"的内存空间中\",{\"1\":{\"482\":1}}],[\"的内存结构\",{\"1\":{\"465\":1}}],[\"的内存分区\",{\"1\":{\"465\":1}}],[\"的内存分代改进\",{\"1\":{\"465\":1}}],[\"的内存区域\",{\"1\":{\"301\":1}}],[\"的内存\",{\"1\":{\"301\":1}}],[\"的问题\",{\"1\":{\"278\":1}}],[\"的大小\",{\"1\":{\"277\":1}}],[\"的锁\",{\"1\":{\"251\":1}}],[\"的结构不同\",{\"1\":{\"686\":1}}],[\"的结构也变为轻量级锁的结构\",{\"1\":{\"278\":1}}],[\"的结构也变为偏向锁结构\",{\"1\":{\"278\":1}}],[\"的结构类似\",{\"1\":{\"252\":1}}],[\"的结构和\",{\"1\":{\"251\":1}}],[\"的结构一样\",{\"1\":{\"249\":1}}],[\"的概念\",{\"1\":{\"249\":1,\"305\":1,\"355\":1}}],[\"的形式\",{\"1\":{\"249\":1}}],[\"的底层数据结构类似都是采用\",{\"1\":{\"249\":1}}],[\"的底层实现\",{\"0\":{\"243\":1}}],[\"的前提是\",{\"1\":{\"246\":1}}],[\"的前提下\",{\"1\":{\"81\":1}}],[\"的默认行为是对堆上的对象产生独特值\",{\"1\":{\"242\":1}}],[\"的相关规定\",{\"1\":{\"242\":1}}],[\"的升序排序\",{\"1\":{\"241\":1}}],[\"的源码非常非常少\",{\"1\":{\"240\":1}}],[\"的幂次则等价于与其除数减一的与\",{\"1\":{\"246\":1}}],[\"的幂次方\",{\"0\":{\"246\":1},\"1\":{\"239\":1,\"246\":2}}],[\"的幂次方大小\",{\"1\":{\"239\":1}}],[\"的幂作为哈希表的大小\",{\"1\":{\"239\":2}}],[\"的支持\",{\"1\":{\"239\":1}}],[\"的描述如下\",{\"1\":{\"235\":1}}],[\"的唯一元素就是这个数组\",{\"1\":{\"233\":1}}],[\"的真正得到的参数就不是数组中的元素\",{\"1\":{\"233\":1}}],[\"的空数组\",{\"1\":{\"235\":1}}],[\"的空\",{\"1\":{\"229\":1}}],[\"的空间花费则体现在它的每一个元素都需要消耗比\",{\"1\":{\"229\":1}}],[\"的空间\",{\"1\":{\"194\":1,\"1030\":1}}],[\"的子类\",{\"1\":{\"220\":1}}],[\"的情况下\",{\"1\":{\"784\":1}}],[\"的情况下的最大价值\",{\"1\":{\"207\":1}}],[\"的情况会更少\",{\"1\":{\"536\":1}}],[\"的情况\",{\"1\":{\"207\":2}}],[\"的条件下的\",{\"1\":{\"207\":1}}],[\"的价值\",{\"1\":{\"207\":1}}],[\"的背包\",{\"1\":{\"207\":1}}],[\"的题型来抽象模型的话\",{\"1\":{\"206\":1}}],[\"的玩家传递到编号\",{\"1\":{\"204\":1,\"205\":1}}],[\"的玩家\",{\"1\":{\"204\":2,\"205\":2}}],[\"的玩家的方案数\",{\"1\":{\"204\":1,\"205\":1}}],[\"的时间轮\",{\"1\":{\"758\":1}}],[\"的时间\",{\"1\":{\"194\":2}}],[\"的时候返回了5这个节点\",{\"1\":{\"970\":1}}],[\"的时候需要用到java动态代理技术\",{\"1\":{\"878\":1}}],[\"的时候才会触发\",{\"1\":{\"463\":1}}],[\"的时候恢复现场\",{\"1\":{\"267\":1}}],[\"的时候已经摒弃了\",{\"1\":{\"249\":1}}],[\"的时候\",{\"1\":{\"82\":2,\"249\":1,\"288\":1,\"317\":1,\"338\":1,\"614\":2,\"782\":1}}],[\"的数量变成了三个\",{\"1\":{\"939\":1}}],[\"的数据时\",{\"1\":{\"655\":1}}],[\"的数据结构\",{\"1\":{\"249\":1}}],[\"的数\",{\"1\":{\"190\":1}}],[\"的网站\",{\"1\":{\"139\":1}}],[\"的效果\",{\"1\":{\"106\":1}}],[\"的功能\",{\"1\":{\"103\":1,\"812\":2}}],[\"的配置文件并且将实现类全部实例化\",{\"1\":{\"893\":1}}],[\"的配置参数封装为一个工具类\",{\"1\":{\"701\":1}}],[\"的配置信息\",{\"1\":{\"674\":1,\"754\":1}}],[\"的配置\",{\"1\":{\"85\":1}}],[\"的\",{\"0\":{\"352\":1,\"353\":1,\"822\":1,\"893\":1},\"1\":{\"82\":1,\"85\":2,\"229\":1,\"239\":1,\"241\":1,\"244\":8,\"246\":1,\"248\":1,\"249\":4,\"308\":1,\"323\":1,\"340\":1,\"367\":2,\"435\":1,\"468\":1,\"488\":1,\"535\":1,\"591\":1,\"599\":1,\"612\":1,\"614\":2,\"617\":1,\"685\":1,\"686\":1,\"702\":3,\"720\":1,\"741\":1,\"742\":1,\"754\":1,\"756\":1,\"758\":2,\"810\":1,\"811\":1,\"813\":1,\"816\":2,\"818\":2,\"842\":1,\"879\":1,\"933\":1}}],[\"的坐标\",{\"1\":{\"78\":1}}],[\"的本地仓库中想看一个\",{\"1\":{\"77\":1}}],[\"的构建命令\",{\"0\":{\"72\":1}}],[\"的上一级\",{\"1\":{\"62\":1}}],[\"另附上官方题解\",{\"1\":{\"975\":1}}],[\"另一方面\",{\"1\":{\"753\":1}}],[\"另一方面将它们推入队列\",{\"1\":{\"727\":1}}],[\"另一方面它将消息\",{\"1\":{\"692\":1}}],[\"另一种是类名中含有decorator\",{\"1\":{\"628\":1}}],[\"另一种用途是作为\",{\"1\":{\"533\":1}}],[\"另一个树的子树\",{\"0\":{\"1017\":1}}],[\"另一个绑定键为\",{\"1\":{\"736\":1}}],[\"另一个classloader加载会更改的类\",{\"1\":{\"670\":1}}],[\"另一个就是from\",{\"1\":{\"490\":1}}],[\"另一个例子\",{\"1\":{\"317\":1}}],[\"另一个线程运行到exchange\",{\"1\":{\"292\":1}}],[\"另一个线程不能使用\",{\"1\":{\"249\":1}}],[\"另一个是\",{\"1\":{\"214\":1}}],[\"另一个配色网站\",{\"1\":{\"139\":1}}],[\"另一个在线制作\",{\"1\":{\"139\":1}}],[\"另外由于依托了spring\",{\"1\":{\"886\":1}}],[\"另外一种描述\",{\"1\":{\"614\":1}}],[\"另外一种是抛出异常\",{\"1\":{\"413\":1}}],[\"另外一类对象的生命周期非常长\",{\"1\":{\"488\":1}}],[\"另外一个问題是及时保证\",{\"1\":{\"471\":1}}],[\"另外一维代表\",{\"1\":{\"207\":1}}],[\"另外等待的5个人中可以是随机获得优先机会\",{\"1\":{\"292\":1}}],[\"另外\",{\"1\":{\"77\":1,\"222\":1,\"239\":1,\"275\":1,\"301\":1,\"313\":1,\"369\":1,\"416\":1,\"607\":1,\"752\":1,\"758\":1,\"904\":1,\"943\":1}}],[\"另外还有一个return指令供声明为\",{\"1\":{\"424\":1}}],[\"另外还有一个\",{\"1\":{\"71\":1}}],[\"另存为\",{\"1\":{\"44\":1}}],[\"子查询\",{\"0\":{\"850\":1},\"1\":{\"843\":1}}],[\"子加载器才会尝试自己去加载\",{\"1\":{\"391\":1}}],[\"子目录\",{\"1\":{\"383\":1}}],[\"子工程引用父工程中的依赖信息时\",{\"1\":{\"88\":1}}],[\"子工程的坐标\",{\"1\":{\"88\":1}}],[\"子工程的pom文件内会出现\",{\"1\":{\"88\":1}}],[\"子工程的pom\",{\"0\":{\"88\":1}}],[\"子标签\",{\"1\":{\"70\":1}}],[\"子类的窄变量可能插入到父类变量的空隙\",{\"1\":{\"477\":1}}],[\"子类\",{\"1\":{\"6\":1}}],[\"可节约一点内存\",{\"1\":{\"935\":1}}],[\"可与通过tcc\",{\"1\":{\"910\":1}}],[\"可灵活控制类加载\",{\"1\":{\"903\":1}}],[\"可灵活回收空闲线程\",{\"1\":{\"291\":1}}],[\"可扩展性的基石\",{\"1\":{\"892\":1}}],[\"可传文件\",{\"1\":{\"888\":2}}],[\"可在内网替代\",{\"1\":{\"884\":1}}],[\"可在它的映射文件中配置<cache\",{\"1\":{\"813\":1}}],[\"可选\",{\"1\":{\"878\":1}}],[\"可选值如下\",{\"1\":{\"836\":1}}],[\"可靠的寻址方式\",{\"1\":{\"877\":1}}],[\"可输出\",{\"1\":{\"827\":1}}],[\"可自由\",{\"1\":{\"827\":1}}],[\"可唯一定位一个\",{\"1\":{\"816\":1}}],[\"可用来保存对象的状态\",{\"1\":{\"813\":1}}],[\"可用性\",{\"1\":{\"797\":1}}],[\"可用于分析某项技术的发展前景\",{\"1\":{\"122\":1}}],[\"可是这些不可路由消息根本没有机会进入到队列\",{\"1\":{\"767\":1}}],[\"可乐\",{\"1\":{\"762\":1,\"765\":1,\"768\":1}}],[\"可去官网下载找到\",{\"1\":{\"756\":1}}],[\"可根据需求决定端口\",{\"1\":{\"753\":1}}],[\"可参考这篇文章来配置\",{\"1\":{\"672\":1}}],[\"可配置多个\",{\"1\":{\"656\":1}}],[\"可防止脏读和不可重复读\",{\"1\":{\"634\":1}}],[\"可防止脏读\",{\"1\":{\"634\":1}}],[\"可指定\",{\"1\":{\"619\":1}}],[\"可指定依赖包的版本\",{\"1\":{\"70\":1}}],[\"可标注任意类为\",{\"1\":{\"618\":1}}],[\"可搭配serial\",{\"1\":{\"539\":1}}],[\"可查看默认设置收集器类型\",{\"1\":{\"537\":1}}],[\"可预测的停顿\",{\"1\":{\"535\":1}}],[\"可通过\",{\"1\":{\"917\":1}}],[\"可通过打印的gc日志的新生代\",{\"1\":{\"537\":1}}],[\"可通过java\",{\"1\":{\"505\":1}}],[\"可通过下列指令显式指定使用哪种即时编译器\",{\"1\":{\"372\":1}}],[\"可从文件\",{\"1\":{\"468\":1}}],[\"可调用无参\",{\"1\":{\"468\":1}}],[\"可进一步通过工具查看泄漏对象到gc\",{\"1\":{\"450\":1}}],[\"可先通过\",{\"1\":{\"449\":1}}],[\"可视化分析工具\",{\"0\":{\"341\":1}}],[\"可视化配置工具\",{\"1\":{\"151\":1}}],[\"可达性分析法中不可达的对象被第一次标记并且进行一次筛选\",{\"1\":{\"323\":1}}],[\"可达性分析算法\",{\"0\":{\"322\":1}}],[\"可控制线程数最大并发数\",{\"1\":{\"291\":1}}],[\"可实现选择性通知\",{\"1\":{\"286\":1}}],[\"可实现公平锁\",{\"1\":{\"286\":1}}],[\"可忽略该参数\",{\"1\":{\"275\":1}}],[\"可重入锁\",{\"0\":{\"271\":1},\"1\":{\"271\":1,\"284\":1}}],[\"可重复的集合\",{\"1\":{\"225\":1}}],[\"可重复的\",{\"1\":{\"215\":3,\"217\":1}}],[\"可能还会引申出\",{\"1\":{\"894\":1}}],[\"可能还包括字符串字面量和数字常量\",{\"1\":{\"375\":1}}],[\"可能就会有多张表\",{\"1\":{\"861\":1}}],[\"可能导致脏读\",{\"1\":{\"634\":1}}],[\"可能会超出count\",{\"1\":{\"939\":1}}],[\"可能会存在修改\",{\"1\":{\"503\":1}}],[\"可能会创建大量的线程\",{\"1\":{\"291\":1}}],[\"可能会堆积大量的请求\",{\"1\":{\"291\":1}}],[\"可能会进入阻塞或轮询状态\",{\"1\":{\"249\":1}}],[\"可能是作为线程池中的一员\",{\"1\":{\"280\":1}}],[\"可能是50个循环或100循环\",{\"1\":{\"278\":1}}],[\"可能相同\",{\"1\":{\"240\":1}}],[\"可使代码更简洁\",{\"1\":{\"935\":1}}],[\"可使价值最大\",{\"1\":{\"207\":2}}],[\"可使这些物品的总体积不超过背包容量\",{\"1\":{\"207\":1}}],[\"可知\",{\"1\":{\"204\":1,\"205\":1}}],[\"可几种声音合成\",{\"1\":{\"144\":1}}],[\"可画\",{\"1\":{\"139\":1}}],[\"可打直接可运行的jar包或war包\",{\"1\":{\"104\":1}}],[\"可以安装\",{\"1\":{\"1004\":1}}],[\"可以构造出z升水\",{\"1\":{\"982\":1}}],[\"可以计算出需要增加的次数\",{\"1\":{\"939\":1}}],[\"可以复用的变量在方法外声明\",{\"1\":{\"935\":1}}],[\"可以采用\",{\"1\":{\"919\":1}}],[\"可以基于虚拟节点\",{\"1\":{\"916\":1}}],[\"可以通讯\",{\"1\":{\"915\":1}}],[\"可以通过调用\",{\"1\":{\"783\":1}}],[\"可以通过实现\",{\"1\":{\"610\":1}}],[\"可以通过实现该接口定义横切逻辑\",{\"1\":{\"603\":1}}],[\"可以通过表达式或匹配的方式指明切入点\",{\"1\":{\"604\":1}}],[\"可以通过选项\",{\"1\":{\"485\":1,\"488\":1,\"498\":1}}],[\"可以通过\",{\"1\":{\"286\":1,\"471\":1}}],[\"可以一次只加载自己想要加载的扩展实现\",{\"1\":{\"909\":1}}],[\"可以一键完成安装\",{\"1\":{\"90\":1}}],[\"可以做到调用时动态决定调用哪个实现\",{\"1\":{\"904\":1}}],[\"可以做到开箱即用\",{\"1\":{\"664\":1}}],[\"可以异步调用\",{\"1\":{\"896\":1}}],[\"可以和spring框架无缝集成\",{\"1\":{\"879\":1}}],[\"可以选择netty或者mina来解决nio数据传输的问题\",{\"1\":{\"878\":1}}],[\"可以选择固定大小或者可扩展\",{\"1\":{\"442\":1}}],[\"可以统称为服务\",{\"1\":{\"873\":1}}],[\"可以这样实现\",{\"1\":{\"854\":1}}],[\"可以组装查询\",{\"1\":{\"843\":1}}],[\"可以查看sql语句\",{\"1\":{\"831\":1}}],[\"可以配置是否启用延迟加载\",{\"1\":{\"821\":1}}],[\"可以唯一找到\",{\"1\":{\"816\":1}}],[\"可以让我们在\",{\"1\":{\"812\":1}}],[\"可以严格控制sql执行性能\",{\"1\":{\"806\":1}}],[\"可以理解为验证码\",{\"1\":{\"771\":1}}],[\"可以理解成是在进程中独立运行的子任务\",{\"1\":{\"264\":1}}],[\"可以很好的应对这个问题\",{\"1\":{\"767\":1}}],[\"可以很好的解决单点故障问题\",{\"1\":{\"758\":1}}],[\"可以为队列设置死信交换机来存储那些处理失败的消息\",{\"1\":{\"767\":1}}],[\"可以为基本类型设置默认值\",{\"1\":{\"600\":1}}],[\"可以替代零个或多个位置\",{\"1\":{\"740\":1}}],[\"可以代替一个位置\",{\"1\":{\"740\":1}}],[\"可以是\",{\"1\":{\"728\":1}}],[\"可以多个消费者消费\",{\"1\":{\"697\":1}}],[\"可以划分出多个\",{\"1\":{\"693\":1}}],[\"可以划分为年轻代\",{\"1\":{\"488\":1}}],[\"可以实现\",{\"1\":{\"687\":1}}],[\"可以实现接口\",{\"1\":{\"687\":1}}],[\"可以放置在build标签外部下载完成后再粘贴进plugin中\",{\"1\":{\"671\":1}}],[\"可以打成jar包直接运行\",{\"1\":{\"667\":1}}],[\"可以包含springboot\",{\"1\":{\"666\":1}}],[\"可以包含多个\",{\"1\":{\"70\":1}}],[\"可以减少jar包的冲突\",{\"1\":{\"664\":1}}],[\"可以支持各种视图技术\",{\"1\":{\"644\":1}}],[\"可以帮助我们进行更简洁的web层的开发\",{\"1\":{\"643\":1}}],[\"可以像\",{\"1\":{\"615\":1}}],[\"可以直接被应用调用\",{\"1\":{\"875\":1}}],[\"可以直接通过\",{\"1\":{\"686\":1}}],[\"可以直接代理实现类\",{\"1\":{\"607\":1}}],[\"可以直接继承\",{\"1\":{\"387\":1}}],[\"可以对成员变量\",{\"1\":{\"599\":1}}],[\"可以对spring\",{\"1\":{\"104\":1}}],[\"可以同时使用两种方式的依赖注入\",{\"1\":{\"597\":1}}],[\"可以试试下面的命令\",{\"1\":{\"587\":1}}],[\"可以发现修改的内容已经进去了\",{\"1\":{\"585\":1}}],[\"可以发现除了可用的方法外\",{\"1\":{\"10\":1}}],[\"可以根据jpa风格的方法名生成对应的sql语句\",{\"1\":{\"867\":1}}],[\"可以根据对象关系模型直接获取\",{\"1\":{\"806\":1,\"823\":1}}],[\"可以根据xml配置\",{\"1\":{\"642\":1}}],[\"可以根据不同的参数生成对应的数据\",{\"1\":{\"565\":1}}],[\"可以根据当前日期或时间创建实例\",{\"1\":{\"565\":1}}],[\"可以根据上一次自旋的时间与结果调整下一次自旋的时间\",{\"1\":{\"278\":1}}],[\"可以向下方这样实现\",{\"1\":{\"562\":1}}],[\"可以连接起来的流操作称为中间操作\",{\"1\":{\"546\":1}}],[\"可以连成一条流水线\",{\"1\":{\"546\":1}}],[\"可以更专心地专注于业务开发\",{\"1\":{\"517\":1}}],[\"可以大大减少堆内存的占用\",{\"1\":{\"510\":1}}],[\"可以不再进行\",{\"1\":{\"939\":1}}],[\"可以不需要其他收集器配合就能独立管理整个\",{\"1\":{\"535\":1}}],[\"可以不存储在内存\",{\"1\":{\"507\":1}}],[\"可以不用数组\",{\"1\":{\"200\":1}}],[\"可以改为\",{\"1\":{\"488\":1}}],[\"可以改善github连接\",{\"1\":{\"113\":1}}],[\"可以存到常量池\",{\"1\":{\"457\":1}}],[\"可以存储\",{\"1\":{\"239\":1}}],[\"可以存储重复元素\",{\"1\":{\"226\":3}}],[\"可以与其他所有的java标识符连用\",{\"1\":{\"434\":1}}],[\"可以进行数据恢复\",{\"1\":{\"839\":1}}],[\"可以进行简单优化\",{\"1\":{\"372\":1}}],[\"可以进行优化\",{\"1\":{\"203\":1}}],[\"可以触发c1编译\",{\"1\":{\"372\":1}}],[\"可以设计为单例或多例\",{\"1\":{\"654\":1}}],[\"可以设置参数\",{\"1\":{\"490\":1}}],[\"可以设置次数\",{\"1\":{\"490\":1}}],[\"可以设置程序执行方式\",{\"0\":{\"371\":1}}],[\"可以设定从该线程池中获得线程的最小间隔时间\",{\"1\":{\"291\":1}}],[\"可以避免类的重复加载\",{\"1\":{\"333\":1}}],[\"可以维护系统的运行安全\",{\"1\":{\"328\":1}}],[\"可以节省毫无意义的请求锁时间\",{\"1\":{\"278\":1}}],[\"可以简单理解为当某段代码即将第一次被执行时进行编译\",{\"1\":{\"278\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"270\":1}}],[\"可以看着是http协议的一种直接应用\",{\"1\":{\"875\":1}}],[\"可以看做是一张表\",{\"1\":{\"458\":1}}],[\"可以看作是当前线程所执行的字节码的行号指示器\",{\"1\":{\"301\":1}}],[\"可以看到哪怕\",{\"1\":{\"757\":1}}],[\"可以看到\",{\"1\":{\"253\":1,\"523\":1,\"762\":1}}],[\"可以看出\",{\"1\":{\"241\":1,\"937\":1}}],[\"可以使用jdk提供的原生的动态代理机制\",{\"1\":{\"878\":1}}],[\"可以使用选项\",{\"1\":{\"488\":1}}],[\"可以使用\",{\"1\":{\"369\":1,\"532\":1,\"618\":1,\"676\":1,\"806\":1}}],[\"可以使用虚拟机参数\",{\"1\":{\"369\":1}}],[\"可以使用包装类型数组就可以解决这个问题\",{\"1\":{\"233\":1}}],[\"可以使用类似这样的方式\",{\"1\":{\"106\":1}}],[\"可以将主类中的注解移到此处\",{\"1\":{\"857\":1}}],[\"可以将其丢弃了\",{\"1\":{\"706\":2}}],[\"可以将异常抛给spring框架\",{\"1\":{\"650\":1}}],[\"可以将简单的组件配置\",{\"1\":{\"592\":1}}],[\"可以将\",{\"1\":{\"228\":1}}],[\"可以抽象出我们的\",{\"1\":{\"207\":1}}],[\"可以得知\",{\"1\":{\"203\":1}}],[\"可以先给学生分数排序\",{\"1\":{\"189\":1}}],[\"可以用于构造器\",{\"1\":{\"597\":1}}],[\"可以用于记录应用程序中的事件时间戳\",{\"1\":{\"557\":1}}],[\"可以用滑动窗口\",{\"1\":{\"188\":1}}],[\"可以用在平时的解题中\",{\"1\":{\"181\":1}}],[\"可以\",{\"1\":{\"143\":1,\"329\":1,\"706\":1}}],[\"可以把该消息删除了\",{\"1\":{\"704\":1}}],[\"可以把视频自动转成漫画\",{\"1\":{\"142\":1}}],[\"可以把版本号去掉\",{\"1\":{\"88\":1}}],[\"可以免费下载模板\",{\"1\":{\"142\":1}}],[\"可以抠图\",{\"1\":{\"140\":1}}],[\"可以指定最终输出jar的meta\",{\"1\":{\"103\":1}}],[\"可以在xml和mapper接口之间跳转\",{\"1\":{\"867\":1}}],[\"可以在开发阶段识别风险\",{\"1\":{\"853\":1}}],[\"可以在lambdaquerywrapper里使用类似user\",{\"1\":{\"853\":1}}],[\"可以在不编写田可sql语句的情况下\",{\"1\":{\"826\":1}}],[\"可以在不知道时间值的情况下\",{\"1\":{\"562\":1}}],[\"可以在\",{\"1\":{\"686\":1,\"817\":1}}],[\"可以在需要自动注入该类\",{\"1\":{\"599\":1}}],[\"可以在已有对象上进行年月日时分秒\",{\"1\":{\"565\":1}}],[\"可以在数字后面加具体单位\",{\"1\":{\"410\":1}}],[\"可以在<properties>内声明自定义属性统一管理\",{\"1\":{\"87\":1}}],[\"可以在idea里测试\",{\"1\":{\"22\":1}}],[\"可以传递到\",{\"1\":{\"82\":1}}],[\"可以传递\",{\"1\":{\"81\":1}}],[\"可以参照官网看到它的用法\",{\"1\":{\"78\":1}}],[\"可以快速在接口方法和xml的sql之间跳转\",{\"1\":{\"22\":1}}],[\"可以搜索内容\",{\"1\":{\"6\":1}}],[\"从一个水壶向另外一个水壶倒水\",{\"1\":{\"981\":1}}],[\"从后到前进行反转\",{\"1\":{\"970\":1}}],[\"从链表中独立了出来\",{\"1\":{\"970\":1}}],[\"从小到大计算dp\",{\"1\":{\"926\":1}}],[\"从上面的回答中\",{\"1\":{\"892\":1}}],[\"从执行sql到返回result的过程\",{\"1\":{\"806\":1}}],[\"从哪个交换机退回\",{\"1\":{\"765\":1}}],[\"从以上优点可知\",{\"1\":{\"665\":1}}],[\"从结构上来看和decorator模式类似\",{\"1\":{\"629\":1}}],[\"从三级缓存通过对象工厂拿到a\",{\"1\":{\"621\":1}}],[\"从客户端的角度看\",{\"1\":{\"604\":1}}],[\"从january到decemeber\",{\"1\":{\"566\":1}}],[\"从支持数据处理操作的源生成的元素序列\",{\"1\":{\"544\":1}}],[\"从局部上来看是基于\",{\"1\":{\"535\":1}}],[\"从整体来看是基于\",{\"1\":{\"535\":1}}],[\"从名字中的mark\",{\"1\":{\"534\":1}}],[\"从效率上来说\",{\"1\":{\"523\":1}}],[\"从根节点开始标记所有被引用对象\",{\"1\":{\"523\":1}}],[\"从内存模型而不是垃圾收集的角度\",{\"1\":{\"500\":1}}],[\"从代码上检查是否存在某些对象生命周期过长\",{\"1\":{\"450\":1}}],[\"从线程共享与否的角度来看\",{\"1\":{\"439\":1}}],[\"从概念上来讲\",{\"1\":{\"381\":1}}],[\"从加密文件中获取\",{\"1\":{\"378\":1}}],[\"从专有数据库中提取\",{\"1\":{\"378\":1}}],[\"从\",{\"1\":{\"378\":1,\"383\":1,\"720\":1,\"744\":1,\"782\":1,\"812\":1}}],[\"从本地系统中直接加载\",{\"1\":{\"378\":1}}],[\"从外观上来看\",{\"1\":{\"356\":1}}],[\"从这些节点开始向下搜索\",{\"1\":{\"322\":1}}],[\"从字符串常量池中拿对象\",{\"1\":{\"317\":1}}],[\"从虚拟机的视角来看\",{\"1\":{\"314\":1}}],[\"从垃圾回收的角度\",{\"1\":{\"304\":1}}],[\"从而把左孩子加入集合\",{\"1\":{\"1034\":1}}],[\"从而可以得到恰好\",{\"1\":{\"981\":1}}],[\"从而可以有选择性的进行线程通知\",{\"1\":{\"286\":1}}],[\"从而有效控制系统中与软件代理交互的人为依赖性\",{\"1\":{\"875\":1}}],[\"从而有能实现有选择性地接收日志\",{\"1\":{\"740\":1}}],[\"从而实现不重复消费\",{\"1\":{\"774\":1}}],[\"从而实现自定义的类加载类\",{\"1\":{\"387\":1}}],[\"从而堆积太多消息\",{\"1\":{\"718\":1}}],[\"从而增加了消费者的\",{\"1\":{\"717\":1}}],[\"从而完成了调用\",{\"1\":{\"632\":1}}],[\"从而使得编译器可以在编译期间织入有关\",{\"1\":{\"603\":1}}],[\"从而使线程所在对象中的其他synchronized数据可以被其他线程使用\",{\"1\":{\"273\":1}}],[\"从而减少一次\",{\"1\":{\"527\":1}}],[\"从而直接在eden空间中分配内存\",{\"1\":{\"502\":1}}],[\"从而提高性能\",{\"1\":{\"485\":1}}],[\"从而不会出现相互干扰的情况\",{\"1\":{\"402\":1}}],[\"从而很大程度上提高了解释器的性能\",{\"1\":{\"362\":1}}],[\"从而诞生了实现解释器在运行时采用逐行解释宇节码执行程序的想法\",{\"1\":{\"360\":1}}],[\"从而导致oom\",{\"1\":{\"291\":2}}],[\"从而也就提供程序的性能\",{\"1\":{\"278\":1}}],[\"从而解决多线程并发访问集合时的线程安全问题\",{\"1\":{\"259\":1}}],[\"从reentrantlock的实现看aqs的原理及应用\",{\"1\":{\"262\":1,\"289\":1}}],[\"从性能的角度上\",{\"1\":{\"231\":1}}],[\"从第2个元素开始\",{\"1\":{\"202\":1}}],[\"从第三行开始\",{\"1\":{\"201\":1}}],[\"从左到右遍历一次排序后的数组\",{\"1\":{\"189\":1}}],[\"从你的图片中提取配色\",{\"1\":{\"139\":1}}],[\"从命令行执行\",{\"1\":{\"106\":1}}],[\"从项目所在的目录中的\",{\"1\":{\"99\":1}}],[\"从maven2开始就固定是4\",{\"1\":{\"70\":1}}],[\"从创建到现在\",{\"1\":{\"1\":1}}],[\"代理层做远程调用和返回结果\",{\"1\":{\"883\":1}}],[\"代理层\",{\"1\":{\"883\":1}}],[\"代理对象\",{\"1\":{\"816\":1}}],[\"代理对象和目标对象是一样的\",{\"1\":{\"604\":1}}],[\"代理是将通知应用到目标对象后创建的对象\",{\"1\":{\"604\":1}}],[\"代理\",{\"1\":{\"604\":1,\"606\":1}}],[\"代理包含了目标对象的全部方法\",{\"1\":{\"603\":1}}],[\"代理类这些都变成了一个个实际的\",{\"1\":{\"607\":1}}],[\"代理类的主要逻辑是\",{\"1\":{\"907\":1}}],[\"代理类的\",{\"1\":{\"607\":1}}],[\"代理类\",{\"1\":{\"603\":1}}],[\"代表着二叉树当前层元素的数量\",{\"1\":{\"1035\":1}}],[\"代表土地\",{\"1\":{\"933\":1}}],[\"代表dao层中第二参数\",{\"1\":{\"819\":1}}],[\"代表接收的是dao层中的第一个参数\",{\"1\":{\"819\":1}}],[\"代表成功添加插件\",{\"1\":{\"756\":1}}],[\"代表拒绝重新入队\",{\"1\":{\"749\":1}}],[\"代表预取值分发\",{\"1\":{\"717\":1}}],[\"代表不公平分发\",{\"1\":{\"717\":1}}],[\"代表开启持久化\",{\"1\":{\"711\":1}}],[\"代表批量应答\",{\"1\":{\"706\":1}}],[\"代表自动应答\",{\"1\":{\"698\":1}}],[\"代表默认交换机\",{\"1\":{\"697\":2}}],[\"代表使用者保留的消息缓冲区\",{\"1\":{\"695\":1}}],[\"代表了一个特定的应用类型\",{\"1\":{\"682\":1}}],[\"代表一个方法的执行\",{\"1\":{\"604\":1}}],[\"代表一个时间\",{\"1\":{\"561\":1}}],[\"代表日期时间\",{\"1\":{\"562\":1}}],[\"代表数组长度\",{\"1\":{\"246\":1}}],[\"代表当前pom\",{\"1\":{\"70\":1}}],[\"代码主要参考自甜姨\",{\"1\":{\"1036\":1}}],[\"代码走到这里说明不可能拼出z升水\",{\"1\":{\"983\":1}}],[\"代码解析为4\",{\"1\":{\"970\":1}}],[\"代码3\",{\"0\":{\"945\":1,\"984\":1}}],[\"代码2\",{\"0\":{\"939\":1,\"944\":1,\"949\":1,\"965\":1,\"969\":1,\"983\":1,\"1030\":1,\"1035\":1}}],[\"代码1\",{\"0\":{\"925\":1,\"938\":1,\"943\":1,\"948\":1,\"963\":1,\"968\":1,\"982\":1,\"1029\":1,\"1034\":1}}],[\"代码零侵入\",{\"1\":{\"904\":1}}],[\"代码生成器\",{\"0\":{\"862\":1}}],[\"代码和手动设置参数以及获取结果集\",{\"1\":{\"806\":1}}],[\"代码中开启\",{\"1\":{\"764\":1}}],[\"代码中可以不用赋初始值就可以直接使用\",{\"1\":{\"472\":1}}],[\"代码中可以不赋初始值就直接使用\",{\"1\":{\"312\":1}}],[\"代码里使用了\",{\"1\":{\"757\":1}}],[\"代码架构图\",{\"1\":{\"754\":1,\"762\":1,\"768\":1}}],[\"代码优化\",{\"0\":{\"507\":1}}],[\"代码处理在程序计数器中的偏移地址\",{\"1\":{\"454\":1}}],[\"代码的执行分类\",{\"0\":{\"365\":1}}],[\"代码的时候\",{\"1\":{\"359\":1,\"709\":1}}],[\"代码编译和执行过程\",{\"0\":{\"357\":1}}],[\"代码编辑\",{\"0\":{\"130\":1}}],[\"代码如下\",{\"1\":{\"87\":1,\"964\":1}}],[\"代码\",{\"0\":{\"931\":1,\"934\":1,\"954\":1,\"973\":1,\"1020\":1,\"1022\":1,\"1040\":1},\"1\":{\"47\":1,\"207\":1,\"734\":1,\"747\":2,\"749\":1,\"780\":1}}],[\"代码块\",{\"1\":{\"46\":1}}],[\"代码收尾\",{\"1\":{\"6\":1}}],[\"代码重构\",{\"1\":{\"6\":1}}],[\"最近公共祖先表示为一个结点\",{\"1\":{\"1038\":1}}],[\"最右边的结点一定是最后被遍历到的\",{\"1\":{\"1035\":1}}],[\"最坏情况下二叉树为一条链\",{\"1\":{\"1029\":1}}],[\"最多拆成3个元素\",{\"1\":{\"996\":1}}],[\"最多为k+1个\",{\"1\":{\"186\":1}}],[\"最长连续递增序列是\",{\"1\":{\"929\":2,\"1038\":2}}],[\"最长连续递增序列\",{\"0\":{\"928\":1}}],[\"最新dubbo面试题\",{\"1\":{\"921\":1}}],[\"最少活跃调用策略\",{\"1\":{\"916\":1}}],[\"最初由facebook开发用做系统内个语言之间的rpc通信\",{\"1\":{\"879\":1}}],[\"最顶端父类\",{\"1\":{\"842\":1}}],[\"最顶层的加载类\",{\"1\":{\"331\":1}}],[\"最起码通知我一声\",{\"1\":{\"764\":1}}],[\"最佳性能和资源使用\",{\"1\":{\"724\":1}}],[\"最佳实践中\",{\"1\":{\"816\":1}}],[\"最佳实践\",{\"1\":{\"146\":1}}],[\"最核心的一步\",{\"1\":{\"678\":1}}],[\"最重要的特性就体现在它的延时属性上\",{\"1\":{\"751\":1}}],[\"最重要的\",{\"1\":{\"678\":1}}],[\"最快\",{\"1\":{\"524\":1}}],[\"最慢\",{\"1\":{\"524\":1}}],[\"最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列\",{\"1\":{\"724\":1}}],[\"最好的选择是使用构造器参数实现强制依赖注入\",{\"1\":{\"597\":1}}],[\"最好的办法自然是为每一个线程都分配一个pc寄存器\",{\"1\":{\"402\":1}}],[\"最好不要用下面这些方法\",{\"1\":{\"259\":1}}],[\"最大公约数\",{\"0\":{\"984\":1}}],[\"最大上升子序列\",{\"0\":{\"924\":1}}],[\"最大的腐烂值\",{\"1\":{\"943\":1}}],[\"最大的区别在于他们各自的的特点所带来的不同应用场景\",{\"1\":{\"875\":1}}],[\"最大的用处就是通过ioc\",{\"1\":{\"592\":1}}],[\"最大可以设置到\",{\"1\":{\"697\":1,\"777\":1,\"779\":1}}],[\"最大值是15\",{\"1\":{\"503\":1}}],[\"最大值肯定是在奇数位上\",{\"1\":{\"198\":1}}],[\"最大堆空间内存\",{\"1\":{\"503\":1}}],[\"最大内存大小\",{\"1\":{\"486\":1}}],[\"最大\",{\"1\":{\"336\":1}}],[\"最大5gb的堆内存\",{\"1\":{\"335\":1}}],[\"最大大小\",{\"1\":{\"305\":1,\"338\":1}}],[\"最大线程数量\",{\"1\":{\"275\":1}}],[\"最大价值为0\",{\"1\":{\"207\":1}}],[\"最大价值\",{\"1\":{\"207\":1}}],[\"最大利润\",{\"1\":{\"202\":1}}],[\"最后打印右孩子\",{\"1\":{\"1024\":1}}],[\"最后请用以上水壶中的一或两个来盛放取得的\",{\"1\":{\"981\":1}}],[\"最后的结果是\",{\"1\":{\"1024\":1}}],[\"最后的结果为\",{\"1\":{\"1024\":1}}],[\"最后的最大层数就是需要的时间\",{\"1\":{\"944\":1}}],[\"最后的调用顺序是\",{\"1\":{\"905\":1}}],[\"最后还需要一个完善的监控机制\",{\"1\":{\"919\":1}}],[\"最后还是需要serial\",{\"1\":{\"534\":1}}],[\"最后消费者得到响应\",{\"1\":{\"891\":1}}],[\"最后通过统一异常处理\",{\"1\":{\"998\":1}}],[\"最后通过\",{\"1\":{\"890\":1}}],[\"最后就是最近流行的服务化架构\",{\"1\":{\"872\":1}}],[\"最后由mybatis框架执行sql并将结果映射为java对象并返回\",{\"1\":{\"806\":1}}],[\"最后由消费者从队列消费消息\",{\"1\":{\"738\":1}}],[\"最后使用\",{\"1\":{\"670\":1}}],[\"最后又将modelandview中的模型数据通过reques域传输到页面\",{\"1\":{\"654\":1}}],[\"最后\",{\"1\":{\"621\":1,\"964\":1,\"1023\":1}}],[\"最后完成垃圾回收\",{\"1\":{\"522\":1}}],[\"最后被垃圾回收器收集\",{\"1\":{\"512\":1}}],[\"最后线程结束\",{\"1\":{\"508\":1}}],[\"最后没办法也就只能升级为重量级锁了\",{\"1\":{\"278\":1}}],[\"最后再加1\",{\"1\":{\"253\":1}}],[\"最后再对1000000007l取余后\",{\"1\":{\"194\":1}}],[\"最后一个单词是\",{\"1\":{\"741\":1,\"742\":1}}],[\"最后一个消费者端开连接以后\",{\"1\":{\"697\":1}}],[\"最后一个节点的\",{\"1\":{\"229\":1}}],[\"最后一位的1被去掉了\",{\"1\":{\"184\":2}}],[\"最后找出所有窗口中分数差最小的值即可\",{\"1\":{\"189\":1}}],[\"最小路径和\",{\"1\":{\"180\":1}}],[\"最终\",{\"1\":{\"970\":1,\"1011\":1}}],[\"最终的max也得到了\",{\"1\":{\"925\":1}}],[\"最终又放入anonymousurls这个map\",{\"1\":{\"789\":1}}],[\"最终这些消费者线程被操作系统杀死\",{\"1\":{\"705\":1}}],[\"最终使得内存耗尽\",{\"1\":{\"705\":1}}],[\"最终生产消息到\",{\"1\":{\"697\":1}}],[\"最终通知\",{\"1\":{\"604\":1}}],[\"最终返回代理类\",{\"1\":{\"890\":1}}],[\"最终返回代理对象\",{\"1\":{\"603\":1}}],[\"最终返回stream<integer>\",{\"1\":{\"549\":1}}],[\"最终标记\",{\"1\":{\"535\":1}}],[\"最终会形成线性字节码执行流\",{\"1\":{\"357\":1}}],[\"最终结果+1\",{\"1\":{\"253\":1}}],[\"最终结果为\",{\"1\":{\"253\":1}}],[\"最终确定一个可用组合\",{\"1\":{\"85\":1}}],[\"最终还是选择了\",{\"1\":{\"1\":1}}],[\"最基本的做法就是将现实生活中的事物抽象为模型\",{\"1\":{\"68\":1}}],[\"和两个\",{\"1\":{\"939\":1}}],[\"和平日有无全方面的了解过一个框架\",{\"1\":{\"919\":1}}],[\"和querywrapper相比\",{\"1\":{\"851\":1}}],[\"和$\",{\"0\":{\"810\":1}}],[\"和死信交换机\",{\"1\":{\"754\":1}}],[\"和消息的\",{\"1\":{\"752\":1}}],[\"和消费者\",{\"1\":{\"701\":1}}],[\"和的消息会被发布到队列\",{\"1\":{\"736\":1}}],[\"和临时队列的绑定关系如下图\",{\"1\":{\"734\":1}}],[\"和那个队列进行了绑定关系\",{\"1\":{\"731\":1}}],[\"和应用程序\",{\"1\":{\"692\":1}}],[\"和普通的\",{\"0\":{\"686\":1}}],[\"和struts2的区别有哪些\",{\"0\":{\"654\":1}}],[\"和server\",{\"1\":{\"372\":1,\"878\":1}}],[\"和required一样\",{\"1\":{\"635\":1}}],[\"和runtime\",{\"1\":{\"518\":1}}],[\"和面向切面\",{\"1\":{\"592\":1}}],[\"和parallel\",{\"1\":{\"534\":1}}],[\"和用户线程\",{\"1\":{\"534\":1}}],[\"和锁消除\",{\"1\":{\"511\":1}}],[\"和老年代\",{\"1\":{\"488\":1}}],[\"和方法区\",{\"1\":{\"482\":1}}],[\"和对象的\",{\"1\":{\"473\":1}}],[\"和一连接到本地代码的库组成\",{\"1\":{\"435\":1}}],[\"和晚期绑定\",{\"1\":{\"420\":1}}],[\"和出栈\",{\"1\":{\"416\":1}}],[\"和自定义类加载器\",{\"1\":{\"381\":1}}],[\"和回边计数器\",{\"1\":{\"368\":1}}],[\"和java的原生序列化\",{\"1\":{\"879\":1}}],[\"和jar包在同一个目录内\",{\"1\":{\"77\":1}}],[\"和jdk中的\",{\"1\":{\"343\":1}}],[\"和最小大小\",{\"1\":{\"305\":1,\"338\":1}}],[\"和虚拟机栈所发挥的作用非常相似\",{\"1\":{\"303\":1}}],[\"和栈内存\",{\"1\":{\"302\":1}}],[\"和之前的版本略有不同\",{\"1\":{\"300\":1}}],[\"和之前的countdownlatch相比\",{\"1\":{\"292\":1}}],[\"和notify\",{\"1\":{\"286\":1}}],[\"和lock的区别\",{\"0\":{\"282\":1}}],[\"和hashmap\",{\"1\":{\"241\":1}}],[\"和第\",{\"1\":{\"229\":1}}],[\"和上面的滑动窗口不同\",{\"1\":{\"190\":1}}],[\"和\",{\"0\":{\"229\":1,\"239\":1,\"240\":1,\"241\":1,\"249\":1,\"617\":1},\"1\":{\"67\":1,\"80\":1,\"98\":2,\"106\":1,\"207\":2,\"214\":1,\"229\":1,\"231\":1,\"239\":2,\"249\":3,\"252\":1,\"278\":2,\"285\":1,\"302\":1,\"303\":1,\"306\":1,\"311\":1,\"351\":1,\"424\":1,\"454\":2,\"465\":3,\"485\":3,\"488\":1,\"531\":1,\"535\":1,\"536\":1,\"599\":2,\"612\":1,\"685\":2,\"693\":2,\"709\":1,\"730\":1,\"731\":2,\"740\":1,\"741\":1,\"754\":3,\"768\":1,\"783\":2,\"875\":1,\"883\":1,\"885\":1,\"933\":1,\"954\":2,\"981\":1,\"1018\":1}}],[\"和谐\",{\"0\":{\"49\":1}}],[\"含义是指定第三方jar的路径前缀\",{\"1\":{\"103\":1}}],[\"含义\",{\"0\":{\"67\":1},\"1\":{\"634\":1}}],[\"本题也不例外\",{\"1\":{\"926\":1}}],[\"本文大部分内容收集自网络\",{\"1\":{\"870\":1}}],[\"本文部分内容来自网络\",{\"1\":{\"213\":1}}],[\"本文部分收集自网络\",{\"1\":{\"117\":1,\"155\":1}}],[\"本内容将介绍整合了\",{\"1\":{\"760\":1}}],[\"本模式使得算法可独立于使用它的客户而变化\",{\"1\":{\"631\":1}}],[\"本质上解决循环依赖的问题就是三级缓存\",{\"1\":{\"621\":1}}],[\"本质上\",{\"1\":{\"424\":1,\"444\":1}}],[\"本质上是一个大的消息缓冲区\",{\"1\":{\"692\":1}}],[\"本质上是\",{\"1\":{\"85\":1}}],[\"本质上是同一个文件\",{\"1\":{\"77\":1}}],[\"本身不需要修改\",{\"1\":{\"315\":1}}],[\"本机直接内存的分配不会受到\",{\"1\":{\"308\":1}}],[\"本地引入\",{\"1\":{\"890\":1}}],[\"本地服务执行具体业务逻辑并将处理结果返回给服务端存根\",{\"1\":{\"874\":1}}],[\"本地缓存\",{\"1\":{\"813\":1}}],[\"本地代码缓存等\",{\"1\":{\"519\":1}}],[\"本地接口的作用是融合不同的编程语言为java所用\",{\"1\":{\"434\":1}}],[\"本地方法可通过本地方法接囗来访问虚拟机内部的运行时数据区\",{\"1\":{\"437\":1}}],[\"本地方法是使用c语言实现的\",{\"1\":{\"437\":1}}],[\"本地方法正是这样一种交流机制\",{\"1\":{\"435\":1}}],[\"本地方法接口\",{\"0\":{\"433\":1}}],[\"本地方法接口与本地方法栈\",{\"0\":{\"432\":1}}],[\"本地方法被执行的时候\",{\"1\":{\"303\":1}}],[\"本地方法栈内jni\",{\"1\":{\"519\":1}}],[\"本地方法栈也是线程私有的\",{\"1\":{\"437\":1}}],[\"本地方法栈和程序员计数器是运行是线程私有的内存区域\",{\"1\":{\"343\":1}}],[\"本地方法栈\",{\"0\":{\"303\":1,\"437\":1},\"1\":{\"300\":1,\"322\":1}}],[\"本地仓库\",{\"1\":{\"77\":1}}],[\"本地仓库中的位置\",{\"1\":{\"65\":1}}],[\"本站创建于2018年3月\",{\"1\":{\"1\":1}}],[\"上代码\",{\"1\":{\"957\":1}}],[\"上一个数是5\",{\"1\":{\"938\":1}}],[\"上一节中的我们的日志系统将所有消息广播给所有消费者\",{\"1\":{\"736\":1}}],[\"上的一个函数或方法\",{\"1\":{\"873\":1}}],[\"上通过参数传递的方式调用另一台机器\",{\"1\":{\"873\":1}}],[\"上文中提到的问题\",{\"1\":{\"756\":1}}],[\"上\",{\"1\":{\"736\":1}}],[\"上调用该方法\",{\"1\":{\"721\":1}}],[\"上不止只有一个消息来自消费者的手动确认\",{\"1\":{\"717\":1}}],[\"上有传送\",{\"1\":{\"706\":1}}],[\"上未应答的消息\",{\"1\":{\"706\":1}}],[\"上述这些类均提供了静态的of\",{\"1\":{\"565\":1}}],[\"上述这些类均提供了静态的now\",{\"1\":{\"565\":1}}],[\"上述现有的算法\",{\"1\":{\"526\":1}}],[\"上述高水位线调整情况会发生很多次\",{\"1\":{\"448\":1}}],[\"上限\",{\"1\":{\"444\":1}}],[\"上行代码中\",{\"1\":{\"439\":1}}],[\"上图是一个队列绑定关系图\",{\"1\":{\"741\":1}}],[\"上图是他们提供的\",{\"1\":{\"142\":1}}],[\"上图中\",{\"1\":{\"357\":1}}],[\"上方代码\",{\"1\":{\"1023\":1}}],[\"上方代码为jdk\",{\"1\":{\"338\":1}}],[\"上方代码用来设置新生代和老年代内存的比值\",{\"1\":{\"337\":1}}],[\"上方代码执行的结果是false\",{\"1\":{\"319\":1}}],[\"上方代码中\",{\"1\":{\"87\":1,\"317\":1}}],[\"上方str4的定义等于\",{\"1\":{\"317\":1}}],[\"上传组件\",{\"1\":{\"160\":1}}],[\"上传真人头像生成卡通头像\",{\"1\":{\"144\":1}}],[\"上面你回答\",{\"1\":{\"894\":1}}],[\"上面的代码相当于下面的\",{\"1\":{\"617\":1}}],[\"上面的代码可以指定新生代内存\",{\"1\":{\"336\":1}}],[\"上面的alloc\",{\"1\":{\"510\":1}}],[\"上面有示意图\",{\"0\":{\"251\":1,\"252\":1}}],[\"上面\",{\"1\":{\"241\":1}}],[\"上面托管了很多有趣的网站\",{\"1\":{\"143\":1}}],[\"上面很多免费教学视频\",{\"1\":{\"126\":1}}],[\"上面坐标对应的\",{\"1\":{\"65\":1}}],[\"上下文切换是现代操作系统的基本功能\",{\"1\":{\"267\":1}}],[\"上下文切换是什么\",{\"0\":{\"267\":1}}],[\"上下文切换\",{\"1\":{\"267\":1}}],[\"上下文操作\",{\"1\":{\"6\":1}}],[\"上下换行\",{\"1\":{\"6\":1}}],[\"坐标信息如下\",{\"1\":{\"77\":1}}],[\"坐标\",{\"1\":{\"65\":1}}],[\"表单提交的远程调用协议\",{\"1\":{\"888\":1}}],[\"表名\",{\"1\":{\"835\":1}}],[\"表中字段username\",{\"1\":{\"837\":1}}],[\"表中字段user\",{\"1\":{\"837\":1}}],[\"表中\",{\"1\":{\"757\":1}}],[\"表中存放着各个方法的实际入囗\",{\"1\":{\"423\":1}}],[\"表明一条消息或者该队列中的所有消息的最大存活时间\",{\"1\":{\"752\":1}}],[\"表达式\",{\"1\":{\"827\":1}}],[\"表达式实现的方式\",{\"1\":{\"241\":1}}],[\"表达\",{\"1\":{\"131\":1}}],[\"表示导入成功\",{\"1\":{\"1011\":1}}],[\"表示第x位的值为1\",{\"1\":{\"949\":1}}],[\"表示消息永远不会过期\",{\"1\":{\"752\":1}}],[\"表示只要有键值对匹配就能接受到消息\",{\"1\":{\"728\":1}}],[\"表示所有的键值对都匹配才能接受到消息\",{\"1\":{\"728\":1}}],[\"表示到这个序列号之前的所有消息都已经得到了处理\",{\"1\":{\"720\":1}}],[\"表示请求参数中必须包含该参数\",{\"1\":{\"651\":1}}],[\"表示是表现层\",{\"1\":{\"651\":1}}],[\"表示一个事务能够读取另一个事务中还未提交的数据\",{\"1\":{\"634\":1}}],[\"表示把日期修改为当月的第一天\",{\"1\":{\"569\":1}}],[\"表示日期\",{\"1\":{\"560\":1}}],[\"表示使用的是默认收集器\",{\"1\":{\"537\":1}}],[\"表示新生代占1\",{\"1\":{\"488\":2}}],[\"表示新消耗了v\",{\"1\":{\"207\":1}}],[\"表示为新生代分配256m的内存\",{\"1\":{\"336\":1}}],[\"表示最小2gb\",{\"1\":{\"335\":1}}],[\"表示要初始化内存的单位\",{\"1\":{\"335\":1}}],[\"表示要初始化内存的具体大小\",{\"1\":{\"335\":1}}],[\"表示走到第i层时的方法数\",{\"1\":{\"200\":1}}],[\"表示k范围内没有重复元素\",{\"1\":{\"186\":1}}],[\"表示遇到了重复元素\",{\"1\":{\"186\":1}}],[\"表示将工程抽象为一个模型\",{\"1\":{\"68\":1}}],[\"表示正式版本\",{\"1\":{\"65\":1}}],[\"表示快照版本\",{\"1\":{\"65\":1}}],[\"表格\",{\"1\":{\"46\":1}}],[\"工业级的话首先得易用\",{\"1\":{\"919\":1}}],[\"工厂模式\",{\"0\":{\"904\":1}}],[\"工厂配置信息\",{\"1\":{\"697\":2,\"698\":1}}],[\"工作队列\",{\"1\":{\"714\":1}}],[\"工作原理\",{\"0\":{\"391\":1}}],[\"工程或者\",{\"1\":{\"753\":1}}],[\"工程又反过来依赖\",{\"1\":{\"91\":1}}],[\"工程依赖\",{\"1\":{\"91\":2}}],[\"工程\",{\"1\":{\"85\":1,\"91\":3,\"696\":1}}],[\"工程能够管理其他\",{\"1\":{\"85\":1}}],[\"工程中不写业务代码\",{\"1\":{\"85\":1}}],[\"工程中\",{\"1\":{\"85\":1,\"462\":1}}],[\"工程为父工程\",{\"1\":{\"85\":1}}],[\"工程继承\",{\"1\":{\"85\":1}}],[\"工程所依赖的\",{\"1\":{\"78\":1}}],[\"工程骨架的\",{\"1\":{\"78\":1}}],[\"工程时\",{\"1\":{\"78\":1,\"85\":1}}],[\"工程的工程\",{\"1\":{\"85\":1}}],[\"工程的工程名\",{\"1\":{\"65\":1}}],[\"工程的\",{\"1\":{\"85\":1}}],[\"工程的依赖信息\",{\"1\":{\"78\":1}}],[\"工程的核心配置文件\",{\"1\":{\"69\":1}}],[\"工程根目录下\",{\"1\":{\"69\":1}}],[\"工具类常用方法\",{\"1\":{\"256\":1}}],[\"工具类\",{\"0\":{\"159\":1,\"988\":1}}],[\"工具大全\",{\"1\":{\"118\":1}}],[\"工具资源\",{\"0\":{\"109\":1},\"1\":{\"120\":1}}],[\"工具\",{\"1\":{\"591\":1},\"2\":{\"24\":1,\"29\":1,\"33\":1,\"50\":1,\"56\":1,\"107\":1,\"115\":1,\"153\":1,\"162\":1}}],[\"公用的数据库连接\",{\"1\":{\"632\":1}}],[\"公平锁\",{\"1\":{\"290\":1}}],[\"公平锁的实现原理\",{\"0\":{\"290\":1}}],[\"公司或组织的\",{\"1\":{\"65\":1}}],[\"公式块\",{\"1\":{\"46\":1}}],[\"包提供的具体实现类的全限定名\",{\"1\":{\"892\":1}}],[\"包里就是我们的代码\",{\"1\":{\"686\":1}}],[\"包名\",{\"1\":{\"452\":1,\"470\":1}}],[\"包和类\",{\"1\":{\"331\":2}}],[\"包和类或者被\",{\"1\":{\"331\":1}}],[\"包括多协议支持\",{\"1\":{\"885\":1}}],[\"包括通过\",{\"1\":{\"685\":1}}],[\"包括配置要使用的propertysource以及profile\",{\"1\":{\"678\":1}}],[\"包括model和view\",{\"1\":{\"642\":1}}],[\"包括aaa\",{\"1\":{\"584\":1}}],[\"包括未运行的\",{\"1\":{\"577\":1}}],[\"包括常量\",{\"1\":{\"573\":1}}],[\"包括jvm调参\",{\"1\":{\"534\":1}}],[\"包括原理\",{\"1\":{\"518\":1}}],[\"包括从父类继承下来的和本身拥有的字段\",{\"1\":{\"477\":1}}],[\"包括程序代码中定义的各种类型的字段\",{\"1\":{\"477\":1}}],[\"包括下面三类常量\",{\"1\":{\"464\":1}}],[\"包括编译期就己经明确的数值字面量\",{\"1\":{\"459\":1}}],[\"包括类和实例初始化\",{\"1\":{\"441\":1}}],[\"包括包名\",{\"1\":{\"395\":1}}],[\"包括包装类型\",{\"1\":{\"242\":1}}],[\"包括\",{\"1\":{\"381\":1,\"885\":1}}],[\"包括系统调用引起的内核态与用户态切换\",{\"1\":{\"278\":1}}],[\"包下的并发集合\",{\"1\":{\"256\":1,\"259\":1}}],[\"包含\",{\"1\":{\"926\":1}}],[\"包含消息的唯一\",{\"1\":{\"720\":1}}],[\"包含了\",{\"1\":{\"693\":1}}],[\"包含两部分\",{\"1\":{\"476\":1}}],[\"包含两个指针\",{\"1\":{\"229\":1}}],[\"包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接\",{\"1\":{\"417\":1}}],[\"包含一个\",{\"1\":{\"251\":1}}],[\"包含3d插画\",{\"1\":{\"139\":1}}],[\"包含多种学科\",{\"1\":{\"124\":1}}],[\"包含的属性\",{\"1\":{\"6\":1}}],[\"包从项目所在的目录中的\",{\"1\":{\"99\":1}}],[\"包版本必须一致\",{\"1\":{\"85\":1}}],[\"包组合\",{\"1\":{\"85\":1}}],[\"包之间的冲突\",{\"1\":{\"82\":1}}],[\"包之所以不参与部署\",{\"1\":{\"80\":1}}],[\"包时\",{\"1\":{\"81\":1}}],[\"包产生冲突\",{\"1\":{\"80\":1}}],[\"包都是以\",{\"1\":{\"80\":1}}],[\"包这样在项目实际运行时真正要用到的\",{\"1\":{\"80\":1}}],[\"包的\",{\"1\":{\"99\":1}}],[\"包的版本进行统一管理\",{\"1\":{\"85\":1}}],[\"包的坐标信息\",{\"1\":{\"78\":1}}],[\"包的列表\",{\"1\":{\"78\":1}}],[\"包原始的\",{\"1\":{\"77\":1}}],[\"包存入\",{\"1\":{\"77\":1}}],[\"包在\",{\"1\":{\"65\":1,\"77\":1}}],[\"包\",{\"1\":{\"65\":1,\"80\":3,\"85\":2,\"99\":2,\"331\":1,\"602\":1,\"686\":1,\"888\":1}}],[\"中序遍历和先序遍历的思维差不多\",{\"1\":{\"1024\":1}}],[\"中序遍历\",{\"0\":{\"1030\":1},\"1\":{\"1024\":3}}],[\"中是否包含和\",{\"1\":{\"1018\":1}}],[\"中是怎么存储的\",{\"1\":{\"467\":1}}],[\"中设置\",{\"1\":{\"901\":2}}],[\"中经过路由的过滤\",{\"1\":{\"891\":1}}],[\"中仍旧能看到此条数据记录\",{\"1\":{\"839\":1}}],[\"中交换机的\",{\"1\":{\"767\":1}}],[\"中一个消息或者队列的属性\",{\"1\":{\"752\":1}}],[\"中一键执行\",{\"1\":{\"90\":1}}],[\"中可以包含\",{\"1\":{\"693\":1}}],[\"中去\",{\"1\":{\"693\":1}}],[\"中怎么禁用某些自动配置特性\",{\"0\":{\"676\":1}}],[\"中拦截器如何使用\",{\"0\":{\"656\":1}}],[\"中对于文件的上传有哪些需要注意\",{\"0\":{\"655\":1}}],[\"中对java堆的描述是\",{\"1\":{\"482\":1}}],[\"中如何解决跨域问题\",{\"0\":{\"673\":1}}],[\"中如何解决\",{\"0\":{\"649\":1}}],[\"中保存了我们的\",{\"1\":{\"612\":1}}],[\"中存放的是各种对象\",{\"1\":{\"595\":1}}],[\"中存储的是稳定的句柄地址\",{\"1\":{\"315\":1}}],[\"中存储的直接就是对象的地址\",{\"1\":{\"315\":1}}],[\"中存储的就是对象的句柄地址\",{\"1\":{\"315\":1}}],[\"中间的节点3不会影响回文属性\",{\"1\":{\"974\":1}}],[\"中间的框是一个队列\",{\"1\":{\"695\":1}}],[\"中间带\",{\"1\":{\"741\":1,\"742\":1}}],[\"中间操作\",{\"1\":{\"546\":4}}],[\"中间放着一个指针作为分界点的指示器\",{\"1\":{\"471\":1}}],[\"中出现\",{\"1\":{\"536\":1}}],[\"中用于运行用户代码的时间与\",{\"1\":{\"532\":1}}],[\"中等难度类型\",{\"0\":{\"1042\":1}}],[\"中等\",{\"1\":{\"524\":1}}],[\"中关于java堆内存有这样一段描述\",{\"1\":{\"505\":1}}],[\"中方法区的变化\",{\"1\":{\"461\":1}}],[\"中方法区的演进\",{\"0\":{\"443\":1}}],[\"中不存在永久代的概念\",{\"1\":{\"444\":1}}],[\"中找到与常量中的描述符合简单名称都相符的方法\",{\"1\":{\"422\":1}}],[\"中找不到\",{\"1\":{\"392\":1}}],[\"中程序的执行性能会非常高效\",{\"1\":{\"365\":1}}],[\"中开辟了一块区域存放运行时常量池\",{\"1\":{\"343\":1}}],[\"中内置了三个重要的\",{\"1\":{\"331\":1}}],[\"中引用的对象\",{\"1\":{\"322\":2}}],[\"中新加入的\",{\"1\":{\"308\":1}}],[\"中还能看到\",{\"1\":{\"249\":1}}],[\"中添加元素\",{\"1\":{\"240\":2}}],[\"中带有初始容量的构造函数\",{\"1\":{\"239\":1}}],[\"中的每一个节点\",{\"1\":{\"1019\":1}}],[\"中的每个值都是唯一的最少操作次数\",{\"1\":{\"937\":1}}],[\"中的p就是5这个节点\",{\"1\":{\"970\":1}}],[\"中的统计数据\",{\"1\":{\"902\":1}}],[\"中的缓存将被\",{\"1\":{\"813\":1}}],[\"中的所有\",{\"1\":{\"813\":1}}],[\"中的消息也可利用\",{\"1\":{\"773\":1}}],[\"中的消息时\",{\"1\":{\"772\":1}}],[\"中的某些消息无法被消费\",{\"1\":{\"744\":1}}],[\"中的查询表中\",{\"1\":{\"693\":1}}],[\"中的运用\",{\"1\":{\"590\":1}}],[\"中的\",{\"1\":{\"525\":1,\"536\":1,\"591\":1,\"599\":1,\"607\":1,\"810\":1}}],[\"中的两个\",{\"1\":{\"525\":1}}],[\"中的常量池\",{\"1\":{\"456\":1}}],[\"中的增量式编译器\",{\"1\":{\"367\":1}}],[\"中的执行引擎充当了将高级语言翻译为机器语言的译者\",{\"1\":{\"355\":1}}],[\"中的永久代\",{\"1\":{\"307\":1}}],[\"中的元素已经是按照\",{\"1\":{\"241\":1}}],[\"中的方法\",{\"1\":{\"240\":1}}],[\"中的tablesizefor\",{\"1\":{\"239\":1}}],[\"中的配置继承了\",{\"1\":{\"85\":1}}],[\"中\",{\"0\":{\"372\":1},\"1\":{\"175\":1,\"332\":1,\"362\":1,\"507\":1,\"525\":1,\"535\":1,\"612\":1,\"638\":1,\"717\":1,\"718\":1,\"745\":1,\"767\":1,\"816\":1,\"889\":1,\"891\":1,\"939\":1}}],[\"中文索引\",{\"1\":{\"802\":1}}],[\"中文系列教程\",{\"1\":{\"146\":1}}],[\"中文字体harmonyos\",{\"1\":{\"38\":1}}],[\"中国\",{\"1\":{\"140\":1}}],[\"中国大学mooc\",{\"1\":{\"126\":1}}],[\"中操作\",{\"1\":{\"89\":1}}],[\"中各自维护各自的依赖信息很容易发生出入\",{\"1\":{\"85\":1}}],[\"中和构建操作相关的命令时\",{\"1\":{\"72\":1}}],[\"中唯一的定位到一个\",{\"1\":{\"65\":1}}],[\"基本用法\",{\"0\":{\"998\":1}}],[\"基本都是由我们的业务规则拼接而来\",{\"1\":{\"774\":1}}],[\"基本都有以下类型的注解\",{\"1\":{\"674\":1}}],[\"基本上就是这么个流程\",{\"1\":{\"889\":1}}],[\"基本上都是动态地给一个对象添加一些额外的职责\",{\"1\":{\"628\":1}}],[\"基本上每个基本类都有of方法用于生成的对应的对象\",{\"1\":{\"565\":1}}],[\"基本上\",{\"1\":{\"534\":1}}],[\"基本思想\",{\"1\":{\"526\":1}}],[\"基本数据类型对应的class对象\",{\"1\":{\"519\":1}}],[\"基本被淘汰\",{\"1\":{\"239\":1}}],[\"基本类型也可以实现转换\",{\"1\":{\"234\":1}}],[\"基本类型\",{\"1\":{\"228\":1}}],[\"基本概念\",{\"0\":{\"64\":1}}],[\"基于分布式协调系统zookeeper\",{\"1\":{\"897\":1}}],[\"基于分代的概念\",{\"1\":{\"525\":1}}],[\"基于网络中组播传输实现\",{\"1\":{\"897\":1}}],[\"基于redis的发布\",{\"1\":{\"897\":1}}],[\"基于redis实现\",{\"1\":{\"897\":1}}],[\"基于redis实现的rpc协议\",{\"1\":{\"888\":1}}],[\"基于reactive\",{\"1\":{\"675\":1}}],[\"基于memcache实现的rpc协议\",{\"1\":{\"888\":1}}],[\"基于maven\",{\"1\":{\"106\":2}}],[\"基于webservice的远程调用协议\",{\"1\":{\"888\":1}}],[\"基于注册中心目录服务\",{\"1\":{\"885\":1}}],[\"基于注解\",{\"1\":{\"633\":1}}],[\"基于netty\",{\"1\":{\"879\":1}}],[\"基于http协议\",{\"1\":{\"879\":1}}],[\"基于java远程方法协议\",{\"1\":{\"879\":1}}],[\"基于jdk的动态代理\",{\"1\":{\"603\":1}}],[\"基于xml\",{\"1\":{\"875\":1}}],[\"基于xml的协议的规范\",{\"1\":{\"875\":1}}],[\"基于雪花算法的策略生成数据id\",{\"1\":{\"836\":1}}],[\"基于sql语句编程\",{\"1\":{\"807\":1}}],[\"基于sortable\",{\"1\":{\"160\":1}}],[\"基于token\",{\"1\":{\"788\":1}}],[\"基于aspectj\",{\"1\":{\"633\":1}}],[\"基于上面的问题\",{\"1\":{\"621\":1}}],[\"基于cglib的动态代理\",{\"1\":{\"603\":1}}],[\"基于静态代理方式实现\",{\"1\":{\"602\":1}}],[\"基于动态代理方式实现\",{\"1\":{\"602\":1}}],[\"基于动态代理实现\",{\"1\":{\"602\":1}}],[\"基于老年代垃圾回收的特性\",{\"1\":{\"523\":1}}],[\"基于逃逸分析在c2上有如下几种优化\",{\"1\":{\"372\":1}}],[\"基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献\",{\"1\":{\"363\":1}}],[\"基于解释器执行己经沦落为低效的代名词\",{\"1\":{\"363\":1}}],[\"基于\",{\"1\":{\"220\":1,\"597\":1,\"633\":1,\"813\":1,\"827\":1,\"888\":3}}],[\"基于原生js\",{\"1\":{\"158\":1}}],[\"基础案例\",{\"0\":{\"694\":1}}],[\"基础\",{\"1\":{\"4\":1},\"2\":{\"224\":1,\"237\":1,\"255\":1}}],[\"验证二叉搜索树\",{\"0\":{\"1027\":1}}],[\"验证库\",{\"1\":{\"159\":1}}],[\"验证\",{\"0\":{\"63\":1},\"1\":{\"379\":2,\"591\":1,\"1007\":1}}],[\"很久没写总结了😪\",{\"1\":{\"942\":1}}],[\"很浪费资源\",{\"1\":{\"909\":1}}],[\"很简单\",{\"1\":{\"894\":1}}],[\"很简单的一个功能对吧\",{\"1\":{\"776\":1}}],[\"很好的与各种数据库兼容\",{\"1\":{\"807\":1}}],[\"很可能在一秒内无法完成所有订单的检查\",{\"1\":{\"751\":1}}],[\"很像子网广播\",{\"1\":{\"728\":1}}],[\"很少用到beanfactory\",{\"1\":{\"611\":1}}],[\"很少在养老区收集\",{\"1\":{\"490\":1}}],[\"很明显\",{\"1\":{\"600\":1}}],[\"很有创意\",{\"1\":{\"143\":1}}],[\"很全\",{\"1\":{\"134\":1}}],[\"很全很强大\",{\"1\":{\"120\":1}}],[\"很类似\",{\"1\":{\"110\":1}}],[\"很多点是要思考的\",{\"1\":{\"893\":1}}],[\"很多时候\",{\"1\":{\"493\":1}}],[\"很多其它的编程语言都有这一机制\",{\"1\":{\"434\":1}}],[\"很多构建命令都可以在\",{\"1\":{\"90\":1}}],[\"很多教材还是使用的老地址\",{\"1\":{\"61\":1}}],[\"很高兴遇见你\",{\"1\":{\"0\":1}}],[\"也即\",{\"1\":{\"1024\":1}}],[\"也即将要执行的指令代码\",{\"1\":{\"399\":1}}],[\"也因此衍生出了一系列相应的技术\",{\"1\":{\"881\":1}}],[\"也提供了更优秀的nio\",{\"1\":{\"878\":1}}],[\"也提供了一些方便的方法供我们使用\",{\"1\":{\"566\":1}}],[\"也收到了交换机的确认回调\",{\"1\":{\"762\":1}}],[\"也一样阻塞消息的发布\",{\"1\":{\"723\":1}}],[\"也正是因为继承了这个依赖\",{\"1\":{\"685\":1}}],[\"也采用标记\",{\"1\":{\"536\":1}}],[\"也被称做被通知\",{\"1\":{\"604\":1}}],[\"也被称为stop\",{\"1\":{\"521\":1}}],[\"也被称之为==\",{\"1\":{\"368\":1}}],[\"也有特殊情况\",{\"1\":{\"512\":1}}],[\"也叫锁消除\",{\"1\":{\"509\":1}}],[\"也叫作容器\",{\"1\":{\"214\":1}}],[\"也无须进行垃圾回收了\",{\"1\":{\"505\":1}}],[\"也没有其它队列能接收这个消息\",{\"1\":{\"762\":1}}],[\"也没有重写add\",{\"1\":{\"233\":1}}],[\"也没特别含义\",{\"1\":{\"478\":1}}],[\"也包括到运行期解析后才能够获得的方法或者字段引用\",{\"1\":{\"459\":1}}],[\"也包含一些从网络收集的文章\",{\"1\":{\"1\":1}}],[\"也发展出可以直接生成本地代码的编译器\",{\"1\":{\"359\":1}}],[\"也号称是世界上最快的java虚拟机\",{\"1\":{\"353\":1}}],[\"也保证了\",{\"1\":{\"333\":1}}],[\"也并非是\",{\"1\":{\"323\":1}}],[\"也会阻塞队列的操作\",{\"1\":{\"782\":1}}],[\"也会自动由扩展类加载器加载\",{\"1\":{\"383\":1}}],[\"也会出现\",{\"1\":{\"303\":1}}],[\"也会通过创建一个新线程来执行该任务\",{\"1\":{\"275\":1}}],[\"也不一定会被马上丢弃\",{\"1\":{\"752\":1}}],[\"也不会转发\",{\"1\":{\"728\":1}}],[\"也不会靠随意回收具有强引用的对象来解决内存不足问题\",{\"1\":{\"325\":1}}],[\"也不是虚拟机规范中定义的内存区域\",{\"1\":{\"308\":1}}],[\"也不需要重新定义wait方法的实现\",{\"1\":{\"288\":1}}],[\"也不能使用\",{\"1\":{\"249\":1}}],[\"也是同样的遍历方式\",{\"1\":{\"1024\":1}}],[\"也是升序的子序列\",{\"1\":{\"929\":1,\"1038\":1}}],[\"也是反射的方式\",{\"1\":{\"468\":1}}],[\"也是运行速度最快的存储区域\",{\"1\":{\"399\":1}}],[\"也是线程私有的\",{\"1\":{\"302\":1}}],[\"也是\",{\"1\":{\"275\":1,\"892\":1}}],[\"也是一种使线程暂停执行的方法\",{\"1\":{\"273\":1}}],[\"也就这样产生了\",{\"1\":{\"881\":1}}],[\"也就清除了队列的确认的消息\",{\"1\":{\"724\":1}}],[\"也就意味着应用程序重新启动通常比\",{\"1\":{\"670\":1}}],[\"也就意味着效率会有一定损耗\",{\"1\":{\"267\":1}}],[\"也就不用分配内存了\",{\"1\":{\"510\":1}}],[\"也就是栈的特点\",{\"1\":{\"1024\":1}}],[\"也就是链表5\",{\"1\":{\"970\":1}}],[\"也就是解码的过程\",{\"1\":{\"878\":2}}],[\"也就是编码的过程\",{\"1\":{\"878\":1}}],[\"也就是把调用\",{\"1\":{\"874\":1}}],[\"也就是生存时间\",{\"1\":{\"745\":1}}],[\"也就是发布一个消息之后只有它被确认发布\",{\"1\":{\"722\":1}}],[\"也就是在老年代空间不足时\",{\"1\":{\"495\":1}}],[\"也就是要先分清楚到底是出现了内存泄漏\",{\"1\":{\"450\":1}}],[\"也就是要尽量把数据分配均匀\",{\"1\":{\"246\":1}}],[\"也就是只要在本方法的异常表中没有搜索到匹配的异常处理器\",{\"1\":{\"424\":1}}],[\"也就是所谓的当前方法\",{\"1\":{\"399\":1}}],[\"也就是hotspot中的永久代\",{\"1\":{\"343\":1}}],[\"也就是s1\",{\"1\":{\"318\":1}}],[\"也就是常量字符串\",{\"1\":{\"317\":1}}],[\"也就是字节码\",{\"1\":{\"303\":1}}],[\"也就是判断当前线程是否是等待队列的队头元素\",{\"1\":{\"290\":1}}],[\"也就是object的wait\",{\"1\":{\"288\":1}}],[\"也就是\",{\"1\":{\"285\":1,\"307\":1,\"329\":1,\"464\":1}}],[\"也就是不保证线程安全\",{\"1\":{\"229\":1}}],[\"也就是说这时对象的依赖关系有可能是不完整的\",{\"1\":{\"600\":1}}],[\"也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象\",{\"1\":{\"390\":1}}],[\"也就是说字符串常量池被单独拿到堆\",{\"1\":{\"307\":1,\"343\":1}}],[\"也就是说正在等待的线程可以选择放弃等待\",{\"1\":{\"286\":1}}],[\"也就是说创建一个链表数组\",{\"1\":{\"244\":1}}],[\"也就是说\",{\"1\":{\"200\":1,\"239\":1,\"242\":1,\"246\":1,\"288\":1,\"419\":1,\"709\":1}}],[\"也称上下文\",{\"1\":{\"267\":1}}],[\"也可自定义拦截规则\",{\"1\":{\"827\":1}}],[\"也可能是不同的数据源\",{\"1\":{\"628\":1}}],[\"也可能是指虚拟机的后端运行期编译器\",{\"1\":{\"367\":1}}],[\"也可以看做它自身的一棵子树\",{\"1\":{\"1018\":1}}],[\"也可以指向head\",{\"1\":{\"964\":1}}],[\"也可以分为\",{\"1\":{\"883\":1}}],[\"也可以像下面这样全局配置\",{\"1\":{\"836\":1}}],[\"也可以像下方代码这样\",{\"1\":{\"549\":1}}],[\"也可以说是\",{\"1\":{\"762\":1}}],[\"也可以说是包括很多开源项目的总称\",{\"1\":{\"592\":1}}],[\"也可以放在原来的配置文件里\",{\"1\":{\"757\":1}}],[\"也可以放在上方的配置文件类里\",{\"1\":{\"755\":1}}],[\"也可以这么理解\",{\"1\":{\"735\":1}}],[\"也可以设置\",{\"1\":{\"720\":1}}],[\"也可以确保不会丢失任何消息\",{\"1\":{\"707\":1}}],[\"也可以用同样的方法\",{\"1\":{\"679\":1}}],[\"也可以用于实现栈\",{\"1\":{\"231\":1}}],[\"也可以在\",{\"1\":{\"783\":1}}],[\"也可以在方法或者类上加\",{\"1\":{\"673\":1}}],[\"也可以在这里统一指定视图\",{\"1\":{\"656\":1}}],[\"也可以在你调用方法后打印出字符串\",{\"1\":{\"648\":1}}],[\"也可以是普通的实例对象\",{\"1\":{\"622\":1}}],[\"也可以是按照先来后到的顺序获得机会\",{\"1\":{\"292\":1}}],[\"也可以把它称为标记\",{\"1\":{\"523\":1}}],[\"也可以无需实现本地方法栈\",{\"1\":{\"437\":1}}],[\"也可以称之为表达式栈\",{\"1\":{\"416\":1}}],[\"也可以加上性能监控\",{\"1\":{\"372\":1}}],[\"也可以使用开源的\",{\"1\":{\"878\":1}}],[\"也可以使用分页插件来完成物理分页\",{\"1\":{\"817\":1}}],[\"也可以使用外置容器\",{\"1\":{\"667\":1}}],[\"也可以使用webservice等等\",{\"1\":{\"436\":1}}],[\"也可以使用\",{\"1\":{\"336\":1}}],[\"也可以使用<excludegroupids>com\",{\"1\":{\"106\":1}}],[\"也可以通过zoneid\",{\"1\":{\"555\":1}}],[\"也可以通过\",{\"1\":{\"275\":1,\"783\":1}}],[\"也可替换为华为云\",{\"1\":{\"61\":1}}],[\"06\",{\"0\":{\"952\":1},\"1\":{\"955\":1,\"972\":1}}],[\"0l\",{\"1\":{\"832\":1}}],[\"0及更新版本\",{\"1\":{\"792\":1}}],[\"0及以上\",{\"1\":{\"104\":1}}],[\"08\",{\"1\":{\"757\":1}}],[\"09\",{\"1\":{\"695\":1,\"711\":1,\"717\":1,\"762\":1,\"768\":1}}],[\"07\",{\"1\":{\"614\":1}}],[\"03t01\",{\"1\":{\"573\":2}}],[\"03t10\",{\"1\":{\"559\":1}}],[\"03\",{\"1\":{\"569\":3,\"573\":6,\"708\":1}}],[\"03c1006e\",{\"1\":{\"388\":1}}],[\"0e91\",{\"1\":{\"343\":1}}],[\"01t10\",{\"1\":{\"559\":1,\"568\":1,\"569\":1}}],[\"01\",{\"0\":{\"952\":1},\"1\":{\"559\":1,\"568\":1,\"573\":7,\"955\":1}}],[\"0110\",{\"1\":{\"253\":1}}],[\"0111\",{\"1\":{\"253\":5}}],[\"0100\",{\"1\":{\"253\":2}}],[\"01背包\",{\"0\":{\"207\":1}}],[\"000\",{\"1\":{\"573\":1}}],[\"0000\",{\"1\":{\"253\":13}}],[\"0001\",{\"1\":{\"253\":9}}],[\"00\",{\"1\":{\"241\":1}}],[\"02\",{\"1\":{\"241\":1,\"559\":1,\"708\":1,\"711\":1,\"962\":2,\"964\":2,\"972\":1}}],[\"0x3f\",{\"1\":{\"184\":1}}],[\"0x33333333\",{\"1\":{\"184\":2}}],[\"0x0f0f0f0f\",{\"1\":{\"184\":1}}],[\"0x55555555\",{\"1\":{\"184\":1}}],[\"0和1交替替换\",{\"0\":{\"183\":1}}],[\"0to255\",{\"1\":{\"139\":1}}],[\"0<\",{\"1\":{\"70\":1,\"99\":1,\"680\":1,\"696\":1}}],[\"0\",{\"1\":{\"61\":1,\"62\":1,\"70\":4,\"77\":5,\"78\":2,\"83\":1,\"85\":11,\"87\":12,\"88\":2,\"180\":1,\"183\":1,\"186\":1,\"187\":4,\"188\":2,\"189\":1,\"190\":1,\"194\":15,\"198\":1,\"199\":4,\"200\":1,\"201\":2,\"202\":12,\"203\":6,\"204\":6,\"205\":6,\"207\":7,\"233\":3,\"235\":2,\"239\":3,\"241\":2,\"244\":1,\"253\":1,\"271\":1,\"284\":1,\"321\":2,\"359\":1,\"548\":1,\"549\":1,\"722\":1,\"723\":4,\"752\":1,\"755\":1,\"756\":1,\"762\":4,\"765\":1,\"768\":1,\"782\":1,\"783\":1,\"788\":8,\"810\":1,\"817\":1,\"819\":2,\"832\":2,\"836\":1,\"864\":2,\"912\":1,\"925\":3,\"931\":1,\"933\":89,\"934\":15,\"937\":2,\"938\":1,\"939\":4,\"943\":16,\"944\":11,\"948\":1,\"949\":3,\"953\":1,\"954\":2,\"957\":6,\"963\":2,\"982\":17,\"983\":5,\"984\":6,\"1007\":2,\"1008\":1,\"1018\":1,\"1022\":1,\"1034\":1,\"1035\":2,\"1038\":1,\"1040\":1}}],[\"要反转链表\",{\"1\":{\"970\":1}}],[\"要直击重点\",{\"1\":{\"890\":1}}],[\"要保证实体类中的属性名和表中的字段名一致\",{\"1\":{\"837\":1}}],[\"要开启二级缓存\",{\"1\":{\"813\":1}}],[\"要开启多线程功能\",{\"1\":{\"701\":1}}],[\"要注意的点是\",{\"1\":{\"762\":1}}],[\"要注意的是它的位置一定要是第一个执行的过滤器\",{\"1\":{\"649\":1}}],[\"要想把类标识成可用于\",{\"1\":{\"618\":1}}],[\"要使指向该对象的指针永远不会逃逸\",{\"1\":{\"507\":1}}],[\"要不断动态加载很多类\",{\"1\":{\"462\":1}}],[\"要弄清楚方法区的运行时常量池\",{\"1\":{\"456\":1}}],[\"要弄清楚方法区\",{\"1\":{\"456\":1}}],[\"要解决oom异常或heapspace的异常\",{\"1\":{\"450\":1}}],[\"要真正宣告一个对象死亡\",{\"1\":{\"323\":1}}],[\"要考虑jrockit客户不配置永久代的习惯\",{\"1\":{\"306\":1}}],[\"要在某个对象上执行wait\",{\"1\":{\"288\":1}}],[\"要比\",{\"1\":{\"239\":1}}],[\"要求该消息与一个特定的路由键完全匹配\",{\"1\":{\"728\":1}}],[\"要求当前类实现\",{\"1\":{\"468\":1}}],[\"要求有父工程时先安装父工程\",{\"1\":{\"90\":1}}],[\"要求目录中文无空格\",{\"1\":{\"61\":1}}],[\"要选择pom\",{\"1\":{\"85\":1}}],[\"要从注释中拿出来\",{\"1\":{\"61\":1}}],[\"默认支持spring\",{\"1\":{\"909\":1}}],[\"默认聚合1min中的统计数据\",{\"1\":{\"902\":1}}],[\"默认也推荐使用netty作为通信框架\",{\"1\":{\"883\":1}}],[\"默认也是采用\",{\"1\":{\"813\":1}}],[\"默认基于json作为传输格式\",{\"1\":{\"875\":1}}],[\"默认数据源\",{\"1\":{\"866\":1}}],[\"默认false\",{\"1\":{\"866\":1}}],[\"默认该作用域下所有\",{\"1\":{\"813\":1}}],[\"默认不打开二级缓存\",{\"1\":{\"813\":1}}],[\"默认会自动加载所有实现handlermapping接口的bean\",{\"1\":{\"789\":1}}],[\"默认exchange\",{\"0\":{\"729\":1}}],[\"默认消息的发送是异步发送的\",{\"1\":{\"717\":1}}],[\"默认消息采用的是自动应答\",{\"1\":{\"708\":1}}],[\"默认消息存储在内存中\",{\"1\":{\"697\":1}}],[\"默认都是有\",{\"1\":{\"685\":1}}],[\"默认参数值\",{\"1\":{\"651\":1}}],[\"默认情况\",{\"1\":{\"635\":1}}],[\"默认情况下\",{\"1\":{\"106\":1,\"448\":1,\"462\":1,\"486\":1,\"502\":1,\"710\":1,\"782\":1,\"902\":1}}],[\"默认级别\",{\"1\":{\"634\":1}}],[\"默认只提供\",{\"1\":{\"612\":1}}],[\"默认通知者自动代理创建器metadata\",{\"1\":{\"604\":1}}],[\"默认当前系统时区\",{\"1\":{\"560\":1,\"561\":1,\"562\":1}}],[\"默认使用什么序列化框架\",{\"0\":{\"898\":1}}],[\"默认使用\",{\"1\":{\"540\":1}}],[\"默认使用的是\",{\"1\":{\"532\":1}}],[\"默认使用系统类加载器加载\",{\"1\":{\"381\":1}}],[\"默认打开一级缓存\",{\"1\":{\"813\":1}}],[\"默认打开\",{\"1\":{\"510\":1}}],[\"默认\",{\"0\":{\"486\":1},\"1\":{\"488\":1,\"615\":1,\"836\":1,\"916\":1,\"917\":1}}],[\"默认大小如下\",{\"1\":{\"410\":1}}],[\"默认单位是\",{\"1\":{\"410\":1}}],[\"默认开启分层编译策略\",{\"1\":{\"372\":1}}],[\"默认垃圾收集器g1\",{\"1\":{\"339\":1,\"537\":1}}],[\"默认垃圾收集器parallel\",{\"1\":{\"339\":2,\"537\":2}}],[\"默认是阻塞的\",{\"1\":{\"896\":1}}],[\"默认是异步的\",{\"1\":{\"891\":1}}],[\"默认是懒汉式\",{\"1\":{\"890\":1}}],[\"默认是\",{\"1\":{\"889\":2,\"890\":1}}],[\"默认是id\",{\"1\":{\"836\":1}}],[\"默认是根据类型注入\",{\"1\":{\"597\":1}}],[\"默认是8\",{\"1\":{\"503\":1}}],[\"默认是2\",{\"1\":{\"503\":1}}],[\"默认是开启的\",{\"1\":{\"502\":1}}],[\"默认是15次\",{\"1\":{\"490\":1}}],[\"默认是按\",{\"1\":{\"241\":1}}],[\"默认是compile\",{\"1\":{\"80\":1}}],[\"默认的是velocity引擎模板\",{\"1\":{\"864\":1}}],[\"默认的为\",{\"1\":{\"783\":1}}],[\"默认的收集器\",{\"0\":{\"532\":1}}],[\"默认的初始化大小为\",{\"1\":{\"239\":1}}],[\"默认的初始大小为\",{\"1\":{\"239\":1}}],[\"默认的官网国内访问速度很慢\",{\"1\":{\"35\":1}}],[\"默认长度为10\",{\"1\":{\"232\":1}}],[\"默认为true\",{\"1\":{\"651\":1}}],[\"默认为物理内存的1\",{\"1\":{\"503\":2}}],[\"默认为15岁\",{\"1\":{\"498\":1}}],[\"默认为\",{\"1\":{\"222\":1,\"239\":1,\"245\":1,\"477\":1}}],[\"默认路径是$\",{\"1\":{\"106\":1}}],[\"默认goal\",{\"0\":{\"106\":1}}],[\"默认值即为master\",{\"1\":{\"866\":1}}],[\"默认值\",{\"1\":{\"619\":1}}],[\"默认值依赖于平台\",{\"1\":{\"448\":1}}],[\"默认值为true\",{\"1\":{\"103\":1}}],[\"默认值是20\",{\"1\":{\"447\":1}}],[\"默认值是\",{\"1\":{\"103\":1}}],[\"默认值是false\",{\"1\":{\"103\":1}}],[\"默认在c盘\",{\"1\":{\"61\":1}}],[\"<<\",{\"1\":{\"949\":4}}],[\"<0\",{\"1\":{\"943\":1}}],[\"<result\",{\"1\":{\"820\":3}}],[\"<resultmap\",{\"1\":{\"820\":1}}],[\"<resultmap>\",{\"1\":{\"811\":1,\"822\":1}}],[\"<relativepath\",{\"1\":{\"753\":1}}],[\"<bean\",{\"1\":{\"617\":1,\"656\":1}}],[\"<beans>\",{\"1\":{\"617\":1}}],[\"<binarysearch\",{\"1\":{\"230\":1}}],[\"<build>\",{\"1\":{\"99\":1,\"671\":1,\"696\":1}}],[\"<target>8<\",{\"1\":{\"696\":1}}],[\"<target>$\",{\"1\":{\"101\":1}}],[\"<t>\",{\"1\":{\"230\":1,\"234\":1}}],[\"<2\",{\"1\":{\"200\":1}}],[\"<=2是因为\",{\"1\":{\"954\":1}}],[\"<=\",{\"1\":{\"188\":1,\"194\":1,\"199\":1,\"201\":1,\"203\":2,\"207\":2,\"239\":1,\"747\":1,\"748\":1,\"850\":2,\"852\":1,\"931\":1,\"937\":3,\"938\":1,\"944\":2,\"954\":1,\"957\":1,\"983\":2,\"1029\":1,\"1030\":1,\"1040\":1}}],[\"<layout>zip<\",{\"1\":{\"106\":2}}],[\"<localrepository>d\",{\"1\":{\"61\":1}}],[\"<update>\",{\"1\":{\"816\":1,\"822\":1}}],[\"<url\",{\"1\":{\"649\":1}}],[\"<url>https\",{\"1\":{\"61\":1}}],[\"<useuniqueversions>false<\",{\"1\":{\"103\":1,\"106\":1}}],[\"<useuniqueversions>\",{\"1\":{\"103\":1}}],[\"<collection\",{\"1\":{\"820\":1}}],[\"<connectoruriencoding=\",{\"1\":{\"649\":1}}],[\"<context\",{\"1\":{\"601\":1}}],[\"<configuration>用来对这个插件进行配置\",{\"1\":{\"106\":1}}],[\"<configuration>\",{\"1\":{\"99\":1,\"101\":1,\"106\":2,\"696\":1}}],[\"<cinit>\",{\"1\":{\"380\":1}}],[\"<classpathprefix>lib\",{\"1\":{\"103\":1,\"106\":1}}],[\"<classpathprefix>\",{\"1\":{\"103\":1}}],[\"<outputdirectory>$\",{\"1\":{\"106\":1}}],[\"<outputdirectory>\",{\"1\":{\"99\":4,\"106\":1}}],[\"<dubbo\",{\"1\":{\"911\":1}}],[\"<directory>\",{\"1\":{\"99\":1}}],[\"<directory>scripts<\",{\"1\":{\"99\":1}}],[\"<directory>$\",{\"1\":{\"99\":1}}],[\"<directory>target<\",{\"1\":{\"99\":1}}],[\"<delete>\",{\"1\":{\"816\":1,\"822\":1}}],[\"<descriptor>src\",{\"1\":{\"99\":1}}],[\"<descriptors>\",{\"1\":{\"99\":1}}],[\"<dependencymanagement>\",{\"1\":{\"87\":2}}],[\"<dependency>\",{\"1\":{\"70\":2,\"83\":1,\"87\":7,\"88\":5,\"670\":1,\"671\":1,\"679\":2,\"680\":1,\"696\":2,\"753\":6,\"830\":1,\"863\":2}}],[\"<dependencies>\",{\"1\":{\"70\":1,\"87\":2,\"88\":1,\"671\":1,\"696\":1,\"753\":1}}],[\"<filter\",{\"1\":{\"649\":4}}],[\"<filter>\",{\"1\":{\"649\":1}}],[\"<fileset>\",{\"1\":{\"99\":4}}],[\"<filesets>\",{\"1\":{\"99\":1}}],[\"<format>zip<\",{\"1\":{\"99\":1}}],[\"<formats>\",{\"1\":{\"99\":1}}],[\"<id\",{\"1\":{\"820\":2}}],[\"<id>repackage<\",{\"1\":{\"106\":1}}],[\"<id>release<\",{\"1\":{\"99\":1}}],[\"<id>make\",{\"1\":{\"99\":1}}],[\"<id>jdk\",{\"1\":{\"61\":1}}],[\"<id>nexus\",{\"1\":{\"61\":1}}],[\"<insert>\",{\"1\":{\"816\":1,\"822\":1}}],[\"<insert\",{\"1\":{\"815\":1}}],[\"<init\",{\"1\":{\"649\":1}}],[\"<init>\",{\"1\":{\"314\":2}}],[\"<include>readme\",{\"1\":{\"99\":1}}],[\"<include>\",{\"1\":{\"99\":1,\"106\":1,\"811\":2}}],[\"<include>application\",{\"1\":{\"99\":1}}],[\"<include>$\",{\"1\":{\"99\":1}}],[\"<includes>\",{\"1\":{\"99\":4,\"106\":1}}],[\"<includebasedirectory>false<\",{\"1\":{\"99\":1}}],[\"<encoding>$\",{\"1\":{\"101\":1}}],[\"<encoding>utf\",{\"1\":{\"99\":1}}],[\"<exclude>\",{\"1\":{\"106\":1}}],[\"<exclude>run<\",{\"1\":{\"99\":1}}],[\"<excludes>\",{\"1\":{\"99\":1,\"106\":1}}],[\"<exclusion>\",{\"1\":{\"83\":1,\"679\":1}}],[\"<exclusions>\",{\"1\":{\"83\":1,\"679\":1}}],[\"<execution>\",{\"1\":{\"99\":1,\"106\":1}}],[\"<executions>\",{\"1\":{\"99\":1,\"106\":1}}],[\"<goal>repackage<\",{\"1\":{\"106\":1}}],[\"<goal>single<\",{\"1\":{\"99\":1}}],[\"<goals>\",{\"1\":{\"99\":1,\"106\":1}}],[\"<groupid>null<\",{\"1\":{\"106\":1}}],[\"<groupid>org\",{\"1\":{\"70\":1,\"87\":7,\"88\":5,\"101\":1,\"106\":2,\"670\":1,\"671\":2,\"679\":3,\"680\":1,\"696\":1,\"753\":6,\"863\":1}}],[\"<groupid>commons\",{\"1\":{\"83\":1,\"696\":1}}],[\"<groupid>com\",{\"1\":{\"70\":2,\"77\":1,\"83\":1,\"88\":2,\"106\":1,\"696\":1,\"753\":1,\"830\":1,\"863\":1}}],[\"<groupid>javax\",{\"1\":{\"65\":1}}],[\"<select>\",{\"1\":{\"816\":1,\"822\":1}}],[\"<select\",{\"1\":{\"814\":2,\"819\":2}}],[\"<selectkey>\",{\"1\":{\"811\":2}}],[\"<sql>\",{\"1\":{\"811\":2}}],[\"<source>8<\",{\"1\":{\"696\":1}}],[\"<source>$\",{\"1\":{\"101\":1}}],[\"<spring\",{\"1\":{\"87\":1}}],[\"<scope>compile<\",{\"1\":{\"83\":1}}],[\"<scope>test<\",{\"1\":{\"70\":1,\"753\":1}}],[\"<scope>表示当前依赖的范围\",{\"1\":{\"70\":1}}],[\"<java\",{\"1\":{\"70\":1,\"101\":1}}],[\"<jdk>1\",{\"1\":{\"61\":1}}],[\"<p\",{\"1\":{\"832\":2}}],[\"<phase>package<\",{\"1\":{\"99\":1}}],[\"<plugin>\",{\"1\":{\"99\":1,\"101\":1,\"106\":2,\"671\":1,\"696\":1}}],[\"<plugins>\",{\"1\":{\"99\":1,\"671\":1,\"696\":1}}],[\"<parametermap>\",{\"1\":{\"811\":1,\"822\":1}}],[\"<param\",{\"1\":{\"649\":2}}],[\"<parent>\",{\"1\":{\"88\":2,\"753\":1}}],[\"<packaging>pom<\",{\"1\":{\"85\":1}}],[\"<packaging>war<\",{\"1\":{\"78\":1}}],[\"<packaging>jar<\",{\"1\":{\"70\":1}}],[\"<project\",{\"1\":{\"101\":1}}],[\"<properties>\",{\"1\":{\"61\":1,\"70\":1,\"87\":1,\"101\":1}}],[\"<profile>\",{\"1\":{\"61\":1}}],[\"<profiles>\",{\"1\":{\"61\":2}}],[\"<version>5\",{\"1\":{\"696\":1}}],[\"<version>$\",{\"1\":{\"87\":2}}],[\"<version>4\",{\"1\":{\"87\":5}}],[\"<version>3\",{\"1\":{\"70\":1,\"99\":1,\"830\":1,\"863\":1}}],[\"<version>1\",{\"1\":{\"70\":1,\"77\":1,\"83\":1,\"88\":2,\"671\":1,\"680\":1,\"753\":1}}],[\"<version>2\",{\"1\":{\"65\":1,\"101\":1,\"106\":1,\"696\":1,\"753\":1,\"863\":1}}],[\"<association\",{\"1\":{\"820\":1}}],[\"<assembly>\",{\"1\":{\"99\":1}}],[\"<addclasspath>true<\",{\"1\":{\"103\":1,\"106\":1}}],[\"<addclasspath>\",{\"1\":{\"103\":1}}],[\"<archive>\",{\"1\":{\"106\":1}}],[\"<archiverconfig>\",{\"1\":{\"99\":1}}],[\"<artifactid>freemarker<\",{\"1\":{\"863\":1}}],[\"<artifactid>fastjson<\",{\"1\":{\"753\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"753\":1}}],[\"<artifactid>amqp\",{\"1\":{\"696\":1}}],[\"<artifactid>null<\",{\"1\":{\"106\":1}}],[\"<artifactid>bar<\",{\"1\":{\"106\":1}}],[\"<artifactid>maven\",{\"1\":{\"99\":1,\"101\":1,\"106\":1,\"696\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"70\":1,\"680\":1,\"830\":1,\"863\":1}}],[\"<artifactid>pro04\",{\"1\":{\"88\":1}}],[\"<artifactid>pro03\",{\"1\":{\"88\":1}}],[\"<artifactid>pro01\",{\"1\":{\"77\":1,\"83\":1}}],[\"<artifactid>commons\",{\"1\":{\"83\":1,\"696\":1}}],[\"<artifactid>springloaded<\",{\"1\":{\"671\":1}}],[\"<artifactid>spring\",{\"1\":{\"70\":1,\"87\":7,\"88\":5,\"106\":1,\"670\":1,\"671\":1,\"679\":3,\"753\":5}}],[\"<artifactid>servlet\",{\"1\":{\"65\":1}}],[\"<artifactid>wms<\",{\"1\":{\"70\":1}}],[\"<activebydefault>true<\",{\"1\":{\"61\":1}}],[\"<activation>\",{\"1\":{\"61\":1}}],[\"<mvc\",{\"1\":{\"652\":1,\"656\":4}}],[\"<mainclass>com\",{\"1\":{\"106\":1}}],[\"<mainclass>\",{\"1\":{\"106\":1}}],[\"<manifest>\",{\"1\":{\"103\":1,\"106\":1}}],[\"<maven\",{\"1\":{\"61\":3}}],[\"<module>pro06\",{\"1\":{\"87\":1}}],[\"<module>pro05\",{\"1\":{\"87\":1}}],[\"<module>pro04\",{\"1\":{\"87\":1}}],[\"<modules>\",{\"1\":{\"87\":1}}],[\"<modelversion>4\",{\"1\":{\"70\":1}}],[\"<mirrorof>central<\",{\"1\":{\"61\":1}}],[\"<mirror>\",{\"1\":{\"61\":1}}],[\"<mirrors>\",{\"1\":{\"61\":1}}],[\"<name>nexus\",{\"1\":{\"61\":1}}],[\"<\",{\"1\":{\"61\":8,\"70\":9,\"83\":6,\"87\":18,\"88\":15,\"99\":32,\"101\":6,\"103\":2,\"106\":19,\"186\":1,\"187\":1,\"189\":1,\"190\":1,\"198\":2,\"199\":1,\"200\":1,\"201\":1,\"202\":6,\"204\":1,\"205\":1,\"207\":1,\"230\":1,\"239\":2,\"253\":1,\"617\":1,\"649\":4,\"656\":3,\"670\":2,\"671\":8,\"679\":5,\"680\":1,\"696\":10,\"722\":1,\"723\":1,\"753\":9,\"779\":1,\"814\":2,\"815\":1,\"819\":2,\"820\":3,\"830\":2,\"863\":2,\"925\":2,\"926\":2,\"931\":1,\"934\":5,\"937\":1,\"938\":1,\"939\":1,\"943\":7,\"944\":5,\"948\":1,\"949\":1,\"954\":3,\"957\":3,\"982\":2,\"983\":1,\"1033\":3,\"1035\":1,\"1040\":1}}],[\"主流rpc框架有哪些\",{\"0\":{\"879\":1}}],[\"主\",{\"0\":{\"815\":1}}],[\"主动使用\",{\"1\":{\"397\":1}}],[\"主动使用和被动使用\",{\"1\":{\"397\":1}}],[\"主动让出\",{\"1\":{\"267\":1}}],[\"主要负责管理\",{\"1\":{\"883\":1}}],[\"主要负责加载\",{\"1\":{\"331\":1}}],[\"主要围绕\",{\"1\":{\"883\":1}}],[\"主要还是他和普通\",{\"1\":{\"686\":1}}],[\"主要优点\",{\"1\":{\"664\":1}}],[\"主要的用途是过滤字符编码\",{\"1\":{\"648\":1}}],[\"主要用户接受用户请求并调用\",{\"1\":{\"618\":1}}],[\"主要用于框架中\",{\"1\":{\"892\":1}}],[\"主要用于数据库相关操作\",{\"1\":{\"618\":1}}],[\"主要用于保存计算过程的中间结果\",{\"1\":{\"416\":1}}],[\"主要用于存储方法参数和定义在方法体内的局部变量\",{\"1\":{\"415\":1}}],[\"主要用于存放键值对\",{\"1\":{\"214\":1}}],[\"主要用于存放单一元素\",{\"1\":{\"214\":1}}],[\"主要用于线程间的控制\",{\"1\":{\"292\":1}}],[\"主要涉及一些复杂的逻辑\",{\"1\":{\"618\":1}}],[\"主要有如下作用\",{\"1\":{\"685\":1}}],[\"主要有3种方式\",{\"1\":{\"602\":1}}],[\"主要有这些方法\",{\"1\":{\"550\":1}}],[\"主要实现类是chronounit\",{\"1\":{\"568\":1}}],[\"主要针对配备多颗处理器及大容量内存的机器\",{\"1\":{\"535\":1}}],[\"主要是封装\",{\"1\":{\"883\":1}}],[\"主要是提供服务的发现\",{\"1\":{\"877\":1}}],[\"主要是提供一些时间单位\",{\"1\":{\"568\":1}}],[\"主要是为了生成代理对象\",{\"1\":{\"622\":1}}],[\"主要是为指定的类生成一个子类\",{\"1\":{\"603\":1}}],[\"主要是程序运行过程中生成的临时变量\",{\"1\":{\"525\":1}}],[\"主要是由两大接口派生而来\",{\"1\":{\"214\":1}}],[\"主要信息\",{\"0\":{\"441\":1}}],[\"主要包括四种验证\",{\"1\":{\"379\":1}}],[\"主要分为两大类\",{\"1\":{\"603\":1}}],[\"主要分为\",{\"1\":{\"379\":1}}],[\"主要目的是为了避免字符串的重复创建\",{\"1\":{\"317\":1}}],[\"主要目标为\",{\"1\":{\"103\":1}}],[\"主要原因\",{\"1\":{\"306\":1}}],[\"主要原因在于并发下的\",{\"1\":{\"247\":1}}],[\"主要来说主要有三点\",{\"1\":{\"286\":1}}],[\"主要来自力扣\",{\"1\":{\"185\":1,\"192\":1,\"196\":1,\"210\":1}}],[\"主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力\",{\"1\":{\"241\":1}}],[\"主要根据集合的特点来选用\",{\"1\":{\"216\":1}}],[\"主要接口和实现类如下图所示\",{\"1\":{\"214\":1}}],[\"主要构建过程\",{\"1\":{\"94\":1}}],[\"主要修改点如下\",{\"1\":{\"61\":1}}],[\"主体程序编译结果存放的目录\",{\"1\":{\"74\":1}}],[\"主程序编译\",{\"1\":{\"74\":1}}],[\"主题已放入阿里云盘\",{\"1\":{\"49\":1}}],[\"主题\",{\"1\":{\"1\":1,\"35\":1,\"38\":1,\"43\":1,\"728\":1}}],[\"无非就是打印顺序的调整\",{\"1\":{\"1024\":1}}],[\"无处不在\",{\"1\":{\"892\":1}}],[\"无缝地支持c\",{\"1\":{\"879\":1}}],[\"无侵入\",{\"1\":{\"827\":1}}],[\"无状态的\",{\"1\":{\"638\":1}}],[\"无法连接到注册中心\",{\"1\":{\"920\":1}}],[\"无法满足业务要求而且性能低下\",{\"1\":{\"751\":1}}],[\"无法收到的消息\",{\"1\":{\"747\":1}}],[\"无法再添加数据到\",{\"1\":{\"745\":1}}],[\"无法消费的回调\",{\"1\":{\"698\":1}}],[\"无法被其他项目依赖\",{\"1\":{\"686\":1}}],[\"无法发送其他类型的请求\",{\"1\":{\"673\":1}}],[\"无法实现的\",{\"1\":{\"617\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"534\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"329\":1,\"464\":1}}],[\"无内存碎片\",{\"1\":{\"523\":1}}],[\"无须等到maxtenuringthreshold中要求的年龄\",{\"1\":{\"498\":1}}],[\"无需调整slow的位置\",{\"1\":{\"974\":1}}],[\"无需再担心字段写错\",{\"1\":{\"827\":1}}],[\"无需再做任何同步操作\",{\"1\":{\"278\":1}}],[\"无需等待\",{\"1\":{\"757\":1}}],[\"无需开发人员手动参与内存的分配与回收\",{\"1\":{\"517\":1}}],[\"无需改变栈中存放的句柄地址\",{\"1\":{\"479\":1}}],[\"无永久代\",{\"1\":{\"461\":1}}],[\"无论是可靠性还是效率都很好\",{\"1\":{\"724\":1}}],[\"无论通过哪种方式退出\",{\"1\":{\"424\":1}}],[\"无论类加载器的类型如何划分\",{\"1\":{\"381\":1}}],[\"无锁机制\",{\"1\":{\"298\":1}}],[\"无符号右移\",{\"1\":{\"244\":1}}],[\"无序\",{\"1\":{\"220\":1}}],[\"无序列表\",{\"1\":{\"46\":1}}],[\"无权图的邻接矩阵和邻接表表示方法\",{\"1\":{\"177\":1}}],[\"无向图\",{\"1\":{\"177\":1}}],[\"无损放大\",{\"1\":{\"132\":1}}],[\"无效\",{\"1\":{\"80\":3,\"676\":1}}],[\"无空格的路径\",{\"1\":{\"60\":1}}],[\"是因为splitter内重写了这个返回的list的tostring方法\",{\"1\":{\"996\":1}}],[\"是因为在查询关联对象或关联集合对象时\",{\"1\":{\"806\":1}}],[\"是列表的长度\",{\"1\":{\"968\":1,\"969\":1}}],[\"是字符串s的长度\",{\"1\":{\"948\":1,\"949\":1}}],[\"是感染它的那个格子的时间+1\",{\"1\":{\"944\":1}}],[\"是不会执行优雅停机的\",{\"1\":{\"913\":1}}],[\"是不存在永久代的概念的\",{\"1\":{\"461\":1}}],[\"是开源的tcc补偿性分布式事务框架\",{\"1\":{\"910\":1}}],[\"是的话直接返回内容\",{\"1\":{\"905\":1}}],[\"是毋庸置疑的\",{\"1\":{\"892\":1}}],[\"是半自动\",{\"0\":{\"823\":1}}],[\"是半编译半解释型语音\",{\"0\":{\"359\":1}}],[\"是如何进行分页的\",{\"0\":{\"817\":1}}],[\"是如何涌过栈帧中的对象引用访问到其内部的对象实例的呢\",{\"1\":{\"479\":1}}],[\"是做什么的\",{\"0\":{\"812\":1}}],[\"是默认值\",{\"1\":{\"762\":1}}],[\"是2\",{\"1\":{\"753\":1}}],[\"是什么呢\",{\"1\":{\"752\":1}}],[\"是固定值\",{\"1\":{\"747\":2,\"748\":2,\"749\":2}}],[\"是四个单词但匹配\",{\"1\":{\"741\":1,\"742\":1}}],[\"是四个单词不匹配任何绑定会被丢弃\",{\"1\":{\"741\":1,\"742\":1}}],[\"是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们\",{\"1\":{\"727\":1}}],[\"是最保守的\",{\"1\":{\"717\":1}}],[\"是工作队列\",{\"1\":{\"699\":1}}],[\"是哪个\",{\"1\":{\"697\":1}}],[\"是我们的消费者\",{\"1\":{\"695\":1}}],[\"是我们的生产者\",{\"1\":{\"695\":1}}],[\"是将这些消息推送到特定队列还是推送到多个队列\",{\"1\":{\"692\":1}}],[\"是将每条请求共享资源的线程封装成一个\",{\"1\":{\"289\":1}}],[\"是可执行\",{\"1\":{\"686\":1}}],[\"是spring4提供的一个新特性\",{\"1\":{\"674\":1}}],[\"是单例模式\",{\"1\":{\"653\":1}}],[\"是模型\",{\"1\":{\"645\":1}}],[\"是能够生成语义代码\",{\"1\":{\"615\":1}}],[\"是针对类实现代理\",{\"1\":{\"603\":1}}],[\"是基于tcp协议传输的\",{\"1\":{\"887\":1}}],[\"是基于spring功能之上添加的web框架\",{\"1\":{\"592\":1}}],[\"是基于\",{\"1\":{\"525\":1}}],[\"是基于这样一个事实\",{\"1\":{\"525\":1}}],[\"是基于可变长的数组和双指针来实现\",{\"1\":{\"231\":1}}],[\"是指控制器接受用户的输入并调用模型和视图去完成用户的需求\",{\"1\":{\"645\":1}}],[\"是指模型表示业务规则\",{\"1\":{\"645\":1}}],[\"是指用户看到并与之交互的界面\",{\"1\":{\"645\":1}}],[\"是指在一个事务内\",{\"1\":{\"634\":1}}],[\"是指一个无法再分解成更小的数据的数据\",{\"1\":{\"510\":1}}],[\"是指多个进程在运行过程中因争夺资源而造成的一种僵局\",{\"1\":{\"269\":1}}],[\"是gc\",{\"1\":{\"482\":1}}],[\"是jvm\",{\"1\":{\"482\":1}}],[\"是反射的方式\",{\"1\":{\"468\":1}}],[\"是没有垃圾收集行为的\",{\"1\":{\"464\":1}}],[\"是老年代的空间不足\",{\"1\":{\"463\":1}}],[\"是通过索引访问的\",{\"1\":{\"459\":1}}],[\"是方法区的一部分\",{\"1\":{\"459\":1}}],[\"是各个线程共享的内存区域\",{\"1\":{\"442\":1}}],[\"是有效的\",{\"1\":{\"413\":1}}],[\"是目前市面上高性能虚拟机的代表作之一\",{\"1\":{\"365\":1}}],[\"是无法完成赋值的\",{\"1\":{\"808\":1}}],[\"是无状态的\",{\"1\":{\"638\":1}}],[\"是无关的\",{\"1\":{\"357\":1}}],[\"是无序的\",{\"1\":{\"215\":2}}],[\"是用数组实现的\",{\"1\":{\"416\":1}}],[\"是用\",{\"1\":{\"289\":1}}],[\"是依赖于\",{\"1\":{\"285\":1}}],[\"是依赖于底层的操作系统的mutex\",{\"1\":{\"278\":1}}],[\"是写锁降级读锁的过程\",{\"1\":{\"279\":1}}],[\"是对锁操作的优化手段\",{\"1\":{\"278\":1}}],[\"是怎么实现的\",{\"0\":{\"276\":1}}],[\"是线程的私有数据\",{\"1\":{\"415\":1}}],[\"是线程私有的\",{\"1\":{\"399\":1,\"407\":1}}],[\"是线程共享的\",{\"1\":{\"305\":1}}],[\"是线程用来控制自身流程的\",{\"1\":{\"273\":1}}],[\"是线程安全的\",{\"1\":{\"239\":1,\"431\":1}}],[\"是使线程暂停执行一段时间的方法\",{\"1\":{\"273\":1}}],[\"是进程中的实际运作单位\",{\"1\":{\"264\":1}}],[\"是操作系统能够进行运算调度的最小单位\",{\"1\":{\"264\":1}}],[\"是把原始数据里的1\",{\"1\":{\"253\":1}}],[\"是一款基于\",{\"1\":{\"867\":1}}],[\"是一款很优秀的\",{\"1\":{\"643\":1}}],[\"是一款面向服务器的垃圾收集器\",{\"1\":{\"535\":1}}],[\"是一个java类库\",{\"1\":{\"879\":1}}],[\"是一个轻量级的remoting\",{\"1\":{\"879\":1}}],[\"是一个消息中间件\",{\"1\":{\"691\":1}}],[\"是一个接口\",{\"1\":{\"646\":1}}],[\"是一个枚举\",{\"1\":{\"566\":1}}],[\"是一个数据集\",{\"1\":{\"412\":1}}],[\"是一个相对于\",{\"1\":{\"355\":1}}],[\"是一个\",{\"1\":{\"318\":1,\"826\":1}}],[\"是一个链表结构的元素\",{\"1\":{\"251\":1}}],[\"是一种可伸缩的跨语言服务的软件框架\",{\"1\":{\"879\":1}}],[\"是一种可重入锁\",{\"1\":{\"251\":1}}],[\"是一种轻量的\",{\"1\":{\"875\":1}}],[\"是一种轻量级开发框架\",{\"1\":{\"591\":1}}],[\"是一种软件设计典范\",{\"1\":{\"645\":1}}],[\"是一种设计模式\",{\"1\":{\"643\":1}}],[\"是一种设计思想\",{\"1\":{\"595\":1}}],[\"是一种数组和链表结构\",{\"1\":{\"251\":1}}],[\"是由四个方向\",{\"1\":{\"933\":1}}],[\"是由程序员创建或特定工具自动生成源代码\",{\"1\":{\"607\":1}}],[\"是由\",{\"1\":{\"251\":1}}],[\"是非线程安全的\",{\"1\":{\"239\":1}}],[\"是泛型方法\",{\"1\":{\"233\":1}}],[\"是在虚拟机栈中\",{\"1\":{\"437\":1}}],[\"是在\",{\"1\":{\"231\":1,\"693\":1}}],[\"是在drake基础上改的\",{\"1\":{\"38\":1}}],[\"是设计师的博客\",{\"1\":{\"139\":1}}],[\"是设计师的微博\",{\"1\":{\"139\":1}}],[\"是否支持延迟加载\",{\"0\":{\"821\":1}}],[\"是否支持快速随机访问\",{\"1\":{\"229\":1}}],[\"是否存在数据库中\",{\"1\":{\"774\":1}}],[\"是否批量应答未应答的消息\",{\"1\":{\"708\":1,\"714\":1,\"717\":1}}],[\"是否恢复消息到队列\",{\"1\":{\"706\":1}}],[\"是否自动签收\",{\"1\":{\"698\":1}}],[\"是否自动删除\",{\"1\":{\"697\":1}}],[\"是否进行共享\",{\"1\":{\"697\":1}}],[\"是否必需\",{\"1\":{\"651\":1}}],[\"是否有什么设计模式可以利用呢\",{\"1\":{\"628\":1}}],[\"是否有需要消除的元素\",{\"1\":{\"194\":1}}],[\"是否懒加载\",{\"1\":{\"612\":1,\"619\":1}}],[\"是否是单例的\",{\"1\":{\"612\":1}}],[\"是否移动回收后的存活对象是一项优缺点并存的风险决策\",{\"1\":{\"523\":1}}],[\"是否设置空间分配担保\",{\"1\":{\"503\":1}}],[\"是否可以脱离synchronize使用\",{\"0\":{\"287\":1}}],[\"是否相同\",{\"1\":{\"244\":1}}],[\"是否指向同一个地方\",{\"1\":{\"242\":1}}],[\"是否保证线程安全\",{\"1\":{\"229\":1}}],[\"是否使用唯一时间戳快照版本而不是\",{\"1\":{\"103\":1}}],[\"是否要在meta\",{\"1\":{\"103\":1}}],[\"是否能够传递到\",{\"1\":{\"81\":1}}],[\"是\",{\"1\":{\"59\":1,\"220\":1,\"240\":1,\"246\":1,\"285\":1,\"317\":1,\"380\":1,\"459\":1,\"524\":2,\"534\":1,\"599\":1,\"610\":2,\"691\":1,\"692\":2,\"706\":1,\"752\":1,\"762\":1,\"810\":2,\"821\":1,\"892\":1,\"1038\":1}}],[\"资源即可\",{\"1\":{\"674\":1}}],[\"资源敏感\",{\"1\":{\"534\":1}}],[\"资源利用率来进行适当调整\",{\"1\":{\"277\":1}}],[\"资源管理器多标签页\",{\"0\":{\"114\":1}}],[\"资源\",{\"1\":{\"591\":1,\"873\":1},\"2\":{\"57\":1,\"116\":1}}],[\"此区有大小限制\",{\"1\":{\"490\":1}}],[\"此规范不要求方法区域的位置或用于管理已编译代码的策略\",{\"1\":{\"441\":1}}],[\"此内存区域的唯一目的就是存放对象实例\",{\"1\":{\"304\":1}}],[\"此线程会自动苏醒\",{\"1\":{\"273\":1}}],[\"此外\",{\"1\":{\"231\":1,\"505\":1,\"720\":1}}],[\"此时深度和res的长度是不相等的\",{\"1\":{\"1034\":1}}],[\"此时深度又等于res元素数\",{\"1\":{\"1034\":1}}],[\"此时为题转化为了求解最大公约数\",{\"1\":{\"984\":1}}],[\"此时最近基本的功能已经有了\",{\"1\":{\"919\":1}}],[\"此时可以使用lambda表达式\",{\"1\":{\"848\":1}}],[\"此时需要在实体类属性上使用\",{\"1\":{\"837\":1}}],[\"此时mybatis\",{\"1\":{\"837\":1}}],[\"此时mark\",{\"1\":{\"278\":2}}],[\"此时钱已经扣了\",{\"1\":{\"771\":1}}],[\"此时生产者是不知道消息被丢弃这个事件的\",{\"1\":{\"764\":1}}],[\"此时队列需要绑定要一个模式上\",{\"1\":{\"728\":1}}],[\"此时并没\",{\"1\":{\"712\":1}}],[\"此时会记录此请求和请求的\",{\"1\":{\"891\":1}}],[\"此时会进行第二次扣款\",{\"1\":{\"771\":1}}],[\"此时会看到消息被\",{\"1\":{\"709\":1}}],[\"此时会重新放回\",{\"1\":{\"490\":1}}],[\"此时是\",{\"1\":{\"709\":1}}],[\"此时你就可以对请求或响应\",{\"1\":{\"648\":1}}],[\"此时该事务还未提交\",{\"1\":{\"634\":1}}],[\"此时再查看刚才的提交\",{\"1\":{\"585\":1}}],[\"此时上次幸存下来的对象放到\",{\"1\":{\"490\":1}}],[\"此时不再是常量池中的符号地址了\",{\"1\":{\"459\":1}}],[\"此时hotspot虚拟机对方法区的实现为永久代\",{\"1\":{\"343\":1}}],[\"此时这个对象锁还没有释放\",{\"1\":{\"271\":1,\"284\":1}}],[\"此时\",{\"1\":{\"233\":1,\"275\":1,\"307\":1,\"424\":1,\"621\":1,\"714\":1,\"717\":1,\"964\":2,\"970\":1,\"974\":2}}],[\"此时就很容易的到从第三行开始状态转移方程为dp\",{\"1\":{\"201\":1}}],[\"此时我们可以通过\",{\"1\":{\"99\":1}}],[\"此处主要记录了\",{\"1\":{\"787\":1}}],[\"此处命名为mvnspringbootrun\",{\"1\":{\"671\":1}}],[\"此处\",{\"1\":{\"288\":1}}],[\"此处需要补充图片\",{\"1\":{\"244\":1}}],[\"此处记录动态规划相关的题目\",{\"1\":{\"196\":1}}],[\"此处记录优先级队列相关的题目\",{\"1\":{\"192\":1}}],[\"此处记录滑动窗口相关的题目\",{\"1\":{\"185\":1}}],[\"此处记录常用的算法\",{\"1\":{\"181\":1}}],[\"此处记录一些用过的小工具\",{\"1\":{\"109\":1}}],[\"此处记录一些编写博客时经常用到的资源\",{\"1\":{\"52\":1}}],[\"此处只分析遇到的用的最多的目标\",{\"1\":{\"105\":1}}],[\"此次也只分析这3个属性\",{\"1\":{\"103\":1}}],[\"此博客所有内容的作用均为记录\",{\"1\":{\"1\":1}}],[\"提到过可以不要求虚拟机在方法区中实现垃圾收集\",{\"1\":{\"464\":1}}],[\"提升了效率\",{\"1\":{\"349\":1}}],[\"提交后发现\",{\"1\":{\"957\":1}}],[\"提交任务的线程\",{\"1\":{\"275\":1}}],[\"提交力扣题目\",{\"1\":{\"22\":1}}],[\"提高效率而生\",{\"1\":{\"826\":1}}],[\"提高用户体验\",{\"1\":{\"532\":1}}],[\"提高并发\",{\"1\":{\"279\":1}}],[\"提高并发访问率\",{\"1\":{\"249\":1}}],[\"提高线程的可管理性\",{\"1\":{\"274\":1}}],[\"提高响应速度\",{\"1\":{\"274\":1}}],[\"提高解题效率\",{\"1\":{\"181\":1}}],[\"提供者压力较大\",{\"1\":{\"888\":1}}],[\"提供者大于消费者\",{\"1\":{\"888\":1}}],[\"提供者个数多于消费者\",{\"1\":{\"888\":1}}],[\"提供与\",{\"1\":{\"888\":1}}],[\"提供和原生webservice的互操作\",{\"1\":{\"888\":1}}],[\"提供基于接口方法的透明远程过程调用\",{\"1\":{\"885\":1}}],[\"提供对多种nio框架抽象封装\",{\"1\":{\"885\":1}}],[\"提供对象关系映射标签\",{\"1\":{\"807\":1}}],[\"提供全表\",{\"1\":{\"827\":1}}],[\"提供映射标签\",{\"1\":{\"807\":1}}],[\"提供xml标签\",{\"1\":{\"807\":1}}],[\"提供的调用链为例\",{\"1\":{\"905\":1}}],[\"提供的基类iservice\",{\"1\":{\"833\":1}}],[\"提供的服务时\",{\"1\":{\"693\":1}}],[\"提供的常用条件注解\",{\"1\":{\"675\":1}}],[\"提供的org\",{\"1\":{\"628\":1}}],[\"提供的插件接口\",{\"1\":{\"817\":1}}],[\"提供的插件\",{\"1\":{\"99\":1}}],[\"提供一个匿名内部类\",{\"1\":{\"621\":1}}],[\"提供了基于\",{\"1\":{\"879\":1}}],[\"提供了代码生成器功能\",{\"1\":{\"826\":1}}],[\"提供了分页\",{\"1\":{\"826\":1}}],[\"提供了通用的mapper和service\",{\"1\":{\"826\":1}}],[\"提供了\",{\"1\":{\"812\":1}}],[\"提供了准生产环境的运行时的应用监控\",{\"1\":{\"665\":1}}],[\"提供了更多的扩展功能\",{\"1\":{\"611\":1}}],[\"提供了完全的\",{\"1\":{\"602\":1}}],[\"提供了多个静态方法可以把他们包装成线程同步的集合\",{\"1\":{\"259\":1}}],[\"提供了多个synchronizedxxx\",{\"1\":{\"259\":1}}],[\"提供\",{\"1\":{\"435\":1}}],[\"提供增删改查数据的基本功能\",{\"1\":{\"225\":1}}],[\"提供免费的占位图\",{\"1\":{\"139\":1}}],[\"提供免费的高清图片\",{\"1\":{\"139\":2}}],[\"提供免费的图标\",{\"1\":{\"139\":1}}],[\"提示\",{\"1\":{\"52\":1,\"87\":1,\"343\":1,\"381\":1,\"388\":1,\"787\":1,\"937\":1,\"953\":1}}],[\"缩小\",{\"1\":{\"48\":1}}],[\"实战\",{\"0\":{\"762\":1,\"765\":1,\"768\":1,\"778\":1},\"1\":{\"674\":1}}],[\"实战视频教程\",{\"1\":{\"126\":1}}],[\"实体类中添加逻辑删除属性\",{\"1\":{\"840\":1}}],[\"实体类名和表名不一致时\",{\"1\":{\"835\":1}}],[\"实体类只需继承\",{\"1\":{\"827\":1}}],[\"实体类\",{\"1\":{\"643\":1}}],[\"实例\",{\"1\":{\"615\":1,\"638\":1}}],[\"实例化的时候把a对象工厂放入三级缓存\",{\"1\":{\"621\":1}}],[\"实例化\",{\"1\":{\"613\":1,\"614\":1}}],[\"实例引用传递\",{\"1\":{\"508\":1}}],[\"实例数据\",{\"0\":{\"477\":1}}],[\"实例初始化方法\",{\"1\":{\"424\":1}}],[\"实例构造器\",{\"1\":{\"421\":1}}],[\"实例的解析结果\",{\"1\":{\"397\":1}}],[\"实际执行业务逻辑的服务层\",{\"1\":{\"882\":1}}],[\"实际案例里\",{\"1\":{\"724\":1}}],[\"实际是依赖\",{\"1\":{\"674\":1}}],[\"实际\",{\"1\":{\"528\":1}}],[\"实际上就是要反转所有相邻节点之间的指针\",{\"1\":{\"970\":1}}],[\"实际上\",{\"1\":{\"727\":1}}],[\"实际上它是spring\",{\"1\":{\"604\":1}}],[\"实际上是通过\",{\"1\":{\"317\":1}}],[\"实际上无论hashset中是否已经存在了某元素\",{\"1\":{\"242\":1}}],[\"实际大小\",{\"1\":{\"48\":1}}],[\"实用\",{\"0\":{\"148\":1}}],[\"实现基本的字符串压缩功能\",{\"1\":{\"953\":1}}],[\"实现逻辑删除\",{\"0\":{\"840\":1}}],[\"实现我们的接口userservice\",{\"1\":{\"833\":1}}],[\"实现自定义插件\",{\"1\":{\"817\":1}}],[\"实现自己的类加载器\",{\"1\":{\"387\":1}}],[\"实现延时队列的两大要素已经集齐\",{\"1\":{\"753\":1}}],[\"实现handlerinterceptor接口\",{\"1\":{\"656\":1}}],[\"实现对代码的增强\",{\"1\":{\"606\":2}}],[\"实现aop的技术\",{\"1\":{\"603\":1}}],[\"实现过程要复杂的多\",{\"1\":{\"528\":1}}],[\"实现简单\",{\"1\":{\"522\":1}}],[\"实现同样的功能需要史多的指令\",{\"1\":{\"405\":1}}],[\"实现且全部继承自java\",{\"1\":{\"331\":1}}],[\"实现方式\",{\"1\":{\"290\":2,\"633\":1}}],[\"实现线程安全的方式\",{\"1\":{\"249\":1}}],[\"实现sortedmap接口让\",{\"1\":{\"241\":1}}],[\"实现了initializingbean接口\",{\"1\":{\"614\":1}}],[\"实现了某个接口\",{\"1\":{\"596\":1}}],[\"实现了temporalunit\",{\"1\":{\"568\":1}}],[\"实现了解释器的核心功能\",{\"1\":{\"362\":1}}],[\"实现了\",{\"1\":{\"240\":1,\"251\":1,\"614\":4}}],[\"实现了访问顺序相关逻辑\",{\"1\":{\"222\":1}}],[\"实现\",{\"1\":{\"220\":1,\"240\":1,\"241\":1,\"249\":1,\"305\":1,\"383\":1,\"384\":1,\"468\":1,\"473\":1,\"765\":1,\"818\":1,\"888\":1,\"897\":1}}],[\"实现的面向切面编程\",{\"1\":{\"627\":1}}],[\"实现的\",{\"1\":{\"220\":1,\"240\":1,\"285\":1,\"525\":1}}],[\"实现拓扑排序的kahn算法\",{\"1\":{\"177\":1}}],[\"实现dijkstra算法\",{\"1\":{\"177\":1}}],[\"实现图的深度优先搜索\",{\"1\":{\"177\":1}}],[\"实现有向图\",{\"1\":{\"177\":1}}],[\"实现堆排序\",{\"1\":{\"176\":1}}],[\"实现二叉树前\",{\"1\":{\"175\":1}}],[\"实现查找二叉查找树中某个节点的后继\",{\"1\":{\"175\":1}}],[\"实现朴素的字符串匹配算法\",{\"1\":{\"174\":1}}],[\"实现模糊二分查找算法\",{\"1\":{\"172\":1}}],[\"实现归并排序\",{\"1\":{\"171\":1}}],[\"实现求链表的中间结点\",{\"1\":{\"167\":1}}],[\"实现两个有序的链表合并为一个有序链表\",{\"1\":{\"167\":1}}],[\"实现两个有序数组合并为一个有序数组\",{\"1\":{\"166\":1}}],[\"实现单链表反转\",{\"1\":{\"167\":1}}],[\"实现单链表\",{\"1\":{\"167\":1}}],[\"实现一个小顶堆\",{\"1\":{\"176\":1}}],[\"实现一个二叉查找树\",{\"1\":{\"175\":1}}],[\"实现一个字符集\",{\"1\":{\"174\":1}}],[\"实现一个lru缓存淘汰算法\",{\"1\":{\"173\":1}}],[\"实现一个基于链表法解决冲突问题的散列表\",{\"1\":{\"173\":1}}],[\"实现一个有序数组的二分查找算法\",{\"1\":{\"172\":1}}],[\"实现一个循环队列\",{\"1\":{\"169\":1}}],[\"实现一个大小固定的有序数组\",{\"1\":{\"166\":1}}],[\"实现一个支持动态扩容的数组\",{\"1\":{\"166\":1}}],[\"实现jar包\",{\"1\":{\"106\":1}}],[\"实现将\",{\"1\":{\"106\":1}}],[\"实现类支持不同的view类型\",{\"1\":{\"646\":1}}],[\"实现类\",{\"1\":{\"6\":1,\"607\":1}}],[\"打成的\",{\"0\":{\"686\":1}}],[\"打印d\",{\"1\":{\"1024\":1}}],[\"打印gc简要信息\",{\"1\":{\"503\":1}}],[\"打印为\",{\"1\":{\"381\":1}}],[\"打包成的可执行\",{\"1\":{\"686\":1}}],[\"打包成可发布的格式\",{\"1\":{\"94\":1}}],[\"打包文件名的标识符\",{\"1\":{\"99\":1}}],[\"打包方式为\",{\"1\":{\"85\":1}}],[\"打包方式\",{\"1\":{\"78\":1}}],[\"打包方式是war\",{\"1\":{\"78\":1}}],[\"打包的结果存放的目录\",{\"1\":{\"76\":1}}],[\"打包操作\",{\"0\":{\"76\":1}}],[\"打字机模式\",{\"1\":{\"48\":1}}],[\"打开spring\",{\"1\":{\"1012\":1}}],[\"打开源码所在文件夹\",{\"1\":{\"1010\":1}}],[\"打开cmd命令行输入\",{\"1\":{\"1007\":1}}],[\"打开浏览器访问地址\",{\"1\":{\"765\":1,\"768\":1}}],[\"打开devtools\",{\"1\":{\"48\":1}}],[\"打开\",{\"1\":{\"44\":1,\"756\":2,\"1006\":1}}],[\"文章\",{\"0\":{\"661\":1}}],[\"文本转二维码\",{\"1\":{\"160\":1}}],[\"文档\",{\"0\":{\"119\":1},\"1\":{\"788\":1}}],[\"文档对象模型\",{\"1\":{\"67\":1}}],[\"文档列表视图\",{\"1\":{\"48\":1}}],[\"文件或注解的方式将要执行的各种\",{\"1\":{\"806\":1}}],[\"文件或者已经打成\",{\"1\":{\"602\":1}}],[\"文件来配置不太好\",{\"1\":{\"595\":1}}],[\"文件来配置\",{\"1\":{\"595\":1}}],[\"文件常量池的另一重要特征是\",{\"1\":{\"459\":1}}],[\"文件格式验证\",{\"1\":{\"379\":1}}],[\"文件被反编译的保护措施\",{\"1\":{\"378\":1}}],[\"文件中的变量占位符\",{\"1\":{\"810\":1}}],[\"文件中增加配置\",{\"1\":{\"686\":1}}],[\"文件中配置\",{\"1\":{\"673\":1}}],[\"文件中常量池部分的内存映射\",{\"1\":{\"375\":1}}],[\"文件中除了有类的版本\",{\"1\":{\"307\":1}}],[\"文件的一部分\",{\"1\":{\"459\":1}}],[\"文件的字节流中包含信息符合当前虚拟机要求\",{\"1\":{\"379\":1}}],[\"文件的方式\",{\"0\":{\"378\":1}}],[\"文件的加载\",{\"1\":{\"375\":1}}],[\"文件的过程\",{\"1\":{\"367\":1}}],[\"文件编译成本地机器代码的过程\",{\"1\":{\"367\":1}}],[\"文件转变成\",{\"1\":{\"367\":1}}],[\"文件转换为\",{\"1\":{\"77\":1}}],[\"文件等也打包\",{\"1\":{\"99\":1}}],[\"文件即可\",{\"1\":{\"77\":1}}],[\"文件时\",{\"1\":{\"77\":1,\"390\":1}}],[\"文件一起存入本地仓库\",{\"1\":{\"77\":1}}],[\"文件树视图\",{\"1\":{\"48\":1}}],[\"文件\",{\"0\":{\"44\":1},\"1\":{\"6\":1,\"43\":1,\"340\":1,\"375\":1,\"378\":1,\"607\":1,\"753\":1,\"1006\":1}}],[\"六\",{\"0\":{\"48\":1}}],[\"不在\",{\"1\":{\"1029\":1}}],[\"不关心它在哪个水壶\",{\"0\":{\"983\":1}}],[\"不关注service具体实现的应用层\",{\"1\":{\"882\":1}}],[\"不为null\",{\"1\":{\"974\":1}}],[\"不妨假设链表为1\",{\"1\":{\"970\":1}}],[\"不用自己重复造轮子\",{\"1\":{\"919\":1}}],[\"不用想的很全面\",{\"1\":{\"919\":1}}],[\"不用\",{\"0\":{\"893\":1}}],[\"不用把大量时间花费在线程调度上\",{\"1\":{\"290\":1}}],[\"不论是从\",{\"1\":{\"892\":1}}],[\"不论是正常返回还是异常退出\",{\"1\":{\"604\":1}}],[\"不存在代码级别的强依赖\",{\"1\":{\"887\":1}}],[\"不存在的include引用\",{\"1\":{\"106\":1}}],[\"不再需要写死服务提供方地址\",{\"1\":{\"884\":1}}],[\"不再是初始值\",{\"1\":{\"503\":1}}],[\"不再是\",{\"1\":{\"249\":1}}],[\"不涉及底层编程接口和通讯模型\",{\"1\":{\"875\":1}}],[\"不涉及线程间的通信\",{\"1\":{\"273\":1}}],[\"不必每次通信都要像http一样去3次握手什么的\",{\"1\":{\"872\":1}}],[\"不像hibernate这种全自动orm映射工具\",{\"1\":{\"806\":1}}],[\"不创建会话\",{\"1\":{\"788\":1}}],[\"不然会报错\",{\"1\":{\"768\":1}}],[\"不然就会出现如下错误\",{\"1\":{\"711\":1}}],[\"不一致\",{\"1\":{\"762\":1}}],[\"不就是想要消息延迟多久被处理吗\",{\"1\":{\"753\":1}}],[\"不匹配任何绑定不会被任何队列接收到会被丢弃\",{\"1\":{\"741\":1,\"742\":1}}],[\"不处理路由键\",{\"1\":{\"728\":2}}],[\"不知道是哪个消息出问题了\",{\"1\":{\"723\":1}}],[\"不知道属于哪个层\",{\"1\":{\"618\":1}}],[\"不公平分发和预取值分发都用到\",{\"1\":{\"717\":1}}],[\"不公平分发思想\",{\"1\":{\"714\":1}}],[\"不公平分发\",{\"0\":{\"713\":1},\"1\":{\"714\":1,\"717\":1}}],[\"不要把你知道的都说了\",{\"1\":{\"890\":1}}],[\"不要用同步\",{\"1\":{\"653\":1}}],[\"不要在代码中使用它\",{\"1\":{\"239\":1}}],[\"不全是构造器方式的循环依赖\",{\"1\":{\"621\":1}}],[\"不将\",{\"1\":{\"599\":1}}],[\"不截断输出\",{\"1\":{\"577\":1}}],[\"不堆积碎片\",{\"1\":{\"524\":2}}],[\"不分代就不能正常工作了吗\",{\"1\":{\"497\":1}}],[\"不调用构造器\",{\"1\":{\"468\":1}}],[\"不受\",{\"1\":{\"461\":1}}],[\"不做统一要求\",{\"1\":{\"444\":1}}],[\"不做具体工作\",{\"1\":{\"97\":1}}],[\"不安全\",{\"1\":{\"431\":1}}],[\"不能随意更换数据库\",{\"1\":{\"807\":1}}],[\"不能随意写\",{\"1\":{\"740\":1}}],[\"不能用用别的注解代替\",{\"1\":{\"651\":1}}],[\"不能保存数据\",{\"1\":{\"638\":1}}],[\"不能\",{\"1\":{\"428\":1}}],[\"不能传递\",{\"1\":{\"81\":1}}],[\"不同在于其存储作用域为\",{\"1\":{\"813\":1}}],[\"不同的使用者有不同的需求\",{\"1\":{\"892\":1}}],[\"不同的负载该值取值也不同\",{\"1\":{\"717\":1}}],[\"不同的对象的生命周期是不一样的\",{\"1\":{\"525\":1}}],[\"不同作用域bean的依赖\",{\"1\":{\"620\":1}}],[\"不同作用域的bean相互依赖\",{\"0\":{\"620\":1}}],[\"不同\",{\"1\":{\"615\":1}}],[\"不同生命周期的对象可以采取不同的收集方式\",{\"1\":{\"525\":1}}],[\"不同对象的生命周期不同\",{\"1\":{\"497\":1}}],[\"不同线程中所包含的栈帧是不允许存在相互引用的\",{\"1\":{\"413\":1}}],[\"不同平台cpu架构不同\",{\"1\":{\"405\":1}}],[\"不同于类的构造器\",{\"1\":{\"380\":1}}],[\"不是书上说什么就是什么\",{\"1\":{\"893\":1}}],[\"不是死板的看源码\",{\"1\":{\"893\":1}}],[\"不是完整收集整个java堆的垃圾收集\",{\"1\":{\"493\":1}}],[\"不是必须的\",{\"1\":{\"478\":1}}],[\"不是好的idea\",{\"1\":{\"444\":1}}],[\"不是\",{\"1\":{\"429\":1,\"638\":1}}],[\"不是用java实现的\",{\"1\":{\"382\":1}}],[\"不是java实现的\",{\"1\":{\"332\":1}}],[\"不开启性能监控\",{\"1\":{\"372\":1}}],[\"不确定\",{\"1\":{\"367\":1}}],[\"不被篡改\",{\"1\":{\"333\":1}}],[\"不管是内存占用或者时间开销也不小\",{\"1\":{\"522\":1}}],[\"不管使用哪种方式\",{\"1\":{\"413\":1}}],[\"不管当前内存空间足够与否\",{\"1\":{\"327\":1}}],[\"不管等待顺序\",{\"1\":{\"290\":1}}],[\"不会真正删除数据\",{\"1\":{\"839\":1}}],[\"不会对应用程序或者数据库的现有设计造成任何影响\",{\"1\":{\"807\":1}}],[\"不会等待集群所有节点都已同步信息完成\",{\"1\":{\"800\":1}}],[\"不会因为多次点击而产生了副作用\",{\"1\":{\"771\":1}}],[\"不会因为单个节点挂掉导致延时队列不可用或者消息丢失\",{\"1\":{\"758\":1}}],[\"不会转发\",{\"1\":{\"728\":1}}],[\"不会超过\",{\"1\":{\"718\":1}}],[\"不会报错\",{\"1\":{\"548\":1}}],[\"不会出现\",{\"1\":{\"522\":1}}],[\"不会\",{\"1\":{\"430\":1}}],[\"不会危害虚拟机自身安全\",{\"1\":{\"379\":1}}],[\"不会在常量池中创建该对象\",{\"1\":{\"318\":1}}],[\"不会上传图片到服务器\",{\"1\":{\"132\":1}}],[\"不包括aaa\",{\"1\":{\"584\":1}}],[\"不包括启动类加载器\",{\"1\":{\"388\":1}}],[\"不包括对象头\",{\"1\":{\"312\":1,\"472\":1}}],[\"不包含\",{\"1\":{\"318\":1,\"485\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"274\":1}}],[\"不剥夺条件\",{\"1\":{\"269\":1}}],[\"不可重复读\",{\"1\":{\"634\":1}}],[\"不可重复读和幻影读\",{\"1\":{\"634\":1}}],[\"不可重复的\",{\"1\":{\"215\":2}}],[\"不可以作为普通的\",{\"1\":{\"686\":1}}],[\"不可以\",{\"1\":{\"622\":1}}],[\"不可不说的java\",{\"1\":{\"262\":1}}],[\"不推荐\",{\"0\":{\"534\":1},\"1\":{\"256\":1,\"656\":1}}],[\"不减1就会得到2048\",{\"1\":{\"253\":1}}],[\"不冲突\",{\"1\":{\"252\":1}}],[\"不相同就通过拉链法解决冲突\",{\"1\":{\"244\":1}}],[\"不过你也不用慌张\",{\"1\":{\"919\":1}}],[\"不过元空间与永久代最大的区别在于\",{\"1\":{\"445\":1}}],[\"不过无论如何\",{\"1\":{\"363\":1}}],[\"不过开发人员也可以给他指定一个时间\",{\"1\":{\"273\":1}}],[\"不过\",{\"1\":{\"247\":1,\"249\":1,\"277\":1,\"327\":1,\"536\":1,\"754\":1}}],[\"不过我们也可以指定排序的比较器\",{\"1\":{\"241\":1}}],[\"不过均摊后的插入操作依然为\",{\"1\":{\"231\":1}}],[\"不允许有\",{\"1\":{\"239\":1}}],[\"不支持存储\",{\"1\":{\"231\":1}}],[\"不支持高效的随机元素访问\",{\"1\":{\"229\":1}}],[\"不难发现\",{\"1\":{\"230\":1}}],[\"不选该物品时的总价值\",{\"1\":{\"207\":1}}],[\"不选\",{\"1\":{\"207\":2}}],[\"不选第一件物品\",{\"1\":{\"207\":1}}],[\"不限速下载器\",{\"1\":{\"148\":1}}],[\"不够多\",{\"1\":{\"139\":1}}],[\"不易统一管理\",{\"1\":{\"85\":1}}],[\"不需要得到目标节点的前驱节点\",{\"1\":{\"964\":1}}],[\"不需要改动dubbo的源码\",{\"1\":{\"909\":1}}],[\"不需要手动开关连接\",{\"1\":{\"807\":1}}],[\"不需要重新编写业务逻辑\",{\"1\":{\"645\":1}}],[\"不需要必须实现接口\",{\"1\":{\"607\":1}}],[\"不需要单独编译\",{\"1\":{\"602\":1}}],[\"不需要我们再重新定义wait方法的实现\",{\"1\":{\"288\":1}}],[\"不需要捕获异常\",{\"1\":{\"273\":1}}],[\"不需要扩容\",{\"1\":{\"231\":1}}],[\"不需要就选择实现\",{\"1\":{\"216\":1}}],[\"不需要排序时就选择\",{\"1\":{\"216\":1}}],[\"不需要写version\",{\"1\":{\"83\":1}}],[\"不需要建这个目录\",{\"1\":{\"61\":1}}],[\"不想要\",{\"1\":{\"82\":1}}],[\"不放进\",{\"1\":{\"80\":1}}],[\"不稳定的版本\",{\"1\":{\"65\":1}}],[\"不常用\",{\"1\":{\"47\":1}}],[\"不合理的设置可能会导致文件在跨系统场景下乱码\",{\"1\":{\"17\":1}}],[\"图例\",{\"1\":{\"734\":1}}],[\"图中元空间就是jdk7以后方法区的实现\",{\"1\":{\"439\":1}}],[\"图中\",{\"1\":{\"266\":1}}],[\"图中只列举了主要的继承派生关系\",{\"1\":{\"214\":1}}],[\"图\",{\"0\":{\"177\":1}}],[\"图库\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"图标\",{\"0\":{\"54\":1}}],[\"图片来自\",{\"1\":{\"249\":1}}],[\"图片裁剪插件\",{\"1\":{\"160\":1}}],[\"图片工具\",{\"0\":{\"132\":1}}],[\"图片\",{\"1\":{\"47\":1}}],[\"图床\",{\"0\":{\"39\":1}}],[\"下标越界\",{\"1\":{\"955\":1}}],[\"下一层\",{\"1\":{\"944\":1}}],[\"下一个工作日\",{\"1\":{\"569\":1}}],[\"下一个编辑点之间切换\",{\"1\":{\"6\":1}}],[\"下的\",{\"1\":{\"892\":1}}],[\"下的所有\",{\"1\":{\"331\":1}}],[\"下线接口\",{\"1\":{\"872\":1}}],[\"下图绑定关系如下\",{\"1\":{\"741\":1}}],[\"下我们一般把后端项目分为\",{\"1\":{\"643\":1}}],[\"下次提交时不想保留上一次的记录\",{\"1\":{\"585\":1}}],[\"下次有新对象需要加载时\",{\"1\":{\"521\":1}}],[\"下加载类库\",{\"1\":{\"383\":1}}],[\"下方代码中str2虽然也用final修饰了\",{\"1\":{\"317\":1}}],[\"下方的while也总是成立的\",{\"1\":{\"954\":1}}],[\"下方的很多参数可以进行选择\",{\"1\":{\"702\":1}}],[\"下方的实例中使用了2个插件\",{\"1\":{\"106\":1}}],[\"下方的代码使用了spring的多个工程\",{\"1\":{\"85\":1}}],[\"下拉刷新和上拉加载框架\",{\"1\":{\"158\":1}}],[\"下面以代码来演示\",{\"1\":{\"990\":1}}],[\"下面附上力扣评论区的解读\",{\"1\":{\"970\":1}}],[\"下面示例中演示了一个惰性队列的声明细节\",{\"1\":{\"783\":1}}],[\"下面详细讲解异步确认是怎么实现的\",{\"1\":{\"724\":1}}],[\"下面的笔记记录了开发中常用的\",{\"1\":{\"1001\":1}}],[\"下面的配置将使用undertow来做服务器而不是tomcat\",{\"1\":{\"679\":1}}],[\"下面的代码段是使\",{\"1\":{\"676\":1}}],[\"下面的例子只针对部分请求拦截\",{\"1\":{\"656\":1}}],[\"下面的内容整理自\",{\"1\":{\"614\":1}}],[\"下面这个例子是通过\",{\"1\":{\"617\":1}}],[\"下面这个方法保证了\",{\"1\":{\"239\":1}}],[\"下面两个表达式其实是等价的\",{\"1\":{\"317\":1}}],[\"下面给出了源代码\",{\"1\":{\"239\":1}}],[\"下面有介绍到\",{\"1\":{\"229\":1}}],[\"下面又有三个主要的子接口\",{\"1\":{\"214\":1}}],[\"下面\",{\"1\":{\"85\":1,\"816\":1}}],[\"下载后解压zip包\",{\"1\":{\"1005\":1}}],[\"下载后解压到不含中文\",{\"1\":{\"60\":1}}],[\"下载gradle构建工具\",{\"0\":{\"1005\":1}}],[\"下载完大约有453mb\",{\"1\":{\"1004\":1}}],[\"下载源码\",{\"0\":{\"1004\":1}}],[\"下载器\",{\"1\":{\"148\":1}}],[\"下载\",{\"1\":{\"114\":1}}],[\"下载缓慢的情况\",{\"1\":{\"113\":1}}],[\"下载地址\",{\"1\":{\"59\":1,\"110\":1}}],[\"下划线\",{\"1\":{\"47\":1}}],[\"斜体\",{\"1\":{\"47\":1}}],[\"五\",{\"0\":{\"47\":1}}],[\"减少单点\",{\"1\":{\"884\":1}}],[\"减少了网络开销\",{\"1\":{\"872\":1}}],[\"减少了50\",{\"1\":{\"807\":1}}],[\"减少参数传递以及跳转过程\",{\"1\":{\"372\":1}}],[\"减少不必要的内存开销\",{\"1\":{\"318\":1}}],[\"减少缩进\",{\"1\":{\"46\":1}}],[\"减少标题级别\",{\"1\":{\"46\":1}}],[\"增量收集算法通过对线程间冲突的妥善处理允许垃圾收集线程以分阶段的方式完成标记\",{\"1\":{\"526\":1}}],[\"增量收集算法的基础仍是传统的标记\",{\"1\":{\"526\":1}}],[\"增量收集算法\",{\"0\":{\"526\":1}}],[\"增删快\",{\"1\":{\"226\":1}}],[\"增删慢\",{\"1\":{\"226\":2}}],[\"增长曲线\",{\"1\":{\"127\":1}}],[\"增加后\",{\"1\":{\"939\":1}}],[\"增加了对扩展点ioc和aop的支持\",{\"1\":{\"909\":1}}],[\"增加了一些高级功能\",{\"0\":{\"286\":1}}],[\"增加了一条双向链表\",{\"1\":{\"222\":1}}],[\"增加预取将提高向消费者传递消息的速度\",{\"1\":{\"717\":1}}],[\"增加缩进\",{\"1\":{\"46\":1}}],[\"增加环绕代码\",{\"1\":{\"6\":1}}],[\"增大标题级别\",{\"1\":{\"46\":1}}],[\"四大核心概念\",{\"0\":{\"692\":1}}],[\"四年\",{\"1\":{\"568\":1}}],[\"四者的区别\",{\"0\":{\"215\":1}}],[\"四\",{\"0\":{\"46\":1}}],[\"查询时\",{\"1\":{\"861\":1}}],[\"查询id小于等于3的用户信息\",{\"1\":{\"850\":1}}],[\"查询用户信息的username和age字段\",{\"1\":{\"849\":1}}],[\"查询条件封装\",{\"1\":{\"842\":1}}],[\"查询集合\",{\"1\":{\"833\":1}}],[\"查询单行\",{\"1\":{\"833\":1}}],[\"查询\",{\"1\":{\"827\":1}}],[\"查询关联对象或者关联集合对象时\",{\"1\":{\"823\":1}}],[\"查询上来\",{\"1\":{\"821\":1}}],[\"查询慢\",{\"1\":{\"226\":1}}],[\"查询快\",{\"1\":{\"226\":2}}],[\"查询销售订单列表\",{\"1\":{\"194\":1}}],[\"查找当前applicationcontext中是否注册有commandlinerunner\",{\"1\":{\"678\":1}}],[\"查找并加载classpath中所有可用的applicationcontext\",{\"1\":{\"678\":1}}],[\"查找和匹配\",{\"0\":{\"550\":1}}],[\"查找过程结束\",{\"1\":{\"422\":1}}],[\"查找操作\",{\"1\":{\"175\":1}}],[\"查找上一个\",{\"1\":{\"45\":1}}],[\"查找下一个\",{\"1\":{\"45\":1}}],[\"查找\",{\"0\":{\"258\":1},\"1\":{\"45\":1,\"256\":1}}],[\"查看结果是否正常\",{\"1\":{\"1012\":1}}],[\"查看服务列表\",{\"1\":{\"912\":1}}],[\"查看交换机的新增功能列表\",{\"1\":{\"756\":1}}],[\"查看给定的localdatetime在其他时区的时间\",{\"1\":{\"562\":1}}],[\"查看所有的参数的最终值\",{\"1\":{\"503\":1}}],[\"查看所有的参数的默认初始值\",{\"1\":{\"503\":1}}],[\"查看的方式不同\",{\"1\":{\"487\":1}}],[\"查看类加载和卸载信息\",{\"1\":{\"464\":1}}],[\"查看\",{\"1\":{\"449\":2}}],[\"查看一个简写是什么意思的网站\",{\"1\":{\"143\":1}}],[\"查看属性和方法的兼容性\",{\"1\":{\"129\":1}}],[\"查看某项技术或关键字的热度趋势\",{\"1\":{\"122\":1}}],[\"查看当前运行中的进程\",{\"1\":{\"503\":1}}],[\"查看当前\",{\"1\":{\"78\":1}}],[\"查看对应\",{\"1\":{\"77\":1}}],[\"查看顶层的\",{\"1\":{\"32\":1}}],[\"查看哪个目录占用空间大\",{\"0\":{\"32\":1}}],[\"查看书签\",{\"1\":{\"11\":1}}],[\"查看实现类\",{\"1\":{\"6\":1}}],[\"句柄访问\",{\"1\":{\"479\":1}}],[\"句柄对应的类未初始化\",{\"1\":{\"397\":1}}],[\"句柄\",{\"1\":{\"315\":1}}],[\"句柄和直接指针两种方式\",{\"0\":{\"315\":1}}],[\"句\",{\"1\":{\"45\":1}}],[\"粘贴为纯文本\",{\"1\":{\"45\":1}}],[\"粘贴\",{\"1\":{\"45\":1}}],[\"剪切\",{\"1\":{\"45\":1}}],[\"重复了\",{\"1\":{\"939\":1}}],[\"重复使用线程或进程\",{\"1\":{\"280\":1}}],[\"重试其它服务器\",{\"1\":{\"917\":1}}],[\"重用\",{\"1\":{\"879\":1}}],[\"重量级对象\",{\"1\":{\"822\":1}}],[\"重量级锁的过程\",{\"1\":{\"279\":1}}],[\"重量级锁\",{\"1\":{\"278\":1}}],[\"重量级锁等\",{\"1\":{\"278\":1}}],[\"重量级锁都是啥\",{\"0\":{\"278\":1}}],[\"重启期间生产者消息投递失败\",{\"1\":{\"759\":1}}],[\"重启\",{\"1\":{\"759\":1}}],[\"重启服务\",{\"1\":{\"756\":1}}],[\"重启下面\",{\"1\":{\"755\":1}}],[\"重启目录\",{\"1\":{\"670\":1}}],[\"重新从缓存里获取消息发布到交换机\",{\"1\":{\"761\":1}}],[\"重新创建一个classloader\",{\"1\":{\"670\":1}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"534\":1}}],[\"重新标记\",{\"1\":{\"534\":1}}],[\"重新打包现有的\",{\"1\":{\"106\":1}}],[\"重新打开上次使用的文件和目录\",{\"1\":{\"37\":1}}],[\"重点讲下cms和g1\",{\"1\":{\"518\":1}}],[\"重点讲一下cms和g1\",{\"1\":{\"518\":1}}],[\"重点是确认\",{\"1\":{\"450\":1}}],[\"重点来了\",{\"1\":{\"246\":1}}],[\"重要的jvm参数\",{\"0\":{\"334\":1}}],[\"重要\",{\"1\":{\"249\":1}}],[\"重做\",{\"1\":{\"45\":1}}],[\"撤销\",{\"1\":{\"45\":1}}],[\"三个经典问题\",{\"1\":{\"515\":1}}],[\"三个生命周期\",{\"0\":{\"94\":1}}],[\"三面\",{\"1\":{\"465\":1}}],[\"三\",{\"0\":{\"45\":1}}],[\"二级缓存namespaces\",{\"1\":{\"813\":1}}],[\"二级缓存与一级缓存其机制相同\",{\"1\":{\"813\":1}}],[\"二级缓存\",{\"0\":{\"813\":1}}],[\"二级不行吗\",{\"0\":{\"622\":1}}],[\"二是采用静态织入的方式\",{\"1\":{\"603\":1}}],[\"二面\",{\"1\":{\"465\":3,\"467\":1,\"518\":1}}],[\"二进制表达为\",{\"1\":{\"253\":1}}],[\"二进制中1的个数\",{\"1\":{\"184\":1}}],[\"二者的本质差异在于标记\",{\"1\":{\"523\":1}}],[\"二者打印的结果相同\",{\"1\":{\"503\":1}}],[\"二者不一致\",{\"1\":{\"319\":1}}],[\"二者交换数据\",{\"1\":{\"292\":1}}],[\"二者相与\",{\"1\":{\"184\":1}}],[\"二者相与赋值给n\",{\"1\":{\"184\":1}}],[\"二者没有关联\",{\"1\":{\"89\":1}}],[\"二叉树的最近公共祖先\",{\"0\":{\"1037\":1}}],[\"二叉树的层次遍历可以用广度优先搜索实现\",{\"1\":{\"1035\":1}}],[\"二叉树的右视图\",{\"0\":{\"1032\":1}}],[\"二叉树的每个节点最多被访问一次\",{\"1\":{\"1030\":1}}],[\"二叉树的直径\",{\"0\":{\"1021\":1}}],[\"二叉树\",{\"0\":{\"175\":1},\"1\":{\"979\":1}}],[\"二分查找\",{\"0\":{\"172\":1,\"927\":1}}],[\"二\",{\"0\":{\"44\":1}}],[\"段落\",{\"0\":{\"46\":1},\"1\":{\"43\":1,\"46\":1}}],[\"一直遍历到最左下\",{\"1\":{\"1024\":1}}],[\"一开始写的代码遇到了\",{\"1\":{\"955\":1}}],[\"一道普通的字符串\",{\"1\":{\"947\":1}}],[\"一道经典的dfs\",{\"1\":{\"942\":1}}],[\"一台机器宕机\",{\"1\":{\"916\":1}}],[\"一对多使用<collection>\",{\"1\":{\"820\":1}}],[\"一对多的关联查询\",{\"0\":{\"820\":1}}],[\"一对一使用<association>\",{\"1\":{\"820\":1}}],[\"一对一\",{\"0\":{\"820\":1}}],[\"一级缓存\",{\"1\":{\"813\":2}}],[\"一级缓存中保存着实例化\",{\"1\":{\"621\":1}}],[\"一致性hash策略\",{\"1\":{\"916\":1}}],[\"一致性\",{\"1\":{\"797\":1}}],[\"一秒消费一个消息\",{\"1\":{\"708\":1}}],[\"一方面它接收来自生产者的消息\",{\"1\":{\"692\":1,\"727\":1}}],[\"一是采用动态代理技术\",{\"1\":{\"603\":1}}],[\"一定要非常熟练\",{\"1\":{\"590\":1}}],[\"一定也是相同的\",{\"1\":{\"242\":1}}],[\"一言以蔽之\",{\"1\":{\"549\":1}}],[\"一种用途是在\",{\"1\":{\"533\":1}}],[\"一种是类名中含有wrapper\",{\"1\":{\"628\":1}}],[\"一种是整堆收集\",{\"1\":{\"493\":1}}],[\"一种是部分收集\",{\"1\":{\"493\":1}}],[\"一种是正常的函数返回\",{\"1\":{\"413\":1}}],[\"一次性创建了所有的bean\",{\"1\":{\"611\":1}}],[\"一次性申请所有的资源\",{\"1\":{\"270\":1}}],[\"一次\",{\"1\":{\"527\":1}}],[\"一次通常可以回收70\",{\"1\":{\"522\":1}}],[\"一起回收的\",{\"1\":{\"493\":1}}],[\"一类是生命周期较短的瞬时对象\",{\"1\":{\"488\":1}}],[\"一一从实际使用角度看的\",{\"1\":{\"482\":1}}],[\"一面\",{\"1\":{\"465\":4,\"518\":7}}],[\"一旦出现问题但很难推断出是那条消息出现了问题\",{\"1\":{\"724\":1}}],[\"一旦发布一条消息\",{\"1\":{\"720\":1}}],[\"一旦发现了只具有弱引用的对象\",{\"1\":{\"327\":1}}],[\"一旦消息被投递到所有匹配的队列之后\",{\"1\":{\"720\":1}}],[\"一旦信道进入\",{\"1\":{\"720\":1}}],[\"一旦数量达到配置的数量\",{\"1\":{\"717\":1}}],[\"一旦向消费者传递了一条消息\",{\"1\":{\"704\":1}}],[\"一旦对象在tlab空间分配内存失败时\",{\"1\":{\"502\":1}}],[\"一旦堆区中的内存大小超过\",{\"1\":{\"485\":1}}],[\"一旦触及这个水位线\",{\"1\":{\"448\":1}}],[\"一样处理\",{\"1\":{\"615\":1}}],[\"一样\",{\"1\":{\"482\":1,\"972\":1}}],[\"一样在本地内存中实现的元空间来代替\",{\"1\":{\"445\":1}}],[\"一样做短视频\",{\"1\":{\"148\":1}}],[\"一共有两套解释执行器\",{\"1\":{\"362\":1}}],[\"一些常驻的异常对象\",{\"1\":{\"519\":1}}],[\"一些附加信息\",{\"0\":{\"425\":1},\"1\":{\"414\":1}}],[\"一些列表实现提供了渐近线性的访问时间\",{\"1\":{\"230\":1}}],[\"一些算法题记录\",{\"1\":{\"210\":1}}],[\"一系列教程\",{\"1\":{\"146\":1}}],[\"一般都会自定义断言工具类\",{\"1\":{\"998\":1}}],[\"一般使用zookeeper提供服务注册与发现功能\",{\"1\":{\"878\":1}}],[\"一般使用带有compact\",{\"1\":{\"471\":1}}],[\"一般一个第三方的应该这样命名\",{\"1\":{\"682\":1}}],[\"一般不推荐使用\",{\"1\":{\"656\":1}}],[\"一般不会修改\",{\"1\":{\"488\":1}}],[\"一般不会太久\",{\"1\":{\"278\":1}}],[\"一般命名为springmvc\",{\"1\":{\"652\":1}}],[\"一般情况下\",{\"1\":{\"625\":1,\"638\":1}}],[\"一般是由标记\",{\"1\":{\"525\":1}}],[\"一般是把\",{\"1\":{\"525\":1}}],[\"一般是在对象的header中记录为可达对象\",{\"1\":{\"521\":1}}],[\"一般回收速度也比较快\",{\"1\":{\"494\":1}}],[\"一般的手段是首先通过内存映像分析工具出来的堆转储快照进行分析\",{\"1\":{\"450\":1}}],[\"一般的\",{\"1\":{\"422\":1,\"512\":1}}],[\"一般来说==这个区域的回收效果比较难令人满意\",{\"1\":{\"464\":1}}],[\"一般来说\",{\"1\":{\"384\":1,\"415\":1,\"527\":1,\"744\":1}}],[\"一般来讲\",{\"1\":{\"372\":1}}],[\"一般将获取锁失败的线程放入等待队列中\",{\"1\":{\"290\":1}}],[\"一般而言我们都会配置的注册中心\",{\"1\":{\"890\":1}}],[\"一般而言\",{\"1\":{\"278\":1}}],[\"一般需要根据任务的类型来配置线程池大小\",{\"1\":{\"277\":1}}],[\"一般应用是很难出现碰撞的\",{\"1\":{\"246\":1}}],[\"一般对使用spring\",{\"1\":{\"104\":1}}],[\"一般作为\",{\"1\":{\"65\":1}}],[\"一键执行\",{\"1\":{\"90\":1}}],[\"一个节点也可以是它自己的祖先\",{\"1\":{\"1038\":1}}],[\"一个额外的string参数\",{\"1\":{\"997\":1}}],[\"一个额外的object参数\",{\"1\":{\"997\":1}}],[\"一个扩展点可以直接setter注入其它扩展点\",{\"1\":{\"909\":1}}],[\"一个流程完毕\",{\"1\":{\"891\":1}}],[\"一个基本的rpc架构里面应该至少包含以下4个组件\",{\"1\":{\"874\":1}}],[\"一个基本认知是如果不进行垃圾回收\",{\"1\":{\"516\":1}}],[\"一个消费者\",{\"1\":{\"762\":1}}],[\"一个消费者就是一个工作队列\",{\"1\":{\"700\":1}}],[\"一个队列\",{\"1\":{\"762\":1}}],[\"一个交换机\",{\"1\":{\"762\":1}}],[\"一个分布式数据系统\",{\"1\":{\"757\":1}}],[\"一个自定义交换机\",{\"1\":{\"757\":1}}],[\"一个生产者\",{\"1\":{\"746\":1}}],[\"一个绑定键为\",{\"1\":{\"736\":1}}],[\"一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上\",{\"1\":{\"728\":1}}],[\"一个工作线程\",{\"1\":{\"701\":1}}],[\"一个快递员帮你传递快件\",{\"1\":{\"691\":1}}],[\"一个快递站\",{\"1\":{\"691\":1}}],[\"一个可引用\",{\"1\":{\"686\":1}}],[\"一个可执行\",{\"1\":{\"686\":1}}],[\"一个轻量级的web层框架\",{\"1\":{\"667\":1}}],[\"一个url对应一个方法\",{\"1\":{\"654\":1}}],[\"一个http\",{\"1\":{\"615\":1}}],[\"一个连接点\",{\"1\":{\"604\":1}}],[\"一个应用程序可以有若干切面\",{\"1\":{\"604\":1}}],[\"一个终端操作\",{\"1\":{\"547\":1}}],[\"一个中间操作链\",{\"1\":{\"547\":1}}],[\"一个数据源\",{\"1\":{\"547\":1}}],[\"一个对象在这里产生\",{\"1\":{\"512\":1}}],[\"一个对象并没有逃逸出方法的话\",{\"1\":{\"505\":1}}],[\"一个极端的例子\",{\"1\":{\"511\":1}}],[\"一个jvm实例只存在一个堆内存\",{\"1\":{\"482\":1}}],[\"一个java源文件中的类\",{\"1\":{\"457\":1}}],[\"一个nativemethod是这样一个java方注\",{\"1\":{\"434\":1}}],[\"一个方法在正常调用完成之后需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定\",{\"1\":{\"424\":1}}],[\"一个方法的结束\",{\"1\":{\"424\":1}}],[\"一个方法宄竟要被调用多少次\",{\"1\":{\"368\":1}}],[\"一个新的栈帧也会随之被创建出来\",{\"1\":{\"416\":1}}],[\"一个新的对象已经产生了\",{\"1\":{\"314\":1}}],[\"一个时间点上\",{\"1\":{\"413\":1}}],[\"一个处理器或者多核处理器中的一个内核\",{\"1\":{\"402\":1}}],[\"一个被多次调用的方法\",{\"1\":{\"368\":1}}],[\"一个运行中的java虚拟机有着一个清晰的任务\",{\"1\":{\"346\":1}}],[\"一个任务一个任务执行的场景\",{\"1\":{\"291\":1}}],[\"一个线程完全可以持有很多锁\",{\"1\":{\"288\":1}}],[\"一个进程因请求资源而阻塞时\",{\"1\":{\"269\":1}}],[\"一个是base\",{\"1\":{\"670\":1}}],[\"一个是\",{\"1\":{\"214\":1}}],[\"一个二维数组\",{\"1\":{\"207\":1}}],[\"一个国外的在线调查问卷网站\",{\"1\":{\"148\":1}}],[\"一个国外微交互汇集网站\",{\"1\":{\"142\":1}}],[\"一个波兰团队做了非常好玩的工具\",{\"1\":{\"142\":1}}],[\"一个帮助开发者成长的社区\",{\"1\":{\"120\":1}}],[\"一个插件可以对应多个目标\",{\"1\":{\"98\":1}}],[\"一个\",{\"1\":{\"85\":1,\"229\":2,\"251\":2,\"434\":1,\"933\":1}}],[\"一个项目或者是项目中的一个模块的\",{\"1\":{\"65\":1}}],[\"一\",{\"0\":{\"43\":1},\"1\":{\"684\":1,\"757\":1}}],[\"一体化\",{\"1\":{\"38\":1}}],[\"qc\",{\"1\":{\"755\":3}}],[\"qd\",{\"1\":{\"754\":6}}],[\"qb\",{\"1\":{\"754\":7}}],[\"qa\",{\"1\":{\"752\":2,\"754\":7}}],[\"q2\",{\"1\":{\"731\":1,\"736\":2,\"741\":4,\"742\":4}}],[\"q1q2\",{\"1\":{\"741\":2,\"742\":2}}],[\"q1\",{\"1\":{\"731\":1,\"736\":2,\"741\":2,\"742\":2,\"1024\":6}}],[\"qos\",{\"1\":{\"717\":3}}],[\"quartz\",{\"1\":{\"758\":1}}],[\"qualifier是根据名称注入\",{\"1\":{\"599\":1}}],[\"qualifier\",{\"1\":{\"599\":6,\"609\":2,\"619\":1,\"754\":7,\"755\":3,\"757\":2,\"762\":3,\"768\":6,\"780\":2}}],[\"querywrapper<>\",{\"1\":{\"844\":1,\"845\":1,\"846\":1,\"849\":1,\"850\":1,\"854\":1,\"858\":1}}],[\"querywrapper<user>\",{\"1\":{\"844\":1,\"845\":1,\"846\":1,\"849\":1,\"850\":1,\"854\":1,\"858\":1}}],[\"querywrapper\",{\"0\":{\"843\":1},\"1\":{\"832\":11,\"842\":1,\"844\":3,\"845\":3,\"846\":3,\"847\":2,\"848\":2,\"849\":3,\"850\":3,\"852\":3,\"853\":3,\"854\":2,\"858\":3}}],[\"query\",{\"1\":{\"651\":3,\"832\":1}}],[\"question\",{\"1\":{\"293\":1,\"595\":1}}],[\"queue<treenode>\",{\"1\":{\"1024\":1,\"1035\":1}}],[\"queue<integer>\",{\"1\":{\"944\":1,\"983\":1}}],[\"queue<int\",{\"1\":{\"194\":2}}],[\"queue中\",{\"1\":{\"902\":1}}],[\"queueconfig\",{\"1\":{\"780\":1}}],[\"queuecbindingx\",{\"1\":{\"755\":1,\"780\":1}}],[\"queuec\",{\"1\":{\"755\":5}}],[\"queued\",{\"1\":{\"754\":5}}],[\"queuedeclare\",{\"1\":{\"697\":3,\"702\":1,\"708\":1,\"711\":1,\"712\":1,\"722\":1,\"723\":1,\"730\":1,\"747\":3,\"748\":2,\"749\":3,\"777\":1,\"779\":1,\"783\":2}}],[\"queuea\",{\"1\":{\"754\":5}}],[\"queuebbindingx\",{\"1\":{\"754\":1}}],[\"queueb\",{\"1\":{\"754\":3}}],[\"queuebuilder\",{\"1\":{\"752\":1,\"754\":2,\"755\":1,\"762\":1,\"768\":3,\"780\":1}}],[\"queuebinding\",{\"1\":{\"762\":1,\"768\":1}}],[\"queuebindingx\",{\"1\":{\"754\":1}}],[\"queuebind\",{\"1\":{\"735\":1,\"747\":3,\"748\":2,\"749\":3}}],[\"queuename\",{\"1\":{\"722\":3,\"723\":3,\"730\":1,\"735\":1}}],[\"queue2\",{\"1\":{\"701\":1}}],[\"queues\",{\"0\":{\"699\":1},\"1\":{\"699\":1,\"702\":2,\"754\":1,\"757\":1,\"762\":1,\"768\":1,\"780\":1}}],[\"queue1b\",{\"1\":{\"754\":2}}],[\"queue1\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"queue按特定的排队规则来确定先后顺序\",{\"1\":{\"215\":1}}],[\"queue\",{\"0\":{\"215\":1,\"221\":1},\"1\":{\"214\":1,\"693\":4,\"697\":5,\"698\":2,\"701\":4,\"702\":2,\"708\":8,\"711\":4,\"712\":4,\"714\":3,\"717\":3,\"728\":1,\"729\":1,\"730\":1,\"731\":1,\"744\":2,\"747\":3,\"748\":2,\"749\":3,\"754\":13,\"755\":4,\"757\":13,\"762\":13,\"768\":26,\"777\":3,\"779\":8,\"780\":10,\"783\":2,\"944\":5,\"1035\":7}}],[\"quick\",{\"1\":{\"235\":1,\"740\":1,\"741\":4,\"742\":4}}],[\"qr\",{\"1\":{\"160\":1}}],[\"q\",{\"1\":{\"42\":1,\"577\":1,\"983\":8,\"1038\":2}}],[\"oxm\",{\"1\":{\"1010\":1}}],[\"omitemptystrings\",{\"1\":{\"996\":1}}],[\"ognl\",{\"1\":{\"812\":1}}],[\"o通道就没戏了\",{\"1\":{\"544\":1}}],[\"osgi\",{\"1\":{\"464\":2}}],[\"optimisticlockerinnerinterceptor\",{\"1\":{\"860\":1}}],[\"options=\",{\"1\":{\"668\":1}}],[\"options说明\",{\"1\":{\"577\":1}}],[\"options\",{\"0\":{\"577\":1},\"1\":{\"42\":1,\"673\":1,\"788\":1}}],[\"open\",{\"1\":{\"614\":1}}],[\"openssl\",{\"1\":{\"587\":1}}],[\"openjdk的默认虚拟机\",{\"1\":{\"351\":1}}],[\"operand\",{\"0\":{\"416\":1},\"1\":{\"414\":1}}],[\"old这种省心又省力方案完全合理\",{\"1\":{\"534\":1}}],[\"old的组合工作起来其实并不稳定\",{\"1\":{\"534\":1}}],[\"old来清理碎片\",{\"1\":{\"534\":1}}],[\"oldgen\",{\"1\":{\"488\":1}}],[\"old\",{\"0\":{\"533\":1},\"1\":{\"304\":2,\"339\":2,\"483\":2,\"493\":1,\"525\":2,\"532\":1,\"537\":2,\"539\":4,\"540\":2}}],[\"oldval\",{\"1\":{\"258\":1}}],[\"obj\",{\"1\":{\"258\":1}}],[\"objects\",{\"1\":{\"788\":1,\"992\":1}}],[\"object>>>\",{\"1\":{\"832\":1}}],[\"object>>\",{\"1\":{\"832\":1,\"849\":1}}],[\"object>\",{\"1\":{\"697\":1,\"747\":1,\"748\":1,\"749\":1,\"752\":1,\"754\":2,\"755\":1,\"757\":1,\"777\":1,\"779\":1,\"780\":1,\"783\":2,\"819\":1,\"832\":2}}],[\"object的wait\",{\"1\":{\"265\":1}}],[\"object类\",{\"1\":{\"235\":1}}],[\"object\",{\"1\":{\"67\":2,\"219\":2,\"221\":2,\"229\":2,\"244\":1,\"258\":5,\"333\":2,\"452\":1,\"515\":1,\"604\":1,\"832\":1,\"997\":1}}],[\"overlay2占用过大\",{\"0\":{\"579\":1}}],[\"override\",{\"1\":{\"241\":1,\"673\":1,\"762\":1,\"765\":3,\"788\":2}}],[\"over\",{\"1\":{\"235\":1}}],[\"overflow\",{\"1\":{\"120\":1,\"450\":1}}],[\"o\",{\"1\":{\"186\":2,\"189\":4,\"190\":4,\"194\":2,\"229\":5,\"231\":1,\"252\":2,\"258\":1,\"308\":1,\"931\":2,\"938\":1,\"948\":2,\"949\":2,\"957\":2,\"968\":3,\"969\":3,\"1029\":4,\"1030\":4,\"1040\":2}}],[\"oftype=\",{\"1\":{\"820\":1}}],[\"oflocalizeddate\",{\"1\":{\"573\":4}}],[\"ofpattern\",{\"1\":{\"573\":1}}],[\"offer\",{\"1\":{\"184\":1,\"983\":5,\"1024\":3}}],[\"office\",{\"1\":{\"110\":1,\"599\":7}}],[\"office插件地址\",{\"1\":{\"110\":1}}],[\"of\",{\"1\":{\"129\":1,\"239\":1,\"244\":1,\"367\":1,\"555\":1,\"559\":4,\"562\":5,\"568\":1,\"569\":1,\"573\":2,\"595\":1,\"975\":1,\"993\":1}}],[\"orangesrotting\",{\"1\":{\"943\":1,\"944\":1}}],[\"orange\",{\"1\":{\"736\":2,\"740\":1,\"741\":7,\"742\":7}}],[\"oracle官网对垃圾回收的描述\",{\"1\":{\"517\":1}}],[\"oracle官网\",{\"1\":{\"513\":1}}],[\"oracle表达了整合两大优秀虚拟机的工作\",{\"1\":{\"352\":1}}],[\"oracle\",{\"1\":{\"351\":1,\"410\":1,\"511\":1,\"628\":1,\"634\":1,\"827\":1}}],[\"oriented\",{\"1\":{\"596\":1}}],[\"origin后缀\",{\"1\":{\"106\":1}}],[\"orm\",{\"0\":{\"823\":1},\"1\":{\"591\":1,\"823\":2}}],[\"or\",{\"1\":{\"242\":1,\"847\":2,\"848\":2,\"851\":2,\"854\":1,\"975\":1}}],[\"orderbyasc\",{\"1\":{\"845\":1}}],[\"orderbydesc\",{\"1\":{\"845\":1}}],[\"order注解\",{\"1\":{\"687\":1}}],[\"ordered接口或者使用\",{\"1\":{\"687\":1}}],[\"order\",{\"1\":{\"194\":2,\"861\":2}}],[\"orders\",{\"1\":{\"194\":2}}],[\"org\",{\"1\":{\"78\":1,\"85\":5,\"605\":3,\"678\":1,\"687\":4,\"753\":4,\"754\":22,\"755\":4,\"757\":3,\"762\":17,\"768\":3,\"788\":1,\"831\":1,\"835\":1,\"836\":1,\"1006\":1}}],[\"other\",{\"1\":{\"42\":1,\"944\":1}}],[\"onhttp工具\",{\"1\":{\"879\":1}}],[\"once\",{\"1\":{\"827\":1}}],[\"one\",{\"1\":{\"822\":1,\"832\":1}}],[\"oneservice\",{\"1\":{\"617\":1}}],[\"only即可\",{\"1\":{\"1005\":1}}],[\"only\",{\"1\":{\"244\":1,\"577\":1}}],[\"onlyifabsent\",{\"1\":{\"242\":1}}],[\"on\",{\"1\":{\"42\":1,\"368\":1,\"410\":1,\"687\":2,\"990\":4,\"991\":2,\"992\":1,\"993\":1,\"996\":3}}],[\"outstandingmessagecount++\",{\"1\":{\"723\":1}}],[\"outstandingmessagecount\",{\"1\":{\"723\":4}}],[\"outmemoryerror\",{\"1\":{\"399\":1}}],[\"outofmemory\",{\"1\":{\"328\":1}}],[\"outofmemoryerror\",{\"1\":{\"301\":1,\"302\":2,\"303\":1,\"304\":1,\"305\":2,\"307\":1,\"308\":1,\"325\":1,\"338\":2,\"409\":1,\"442\":2,\"447\":1,\"448\":1,\"459\":1,\"462\":1,\"485\":1,\"519\":1}}],[\"outputfile\",{\"1\":{\"864\":1}}],[\"outputdir\",{\"1\":{\"864\":1}}],[\"outputdirectory>\",{\"1\":{\"99\":4,\"106\":1}}],[\"output\",{\"1\":{\"106\":2,\"308\":1}}],[\"out\",{\"1\":{\"6\":1,\"10\":1,\"201\":7,\"233\":4,\"234\":1,\"241\":1,\"317\":7,\"318\":6,\"319\":2,\"332\":3,\"381\":5,\"392\":1,\"416\":1,\"510\":2,\"548\":1,\"559\":2,\"562\":5,\"568\":1,\"569\":3,\"571\":2,\"573\":8,\"588\":1,\"605\":6,\"697\":1,\"698\":3,\"701\":4,\"708\":5,\"711\":2,\"712\":2,\"714\":3,\"717\":3,\"722\":2,\"723\":1,\"734\":2,\"738\":1,\"742\":1,\"747\":5,\"748\":3,\"749\":5,\"779\":3,\"780\":1,\"815\":2,\"853\":1,\"854\":1,\"858\":5,\"993\":1,\"996\":4,\"1024\":8}}],[\"还要注意\",{\"1\":{\"935\":1}}],[\"还要等待你好\",{\"1\":{\"755\":1}}],[\"还记得\",{\"1\":{\"730\":1}}],[\"还没有执行到\",{\"1\":{\"709\":1}}],[\"还需要调整slow的位置\",{\"1\":{\"974\":1}}],[\"还需要有会话和状态保持的功能\",{\"1\":{\"877\":1}}],[\"还需要对其进行封装\",{\"1\":{\"872\":1}}],[\"还需要注意的一点是\",{\"1\":{\"752\":1}}],[\"还需要修改配置\",{\"1\":{\"670\":1}}],[\"还需要记录数组的长度\",{\"1\":{\"476\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"535\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"535\":1}}],[\"还包含一个后进先出\",{\"1\":{\"416\":1}}],[\"还可能是指使用静态提前编译器\",{\"1\":{\"367\":1}}],[\"还可以设置优先级\",{\"1\":{\"843\":1}}],[\"还可以使用\",{\"1\":{\"464\":1}}],[\"还可以保存具有映射关系的数据\",{\"1\":{\"217\":1}}],[\"还可以进一步优化\",{\"1\":{\"202\":1}}],[\"还是\",{\"1\":{\"892\":1}}],[\"还是parallel\",{\"1\":{\"540\":1}}],[\"还是相对简单\",{\"1\":{\"464\":1}}],[\"还是内存溢出\",{\"1\":{\"450\":1}}],[\"还是会出现溢出\",{\"1\":{\"428\":1}}],[\"还是会存在其他问题比如数据丢失\",{\"1\":{\"247\":1}}],[\"还是完全采用即时编译器执行\",{\"1\":{\"371\":1}}],[\"还是比较准确的\",{\"1\":{\"359\":1}}],[\"还会使用一个含有\",{\"1\":{\"902\":1}}],[\"还会进行一项称为自旋锁的优化手段\",{\"1\":{\"278\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"274\":1}}],[\"还有duddo\",{\"1\":{\"898\":1}}],[\"还有mina\",{\"1\":{\"883\":1}}],[\"还有很多其他的标签\",{\"1\":{\"811\":1}}],[\"还有哪些标签\",{\"0\":{\"811\":1}}],[\"还有比如说\",{\"1\":{\"744\":1}}],[\"还有\",{\"1\":{\"435\":1,\"619\":1}}],[\"还有许多高级语言同样也是基于解释器执行的\",{\"1\":{\"363\":1}}],[\"还有常量池表\",{\"1\":{\"307\":1}}],[\"还有如下可能变化的结构\",{\"1\":{\"278\":1}}],[\"还有其他很多快捷功能\",{\"1\":{\"10\":1}}],[\"还自定义了下面4个\",{\"1\":{\"42\":1}}],[\"u\",{\"1\":{\"813\":1}}],[\"usr\",{\"1\":{\"756\":2}}],[\"usd\",{\"1\":{\"740\":1}}],[\"usefornull\",{\"1\":{\"990\":1,\"991\":1}}],[\"usessl=false\",{\"1\":{\"831\":1,\"866\":2}}],[\"usegeneratedkeys=\",{\"1\":{\"815\":1}}],[\"used\",{\"1\":{\"687\":2}}],[\"useurlfragment\",{\"1\":{\"668\":1}}],[\"useuniqueversions>\",{\"1\":{\"103\":1,\"106\":1}}],[\"useparalleloldgc\",{\"1\":{\"532\":1}}],[\"usetlab\",{\"1\":{\"471\":1}}],[\"usecounterdecay\",{\"1\":{\"369\":1}}],[\"use\",{\"1\":{\"129\":1,\"827\":1}}],[\"userssl=false\",{\"1\":{\"864\":1}}],[\"users\",{\"1\":{\"845\":1,\"852\":1,\"853\":2}}],[\"userserviceimpl\",{\"1\":{\"833\":1}}],[\"userservice\",{\"1\":{\"833\":2}}],[\"userselectuser\",{\"1\":{\"819\":1}}],[\"user>\",{\"1\":{\"833\":1}}],[\"usermapper\",{\"1\":{\"819\":1,\"844\":1,\"845\":1,\"846\":1,\"847\":1,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"853\":1,\"854\":1,\"858\":1}}],[\"userdetailsservice\",{\"1\":{\"788\":2}}],[\"usernamepasswordauthenticationfilter\",{\"1\":{\"788\":1}}],[\"username\",{\"1\":{\"651\":3,\"753\":1,\"754\":3,\"762\":1,\"765\":1,\"819\":5,\"831\":1,\"837\":1,\"840\":1,\"844\":1,\"847\":2,\"848\":2,\"849\":2,\"850\":1,\"851\":1,\"852\":3,\"853\":3,\"866\":2}}],[\"userid\",{\"1\":{\"651\":3}}],[\"user\",{\"1\":{\"41\":1,\"42\":1,\"381\":1,\"651\":3,\"788\":1,\"819\":3,\"820\":3,\"840\":2,\"847\":8,\"848\":8,\"849\":1,\"850\":3,\"851\":2,\"852\":1,\"853\":3,\"854\":11,\"864\":1,\"1001\":1,\"1007\":1}}],[\"uuid\",{\"1\":{\"722\":2,\"723\":2,\"773\":1,\"836\":1}}],[\"uriencoding=\",{\"1\":{\"649\":2}}],[\"url中可以通过一个或多个\",{\"1\":{\"651\":1}}],[\"urlclassloader\",{\"1\":{\"387\":1}}],[\"url\",{\"1\":{\"143\":1,\"649\":1,\"651\":1,\"788\":1,\"831\":1,\"866\":2,\"889\":3,\"890\":1,\"1008\":1,\"1009\":3}}],[\"url>\",{\"1\":{\"61\":1}}],[\"utils\",{\"1\":{\"701\":3,\"708\":2,\"711\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"779\":2}}],[\"util\",{\"1\":{\"233\":1,\"234\":1,\"555\":1,\"697\":1,\"698\":1,\"701\":3,\"708\":1,\"711\":1,\"722\":2,\"723\":2,\"734\":2,\"738\":3,\"742\":3,\"747\":7,\"754\":4,\"755\":2,\"757\":1,\"779\":2,\"982\":1,\"983\":1}}],[\"util包下的date和calendar类不支持时区\",{\"1\":{\"555\":1}}],[\"util包下\",{\"1\":{\"225\":1}}],[\"utf\",{\"1\":{\"18\":1,\"19\":1,\"649\":5,\"685\":1,\"708\":1,\"711\":1,\"712\":1,\"729\":1,\"734\":1,\"742\":1,\"747\":2,\"748\":1,\"749\":2}}],[\"upper\",{\"1\":{\"1029\":7}}],[\"uploads\",{\"1\":{\"1038\":1}}],[\"upload\",{\"1\":{\"160\":1,\"1038\":1}}],[\"updatewrapper<>\",{\"1\":{\"851\":1}}],[\"updatewrapper<user>\",{\"1\":{\"851\":1}}],[\"updatewrapper\",{\"0\":{\"851\":1},\"1\":{\"832\":1,\"842\":1,\"851\":3,\"854\":3}}],[\"updatebyid\",{\"1\":{\"832\":1}}],[\"update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行minorgc\",{\"1\":{\"504\":1}}],[\"update24之后\",{\"1\":{\"504\":1}}],[\"update\",{\"1\":{\"148\":1,\"827\":1,\"832\":1,\"840\":1,\"842\":1,\"847\":2,\"848\":2,\"851\":2,\"854\":1,\"860\":1}}],[\"uzerme\",{\"1\":{\"148\":1}}],[\"uid\",{\"1\":{\"836\":2}}],[\"ui组件库\",{\"0\":{\"157\":1}}],[\"ui\",{\"0\":{\"156\":1},\"1\":{\"139\":2,\"140\":1,\"143\":1,\"147\":1,\"156\":1,\"157\":2,\"711\":1,\"788\":1}}],[\"uigradients\",{\"1\":{\"139\":1,\"140\":1}}],[\"uimovement\",{\"1\":{\"139\":1}}],[\"uncommitted\",{\"1\":{\"634\":2}}],[\"unable\",{\"1\":{\"588\":1}}],[\"undertow<\",{\"1\":{\"679\":1}}],[\"undefned\",{\"1\":{\"399\":1}}],[\"undraw\",{\"1\":{\"139\":2}}],[\"unlock\",{\"1\":{\"285\":1}}],[\"unix\",{\"1\":{\"340\":1}}],[\"unit\",{\"1\":{\"282\":1,\"335\":3,\"336\":2}}],[\"unicode\",{\"1\":{\"143\":1}}],[\"unsee\",{\"1\":{\"143\":1}}],[\"unsplash\",{\"1\":{\"139\":1}}],[\"unpkg\",{\"1\":{\"135\":1}}],[\"会进行回溯\",{\"1\":{\"1034\":1}}],[\"会把右孩子加入res\",{\"1\":{\"1034\":1}}],[\"会显得杂乱无章\",{\"1\":{\"919\":1}}],[\"会产生警告\",{\"1\":{\"918\":1}}],[\"会产生大量的对象\",{\"1\":{\"525\":1}}],[\"会读取到spring默认的一些schema以及dubbo自定义的schema\",{\"1\":{\"908\":1}}],[\"会调用serviceconfig的export方法\",{\"1\":{\"904\":1}}],[\"会调用这个方法\",{\"1\":{\"619\":1}}],[\"会通过\",{\"1\":{\"889\":1}}],[\"会根据配置参数组装成\",{\"1\":{\"889\":1}}],[\"会拦截接口方法\",{\"1\":{\"816\":1}}],[\"会引起sql注入\",{\"1\":{\"814\":1}}],[\"会遍历传入的map\",{\"1\":{\"789\":1}}],[\"会扫描到所有匹配的接口\",{\"1\":{\"789\":1}}],[\"会直接在上方返回\",{\"1\":{\"1034\":1}}],[\"会直接给消息生产者发送确认消息\",{\"1\":{\"764\":1}}],[\"会直接使用你给定的大小\",{\"1\":{\"239\":1}}],[\"会报错\",{\"1\":{\"756\":1}}],[\"会报异常java\",{\"1\":{\"447\":1}}],[\"会导致消费者连接节点的内存消耗变大\",{\"1\":{\"717\":1}}],[\"会导致暂停时间太长\",{\"1\":{\"349\":1}}],[\"会优先分配给其他已经处理完消息或者空闲的工作队列\",{\"1\":{\"714\":1}}],[\"会看到如下结果\",{\"1\":{\"714\":1}}],[\"会发生什么情况\",{\"1\":{\"704\":1}}],[\"会影响性能的\",{\"1\":{\"653\":1}}],[\"会影响其他内存结构的正常使用\",{\"1\":{\"429\":1}}],[\"会将\",{\"1\":{\"810\":1}}],[\"会将内存中的消息换页至磁盘中\",{\"1\":{\"782\":1}}],[\"会将该消息返回给生产者\",{\"1\":{\"765\":1}}],[\"会将流扁平化\",{\"1\":{\"549\":1}}],[\"会将其存入字符串常量池\",{\"1\":{\"317\":1}}],[\"会将其扩充为\",{\"1\":{\"239\":1}}],[\"会在filter方法返回的偶数流中\",{\"1\":{\"548\":1}}],[\"会在常量池内创建一个\",{\"1\":{\"319\":1}}],[\"会使得垃圾回收的总体成本上升\",{\"1\":{\"526\":1}}],[\"会使用jdkdynamicaopproxy来创建代理\",{\"1\":{\"603\":1}}],[\"会使用即时编译技术\",{\"1\":{\"365\":1}}],[\"会使用启动类加载器\",{\"1\":{\"332\":1}}],[\"会做什么事情\",{\"1\":{\"518\":1}}],[\"会变成\",{\"1\":{\"510\":1}}],[\"会和\",{\"1\":{\"493\":1}}],[\"会有返回值传递给上层的方法调用者\",{\"1\":{\"424\":1}}],[\"会很频繁的使用到动态分派\",{\"1\":{\"423\":1}}],[\"会被解析为\",{\"1\":{\"822\":1}}],[\"会被静态替换为com\",{\"1\":{\"810\":1}}],[\"会被引导类加载器加载\",{\"1\":{\"393\":1}}],[\"会被编译器当做常量来处理\",{\"1\":{\"317\":1}}],[\"会返回一个空流\",{\"1\":{\"548\":1}}],[\"会返回\",{\"1\":{\"381\":1}}],[\"会先根据配置参数组装成\",{\"1\":{\"890\":1}}],[\"会先尝试触发minorgc\",{\"1\":{\"495\":1}}],[\"会先检查该方法是否存在被jit编译过的版本\",{\"1\":{\"369\":1}}],[\"会先计算对象的hashcode值来判断对象加入的位置\",{\"1\":{\"242\":1}}],[\"会创建\",{\"1\":{\"319\":1,\"890\":1}}],[\"会受到方法区内存的限制\",{\"1\":{\"307\":1}}],[\"会升级为轻量级锁\",{\"1\":{\"278\":1}}],[\"会涉及到一些cas操作\",{\"1\":{\"278\":1}}],[\"会释放当前的锁\",{\"1\":{\"273\":1}}],[\"会假设对象没有重复出现\",{\"1\":{\"242\":1}}],[\"会默认在将指定的元素追加到此列表的末尾\",{\"1\":{\"229\":1}}],[\"会自动扩增容量的array\",{\"1\":{\"228\":1}}],[\"会造成代码调试比较麻烦\",{\"1\":{\"904\":1}}],[\"会造成阻塞\",{\"1\":{\"292\":1}}],[\"会造成元素之间会形成一个循环链表\",{\"1\":{\"247\":1}}],[\"会造成数据溢出的错误\",{\"1\":{\"228\":1}}],[\"会造成内存浪费\",{\"1\":{\"228\":1}}],[\"会去$\",{\"1\":{\"106\":1}}],[\"会查找包内第一个含有main\",{\"1\":{\"106\":1}}],[\"会出现什么问题呢\",{\"1\":{\"837\":1}}],[\"会出现异常\",{\"1\":{\"566\":1}}],[\"会出现\",{\"1\":{\"41\":1}}],[\"会输入system\",{\"1\":{\"10\":1}}],[\"其表结构相同\",{\"1\":{\"861\":1}}],[\"其每个子元素会被解析为\",{\"1\":{\"822\":2}}],[\"其存储作用域为\",{\"1\":{\"813\":1}}],[\"其执行原理为\",{\"1\":{\"812\":1}}],[\"其二在发布消息成功后使用\",{\"1\":{\"762\":1}}],[\"其一效果和\",{\"1\":{\"762\":1}}],[\"其通道已关闭\",{\"1\":{\"707\":1}}],[\"其工作原理是\",{\"1\":{\"648\":1}}],[\"其作用是进行解析操作\",{\"1\":{\"646\":1}}],[\"其作用是执行相关的请求处理逻辑\",{\"1\":{\"646\":1}}],[\"其作用是根据映射器处理器找到的处理器信息\",{\"1\":{\"646\":1}}],[\"其作用是根据请求的url路径\",{\"1\":{\"646\":1}}],[\"其作用是接收用户请求\",{\"1\":{\"646\":1}}],[\"其代理对象必须是某个接口的实现\",{\"1\":{\"603\":1}}],[\"其团队也参与了java\",{\"1\":{\"574\":1}}],[\"其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗\",{\"1\":{\"511\":1}}],[\"其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小\",{\"1\":{\"485\":1}}],[\"其空间大小也就确定了\",{\"1\":{\"482\":1}}],[\"其默认的\",{\"1\":{\"448\":1}}],[\"其返回值将会被压入当前栈帧的操作数栈中\",{\"1\":{\"416\":1}}],[\"其余行为\",{\"1\":{\"531\":1}}],[\"其余的字节码指令将操作数取出栈\",{\"1\":{\"416\":1}}],[\"其余位置上的元素都是由上方的元素以及上方左侧的元素相加得到的\",{\"1\":{\"201\":1}}],[\"其所需的最大深度在编译期就定义好了\",{\"1\":{\"416\":1}}],[\"其内部保存一个个的栈帧\",{\"1\":{\"407\":1}}],[\"其内部是基于\",{\"1\":{\"220\":1}}],[\"其后所有的类加载器都继承自\",{\"1\":{\"388\":1}}],[\"其区别是物理机的执行引擎是直接建立在处理器\",{\"1\":{\"355\":1}}],[\"其最主要的原因是它很难解决对象之间相互循环引用的问题\",{\"1\":{\"321\":1}}],[\"其效果就相当于访问常量\",{\"1\":{\"317\":1}}],[\"其次就是rpc框架一般都有注册中心\",{\"1\":{\"872\":1}}],[\"其次一旦我们断开了消费者的连接\",{\"1\":{\"730\":1}}],[\"其次\",{\"1\":{\"280\":2}}],[\"其主要结构是由mark\",{\"1\":{\"278\":1}}],[\"其中n表示字符串的长度\",{\"1\":{\"957\":1}}],[\"其中n是数组orders的长度\",{\"1\":{\"194\":2}}],[\"其中交换机类型时\",{\"1\":{\"762\":1}}],[\"其中我的版本是\",{\"1\":{\"756\":1}}],[\"其中一个消费者接收到消息后把日志存储在磁盘\",{\"1\":{\"734\":1}}],[\"其中一维代表\",{\"1\":{\"207\":1}}],[\"其中启动两个消费者\",{\"1\":{\"734\":1}}],[\"其中有两个替换符是大家需要注意的\",{\"1\":{\"740\":1}}],[\"其中有个消费者\",{\"1\":{\"714\":1}}],[\"其中有些对象是与业务信息相关\",{\"1\":{\"525\":1}}],[\"其中invocationhandler只是一个接口\",{\"1\":{\"603\":1}}],[\"其中创新的gcih\",{\"1\":{\"505\":1}}],[\"其中又分为\",{\"1\":{\"493\":1}}],[\"其中年轻代又可以划分为\",{\"1\":{\"488\":1}}],[\"其中的栈指的就是操作数栈\",{\"1\":{\"416\":1}}],[\"其中栈就是现在说的虚拟机栈\",{\"1\":{\"302\":1}}],[\"其中等待的另外5个人中又有一个人可以占用了\",{\"1\":{\"292\":1}}],[\"其中mark\",{\"1\":{\"278\":1}}],[\"其中\",{\"1\":{\"203\":1,\"317\":1,\"483\":1,\"811\":1,\"926\":1,\"940\":1,\"948\":1,\"949\":1,\"974\":1,\"1029\":2,\"1030\":2}}],[\"其比较规则相反\",{\"1\":{\"194\":1}}],[\"其他类型的算法题总结\",{\"1\":{\"987\":1}}],[\"其他类型\",{\"0\":{\"987\":1}}],[\"其他类加载器均由\",{\"1\":{\"331\":1}}],[\"其他所有请求都需要认证\",{\"1\":{\"788\":1}}],[\"其他所有程序都执行结束后我再执行\",{\"1\":{\"292\":1}}],[\"其他可能没有\",{\"1\":{\"765\":1}}],[\"其他消息类型的消息将被丢弃\",{\"1\":{\"736\":1}}],[\"其他的参数信息\",{\"1\":{\"697\":1}}],[\"其他的虚拟机实现并没有永久代这一说法\",{\"1\":{\"305\":1}}],[\"其他参数\",{\"1\":{\"697\":1}}],[\"其他相关类\",{\"0\":{\"567\":1}}],[\"其他工具类\",{\"0\":{\"574\":1}}],[\"其他工具\",{\"0\":{\"513\":1}}],[\"其他方法\",{\"1\":{\"765\":1}}],[\"其他方法称为虚方法\",{\"1\":{\"421\":1}}],[\"其他方法都是直接调用\",{\"1\":{\"240\":1}}],[\"其他使用java类的方式都被看作是对类的被动使用\",{\"1\":{\"397\":1}}],[\"其他平台上还是classic\",{\"1\":{\"350\":1}}],[\"其他段的数据也能被其他线程访问\",{\"1\":{\"251\":1}}],[\"其他线程也访问同步方法\",{\"1\":{\"249\":1}}],[\"其他\",{\"0\":{\"138\":1,\"161\":1,\"394\":1,\"540\":1,\"570\":1,\"986\":1,\"994\":1}}],[\"其他版本慎用\",{\"1\":{\"114\":1}}],[\"其他属性含义见官网\",{\"1\":{\"103\":1}}],[\"其他配置\",{\"0\":{\"41\":1}}],[\"其实比普通的配置文件就多了一个标签\",{\"1\":{\"911\":1}}],[\"其实netty内部是封装了socket的\",{\"1\":{\"872\":1}}],[\"其实是\",{\"1\":{\"731\":1}}],[\"其实是一段\",{\"1\":{\"367\":1}}],[\"其实说白了springboot的自动配置\",{\"1\":{\"674\":1}}],[\"其实会转换成一个个\",{\"1\":{\"612\":1}}],[\"其实每个jvm\",{\"1\":{\"498\":1}}],[\"其实不分代完全可以\",{\"1\":{\"497\":1}}],[\"其实不然\",{\"1\":{\"464\":1}}],[\"其实叫\",{\"1\":{\"367\":1}}],[\"其实就是\",{\"1\":{\"674\":1}}],[\"其实就是dp\",{\"1\":{\"207\":1}}],[\"其实就是求子数组最大和\",{\"1\":{\"187\":1}}],[\"其实学习\",{\"1\":{\"69\":1}}],[\"其实还有一个国内的中文站\",{\"1\":{\"35\":1}}],[\"全名\",{\"1\":{\"452\":1}}],[\"全称\",{\"1\":{\"353\":1}}],[\"全面的java运行时解决方案组合\",{\"1\":{\"352\":1}}],[\"全部置为1\",{\"1\":{\"925\":1}}],[\"全部代码都靠即时编译器编译后执行\",{\"1\":{\"352\":1}}],[\"全部勾选\",{\"1\":{\"40\":1}}],[\"全是干货\",{\"1\":{\"262\":1}}],[\"全历史\",{\"1\":{\"148\":1}}],[\"全球排名\",{\"1\":{\"127\":1}}],[\"全选\",{\"1\":{\"45\":1}}],[\"全局搜索内容\",{\"1\":{\"6\":1}}],[\"进阶\",{\"1\":{\"967\":1}}],[\"进而无法接收新的消息\",{\"1\":{\"782\":1}}],[\"进而影响分配速度\",{\"1\":{\"501\":1}}],[\"进而函数调用就会占用更多的栈空间\",{\"1\":{\"415\":1}}],[\"进而它将允许自旋等待持续相对更长的时间\",{\"1\":{\"278\":1}}],[\"进程id\",{\"1\":{\"487\":1,\"503\":1}}],[\"进程的启动类\",{\"1\":{\"340\":1}}],[\"进程是指在系统中正在运行的一个应用程序\",{\"1\":{\"264\":1}}],[\"进一步封装\",{\"1\":{\"833\":1}}],[\"进一步获取其类型\",{\"1\":{\"789\":1}}],[\"进一步划分的目的是更好地回收内存\",{\"1\":{\"304\":1}}],[\"进一步优化\",{\"1\":{\"202\":1}}],[\"进行跟左右操作\",{\"1\":{\"1024\":1}}],[\"进行3个判断\",{\"1\":{\"1019\":1}}],[\"进行操作\",{\"1\":{\"982\":1}}],[\"进行感染\",{\"1\":{\"944\":1}}],[\"进行改造和优化\",{\"1\":{\"776\":1}}],[\"进行消费\",{\"1\":{\"744\":1}}],[\"进行了绑定\",{\"1\":{\"731\":1}}],[\"进行标识的交换机是默认交换\",{\"1\":{\"729\":1}}],[\"进行连接的时候\",{\"1\":{\"695\":1}}],[\"进行通讯\",{\"1\":{\"693\":1}}],[\"进行使用\",{\"1\":{\"675\":1}}],[\"进行养老区的内存清理\",{\"1\":{\"490\":1}}],[\"进行查找对应的\",{\"1\":{\"470\":1}}],[\"进行\",{\"1\":{\"431\":1,\"697\":1}}],[\"进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的\",{\"1\":{\"369\":1}}],[\"进行get\",{\"1\":{\"280\":1}}],[\"进行自定义打包\",{\"1\":{\"99\":1}}],[\"进行上传\",{\"1\":{\"39\":1}}],[\"进入官网后点击4\",{\"1\":{\"1005\":1}}],[\"进入dfs进行递归传染\",{\"1\":{\"943\":1}}],[\"进入拦截器方法\",{\"1\":{\"821\":1}}],[\"进入目录后执行下面命令让该插件生效\",{\"1\":{\"756\":1}}],[\"进入自己的\",{\"1\":{\"702\":1}}],[\"进入handler方法之后\",{\"1\":{\"656\":1}}],[\"进入\",{\"1\":{\"656\":1,\"777\":1}}],[\"进入bash或弹出的记事本后直接退出\",{\"1\":{\"585\":1}}],[\"进入build\",{\"1\":{\"15\":1}}],[\"进入等待状态\",{\"1\":{\"273\":1}}],[\"进入editor\",{\"1\":{\"16\":1}}],[\"配合以hession序列化完成\",{\"1\":{\"887\":1}}],[\"配合jwt使用时\",{\"1\":{\"787\":1}}],[\"配合工作\",{\"1\":{\"531\":1}}],[\"配合\",{\"1\":{\"39\":1}}],[\"配置阿里云镜像\",{\"0\":{\"1008\":1}}],[\"配置阿里云提供的镜像仓库\",{\"1\":{\"61\":1}}],[\"配置环境变量及仓库地址\",{\"0\":{\"1007\":1}}],[\"配置层\",{\"1\":{\"883\":1}}],[\"配置数据源信息\",{\"1\":{\"866\":1}}],[\"配置数据源和日志\",{\"0\":{\"831\":1}}],[\"配置mybatis\",{\"1\":{\"835\":1,\"836\":2}}],[\"配置mybatis日志\",{\"1\":{\"835\":1,\"836\":1}}],[\"配置maven工程的基础jdk版本\",{\"1\":{\"61\":1}}],[\"配置maven本地仓库的存放位置\",{\"1\":{\"61\":1}}],[\"配置日志\",{\"1\":{\"831\":1}}],[\"配置好插件之后\",{\"1\":{\"827\":1}}],[\"配置信息都封装到\",{\"1\":{\"822\":1}}],[\"配置起来\",{\"1\":{\"806\":1}}],[\"配置类中添加乐观锁插件\",{\"1\":{\"860\":1}}],[\"配置类别名\",{\"1\":{\"831\":1}}],[\"配置类文件开启\",{\"1\":{\"764\":1}}],[\"配置类\",{\"1\":{\"754\":1,\"762\":1,\"768\":2}}],[\"配置类代码\",{\"1\":{\"754\":1,\"757\":1,\"780\":1}}],[\"配置参数现在是\",{\"1\":{\"697\":2}}],[\"配置参数\",{\"1\":{\"697\":2,\"702\":3}}],[\"配置参考\",{\"1\":{\"634\":1,\"635\":1}}],[\"配置文件中\",{\"1\":{\"821\":1}}],[\"配置文件\",{\"1\":{\"683\":1}}],[\"配置文件就是\",{\"1\":{\"69\":1}}],[\"配置新生代与老年代在堆结构的占比\",{\"1\":{\"488\":1,\"503\":1}}],[\"配置中可以指定编译时的java版本\",{\"1\":{\"101\":1}}],[\"配置聚合之后\",{\"1\":{\"90\":1}}],[\"配置方式\",{\"0\":{\"83\":1}}],[\"配置依赖信息\",{\"1\":{\"70\":1}}],[\"配置\",{\"0\":{\"866\":1},\"1\":{\"15\":1,\"99\":1,\"114\":1,\"617\":1,\"827\":1,\"890\":1}}],[\"字面意思可以这样理解\",{\"1\":{\"744\":1}}],[\"字面量比较接近\",{\"1\":{\"464\":1}}],[\"字面量和符号引用\",{\"1\":{\"464\":1}}],[\"字面量等类型\",{\"1\":{\"458\":1}}],[\"字节跳动\",{\"1\":{\"465\":1,\"518\":1}}],[\"字节码验证\",{\"1\":{\"379\":1}}],[\"字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令\",{\"1\":{\"399\":1}}],[\"字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令\",{\"1\":{\"301\":1}}],[\"字节码解释器在执行时通过纯软件代码模拟字节码的执行\",{\"1\":{\"362\":1}}],[\"字节码文件\",{\"1\":{\"343\":1,\"456\":1}}],[\"字段的名称和描述符\",{\"1\":{\"464\":1}}],[\"字段的升序来排列了\",{\"1\":{\"241\":1}}],[\"字段引用\",{\"1\":{\"458\":1}}],[\"字段和方法数据\",{\"1\":{\"441\":1}}],[\"字段\",{\"1\":{\"307\":1,\"379\":1,\"461\":1,\"597\":1}}],[\"字符串类的算法题总结\",{\"1\":{\"960\":1,\"977\":1}}],[\"字符串长度在\",{\"1\":{\"953\":1}}],[\"字符串aabcccccaaa会变为a2b1c5a3\",{\"1\":{\"953\":1}}],[\"字符串压缩\",{\"0\":{\"952\":1},\"1\":{\"953\":1}}],[\"字符串值\",{\"1\":{\"458\":1}}],[\"字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池\",{\"1\":{\"317\":1}}],[\"字符串常量池\",{\"0\":{\"463\":1},\"1\":{\"317\":1,\"461\":1,\"519\":1}}],[\"字符串常量池被从方法区拿到了堆中\",{\"1\":{\"307\":1,\"317\":1,\"318\":1,\"343\":1}}],[\"字符串\",{\"0\":{\"174\":1,\"959\":1,\"960\":1},\"1\":{\"185\":1,\"319\":2,\"777\":1},\"2\":{\"956\":1,\"958\":1}}],[\"字符集等等\",{\"1\":{\"70\":1}}],[\"字符集编码等\",{\"1\":{\"14\":1}}],[\"字号改为16px\",{\"1\":{\"38\":1}}],[\"侧边栏\",{\"1\":{\"38\":1}}],[\"恢复\",{\"1\":{\"37\":1}}],[\"自然不会存在线程安全问题\",{\"1\":{\"638\":1}}],[\"自身需要的类\",{\"1\":{\"382\":1}}],[\"自旋很少成功获得过\",{\"1\":{\"278\":1}}],[\"自旋等待刚刚成功获得过锁\",{\"1\":{\"278\":1}}],[\"自旋锁\",{\"0\":{\"278\":1},\"1\":{\"278\":1}}],[\"自适应自旋假定不同线程持有同一个锁对象的时间基本相当\",{\"1\":{\"278\":1}}],[\"自适应自旋解决的是\",{\"1\":{\"278\":1}}],[\"自适应自旋锁\",{\"1\":{\"278\":1}}],[\"自适应意味着自旋的时间不再固定了\",{\"1\":{\"278\":1}}],[\"自动生成的键值在\",{\"1\":{\"815\":1}}],[\"自动应答\",{\"0\":{\"705\":1}}],[\"自动删除\",{\"1\":{\"697\":2,\"702\":1}}],[\"自动化的插件配置\",{\"1\":{\"685\":1}}],[\"自动化的资源过滤\",{\"1\":{\"685\":1}}],[\"自动重新启动应用程序\",{\"1\":{\"670\":1}}],[\"自动注入的策略就从\",{\"1\":{\"599\":1}}],[\"自动内存管理机制\",{\"1\":{\"517\":1}}],[\"自动内存管理\",{\"1\":{\"517\":1}}],[\"自动醒来\",{\"1\":{\"273\":1}}],[\"自动导入\",{\"0\":{\"7\":1}}],[\"自己尝试后ac了\",{\"1\":{\"957\":1}}],[\"自己不得不实现之外\",{\"1\":{\"240\":1}}],[\"自己的\",{\"1\":{\"85\":1}}],[\"自平衡的排序二叉树\",{\"1\":{\"220\":1,\"222\":1}}],[\"自定义的mapper接口继承这个接口\",{\"1\":{\"832\":1}}],[\"自定义负载均衡\",{\"0\":{\"799\":1}}],[\"自定义接口\",{\"0\":{\"790\":1}}],[\"自定义匿名访问所有url放行\",{\"1\":{\"788\":1}}],[\"自定义交换机的类型\",{\"1\":{\"757\":1}}],[\"自定义交换机\",{\"1\":{\"757\":1}}],[\"自定义starter\",{\"1\":{\"684\":1}}],[\"自定义实现spring的全局异常解析器handlerexceptionresolver\",{\"1\":{\"650\":1}}],[\"自定义类\",{\"1\":{\"393\":2}}],[\"自定义类加载器一般指的是程序中开发人员自定义的一类类加载器\",{\"1\":{\"381\":1}}],[\"自定义java\",{\"1\":{\"392\":1}}],[\"自定义一个可运行jar名称\",{\"1\":{\"104\":1}}],[\"自定义打包的插件\",{\"0\":{\"99\":1}}],[\"自用设置\",{\"0\":{\"36\":1}}],[\"注册等功能\",{\"1\":{\"919\":1}}],[\"注册层\",{\"1\":{\"883\":1}}],[\"注册中心会每5秒定时检查是否有服务更新\",{\"1\":{\"906\":1}}],[\"注册中心不需要任何中心节点\",{\"1\":{\"897\":1}}],[\"注册中心基于接口名查询服务提供者的ip地址\",{\"1\":{\"884\":1}}],[\"注册中心\",{\"1\":{\"878\":1,\"882\":1}}],[\"注入属性时发现依赖a\",{\"1\":{\"621\":1}}],[\"注释掉distributionurl=https\",{\"1\":{\"1006\":1}}],[\"注释指定注入\",{\"1\":{\"599\":1}}],[\"注释的翻译如下\",{\"1\":{\"230\":1}}],[\"注解的\",{\"1\":{\"676\":1}}],[\"注解的自定义性更强\",{\"1\":{\"617\":1}}],[\"注解\",{\"1\":{\"673\":1,\"819\":1,\"835\":1,\"866\":1}}],[\"注解实现将\",{\"1\":{\"651\":1}}],[\"注解实现接收\",{\"1\":{\"651\":1}}],[\"注解进行查找\",{\"1\":{\"642\":1}}],[\"注解标注\",{\"1\":{\"618\":1}}],[\"注解自动装配的\",{\"1\":{\"618\":1}}],[\"注解自动装配\",{\"1\":{\"618\":1}}],[\"注解来注册\",{\"1\":{\"617\":1}}],[\"注解比\",{\"1\":{\"617\":1}}],[\"注解通常是我们在标有该注解的方法中定义产生这个\",{\"1\":{\"617\":1}}],[\"注解定义要扫描的路径从中找出标识了需要装配的类自动装配到\",{\"1\":{\"617\":1}}],[\"注解作用于类\",{\"1\":{\"617\":1}}],[\"注解注入\",{\"1\":{\"597\":1}}],[\"注解配置就慢慢开始流行起来\",{\"1\":{\"595\":1}}],[\"注解即可\",{\"1\":{\"595\":1}}],[\"注解annotation\",{\"1\":{\"452\":1}}],[\"注\",{\"1\":{\"35\":1,\"305\":1,\"390\":1,\"422\":1,\"695\":1,\"717\":1,\"741\":1}}],[\"注意是开区间\",{\"1\":{\"1029\":1}}],[\"注意答案不应该是11\",{\"1\":{\"933\":1}}],[\"注意到有一些观点\",{\"1\":{\"511\":1}}],[\"注意上图中的加载器划分关系为包含关系\",{\"1\":{\"381\":1}}],[\"注意这是经验数据\",{\"1\":{\"278\":1}}],[\"注意list必须是有序的\",{\"1\":{\"258\":1}}],[\"注意事项\",{\"0\":{\"233\":1},\"1\":{\"777\":1}}],[\"注意双向链表和双向循环链表的区别\",{\"1\":{\"229\":1}}],[\"注意\",{\"1\":{\"14\":1,\"85\":1,\"114\":1,\"117\":1,\"155\":1,\"213\":1,\"493\":1,\"521\":1,\"528\":1,\"573\":1,\"711\":1,\"734\":1,\"748\":1,\"836\":1,\"859\":1,\"882\":1,\"929\":1,\"933\":1,\"997\":1,\"1038\":1}}],[\"执行最快\",{\"0\":{\"984\":1}}],[\"执行监听器方法\",{\"1\":{\"906\":1}}],[\"执行第二步\",{\"1\":{\"777\":1}}],[\"执行步骤\",{\"1\":{\"702\":1}}],[\"执行打包操作的配置\",{\"1\":{\"685\":1}}],[\"执行handler完成执行此方法\",{\"1\":{\"656\":1}}],[\"执行完后恢复事务\",{\"1\":{\"635\":1}}],[\"执行完内存回收后是否会在内存空间中产生内存碎片\",{\"1\":{\"490\":1}}],[\"执行postprocessafterinitialization\",{\"1\":{\"614\":1}}],[\"执行postprocessbeforeinitialization\",{\"1\":{\"614\":1}}],[\"执行指定的方法\",{\"1\":{\"614\":2}}],[\"执行afterpropertiesset\",{\"1\":{\"614\":1}}],[\"执行add\",{\"1\":{\"229\":1}}],[\"执行流水线\",{\"1\":{\"547\":1}}],[\"执行过程\",{\"1\":{\"523\":1}}],[\"执行垃圾回收的重点区域\",{\"1\":{\"482\":1}}],[\"执行实例化代码块\",{\"1\":{\"474\":1}}],[\"执行结束后的出栈工作\",{\"1\":{\"408\":1}}],[\"执行结果返回\",{\"1\":{\"816\":1}}],[\"执行结果\",{\"1\":{\"392\":1}}],[\"执行前会使用\",{\"1\":{\"810\":1}}],[\"执行前\",{\"1\":{\"380\":1}}],[\"执行效率高\",{\"1\":{\"365\":1}}],[\"执行引擎遇到任意一个方法返回的字节码指令\",{\"1\":{\"424\":1}}],[\"执行引擎运行的所有字节码指令只针对当前栈帧进行操作\",{\"1\":{\"413\":1}}],[\"执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在\",{\"1\":{\"356\":1}}],[\"执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于pc寄存器\",{\"1\":{\"356\":1}}],[\"执行引擎的工作过程\",{\"0\":{\"356\":1}}],[\"执行引擎是\",{\"1\":{\"355\":1}}],[\"执行引擎概述\",{\"0\":{\"355\":1}}],[\"执行引擎\",{\"0\":{\"354\":1},\"1\":{\"355\":1}}],[\"执行次数较多的\",{\"1\":{\"349\":1}}],[\"执行一个所谓的java程序的时候\",{\"1\":{\"346\":1}}],[\"执行java程序\",{\"1\":{\"346\":1}}],[\"执行时加载本地方法库\",{\"1\":{\"437\":1}}],[\"执行时\",{\"1\":{\"319\":1}}],[\"执行很多短期异步的小程序或者负载教轻的服务器\",{\"1\":{\"291\":1}}],[\"执行长期的任务\",{\"1\":{\"291\":1}}],[\"执行任何一个具体环节的操作\",{\"1\":{\"95\":1}}],[\"执行\",{\"0\":{\"72\":1,\"314\":1,\"346\":1,\"474\":1},\"1\":{\"99\":1,\"314\":1,\"525\":1,\"614\":1,\"774\":1}}],[\"执行mvn\",{\"1\":{\"63\":1}}],[\"执行du\",{\"1\":{\"32\":1}}],[\"执行选中内容\",{\"1\":{\"27\":1}}],[\"先压左后压右\",{\"1\":{\"1035\":1}}],[\"先考察右孩子\",{\"1\":{\"1034\":1}}],[\"先遍历该左子树的根节点\",{\"1\":{\"1024\":1}}],[\"先遍历根节点\",{\"1\":{\"1024\":1}}],[\"先序遍历的遍历顺序是\",{\"1\":{\"1024\":2}}],[\"先传入root\",{\"1\":{\"1023\":1}}],[\"先找到下一个节点赋值给tmp\",{\"1\":{\"970\":1}}],[\"先把fast右移n位\",{\"1\":{\"964\":1}}],[\"先把cur\",{\"1\":{\"957\":1}}],[\"先把sql合并\",{\"1\":{\"28\":1}}],[\"先拼\",{\"1\":{\"954\":1}}],[\"先计数后遍历\",{\"0\":{\"939\":1}}],[\"先排序后遍历\",{\"0\":{\"938\":1}}],[\"先注册自己的服务\",{\"1\":{\"906\":1}}],[\"先定义接口方法\",{\"1\":{\"859\":1}}],[\"先判断当前的节点值是否想等\",{\"1\":{\"1019\":1}}],[\"先判断当前订单是否为采购类\",{\"1\":{\"194\":1}}],[\"先判断该消息是否已消费过\",{\"1\":{\"773\":1}}],[\"先启动消费者\",{\"1\":{\"747\":1}}],[\"先启动两个消费者再启动生产者\",{\"1\":{\"734\":1}}],[\"先从概念解释上搞清楚这个定义\",{\"1\":{\"744\":1}}],[\"先发布一批消息然后一起确认可以极大地提高吞吐量\",{\"1\":{\"723\":1}}],[\"先创建好\",{\"1\":{\"696\":1}}],[\"先打印可用的时区id字符串\",{\"1\":{\"562\":1}}],[\"先来说说方法区内常量池之中主要存放的两大类常量\",{\"1\":{\"464\":1}}],[\"先进后出\",{\"1\":{\"413\":1}}],[\"先必须锁定该对象\",{\"1\":{\"288\":1}}],[\"先处理\",{\"1\":{\"207\":1}}],[\"先获取当前用户的数量和销售队列中第一个元素的数量的最小值\",{\"1\":{\"194\":1}}],[\"先安装被依赖的工程\",{\"1\":{\"90\":1}}],[\"先执行df\",{\"1\":{\"32\":1}}],[\"似乎没有批量执行sql的方法\",{\"1\":{\"28\":1}}],[\"似乎不能搜索中文\",{\"1\":{\"6\":1}}],[\"5的深度之和\",{\"1\":{\"1023\":1}}],[\"5的深度为1\",{\"1\":{\"1023\":1}}],[\"5的最大深度+1\",{\"1\":{\"1023\":1}}],[\"543\",{\"0\":{\"1021\":1}}],[\"50\",{\"1\":{\"933\":1}}],[\"50000\",{\"1\":{\"953\":1}}],[\"5000\",{\"1\":{\"752\":3}}],[\"5以上版本服务提供端口支持telnet命令连接服务\",{\"1\":{\"912\":1}}],[\"5及更旧版本或spring\",{\"1\":{\"792\":1}}],[\"5mb\",{\"1\":{\"784\":1}}],[\"59\",{\"1\":{\"768\":1}}],[\"59d04e29\",{\"1\":{\"343\":1}}],[\"58\",{\"1\":{\"754\":1}}],[\"572\",{\"0\":{\"1017\":1}}],[\"57\",{\"1\":{\"742\":1}}],[\"5672\",{\"1\":{\"695\":2,\"697\":1,\"753\":1,\"762\":1,\"765\":1}}],[\"5+\",{\"1\":{\"234\":1}}],[\"5<\",{\"1\":{\"65\":1,\"753\":1}}],[\"5\",{\"0\":{\"23\":1,\"77\":1,\"78\":1,\"91\":1,\"371\":1,\"431\":1,\"456\":1,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"474\":1,\"519\":1,\"525\":1},\"1\":{\"46\":1,\"65\":2,\"70\":1,\"184\":1,\"207\":2,\"286\":1,\"488\":1,\"533\":1,\"665\":1,\"668\":1,\"678\":1,\"697\":1,\"706\":3,\"717\":1,\"718\":1,\"753\":3,\"779\":2,\"792\":3,\"830\":1,\"863\":1,\"874\":1,\"876\":1,\"879\":1,\"902\":1,\"929\":3,\"937\":3,\"967\":1,\"970\":5,\"981\":2,\"1018\":2,\"1028\":3,\"1033\":2,\"1038\":4}}],[\"把当前元素弹出\",{\"1\":{\"1035\":1}}],[\"把n+y放入队列q中\",{\"1\":{\"983\":1}}],[\"把n+x放入队列q中\",{\"1\":{\"983\":1}}],[\"把处理过的这个状态加入到已经处理过的集合内\",{\"1\":{\"982\":1}}],[\"把slow指向节点4\",{\"1\":{\"974\":1}}],[\"把原来的头结点链到第二个节点之后\",{\"1\":{\"970\":1}}],[\"把cur赋给pre\",{\"1\":{\"957\":1}}],[\"把vis的第x为改为1\",{\"1\":{\"949\":1}}],[\"把值置为2\",{\"1\":{\"944\":1}}],[\"把字节序列恢复为对象的过程称为对象的反序列化\",{\"1\":{\"878\":2}}],[\"把字节码转变成机器码的过程\",{\"1\":{\"367\":1}}],[\"把消息写出到文件\",{\"1\":{\"734\":1}}],[\"把容器替换为jetty\",{\"1\":{\"679\":1}}],[\"把它的孩子节点压入\",{\"1\":{\"1035\":1}}],[\"把它们一个个封装起来\",{\"1\":{\"631\":1}}],[\"把它看作方法区的具体实现\",{\"1\":{\"304\":1,\"483\":1}}],[\"把b放入一级缓存\",{\"1\":{\"621\":1}}],[\"把a放入二级缓存\",{\"1\":{\"621\":1}}],[\"把应用从复杂的依赖关系中解放出来\",{\"1\":{\"595\":1}}],[\"把对象转换为字节序列的过程称为对象的序列化\",{\"1\":{\"878\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"314\":1,\"474\":1}}],[\"把对应的年月日时分秒等修改为想要的值\",{\"1\":{\"562\":1}}],[\"把方法引用dish\",{\"1\":{\"549\":1}}],[\"把内存化整为零\",{\"1\":{\"535\":1}}],[\"把内存分配的动作按照线程划分在不同的空间之中进行\",{\"1\":{\"471\":1}}],[\"把新创建的对象放到某一地方\",{\"1\":{\"497\":1}}],[\"把一些不会运行的代码折叠掉\",{\"1\":{\"372\":1}}],[\"把越来越多的代码编译成本地代码\",{\"1\":{\"365\":1}}],[\"把代码编译成本地代码\",{\"1\":{\"365\":1}}],[\"把这个虚引用加入到与之关联的引用队列中\",{\"1\":{\"328\":1}}],[\"把你的jar\",{\"1\":{\"105\":1}}],[\"把版本号去掉就表示子工程中这个依赖的版本由父工程决定\",{\"1\":{\"88\":1}}],[\"把markdown文件复制到idea或其他jetbrains系的ide内\",{\"1\":{\"55\":1}}],[\"把默认的谷歌替换为百度\",{\"1\":{\"41\":1}}],[\"把\",{\"1\":{\"21\":1,\"62\":1,\"82\":1,\"367\":1,\"693\":1,\"821\":1}}],[\"8808\",{\"1\":{\"753\":2,\"754\":1,\"755\":2,\"757\":2,\"762\":2,\"765\":2,\"768\":1}}],[\"8888\",{\"1\":{\"668\":2}}],[\"8192\",{\"1\":{\"649\":1}}],[\"81252106https\",{\"1\":{\"293\":1}}],[\"8环境下\",{\"1\":{\"537\":1}}],[\"8080\",{\"1\":{\"649\":1}}],[\"80\",{\"1\":{\"488\":1}}],[\"809c\",{\"1\":{\"388\":1}}],[\"80940110\",{\"1\":{\"289\":1}}],[\"8c02\",{\"1\":{\"483\":1}}],[\"8及更旧版本\",{\"1\":{\"792\":1}}],[\"8及之后\",{\"1\":{\"461\":1}}],[\"8及以后的版本使用\",{\"1\":{\"449\":1}}],[\"8及以上\",{\"1\":{\"104\":1}}],[\"8种基本数据类型\",{\"1\":{\"407\":1}}],[\"85a2\",{\"1\":{\"381\":1}}],[\"8中移除整个永久代\",{\"1\":{\"343\":1}}],[\"8之后jvm\",{\"1\":{\"343\":1}}],[\"8之前hotspot的实现方式是永久代\",{\"1\":{\"300\":1}}],[\"8之前的内部结构\",{\"1\":{\"244\":1}}],[\"8版本对它的\",{\"1\":{\"305\":1}}],[\"8区别\",{\"1\":{\"292\":1}}],[\"8<\",{\"1\":{\"61\":5,\"70\":1,\"99\":1,\"101\":2,\"649\":1}}],[\"8\",{\"0\":{\"92\":1,\"244\":1,\"245\":1,\"252\":1,\"528\":1,\"532\":1,\"540\":1},\"1\":{\"18\":1,\"19\":1,\"41\":1,\"49\":1,\"184\":1,\"222\":4,\"239\":3,\"244\":5,\"245\":3,\"247\":1,\"249\":7,\"252\":3,\"253\":3,\"300\":1,\"304\":2,\"305\":1,\"307\":1,\"338\":2,\"339\":1,\"442\":1,\"532\":1,\"534\":1,\"537\":1,\"540\":1,\"549\":1,\"636\":1,\"649\":5,\"678\":1,\"685\":2,\"696\":1,\"706\":3,\"708\":1,\"711\":1,\"712\":1,\"717\":1,\"729\":1,\"734\":1,\"742\":1,\"747\":2,\"748\":1,\"749\":2,\"756\":3,\"831\":1,\"864\":1,\"866\":2,\"874\":1,\"957\":1,\"1003\":1,\"1038\":1}}],[\"新格子\",{\"1\":{\"944\":2}}],[\"新坐标还在格子里面\",{\"1\":{\"943\":1}}],[\"新版\",{\"1\":{\"764\":1}}],[\"新版本的日期\",{\"1\":{\"573\":1}}],[\"新创建的店铺\",{\"1\":{\"751\":1}}],[\"新创建一个\",{\"1\":{\"685\":1}}],[\"新的时区类java\",{\"1\":{\"555\":1}}],[\"新的高水位线的值取决于gc后释放了多少元空间\",{\"1\":{\"448\":1}}],[\"新增一个配置类\",{\"1\":{\"757\":1}}],[\"新增一个配置文件类\",{\"1\":{\"755\":1}}],[\"新增方法\",{\"1\":{\"755\":1}}],[\"新增\",{\"1\":{\"534\":1}}],[\"新生代采用标记\",{\"1\":{\"530\":1,\"531\":1}}],[\"新生代1\",{\"1\":{\"503\":1}}],[\"新生代收集\",{\"1\":{\"493\":1}}],[\"新生代中\",{\"1\":{\"488\":1}}],[\"新生代中为什么要分为\",{\"1\":{\"465\":1}}],[\"新生代占整个堆的1\",{\"1\":{\"488\":2}}],[\"新生代占整个堆栈的\",{\"1\":{\"337\":1}}],[\"新生代+老年代+元空间\",{\"1\":{\"483\":1}}],[\"新生代+老年代+永久区\",{\"1\":{\"483\":1}}],[\"新生代\",{\"1\":{\"304\":1,\"339\":2,\"483\":2,\"493\":1,\"497\":1,\"537\":2,\"539\":2}}],[\"新生代和老年代\",{\"1\":{\"304\":1}}],[\"新定义的线程继承于thread类\",{\"1\":{\"288\":1}}],[\"新开一个cmd窗口\",{\"1\":{\"63\":1}}],[\"新旧地址的对应关系参考官网\",{\"1\":{\"61\":1}}],[\"新建一个init\",{\"1\":{\"1008\":1}}],[\"新建启动类\",{\"1\":{\"753\":1}}],[\"新建窗口\",{\"1\":{\"44\":1}}],[\"新建\",{\"1\":{\"44\":1}}],[\"新建项目后该设置又会失效\",{\"1\":{\"14\":1}}],[\"新项目的默认设置\",{\"0\":{\"19\":1},\"1\":{\"17\":1}}],[\"编写一种方法\",{\"1\":{\"953\":1}}],[\"编写两个程序\",{\"1\":{\"695\":1}}],[\"编组xml\",{\"1\":{\"591\":1}}],[\"编程式事务管理\",{\"1\":{\"633\":1}}],[\"编程实现一个数据序列的最长递增子序列\",{\"1\":{\"180\":1}}],[\"编程实现一组数据集合的全排列\",{\"1\":{\"170\":1}}],[\"编程实现查找两个字符串的最长公共子序列\",{\"1\":{\"180\":1}}],[\"编程实现莱文斯坦最短编辑距离\",{\"1\":{\"180\":1}}],[\"编程实现o\",{\"1\":{\"171\":1}}],[\"编程实现求阶乘n\",{\"1\":{\"170\":1}}],[\"编程实现斐波那契数列求值f\",{\"1\":{\"170\":1}}],[\"编程模拟实现一个浏览器的前进\",{\"1\":{\"168\":1}}],[\"编程自学之路\",{\"1\":{\"118\":1}}],[\"编程导航\",{\"1\":{\"118\":1}}],[\"编码\",{\"1\":{\"101\":1,\"765\":1,\"874\":1}}],[\"编码设置也是很重要的一个步骤\",{\"1\":{\"17\":1}}],[\"编码设置\",{\"0\":{\"17\":1}}],[\"编译compiletestjava模块\",{\"0\":{\"1010\":1}}],[\"编译版本\",{\"1\":{\"696\":1}}],[\"编译版本为\",{\"1\":{\"685\":1}}],[\"编译织入的方式慢\",{\"1\":{\"602\":1}}],[\"编译之后生成一个新的类\",{\"1\":{\"602\":1}}],[\"编译时织入\",{\"1\":{\"602\":1}}],[\"编译后织入\",{\"1\":{\"602\":1}}],[\"编译后产生一个字节码文件\",{\"1\":{\"457\":1}}],[\"编译后的代码缓存等\",{\"1\":{\"451\":1}}],[\"编译后的代码等数据\",{\"1\":{\"343\":1}}],[\"编译出来的机器码性能比解释器高\",{\"1\":{\"372\":1}}],[\"编译为本地机器指令执行\",{\"1\":{\"368\":1}}],[\"编译为对应平台上的本地机器指令才可以\",{\"1\":{\"355\":1}}],[\"编译期\",{\"1\":{\"367\":1}}],[\"编译成本地机器指令\",{\"1\":{\"349\":1}}],[\"编译javac\",{\"1\":{\"343\":1}}],[\"编译器方便地生成rpc客户端和服务器通信代码\",{\"1\":{\"879\":1}}],[\"编译器编译就行了\",{\"1\":{\"602\":1}}],[\"编译器可以对代码做如下优化\",{\"1\":{\"507\":1}}],[\"编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上\",{\"1\":{\"506\":1}}],[\"编译器容易实现\",{\"1\":{\"405\":1}}],[\"编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来\",{\"1\":{\"380\":1}}],[\"编译器的前端\",{\"1\":{\"367\":1}}],[\"编译器细节\",{\"0\":{\"367\":1}}],[\"编译器发挥作用\",{\"1\":{\"365\":1}}],[\"编译器要想发挥作用\",{\"1\":{\"365\":1}}],[\"编译器\",{\"0\":{\"358\":1,\"364\":1},\"1\":{\"358\":1,\"365\":1,\"367\":2}}],[\"编译器与解释器混合工作模式\",{\"1\":{\"350\":1}}],[\"编译器不能确定\",{\"1\":{\"317\":1}}],[\"编译器就能确认值\",{\"1\":{\"317\":1}}],[\"编译器在程序编译期就可以确定它的值\",{\"1\":{\"317\":1}}],[\"编译器会优化成\",{\"1\":{\"317\":1}}],[\"编译就是由\",{\"1\":{\"97\":1}}],[\"编译测试源代码\",{\"1\":{\"94\":1}}],[\"编译项目\",{\"1\":{\"94\":1}}],[\"编译操作\",{\"0\":{\"74\":1}}],[\"编辑器\",{\"1\":{\"159\":1}}],[\"编辑\",{\"0\":{\"45\":1},\"1\":{\"43\":1}}],[\"编辑工具\",{\"1\":{\"1\":1}}],[\"ls\",{\"1\":{\"993\":1}}],[\"lc\",{\"1\":{\"947\":1,\"1038\":1}}],[\"lcb\",{\"1\":{\"820\":3}}],[\"lt\",{\"1\":{\"854\":1}}],[\"lreturn\",{\"1\":{\"424\":1}}],[\"lnvocation\",{\"1\":{\"368\":1}}],[\"lnterpreter\",{\"0\":{\"358\":1}}],[\"lldouble\",{\"1\":{\"289\":1}}],[\"l\",{\"1\":{\"234\":3,\"577\":1,\"1029\":4}}],[\"levelodertraversal\",{\"1\":{\"1024\":1}}],[\"leftdepth\",{\"1\":{\"1022\":4}}],[\"left\",{\"1\":{\"1020\":3,\"1022\":1,\"1024\":8,\"1029\":3,\"1030\":1,\"1034\":2,\"1035\":2}}],[\"le\",{\"1\":{\"852\":1,\"853\":1}}],[\"letter\",{\"1\":{\"697\":3,\"702\":1,\"747\":2,\"748\":2,\"749\":2,\"754\":10,\"755\":4}}],[\"leastactive\",{\"1\":{\"916\":1}}],[\"learning\",{\"1\":{\"660\":1}}],[\"leak\",{\"1\":{\"450\":1}}],[\"len\",{\"1\":{\"202\":7}}],[\"lengthoflis\",{\"1\":{\"925\":1}}],[\"length==hash\",{\"1\":{\"246\":1}}],[\"length\",{\"1\":{\"186\":3,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"202\":3,\"234\":1,\"246\":2,\"549\":1,\"748\":1,\"749\":1,\"925\":3,\"931\":3,\"934\":4,\"937\":1,\"938\":1,\"943\":6,\"944\":2,\"948\":1,\"949\":1,\"954\":4,\"957\":2,\"1040\":3}}],[\"leetcode\",{\"0\":{\"961\":1,\"966\":1,\"971\":1,\"980\":1,\"1017\":1,\"1021\":1,\"1027\":1,\"1032\":1,\"1037\":1},\"1\":{\"22\":1,\"150\":2,\"942\":1,\"955\":1,\"962\":1,\"972\":1,\"1038\":1}}],[\"late\",{\"1\":{\"420\":1}}],[\"last\",{\"1\":{\"416\":1}}],[\"lastindexofsublist\",{\"1\":{\"258\":1}}],[\"launcher$extclassloader\",{\"1\":{\"332\":1,\"381\":1,\"383\":1}}],[\"launcher$appclassloader\",{\"1\":{\"332\":1,\"381\":2,\"384\":1}}],[\"landin\",{\"1\":{\"289\":1}}],[\"language\",{\"1\":{\"919\":1}}],[\"langclass\",{\"1\":{\"377\":1}}],[\"lang\",{\"1\":{\"184\":1,\"227\":1,\"305\":1,\"329\":1,\"331\":1,\"333\":1,\"338\":1,\"387\":1,\"388\":1,\"392\":5,\"393\":3,\"397\":1,\"422\":2,\"435\":1,\"442\":2,\"447\":1,\"462\":1,\"464\":1,\"603\":1,\"605\":2,\"994\":1,\"998\":4}}],[\"lambda表达式内的逻辑优先运算\",{\"1\":{\"851\":1,\"854\":1}}],[\"lambdaupdatewrapper<>\",{\"1\":{\"854\":1}}],[\"lambdaupdatewrapper<user>\",{\"1\":{\"854\":1}}],[\"lambdaupdatewrapper\",{\"0\":{\"854\":1},\"1\":{\"842\":1}}],[\"lambdaquerywrapper<>\",{\"1\":{\"853\":1}}],[\"lambdaquerywrapper<user>\",{\"1\":{\"853\":1}}],[\"lambdaquerywrapper\",{\"0\":{\"853\":1},\"1\":{\"842\":1}}],[\"lambdas\",{\"1\":{\"549\":1}}],[\"lambda\",{\"0\":{\"542\":1},\"1\":{\"241\":1,\"827\":2,\"842\":1,\"854\":1}}],[\"lazy\",{\"1\":{\"235\":1,\"619\":1,\"702\":1,\"741\":5,\"742\":6,\"783\":5}}],[\"lazyloadingenabled=true|false\",{\"1\":{\"821\":1}}],[\"lazyload\",{\"1\":{\"160\":1}}],[\"layout>\",{\"1\":{\"106\":2}}],[\"label\",{\"1\":{\"42\":1,\"577\":1}}],[\"like\",{\"1\":{\"814\":2,\"844\":1,\"847\":2,\"848\":2,\"851\":2,\"852\":2,\"853\":1,\"854\":1,\"858\":1}}],[\"lisi\",{\"1\":{\"747\":3,\"748\":2,\"749\":3,\"996\":2}}],[\"list不能为null\",{\"1\":{\"998\":4}}],[\"listnode\",{\"1\":{\"963\":9,\"965\":6,\"968\":8,\"969\":3,\"973\":8,\"975\":14}}],[\"list🍉\",{\"1\":{\"262\":1}}],[\"list的前distance个元素整体移到后面\",{\"1\":{\"257\":1}}],[\"listiterator\",{\"1\":{\"230\":1}}],[\"list是一个有序的\",{\"1\":{\"225\":1}}],[\"list存储的元素是有序的\",{\"1\":{\"215\":1}}],[\"list<user>\",{\"1\":{\"844\":1,\"845\":1,\"850\":1,\"852\":1,\"853\":1}}],[\"list<object>\",{\"1\":{\"832\":1}}],[\"list<map<string\",{\"1\":{\"832\":1,\"849\":1}}],[\"list<name>\",{\"1\":{\"814\":2}}],[\"list<requestmethod>\",{\"1\":{\"788\":1}}],[\"list<int\",{\"1\":{\"549\":2}}],[\"list<integer>\",{\"1\":{\"201\":2,\"548\":2,\"549\":1,\"957\":1,\"1034\":2,\"1035\":2}}],[\"list<dish>\",{\"1\":{\"548\":2}}],[\"list<string>\",{\"1\":{\"235\":1,\"546\":1,\"549\":2,\"990\":2,\"991\":1,\"996\":2,\"998\":1}}],[\"list<t>\",{\"1\":{\"234\":2,\"259\":1,\"832\":4}}],[\"list<\",{\"1\":{\"230\":1}}],[\"list<list<integer>>\",{\"1\":{\"201\":2}}],[\"list\",{\"0\":{\"13\":1,\"215\":1,\"225\":1,\"234\":1,\"235\":1},\"1\":{\"78\":1,\"214\":1,\"216\":1,\"229\":1,\"230\":6,\"233\":2,\"234\":4,\"235\":2,\"257\":12,\"258\":11,\"259\":2,\"548\":1,\"674\":1,\"776\":1,\"827\":1,\"833\":1,\"844\":1,\"850\":1,\"957\":4,\"963\":1,\"965\":1,\"968\":1,\"973\":1,\"975\":1,\"996\":4,\"998\":4}}],[\"live\",{\"1\":{\"745\":1}}],[\"limit返回的流会包含所有元素\",{\"1\":{\"548\":1}}],[\"limit\",{\"1\":{\"546\":2,\"547\":1,\"548\":1,\"817\":1,\"996\":1}}],[\"lifetime=\",{\"1\":{\"668\":1}}],[\"life\",{\"1\":{\"369\":1,\"614\":1}}],[\"link\",{\"1\":{\"435\":1,\"792\":7}}],[\"linking\",{\"0\":{\"379\":1},\"1\":{\"414\":1,\"417\":1}}],[\"linked\",{\"1\":{\"963\":1,\"965\":1,\"968\":1,\"973\":1}}],[\"linkedhashmap\",{\"1\":{\"220\":1,\"222\":4}}],[\"linkedhashset\",{\"1\":{\"220\":2}}],[\"linkedlist<integer>\",{\"1\":{\"944\":1}}],[\"linkedlist<>\",{\"1\":{\"201\":1,\"983\":1,\"1024\":1,\"1035\":1}}],[\"linkedlist\",{\"0\":{\"229\":1,\"231\":1},\"1\":{\"216\":1,\"219\":1,\"226\":1,\"229\":5,\"231\":5,\"259\":1}}],[\"linux命令手册\",{\"1\":{\"138\":1}}],[\"linux\",{\"1\":{\"343\":1,\"410\":1,\"695\":1,\"756\":1},\"2\":{\"34\":1}}],[\"linux相关\",{\"0\":{\"31\":1}}],[\"libs\",{\"1\":{\"1009\":1}}],[\"library\",{\"1\":{\"435\":1}}],[\"lib目录下的\",{\"1\":{\"331\":1}}],[\"lib\",{\"0\":{\"579\":1},\"1\":{\"143\":1,\"331\":1,\"383\":1,\"756\":4}}],[\"lib外置需要的配置\",{\"1\":{\"106\":1}}],[\"little\",{\"1\":{\"142\":1}}],[\"lipengzhou\",{\"1\":{\"47\":1}}],[\"lower\",{\"1\":{\"1029\":7}}],[\"lookup\",{\"1\":{\"619\":1}}],[\"long类型可以根据需求改变为string或int\",{\"1\":{\"651\":1}}],[\"long在不同时区下显示的效果会不一样\",{\"1\":{\"573\":1}}],[\"long\",{\"1\":{\"573\":1,\"651\":1,\"706\":3,\"722\":3,\"723\":2,\"832\":2,\"836\":1,\"860\":1}}],[\"longer\",{\"1\":{\"515\":1}}],[\"lockinterruptibly\",{\"1\":{\"286\":1}}],[\"lock\",{\"1\":{\"282\":1,\"285\":1,\"286\":2}}],[\"lock可以唤醒指定线程\",{\"1\":{\"282\":1}}],[\"lock可中断设置超时trylock\",{\"1\":{\"282\":1}}],[\"lock默认是非公平锁\",{\"1\":{\"282\":1}}],[\"lock需要手动释放锁\",{\"1\":{\"282\":1}}],[\"lock指具体的类\",{\"1\":{\"282\":1}}],[\"lock来实现的\",{\"1\":{\"278\":1}}],[\"locksupport\",{\"0\":{\"272\":1}}],[\"locksupport类\",{\"1\":{\"265\":1}}],[\"localhost20880\",{\"1\":{\"912\":1}}],[\"localhost\",{\"1\":{\"651\":1,\"754\":1,\"755\":2,\"757\":2,\"762\":1,\"765\":1,\"768\":1,\"831\":1,\"866\":2}}],[\"localdate\",{\"1\":{\"571\":3}}],[\"localdate与localtime都是不可变对象\",{\"1\":{\"565\":1}}],[\"localdate是一个不可变的日期时间对象\",{\"1\":{\"560\":1}}],[\"localdate类\",{\"0\":{\"560\":1}}],[\"localdatetime2\",{\"1\":{\"569\":2}}],[\"localdatetime1\",{\"1\":{\"568\":2,\"569\":2}}],[\"localdatetime类是一个不可变的日期时间对象\",{\"1\":{\"562\":1}}],[\"localdatetime类\",{\"0\":{\"562\":1}}],[\"localdatetime\",{\"1\":{\"555\":1,\"559\":5,\"562\":5,\"568\":5,\"569\":8,\"573\":15}}],[\"localtime是一个不可变的日期时间对象\",{\"1\":{\"561\":1}}],[\"localtime类\",{\"0\":{\"561\":1}}],[\"localtime\",{\"1\":{\"555\":1}}],[\"localrepository>\",{\"1\":{\"61\":1}}],[\"local\",{\"0\":{\"415\":1,\"501\":1},\"1\":{\"15\":1,\"414\":1,\"415\":1,\"482\":1,\"573\":1}}],[\"loadbalance\",{\"1\":{\"916\":4}}],[\"loaded\",{\"0\":{\"671\":1}}],[\"loader\",{\"1\":{\"345\":1,\"381\":3}}],[\"loading\",{\"0\":{\"376\":1},\"1\":{\"464\":1}}],[\"loadclass\",{\"1\":{\"332\":1,\"387\":2}}],[\"load\",{\"1\":{\"239\":2,\"244\":1}}],[\"loadfactorynames\",{\"1\":{\"674\":1}}],[\"loadfactor\",{\"1\":{\"239\":6}}],[\"lodash\",{\"1\":{\"159\":1}}],[\"lorem\",{\"1\":{\"139\":1}}],[\"logs\",{\"1\":{\"734\":2,\"738\":2,\"742\":1}}],[\"log实现的\",{\"1\":{\"633\":1}}],[\"log\",{\"1\":{\"252\":1,\"754\":2,\"755\":2,\"757\":2,\"762\":5,\"765\":4,\"768\":1,\"780\":1,\"831\":1,\"835\":1,\"836\":1}}],[\"log⁡n\",{\"1\":{\"194\":3}}],[\"logn\",{\"1\":{\"189\":1,\"190\":1}}],[\"logo\",{\"1\":{\"139\":7}}],[\"logojoy\",{\"1\":{\"139\":1}}],[\"logging\",{\"1\":{\"85\":2,\"831\":1,\"835\":1,\"836\":1}}],[\"logging<\",{\"1\":{\"83\":2}}],[\"logging包\",{\"1\":{\"83\":1}}],[\"lombok\",{\"1\":{\"22\":1,\"754\":2,\"757\":1,\"762\":3,\"768\":1}}],[\"内嵌\",{\"1\":{\"888\":1}}],[\"内嵌vscode的在线ide\",{\"1\":{\"130\":1}}],[\"内含分布式唯一\",{\"1\":{\"827\":1}}],[\"内直接书写带有物理分页的参数来完成物理分页功能\",{\"1\":{\"817\":1}}],[\"内置全局拦截插件\",{\"1\":{\"827\":1}}],[\"内置性能分析插件\",{\"1\":{\"827\":1}}],[\"内置分页插件\",{\"1\":{\"827\":1}}],[\"内置代码生成器\",{\"1\":{\"827\":1}}],[\"内置通用\",{\"1\":{\"827\":1}}],[\"内置了servlet容器\",{\"1\":{\"666\":1}}],[\"内置了两个jit编译器\",{\"1\":{\"372\":1}}],[\"内置锁在java中被抽象为监视器锁\",{\"1\":{\"278\":1}}],[\"内部for执行一圈下来\",{\"1\":{\"925\":1}}],[\"内部子系统较多\",{\"1\":{\"872\":1}}],[\"内部数据结构之间的映射关系\",{\"0\":{\"822\":1}}],[\"内部建立的逻辑连接\",{\"1\":{\"693\":1}}],[\"内部使用的一种数据结构\",{\"1\":{\"692\":1}}],[\"内部包含了常量池\",{\"1\":{\"456\":1}}],[\"内部包含了运行时常量池\",{\"1\":{\"456\":1}}],[\"内部结构也调整了\",{\"1\":{\"445\":1}}],[\"内部\",{\"1\":{\"382\":1,\"810\":1,\"822\":1}}],[\"内部代号\",{\"1\":{\"353\":1}}],[\"内部的方法基本都经过synchronized\",{\"1\":{\"239\":1}}],[\"内容相同的字符串\",{\"1\":{\"318\":1}}],[\"内容来自个人总结及网络收集\",{\"1\":{\"1\":1}}],[\"内存开销对比\",{\"0\":{\"784\":1}}],[\"内存减半的高额代价\",{\"1\":{\"523\":1}}],[\"内存迟早都会被消耗完\",{\"1\":{\"516\":1}}],[\"内存还不足\",{\"1\":{\"495\":1}}],[\"内存细分\",{\"0\":{\"483\":1}}],[\"内存布局与访问定位\",{\"0\":{\"466\":1}}],[\"内存模型以及分区\",{\"1\":{\"465\":1}}],[\"内存模型吧\",{\"1\":{\"465\":1}}],[\"内存为什么要分成新生代\",{\"1\":{\"465\":1}}],[\"内存结构\",{\"1\":{\"465\":1}}],[\"内存结构概述\",{\"0\":{\"374\":1}}],[\"内存分配策略\",{\"0\":{\"498\":1}}],[\"内存分配结束\",{\"1\":{\"472\":1}}],[\"内存分配\",{\"1\":{\"465\":1}}],[\"内存分配完成后\",{\"1\":{\"312\":1}}],[\"内存分区\",{\"1\":{\"465\":2}}],[\"内存分哪几个区\",{\"1\":{\"465\":1}}],[\"内存总量确定的情况下\",{\"1\":{\"429\":1}}],[\"内存可以粗糙的区分为堆内存\",{\"1\":{\"302\":1}}],[\"内存区域分散的缺点\",{\"1\":{\"523\":1}}],[\"内存区域\",{\"0\":{\"300\":1}}],[\"内存泄漏\",{\"1\":{\"280\":1}}],[\"内存等系统资源进行处理\",{\"1\":{\"267\":1}}],[\"内存是放不下的\",{\"1\":{\"246\":1}}],[\"内存空间占用\",{\"1\":{\"229\":1}}],[\"内设置\",{\"1\":{\"14\":1}}],[\"41\",{\"1\":{\"754\":1}}],[\"47<\",{\"1\":{\"753\":1}}],[\"47ae\",{\"1\":{\"388\":1}}],[\"43\",{\"1\":{\"738\":1}}],[\"42\",{\"1\":{\"701\":1}}],[\"443\",{\"0\":{\"588\":1},\"1\":{\"588\":1}}],[\"456a\",{\"1\":{\"483\":1}}],[\"458e\",{\"1\":{\"381\":1}}],[\"4时被淘汰\",{\"1\":{\"349\":1}}],[\"4b7d\",{\"1\":{\"343\":1}}],[\"4种引用类型\",{\"0\":{\"324\":1}}],[\"404\",{\"1\":{\"1045\":1}}],[\"404页素材\",{\"1\":{\"139\":1}}],[\"404页\",{\"1\":{\"139\":1}}],[\"40000\",{\"1\":{\"754\":1,\"937\":2,\"939\":3}}],[\"40s\",{\"1\":{\"754\":5,\"755\":1}}],[\"40\",{\"1\":{\"246\":2}}],[\"4\",{\"0\":{\"13\":1,\"20\":1,\"21\":1,\"22\":1,\"70\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":2,\"77\":1,\"90\":1,\"104\":1,\"105\":1,\"106\":1,\"364\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":2,\"369\":2,\"370\":2,\"371\":1,\"372\":1,\"385\":1,\"430\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"455\":2,\"456\":1,\"459\":1,\"473\":1,\"518\":1,\"524\":1},\"1\":{\"46\":1,\"78\":2,\"85\":5,\"184\":1,\"207\":6,\"239\":1,\"244\":2,\"253\":3,\"308\":1,\"486\":1,\"503\":1,\"548\":2,\"549\":6,\"584\":1,\"665\":1,\"678\":1,\"697\":3,\"698\":2,\"701\":2,\"717\":1,\"748\":1,\"749\":1,\"792\":1,\"818\":2,\"827\":1,\"836\":1,\"874\":2,\"875\":1,\"876\":1,\"877\":1,\"878\":1,\"879\":1,\"902\":1,\"929\":1,\"934\":1,\"937\":1,\"943\":1,\"944\":1,\"970\":5,\"981\":1,\"1004\":2,\"1005\":1,\"1006\":3,\"1007\":1,\"1008\":1,\"1018\":4,\"1023\":3,\"1028\":3,\"1033\":3,\"1038\":2}}],[\"勾选自动保存\",{\"1\":{\"37\":1}}],[\"勾选\",{\"1\":{\"12\":1,\"38\":1}}],[\"勾选这个选项\",{\"1\":{\"7\":1}}],[\"3的深度之和\",{\"1\":{\"1023\":1}}],[\"3的深度为1\",{\"1\":{\"1023\":1}}],[\"3的最大深度+1\",{\"1\":{\"1023\":1}}],[\"31<\",{\"1\":{\"863\":1}}],[\"3306\",{\"1\":{\"831\":1,\"864\":1,\"866\":2}}],[\"330提供\",{\"1\":{\"609\":1}}],[\"39999\",{\"1\":{\"939\":1}}],[\"39\",{\"1\":{\"723\":1}}],[\"39145991\",{\"1\":{\"114\":1}}],[\"365\",{\"0\":{\"980\":1}}],[\"3600\",{\"1\":{\"673\":1}}],[\"36354489\",{\"1\":{\"114\":1}}],[\"3后才拥有springboot\",{\"1\":{\"669\":1}}],[\"3735273\",{\"1\":{\"614\":1}}],[\"37634385\",{\"1\":{\"114\":1}}],[\"3时\",{\"1\":{\"351\":1}}],[\"32\",{\"1\":{\"701\":1}}],[\"32位机器默认是64m\",{\"1\":{\"447\":1}}],[\"32bit\",{\"1\":{\"416\":1}}],[\"320\",{\"1\":{\"253\":1}}],[\"321\",{\"1\":{\"253\":1}}],[\"35\",{\"1\":{\"241\":1,\"779\":2}}],[\"3d模型\",{\"1\":{\"141\":1}}],[\"3d\",{\"0\":{\"141\":1}}],[\"3d字体\",{\"1\":{\"134\":1}}],[\"3020\",{\"1\":{\"568\":1}}],[\"300\",{\"0\":{\"924\":1},\"1\":{\"546\":1,\"548\":1,\"717\":1}}],[\"30\",{\"1\":{\"129\":1,\"562\":1,\"844\":1}}],[\"3\",{\"0\":{\"12\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":2,\"18\":2,\"19\":2,\"20\":2,\"21\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":2,\"70\":1,\"71\":2,\"75\":1,\"82\":1,\"83\":1,\"89\":1,\"99\":1,\"103\":1,\"360\":1,\"361\":1,\"362\":1,\"363\":2,\"367\":1,\"384\":1,\"397\":1,\"429\":1,\"443\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":2,\"450\":1,\"454\":1,\"463\":1,\"472\":1,\"478\":1,\"479\":1,\"496\":1,\"510\":1,\"517\":1,\"523\":1},\"1\":{\"46\":1,\"49\":1,\"78\":2,\"97\":1,\"98\":1,\"101\":1,\"106\":1,\"114\":1,\"188\":1,\"199\":2,\"201\":2,\"207\":6,\"233\":2,\"234\":3,\"241\":1,\"329\":1,\"379\":1,\"488\":1,\"503\":2,\"513\":1,\"546\":1,\"548\":5,\"549\":12,\"559\":1,\"569\":1,\"573\":8,\"584\":1,\"592\":1,\"600\":1,\"617\":1,\"665\":1,\"676\":1,\"678\":1,\"680\":1,\"697\":3,\"698\":2,\"701\":1,\"702\":1,\"718\":1,\"724\":1,\"741\":2,\"742\":2,\"755\":1,\"756\":4,\"780\":1,\"782\":1,\"783\":1,\"792\":1,\"836\":1,\"850\":2,\"858\":1,\"861\":1,\"863\":1,\"874\":2,\"875\":1,\"876\":1,\"877\":1,\"878\":1,\"879\":1,\"902\":1,\"929\":4,\"937\":3,\"938\":1,\"939\":3,\"970\":4,\"981\":1,\"996\":2,\"1004\":3,\"1018\":2,\"1023\":1,\"1028\":3,\"1033\":3,\"1038\":5}}],[\"mp提供了动态表名sql解析器\",{\"1\":{\"861\":1}}],[\"mp提供的分页对象\",{\"1\":{\"859\":1}}],[\"mpe\",{\"1\":{\"832\":1}}],[\"mp\",{\"1\":{\"826\":1}}],[\"mnesia\",{\"1\":{\"757\":1}}],[\"mnemonic即可\",{\"1\":{\"11\":1}}],[\"mnemonic\",{\"1\":{\"11\":1}}],[\"msgttlqueueconfig\",{\"1\":{\"755\":1}}],[\"msg\",{\"1\":{\"754\":2,\"757\":2,\"762\":2,\"768\":2,\"780\":1}}],[\"ms\",{\"1\":{\"722\":1,\"723\":1}}],[\"mq\",{\"1\":{\"718\":1,\"745\":1,\"772\":4,\"773\":3}}],[\"mvc需要依赖于xml配置进行开发\",{\"1\":{\"667\":1}}],[\"mvc只是spring的一个模块\",{\"1\":{\"667\":1}}],[\"mvc的整合\",{\"1\":{\"667\":1}}],[\"mvc的区别\",{\"0\":{\"667\":1}}],[\"mvc的主要组件\",{\"0\":{\"646\":1}}],[\"mvc的好处之一在于它能为应用程序处理很多不同的视图\",{\"1\":{\"645\":1}}],[\"mvc的全名是model\",{\"1\":{\"645\":1}}],[\"mvc的理解\",{\"0\":{\"643\":1}}],[\"mvc是其中一个开源项目\",{\"1\":{\"592\":1}}],[\"mvc就是一个mvc模式的web开发框架\",{\"1\":{\"592\":1}}],[\"mvc和spring\",{\"1\":{\"591\":1}}],[\"mvc\",{\"0\":{\"642\":1},\"1\":{\"591\":1,\"618\":1,\"643\":5,\"656\":1}}],[\"mvn\",{\"1\":{\"72\":1,\"73\":1,\"74\":2,\"75\":1,\"76\":1,\"77\":1,\"78\":4,\"90\":2,\"99\":1}}],[\"mm\",{\"1\":{\"573\":3}}],[\"mb\",{\"1\":{\"335\":1}}],[\"multicast注册中心\",{\"1\":{\"897\":1}}],[\"multicast\",{\"1\":{\"693\":1,\"897\":1}}],[\"multiple\",{\"1\":{\"701\":1,\"706\":3,\"720\":1,\"832\":1}}],[\"multiples\",{\"1\":{\"244\":1}}],[\"multipartfile\",{\"1\":{\"655\":2}}],[\"multipart\",{\"1\":{\"655\":1}}],[\"mutex\",{\"1\":{\"278\":1}}],[\"m为线程池的编号\",{\"1\":{\"275\":1}}],[\"m\",{\"1\":{\"259\":1,\"275\":1,\"335\":1,\"535\":1,\"645\":1,\"934\":5}}],[\"myqueue\",{\"1\":{\"783\":1}}],[\"mycallback\",{\"1\":{\"762\":5,\"765\":3}}],[\"myconfiguration\",{\"1\":{\"676\":2}}],[\"mybaits的优缺点\",{\"0\":{\"807\":1}}],[\"mybatisplusinterceptor\",{\"1\":{\"857\":4,\"860\":4}}],[\"mybatisplusconfig\",{\"1\":{\"857\":1,\"860\":1}}],[\"mybatisplus\",{\"1\":{\"832\":1,\"836\":1,\"857\":1,\"860\":1,\"864\":1}}],[\"mybatis的增强工具\",{\"1\":{\"826\":1}}],[\"mybatis的一级\",{\"0\":{\"813\":1}}],[\"mybatisutil\",{\"1\":{\"819\":1}}],[\"mybatis3\",{\"1\":{\"816\":2}}],[\"mybatis通过反射创建对象\",{\"1\":{\"808\":1}}],[\"mybatis是如何将sql执行结果封装为目标对象并返回的\",{\"0\":{\"808\":1}}],[\"mybatis是一个半orm\",{\"1\":{\"806\":1}}],[\"mybatis面试题\",{\"0\":{\"805\":1}}],[\"mybatis\",{\"0\":{\"812\":1,\"817\":1,\"818\":1,\"821\":1,\"822\":2,\"823\":1,\"825\":1,\"868\":1,\"869\":1},\"1\":{\"680\":1,\"806\":1,\"810\":1,\"812\":2,\"816\":2,\"817\":3,\"818\":3,\"821\":2,\"822\":1,\"823\":1,\"824\":1,\"826\":2,\"827\":1,\"830\":1,\"831\":2,\"833\":2,\"835\":1,\"836\":1,\"837\":1,\"856\":1,\"860\":1,\"864\":3,\"866\":2}}],[\"mybatis插件\",{\"1\":{\"22\":1}}],[\"mybatisx插件\",{\"0\":{\"867\":1}}],[\"mybatisx等插件\",{\"1\":{\"826\":1}}],[\"mybatisx\",{\"1\":{\"22\":1,\"867\":1}}],[\"mybean\",{\"1\":{\"687\":1}}],[\"myhandlerinterceptoradapter\",{\"1\":{\"656\":1}}],[\"mysql\",{\"1\":{\"810\":1,\"827\":1,\"831\":2,\"857\":1,\"860\":1,\"864\":1,\"866\":4}}],[\"mysql默认级别\",{\"1\":{\"634\":1}}],[\"mysql等\",{\"1\":{\"628\":1}}],[\"mylist\",{\"1\":{\"233\":5,\"234\":2}}],[\"myarray2\",{\"1\":{\"234\":2}}],[\"myarray\",{\"1\":{\"233\":3,\"234\":4}}],[\"md\",{\"1\":{\"159\":1}}],[\"mdn\",{\"1\":{\"119\":2}}],[\"md<\",{\"1\":{\"99\":1}}],[\"mid\",{\"0\":{\"1041\":1}}],[\"millennia\",{\"1\":{\"568\":1}}],[\"mixed\",{\"1\":{\"493\":1}}],[\"misc\",{\"1\":{\"332\":2,\"381\":3,\"383\":1,\"384\":1}}],[\"minincrementforunique\",{\"1\":{\"938\":1,\"939\":1}}],[\"minimumdifference\",{\"1\":{\"189\":1,\"190\":1}}],[\"mina\",{\"1\":{\"883\":2}}],[\"minsparethreads=\",{\"1\":{\"649\":1}}],[\"minus\",{\"1\":{\"565\":1}}],[\"minorgc的发生频率要比majorgc高很多\",{\"1\":{\"512\":1}}],[\"minorgc\",{\"1\":{\"495\":1}}],[\"minor\",{\"0\":{\"493\":1,\"494\":1},\"1\":{\"490\":1,\"493\":1,\"494\":2}}],[\"minvalue\",{\"1\":{\"202\":4}}],[\"min\",{\"1\":{\"189\":1,\"190\":1,\"194\":8,\"202\":8,\"258\":2}}],[\"microsoft\",{\"1\":{\"110\":1}}],[\"mirrors>\",{\"1\":{\"61\":1}}],[\"mirror>\",{\"1\":{\"61\":1}}],[\"mirrorof>\",{\"1\":{\"61\":1}}],[\"mf文件详细说明\",{\"1\":{\"103\":1}}],[\"mf文件中创建class\",{\"1\":{\"103\":1}}],[\"move\",{\"1\":{\"937\":4}}],[\"mock\",{\"1\":{\"901\":1}}],[\"mock=\",{\"1\":{\"901\":2}}],[\"mongo\",{\"1\":{\"667\":1}}],[\"month中包含标准日历中的12个月份的常量\",{\"1\":{\"566\":1}}],[\"month\",{\"0\":{\"566\":1}}],[\"monthday\",{\"0\":{\"565\":1}}],[\"monitorfilter\",{\"1\":{\"905\":1}}],[\"monitorfilter向dubbomonitor\",{\"1\":{\"902\":1}}],[\"monitor实现原理\",{\"0\":{\"902\":1}}],[\"monitoring\",{\"1\":{\"340\":1}}],[\"monitor\",{\"1\":{\"278\":2,\"882\":1,\"883\":1}}],[\"monitorexit\",{\"1\":{\"278\":1}}],[\"monitorenter\",{\"1\":{\"278\":1}}],[\"mono\",{\"1\":{\"38\":1}}],[\"mobile\",{\"1\":{\"146\":1}}],[\"mode\",{\"1\":{\"525\":1,\"619\":2,\"702\":1,\"783\":3}}],[\"modelmap\",{\"1\":{\"656\":1}}],[\"modelandview是springmvc框架的一个底层对象\",{\"1\":{\"642\":1}}],[\"modelversion>\",{\"1\":{\"70\":1}}],[\"model\",{\"1\":{\"67\":2,\"645\":1,\"827\":2}}],[\"modulename\",{\"1\":{\"864\":1}}],[\"modules\",{\"1\":{\"89\":1}}],[\"modules>\",{\"1\":{\"87\":1}}],[\"module>\",{\"1\":{\"87\":3}}],[\"module<\",{\"1\":{\"87\":3,\"88\":1}}],[\"module\",{\"1\":{\"85\":3}}],[\"moefy\",{\"1\":{\"53\":1}}],[\"moefyit\",{\"1\":{\"53\":1}}],[\"memcache\",{\"1\":{\"888\":1}}],[\"memory\",{\"1\":{\"340\":1,\"410\":1,\"450\":3,\"492\":1,\"521\":1}}],[\"messageproperties\",{\"1\":{\"712\":2}}],[\"messageid\",{\"1\":{\"697\":1}}],[\"message\",{\"1\":{\"693\":4,\"697\":3,\"698\":2,\"701\":3,\"708\":5,\"711\":3,\"712\":3,\"714\":2,\"717\":2,\"722\":5,\"723\":5,\"729\":1,\"734\":3,\"738\":3,\"742\":3,\"747\":7,\"748\":5,\"749\":6,\"752\":3,\"754\":12,\"755\":11,\"756\":4,\"757\":9,\"762\":10,\"765\":4,\"768\":4,\"779\":6,\"780\":9}}],[\"message的描述有误\",{\"1\":{\"585\":1}}],[\"mescroll\",{\"1\":{\"158\":1}}],[\"medium\",{\"1\":{\"573\":1}}],[\"meditor\",{\"1\":{\"159\":1}}],[\"method不需要继承的另一种实现方式吧\",{\"1\":{\"632\":1}}],[\"method的理解\",{\"1\":{\"632\":1}}],[\"method模式一般是需要继承的\",{\"1\":{\"632\":1}}],[\"method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\",{\"1\":{\"632\":1}}],[\"method配置的方法\",{\"1\":{\"614\":2}}],[\"method方法\",{\"1\":{\"613\":1,\"614\":2}}],[\"methodarea\",{\"1\":{\"442\":1}}],[\"method时\",{\"1\":{\"434\":1}}],[\"method\",{\"0\":{\"435\":1,\"437\":1,\"454\":1},\"1\":{\"413\":1,\"423\":1,\"437\":1,\"614\":2,\"619\":5,\"624\":1,\"687\":1,\"693\":1,\"791\":1,\"792\":3,\"879\":1}}],[\"methodhandle\",{\"1\":{\"397\":1}}],[\"methodref\",{\"1\":{\"379\":1}}],[\"metaspacesize设置为一个相对较高的值\",{\"1\":{\"448\":1}}],[\"metaspacesize值为21mb\",{\"1\":{\"448\":1}}],[\"metaspacesize\",{\"1\":{\"448\":1,\"449\":1}}],[\"metaspacesize是21m\",{\"1\":{\"448\":1}}],[\"metaspacesize和\",{\"1\":{\"448\":1}}],[\"metaspacesize=n\",{\"1\":{\"305\":1,\"338\":1}}],[\"metaspace\",{\"1\":{\"305\":2,\"307\":2,\"338\":2,\"343\":1,\"442\":1,\"448\":1,\"483\":1}}],[\"metadata\",{\"1\":{\"278\":1,\"674\":1}}],[\"meta\",{\"1\":{\"103\":1,\"483\":1,\"619\":1,\"683\":1,\"892\":1}}],[\"menory\",{\"1\":{\"350\":1}}],[\"menu\",{\"1\":{\"42\":2,\"546\":1,\"548\":2,\"549\":1}}],[\"merge\",{\"1\":{\"28\":1}}],[\"master\",{\"1\":{\"866\":2}}],[\"mariadb\",{\"1\":{\"827\":1}}],[\"mark\",{\"0\":{\"521\":1,\"523\":1},\"1\":{\"476\":1,\"520\":2,\"523\":2,\"525\":3,\"534\":1}}],[\"markdown增强\",{\"1\":{\"55\":1}}],[\"markdown增强语法\",{\"0\":{\"55\":1}}],[\"markdown\",{\"0\":{\"40\":1},\"1\":{\"40\":1,\"55\":2,\"159\":1}}],[\"male\",{\"1\":{\"741\":2,\"742\":2}}],[\"major\",{\"0\":{\"493\":1,\"495\":1},\"1\":{\"490\":1,\"493\":2,\"495\":1}}],[\"majorgc\",{\"1\":{\"490\":1,\"495\":1}}],[\"macos\",{\"1\":{\"410\":1}}],[\"machine\",{\"1\":{\"353\":1,\"407\":1}}],[\"mac\",{\"1\":{\"343\":1}}],[\"mac系统下按control\",{\"1\":{\"131\":1}}],[\"map中key存储服务url\",{\"1\":{\"897\":1}}],[\"map存储\",{\"1\":{\"897\":1}}],[\"maps\",{\"1\":{\"849\":1}}],[\"mappedstatement\",{\"1\":{\"816\":5,\"822\":1}}],[\"mapperxml\",{\"1\":{\"864\":1}}],[\"mapper<t>\",{\"1\":{\"832\":1}}],[\"mapperscan\",{\"1\":{\"857\":1,\"860\":1}}],[\"mappers\",{\"1\":{\"816\":2}}],[\"mapper\",{\"1\":{\"809\":1,\"813\":1,\"814\":2,\"815\":1,\"816\":2,\"827\":2,\"832\":1,\"833\":1,\"857\":1,\"860\":1}}],[\"mapper接口方法的输出参数类型和mapper\",{\"1\":{\"809\":1}}],[\"mapper接口方法的输入参数类型和mapper\",{\"1\":{\"809\":1}}],[\"mapper接口里的方法名和mapper\",{\"1\":{\"809\":1}}],[\"mapping\",{\"1\":{\"656\":1}}],[\"mapping>\",{\"1\":{\"649\":2}}],[\"map<integer\",{\"1\":{\"944\":1}}],[\"map<requestmappinginfo\",{\"1\":{\"788\":2}}],[\"map<string\",{\"1\":{\"697\":1,\"738\":1,\"747\":1,\"748\":1,\"749\":1,\"752\":1,\"754\":2,\"755\":1,\"757\":1,\"777\":1,\"779\":1,\"780\":1,\"783\":1,\"788\":3,\"819\":1,\"832\":2,\"993\":1}}],[\"map<k\",{\"1\":{\"259\":1}}],[\"map使用键值对\",{\"1\":{\"215\":1}}],[\"map\",{\"0\":{\"215\":1,\"222\":1,\"238\":1,\"993\":1},\"1\":{\"214\":1,\"216\":1,\"240\":2,\"242\":1,\"259\":1,\"340\":1,\"546\":2,\"547\":1,\"549\":6,\"595\":1,\"697\":2,\"702\":5,\"724\":2,\"738\":2,\"742\":2,\"747\":2,\"754\":1,\"755\":1,\"779\":1,\"788\":1,\"819\":4,\"889\":1,\"891\":1,\"957\":1,\"982\":1,\"993\":2}}],[\"maptolong\",{\"1\":{\"194\":2}}],[\"match\",{\"1\":{\"728\":3}}],[\"mat\",{\"1\":{\"540\":1}}],[\"math\",{\"1\":{\"187\":1,\"189\":1,\"190\":1,\"194\":2,\"202\":7,\"207\":1,\"925\":2,\"934\":1,\"939\":1,\"1022\":2}}],[\"material\",{\"1\":{\"156\":1}}],[\"magi\",{\"1\":{\"143\":1}}],[\"maker\",{\"1\":{\"139\":1}}],[\"mandatory\",{\"1\":{\"635\":2,\"764\":6,\"765\":1,\"767\":1,\"768\":1}}],[\"management\",{\"1\":{\"350\":1}}],[\"manypixels\",{\"1\":{\"139\":1}}],[\"manifest文件\",{\"1\":{\"106\":1}}],[\"manifest文件中\",{\"1\":{\"103\":1}}],[\"manifest>\",{\"1\":{\"103\":1,\"106\":1}}],[\"manifest\",{\"1\":{\"103\":2}}],[\"mainclass>\",{\"1\":{\"106\":1}}],[\"main\",{\"1\":{\"94\":1,\"99\":2,\"241\":1,\"332\":1,\"392\":4,\"510\":1,\"559\":1,\"562\":2,\"568\":1,\"569\":1,\"571\":1,\"573\":2,\"670\":1,\"687\":1,\"697\":1,\"698\":1,\"701\":3,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"748\":2,\"749\":2,\"753\":1,\"779\":2,\"864\":1}}],[\"main目录\",{\"1\":{\"80\":1}}],[\"maxareaofisland\",{\"1\":{\"934\":1}}],[\"maxage\",{\"1\":{\"673\":1}}],[\"maxsparethreads=\",{\"1\":{\"649\":1}}],[\"maxthreads=\",{\"1\":{\"649\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"503\":1}}],[\"maxtenuringthreshold来设置\",{\"1\":{\"498\":1}}],[\"maxtenuringthreshold=<n>\",{\"1\":{\"490\":1}}],[\"maxhttpheadersize=\",{\"1\":{\"649\":1}}],[\"maxheapsize\",{\"1\":{\"485\":1}}],[\"maxmetaspacesize的值是\",{\"1\":{\"448\":1}}],[\"maxmetaspacesize指定\",{\"1\":{\"448\":1}}],[\"maxmetaspacesize=n\",{\"1\":{\"305\":1,\"338\":1}}],[\"maxnewsize=1024m表示新生代最小256m\",{\"1\":{\"336\":1}}],[\"maxnewsize=<young\",{\"1\":{\"336\":1}}],[\"maxpermsize\",{\"1\":{\"444\":1,\"447\":1}}],[\"maxpermsize=n\",{\"1\":{\"305\":1,\"338\":1}}],[\"maxprofit\",{\"1\":{\"202\":3}}],[\"maximumpoolsize\",{\"1\":{\"275\":1,\"277\":2}}],[\"maximum\",{\"1\":{\"239\":4,\"253\":2,\"777\":1}}],[\"maxvalue\",{\"1\":{\"207\":1}}],[\"max可以初始化为0\",{\"1\":{\"187\":1}}],[\"max\",{\"1\":{\"32\":1,\"187\":6,\"198\":2,\"202\":17,\"207\":2,\"258\":2,\"291\":2,\"697\":1,\"748\":1,\"749\":1,\"777\":2,\"779\":1,\"780\":1,\"925\":6,\"926\":2,\"934\":1,\"939\":11,\"1022\":2,\"1030\":1}}],[\"mavencentral\",{\"1\":{\"1008\":1,\"1009\":2}}],[\"mavenlocal\",{\"1\":{\"1008\":1}}],[\"maven依赖\",{\"1\":{\"683\":1}}],[\"maven自己先打的包会被加上\",{\"1\":{\"106\":1}}],[\"maven官方插件\",{\"1\":{\"103\":1}}],[\"maven编译插件\",{\"1\":{\"101\":1}}],[\"maven插件官网\",{\"1\":{\"97\":1}}],[\"maven的生命周期\",{\"0\":{\"93\":1}}],[\"maven的仓库\",{\"1\":{\"65\":1}}],[\"maven工程之间\",{\"1\":{\"85\":1}}],[\"maven工程间的继承\",{\"0\":{\"84\":1}}],[\"mavenrepository\",{\"1\":{\"77\":1}}],[\"mavenrepository<\",{\"1\":{\"61\":1}}],[\"maven<\",{\"1\":{\"77\":1,\"83\":1,\"88\":2}}],[\"maven本地仓库根目录\",{\"1\":{\"65\":1}}],[\"maven中的坐标\",{\"0\":{\"65\":1}}],[\"maven介绍\",{\"0\":{\"59\":1}}],[\"maven笔记\",{\"0\":{\"58\":1}}],[\"maven配置\",{\"0\":{\"15\":1}}],[\"maven\",{\"0\":{\"72\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1},\"1\":{\"7\":2,\"15\":2,\"21\":1,\"59\":2,\"60\":1,\"61\":5,\"62\":4,\"65\":2,\"69\":3,\"72\":1,\"77\":9,\"78\":2,\"83\":2,\"85\":4,\"87\":3,\"88\":2,\"90\":2,\"94\":1,\"95\":1,\"97\":3,\"98\":1,\"99\":2,\"101\":1,\"103\":1,\"104\":2,\"106\":5,\"671\":1,\"696\":2,\"753\":1,\"827\":1,\"1008\":2,\"1009\":5},\"2\":{\"108\":1}}],[\"书签重命名\",{\"1\":{\"11\":1}}],[\"bfs2\",{\"0\":{\"983\":1}}],[\"bfs1\",{\"0\":{\"982\":1}}],[\"bfs\",{\"0\":{\"944\":1,\"1035\":1},\"1\":{\"983\":1}}],[\"bfs题\",{\"1\":{\"942\":1}}],[\"bcryptpasswordencoder\",{\"1\":{\"788\":1}}],[\"blackgreen\",{\"1\":{\"736\":1}}],[\"black\",{\"1\":{\"736\":1}}],[\"blog\",{\"1\":{\"289\":1,\"293\":1}}],[\"b对象\",{\"1\":{\"621\":1}}],[\"b已经实例化并且初始化完成\",{\"1\":{\"621\":1}}],[\"b互相依赖\",{\"1\":{\"621\":1}}],[\"bbb\",{\"1\":{\"584\":1,\"996\":1}}],[\"business\",{\"1\":{\"883\":1}}],[\"but\",{\"1\":{\"832\":1}}],[\"builtinexchangetype\",{\"1\":{\"738\":2,\"742\":2,\"747\":7,\"748\":3,\"749\":3}}],[\"builder\",{\"1\":{\"697\":1,\"747\":1,\"748\":1,\"779\":1,\"864\":6}}],[\"build>\",{\"1\":{\"99\":1,\"671\":1,\"696\":1}}],[\"build\",{\"1\":{\"7\":2,\"15\":1,\"99\":1,\"101\":3,\"105\":1,\"106\":1,\"697\":1,\"747\":1,\"748\":1,\"752\":1,\"754\":2,\"755\":1,\"762\":1,\"768\":4,\"779\":1,\"780\":1,\"1009\":2}}],[\"bumpthepointer\",{\"1\":{\"471\":1}}],[\"buffers\",{\"1\":{\"879\":1}}],[\"buffer\",{\"0\":{\"501\":1},\"1\":{\"308\":1,\"471\":1,\"482\":1}}],[\"buy\",{\"1\":{\"194\":9}}],[\"break\",{\"1\":{\"788\":6,\"948\":1}}],[\"broadcast\",{\"1\":{\"917\":1}}],[\"broker\",{\"1\":{\"693\":5,\"720\":3,\"744\":1,\"762\":2}}],[\"brown\",{\"1\":{\"235\":1,\"741\":2,\"742\":2}}],[\"browser\",{\"1\":{\"148\":1,\"340\":1}}],[\"brandmark\",{\"1\":{\"139\":1}}],[\"bēhance\",{\"1\":{\"139\":2}}],[\"boundsql\",{\"1\":{\"822\":1}}],[\"bounded\",{\"1\":{\"244\":1}}],[\"boss\",{\"1\":{\"599\":1}}],[\"boxed\",{\"1\":{\"234\":1}}],[\"box\",{\"1\":{\"134\":1}}],[\"boolean\",{\"1\":{\"186\":1,\"242\":3,\"258\":1,\"286\":1,\"697\":3,\"698\":1,\"702\":3,\"706\":5,\"708\":2,\"711\":1,\"714\":1,\"717\":1,\"722\":1,\"762\":1,\"765\":1,\"832\":1,\"934\":2,\"948\":2,\"957\":2,\"973\":1,\"975\":2,\"982\":1,\"983\":1,\"984\":1,\"1020\":2,\"1029\":2,\"1030\":1}}],[\"boolean类型的标志位持续变化的题目中\",{\"1\":{\"183\":1}}],[\"boot工程\",{\"1\":{\"753\":1}}],[\"boot自己实现starter\",{\"0\":{\"684\":1}}],[\"boot自动配置原理\",{\"1\":{\"674\":1}}],[\"boot启动的时候会找到starter\",{\"1\":{\"683\":1}}],[\"boot官方保留\",{\"1\":{\"682\":1}}],[\"boot官方的启动器都是以spring\",{\"1\":{\"682\":1}}],[\"boot开头命名\",{\"1\":{\"682\":1}}],[\"boot集成mybatis\",{\"0\":{\"680\":1}}],[\"boot容器替换\",{\"0\":{\"679\":1}}],[\"boot应用将要使用的environment\",{\"1\":{\"678\":1}}],[\"boot应用开发管理这不同的框架和版本依赖\",{\"1\":{\"665\":1}}],[\"boot的优势之上\",{\"1\":{\"886\":1}}],[\"boot的starter的执行原理\",{\"0\":{\"683\":1}}],[\"boot的自动配置是如何实现的\",{\"0\":{\"674\":1}}],[\"boot的最大优点就是为开发者屏蔽了底层框架的复杂性\",{\"1\":{\"665\":1}}],[\"boot还集成了许多第三方库配置\",{\"1\":{\"667\":1}}],[\"boot提供了内置的tomcat\",{\"1\":{\"667\":1}}],[\"boot提供的maven打包插件\",{\"1\":{\"104\":1}}],[\"boot几乎可以实现零配置\",{\"1\":{\"667\":1}}],[\"boot是spring和spring\",{\"1\":{\"667\":1}}],[\"boot与spring\",{\"0\":{\"667\":1}}],[\"boot跟spring\",{\"0\":{\"666\":1}}],[\"boot降低了入门门槛\",{\"1\":{\"665\":1}}],[\"boot为开发者导入项目所使用的框架设置好了默认配置\",{\"1\":{\"665\":1}}],[\"bootstrapclassloader\",{\"1\":{\"331\":2,\"332\":4,\"381\":4}}],[\"bootstrap\",{\"0\":{\"382\":1},\"1\":{\"156\":1,\"345\":1,\"381\":2,\"382\":1}}],[\"boot重新打包文件的输出目录\",{\"1\":{\"106\":1}}],[\"boot<\",{\"1\":{\"70\":1,\"106\":1,\"670\":1,\"671\":1,\"679\":3,\"680\":1,\"753\":5}}],[\"boot\",{\"0\":{\"104\":1,\"664\":1,\"665\":1,\"670\":1,\"673\":1,\"685\":1,\"686\":1,\"687\":1},\"1\":{\"70\":2,\"87\":1,\"103\":1,\"104\":2,\"105\":6,\"106\":5,\"382\":1,\"660\":1,\"661\":3,\"670\":1,\"671\":1,\"673\":1,\"674\":3,\"676\":1,\"679\":4,\"680\":1,\"682\":3,\"685\":4,\"686\":5,\"687\":1,\"753\":8,\"792\":2,\"830\":1}}],[\"bookmark即可\",{\"1\":{\"11\":1}}],[\"bookmarks\",{\"1\":{\"11\":1}}],[\"bookmark\",{\"1\":{\"11\":3}}],[\"b站\",{\"1\":{\"126\":1}}],[\"bytype\",{\"1\":{\"598\":1,\"599\":1,\"619\":1}}],[\"bytecodes\",{\"1\":{\"454\":1}}],[\"byte\",{\"1\":{\"424\":1}}],[\"bytes\",{\"1\":{\"410\":1}}],[\"byname\",{\"1\":{\"598\":1,\"599\":1,\"619\":1}}],[\"by\",{\"1\":{\"118\":5,\"244\":1}}],[\"byqanalyseserverapplication<\",{\"1\":{\"106\":1}}],[\"byqanalyseserver\",{\"1\":{\"106\":1}}],[\"between\",{\"1\":{\"844\":1}}],[\"betheme\",{\"1\":{\"140\":1}}],[\"begin\",{\"1\":{\"722\":2,\"723\":2}}],[\"before\",{\"1\":{\"577\":1,\"604\":1,\"605\":3}}],[\"be\",{\"1\":{\"515\":1}}],[\"bean循环依赖问题\",{\"0\":{\"621\":1}}],[\"bean注解使用示例\",{\"1\":{\"617\":1}}],[\"bean注解作用于方法\",{\"1\":{\"617\":1}}],[\"bean来实现\",{\"1\":{\"617\":1}}],[\"bean告诉了\",{\"1\":{\"617\":1}}],[\"bean以单实例的方式存在\",{\"1\":{\"615\":1}}],[\"beanpostprocessor去生成代理对象之后\",{\"1\":{\"622\":1}}],[\"beanpostprocessor\",{\"1\":{\"614\":2}}],[\"beanclassloaderaware\",{\"1\":{\"614\":1}}],[\"beannameaware\",{\"1\":{\"614\":1}}],[\"beannameautoproxycreator\",{\"1\":{\"604\":1}}],[\"bean的作用范围\",{\"0\":{\"615\":1}}],[\"bean的生命周期\",{\"0\":{\"614\":1}}],[\"bean的加载过程\",{\"0\":{\"613\":1}}],[\"beandefinition是一个接口\",{\"1\":{\"612\":1}}],[\"beandefinition\",{\"1\":{\"612\":3}}],[\"bean是什么\",{\"0\":{\"612\":1}}],[\"beanfactroy采用的是延迟加载形式来注入bean的\",{\"1\":{\"611\":1}}],[\"beanfactory对象的实例\",{\"1\":{\"614\":1}}],[\"beanfactoryaware\",{\"1\":{\"614\":1}}],[\"beanfactory需要手动注册\",{\"1\":{\"611\":1}}],[\"beanfactorypostprocessor的使用\",{\"1\":{\"611\":1}}],[\"beanfactory采取延迟加载\",{\"1\":{\"611\":1}}],[\"beanfactory和applicationcontext都支持beanpostprocessor\",{\"1\":{\"611\":1}}],[\"beanfactory和applicationcontext有什么区别\",{\"0\":{\"611\":1}}],[\"beanfactory和factorybean的区别\",{\"0\":{\"610\":1}}],[\"beanfactory\",{\"1\":{\"610\":1,\"612\":1}}],[\"beanfacotry加载后\",{\"1\":{\"611\":1}}],[\"bean名称自动代理创建器defaultadvisorautoproxycreator\",{\"1\":{\"604\":1}}],[\"bean\",{\"0\":{\"598\":1,\"617\":1,\"618\":1,\"619\":1},\"1\":{\"595\":1,\"599\":7,\"610\":4,\"612\":6,\"614\":18,\"615\":1,\"617\":8,\"618\":3,\"619\":3,\"638\":4,\"674\":1,\"687\":3,\"753\":1,\"754\":12,\"755\":3,\"757\":3,\"762\":4,\"768\":8,\"780\":3,\"788\":2,\"857\":1,\"860\":1,\"908\":1,\"909\":1}}],[\"beans>\",{\"1\":{\"617\":1}}],[\"beans<\",{\"1\":{\"87\":2,\"88\":1}}],[\"beans\",{\"1\":{\"85\":1,\"591\":1,\"754\":4,\"755\":1,\"762\":2}}],[\"bea被oracle收购\",{\"1\":{\"352\":1}}],[\"bea\",{\"0\":{\"352\":1},\"1\":{\"444\":1,\"445\":1,\"461\":1}}],[\"best\",{\"1\":{\"146\":1}}],[\"been\",{\"1\":{\"78\":1}}],[\"b\",{\"1\":{\"81\":5,\"82\":3,\"85\":3,\"91\":2,\"194\":4,\"234\":1,\"584\":3,\"821\":4,\"995\":2,\"998\":1,\"1004\":1,\"1024\":1}}],[\"baomidou\",{\"1\":{\"832\":1,\"836\":1}}],[\"baomidou<\",{\"1\":{\"70\":1,\"830\":1,\"863\":1}}],[\"bar\",{\"1\":{\"814\":2}}],[\"batchsize\",{\"1\":{\"723\":2}}],[\"basemapper<t>\",{\"1\":{\"832\":1}}],[\"basemapper<t>接口\",{\"0\":{\"832\":1}}],[\"baseresultmap\",{\"1\":{\"819\":1}}],[\"base\",{\"1\":{\"740\":2,\"989\":1,\"995\":1}}],[\"base的web项目\",{\"1\":{\"675\":1}}],[\"basic\",{\"1\":{\"717\":2,\"720\":1,\"745\":2}}],[\"basicqos\",{\"1\":{\"714\":2,\"717\":2}}],[\"basicrecover\",{\"1\":{\"706\":2}}],[\"basicreject\",{\"1\":{\"706\":3,\"749\":1}}],[\"basicnack\",{\"1\":{\"706\":2}}],[\"basicack\",{\"1\":{\"706\":2,\"708\":2,\"714\":1,\"717\":1,\"749\":1}}],[\"basicconsume\",{\"1\":{\"698\":3,\"701\":1,\"708\":2,\"714\":1,\"717\":1,\"747\":2,\"748\":1,\"749\":2,\"779\":1}}],[\"basicproperties\",{\"1\":{\"697\":2,\"747\":2,\"748\":2,\"779\":2}}],[\"basicpublish\",{\"1\":{\"697\":3,\"701\":1,\"702\":1,\"708\":1,\"711\":1,\"712\":2,\"722\":1,\"723\":1,\"729\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":1,\"748\":2,\"779\":2}}],[\"basicdatasource\",{\"1\":{\"628\":1}}],[\"bash\",{\"1\":{\"119\":1}}],[\"backqueue\",{\"1\":{\"768\":3}}],[\"backupbinding\",{\"1\":{\"768\":1}}],[\"backupexchange\",{\"1\":{\"768\":8}}],[\"backup\",{\"1\":{\"768\":9}}],[\"backedge\",{\"1\":{\"370\":1}}],[\"back\",{\"1\":{\"368\":1,\"762\":2}}],[\"backgroundremover\",{\"1\":{\"132\":1}}],[\"banner\",{\"1\":{\"140\":1}}],[\"baidu\",{\"1\":{\"41\":1}}],[\"bif=baz\",{\"1\":{\"577\":1}}],[\"bit\",{\"1\":{\"244\":1,\"410\":3}}],[\"bitcount\",{\"1\":{\"184\":2}}],[\"big\",{\"1\":{\"142\":1}}],[\"bilibili\",{\"1\":{\"126\":1}}],[\"bi<\",{\"1\":{\"70\":1}}],[\"binarytree\",{\"1\":{\"1038\":1}}],[\"binary\",{\"1\":{\"1029\":1,\"1034\":1}}],[\"binarysearch\",{\"1\":{\"230\":2,\"258\":1}}],[\"bind\",{\"1\":{\"754\":7,\"755\":1,\"757\":1,\"762\":5,\"768\":3,\"780\":1}}],[\"bindingdelayedqueue\",{\"1\":{\"757\":1}}],[\"bindingbuilder\",{\"1\":{\"754\":3,\"755\":1,\"757\":1,\"762\":1,\"768\":3,\"780\":1}}],[\"bindings\",{\"1\":{\"735\":1}}],[\"bindingkeyentry\",{\"1\":{\"738\":3,\"742\":3}}],[\"bindingkeymap\",{\"1\":{\"738\":6,\"742\":10}}],[\"bindingkey\",{\"1\":{\"729\":1,\"738\":3,\"742\":2,\"762\":1}}],[\"binding\",{\"1\":{\"420\":2,\"693\":3,\"731\":1,\"735\":1,\"754\":3,\"755\":1,\"757\":1,\"762\":1,\"768\":3,\"780\":1}}],[\"bingding\",{\"1\":{\"731\":1}}],[\"bin添加到path中\",{\"1\":{\"62\":1}}],[\"bin\",{\"1\":{\"60\":1,\"62\":1,\"1006\":3,\"1007\":1}}],[\"项目打包成两个\",{\"1\":{\"686\":1}}],[\"项目最终打包成的\",{\"1\":{\"686\":1}}],[\"项目\",{\"1\":{\"685\":1}}],[\"项目有以下三种类型\",{\"1\":{\"675\":1}}],[\"项目中一般这样实现\",{\"1\":{\"833\":1}}],[\"项目中如何进行aop配置\",{\"0\":{\"605\":1}}],[\"项目中遇到\",{\"0\":{\"100\":1}}],[\"项目中会有一些重要的\",{\"1\":{\"11\":1}}],[\"项目的配置文件\",{\"1\":{\"99\":1}}],[\"项目对象模型\",{\"1\":{\"67\":1}}],[\"项目提供构建和依赖管理支持的工具\",{\"1\":{\"59\":1}}],[\"项目总结及其他内容\",{\"1\":{\"1\":1}}],[\"给每个实现类配了个名字\",{\"1\":{\"893\":1}}],[\"给队列设置优先级\",{\"1\":{\"780\":1}}],[\"给生产者\",{\"1\":{\"719\":1}}],[\"给消息赋予一个\",{\"1\":{\"779\":1}}],[\"给消息赋予\",{\"1\":{\"697\":1}}],[\"给定如下二叉树\",{\"1\":{\"1038\":1}}],[\"给定一棵二叉树\",{\"1\":{\"1033\":1}}],[\"给定一个二叉树\",{\"1\":{\"1028\":1,\"1038\":1}}],[\"给定一个包含了一些\",{\"1\":{\"933\":1}}],[\"给定一个未经排序的整数数组\",{\"1\":{\"929\":1}}],[\"给定的树\",{\"1\":{\"1018\":2}}],[\"给定的树t\",{\"1\":{\"1018\":1}}],[\"给定的树s\",{\"1\":{\"1018\":1}}],[\"给定的矩阵grid\",{\"1\":{\"933\":1}}],[\"给定两个非空二叉树\",{\"1\":{\"1018\":1}}],[\"给定两个数字列表\",{\"1\":{\"549\":1}}],[\"给定整数数组\",{\"1\":{\"937\":1}}],[\"给定\",{\"1\":{\"549\":1}}],[\"给定价值与成本\",{\"1\":{\"206\":1}}],[\"给成员变量赋值\",{\"1\":{\"508\":1}}],[\"给对象中添加一个引用计数器\",{\"1\":{\"321\":1}}],[\"给代码创建书签\",{\"0\":{\"11\":1}}],[\"给选中的代码块增加if\",{\"1\":{\"6\":1}}],[\"rmi包实现\",{\"1\":{\"879\":1}}],[\"rmi\",{\"1\":{\"879\":1,\"888\":1}}],[\"rpc通信\",{\"1\":{\"887\":1}}],[\"rpc调用\",{\"1\":{\"879\":1}}],[\"rpc使用了哪些关键技术\",{\"0\":{\"878\":1}}],[\"rpc使得程序能够像访问本地系统资源一样\",{\"1\":{\"873\":1}}],[\"rpc的实现基础\",{\"0\":{\"877\":1}}],[\"rpc的优势会很明显\",{\"1\":{\"872\":1}}],[\"rpc和soa\",{\"0\":{\"875\":1}}],[\"rpc就是从一台机器\",{\"1\":{\"873\":1}}],[\"rpc一般配合netty框架\",{\"1\":{\"872\":1}}],[\"rpc框架需要解决的问题\",{\"0\":{\"876\":1}}],[\"rpc框架是一个强力的支撑\",{\"1\":{\"872\":1}}],[\"rpc框架的好处就显示出来了\",{\"1\":{\"872\":1}}],[\"rpc\",{\"0\":{\"871\":1,\"919\":1},\"1\":{\"873\":1,\"875\":1,\"879\":2,\"883\":2,\"919\":1}}],[\"rt\",{\"1\":{\"382\":1,\"392\":1}}],[\"ruby\",{\"1\":{\"363\":1}}],[\"running\",{\"1\":{\"515\":1,\"577\":1,\"670\":1}}],[\"runnable\",{\"1\":{\"266\":1}}],[\"run\",{\"1\":{\"99\":1,\"105\":1,\"687\":6,\"753\":1}}],[\"runtime\",{\"1\":{\"80\":1,\"343\":1,\"459\":1,\"482\":1,\"791\":1,\"792\":1}}],[\"roundrobin\",{\"1\":{\"916\":1}}],[\"routingkey\",{\"1\":{\"729\":1,\"735\":2,\"736\":1,\"738\":3,\"747\":1,\"748\":1,\"749\":1,\"757\":2,\"762\":14,\"765\":3}}],[\"routing\",{\"1\":{\"693\":2,\"697\":1,\"702\":1,\"740\":1,\"747\":2,\"748\":2,\"749\":2,\"754\":2,\"755\":1,\"757\":4}}],[\"row\",{\"1\":{\"944\":2}}],[\"rowbounds\",{\"1\":{\"817\":1}}],[\"rows\",{\"1\":{\"815\":3}}],[\"role\",{\"1\":{\"788\":1}}],[\"rollbackfor=exception\",{\"0\":{\"637\":1}}],[\"rollback\",{\"1\":{\"633\":1}}],[\"root\",{\"1\":{\"534\":1,\"864\":1,\"866\":2,\"1022\":6,\"1024\":27,\"1029\":11,\"1030\":11,\"1034\":2,\"1035\":3,\"1038\":1}}],[\"roots溯源\",{\"1\":{\"540\":1}}],[\"roots包括哪些元素\",{\"0\":{\"519\":1}}],[\"roots引用链的信息\",{\"1\":{\"450\":1}}],[\"roots相关联并导致垃圾收集器无法自动回收它们的\",{\"1\":{\"450\":1}}],[\"roots的引用链\",{\"1\":{\"450\":1}}],[\"roots\",{\"1\":{\"322\":3}}],[\"rotate\",{\"1\":{\"257\":1}}],[\"random\",{\"1\":{\"916\":1}}],[\"randomuuid\",{\"1\":{\"722\":1,\"723\":1}}],[\"randomaccess的源码如上\",{\"1\":{\"230\":1}}],[\"randomaccess\",{\"1\":{\"230\":3}}],[\"ram\",{\"1\":{\"717\":1}}],[\"rabbitconfig\",{\"1\":{\"754\":1}}],[\"rabbitlistener\",{\"1\":{\"754\":2,\"757\":2,\"762\":2,\"768\":2,\"780\":1}}],[\"rabbit\",{\"1\":{\"730\":1,\"740\":1,\"741\":6,\"742\":6,\"753\":1,\"754\":5,\"757\":1,\"762\":5,\"768\":1}}],[\"rabbit工厂配置信息\",{\"1\":{\"701\":1}}],[\"rabbitmq插件实现延迟队列\",{\"0\":{\"756\":1}}],[\"rabbitmqapplication\",{\"1\":{\"753\":3}}],[\"rabbitmq持久化\",{\"0\":{\"710\":1}}],[\"rabbitmqutils\",{\"1\":{\"701\":6,\"708\":4,\"711\":2,\"712\":1,\"714\":1,\"717\":1,\"722\":2,\"723\":2,\"734\":2,\"738\":2,\"742\":2,\"747\":6,\"748\":2,\"749\":2,\"779\":4}}],[\"rabbitmq<\",{\"1\":{\"696\":1}}],[\"rabbitmq的概念\",{\"0\":{\"691\":1}}],[\"rabbitmq\",{\"0\":{\"690\":1,\"694\":1,\"695\":1,\"703\":1,\"726\":1,\"743\":1,\"750\":1,\"759\":1,\"769\":1,\"785\":1,\"786\":1},\"1\":{\"690\":1,\"691\":3,\"692\":3,\"693\":3,\"695\":1,\"696\":1,\"697\":10,\"698\":3,\"701\":9,\"702\":1,\"704\":3,\"706\":1,\"707\":1,\"708\":4,\"710\":2,\"711\":2,\"712\":1,\"714\":4,\"717\":3,\"719\":2,\"722\":1,\"723\":1,\"725\":3,\"727\":1,\"734\":1,\"738\":2,\"742\":2,\"744\":1,\"747\":9,\"752\":1,\"753\":3,\"754\":8,\"755\":1,\"756\":19,\"758\":3,\"759\":3,\"762\":2,\"764\":2,\"765\":2,\"767\":2,\"776\":1,\"779\":5,\"782\":4}}],[\"rabbittemplate\",{\"1\":{\"10\":2,\"752\":1,\"753\":1,\"754\":10,\"755\":5,\"757\":3,\"762\":9,\"764\":2,\"765\":8,\"780\":1}}],[\"r\",{\"1\":{\"27\":1,\"944\":4,\"984\":2,\"1029\":4}}],[\"redis注册中心\",{\"1\":{\"897\":1}}],[\"redis\",{\"1\":{\"758\":1,\"774\":2,\"776\":2,\"878\":1,\"888\":1}}],[\"redis等多种\",{\"1\":{\"798\":1}}],[\"redis等\",{\"1\":{\"667\":1}}],[\"reject\",{\"1\":{\"706\":2,\"745\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"275\":1}}],[\"requeue\",{\"1\":{\"706\":6,\"745\":1,\"749\":1}}],[\"requestmethod\",{\"1\":{\"792\":2}}],[\"requestmethods\",{\"1\":{\"788\":3}}],[\"requestmethodenum\",{\"1\":{\"788\":15}}],[\"requestmappinghandlermapping是在dispatcherservlet的初始化过程中自动加载的\",{\"1\":{\"789\":1}}],[\"requestmappinghandlermapping\",{\"0\":{\"789\":1},\"1\":{\"788\":1}}],[\"requestmapping\",{\"1\":{\"651\":2,\"754\":2,\"755\":1,\"757\":1,\"762\":2,\"765\":1,\"792\":16}}],[\"requestparam\",{\"1\":{\"651\":2,\"673\":1}}],[\"requestbody\",{\"1\":{\"651\":1,\"673\":1}}],[\"request\",{\"1\":{\"612\":1,\"615\":1,\"648\":1,\"649\":1,\"788\":3}}],[\"requirenonnull\",{\"1\":{\"788\":1}}],[\"requires\",{\"1\":{\"635\":2}}],[\"required\",{\"1\":{\"599\":2,\"635\":3,\"651\":2}}],[\"res长度也为0\",{\"1\":{\"1034\":1}}],[\"res就是最终的最大值\",{\"1\":{\"1023\":1}}],[\"res\",{\"1\":{\"939\":4,\"1022\":4,\"1034\":4,\"1035\":4}}],[\"result\",{\"1\":{\"832\":1,\"846\":1,\"847\":1,\"848\":1,\"851\":1,\"854\":2,\"975\":5}}],[\"resultmapping\",{\"1\":{\"822\":1}}],[\"resultmap\",{\"1\":{\"822\":1}}],[\"resultmap>\",{\"1\":{\"820\":1}}],[\"resultmap=\",{\"1\":{\"819\":1}}],[\"resulttype=\",{\"1\":{\"819\":1}}],[\"resultsethandler\",{\"1\":{\"818\":1}}],[\"resultset\",{\"1\":{\"817\":1}}],[\"restore\",{\"1\":{\"975\":1}}],[\"rest相比rpc更为灵活\",{\"1\":{\"887\":1}}],[\"rest\",{\"1\":{\"875\":2}}],[\"rest的区别\",{\"0\":{\"875\":1}}],[\"restcontroller\",{\"1\":{\"673\":1,\"754\":2,\"755\":1,\"757\":1,\"762\":2,\"765\":1,\"780\":1}}],[\"restful\",{\"1\":{\"673\":1}}],[\"restart\",{\"1\":{\"670\":1,\"756\":1}}],[\"restarting\",{\"1\":{\"577\":1}}],[\"responsebody\",{\"1\":{\"651\":1}}],[\"response\",{\"1\":{\"648\":1,\"649\":1}}],[\"reset\",{\"1\":{\"587\":1}}],[\"resource\",{\"1\":{\"673\":1}}],[\"resource注解\",{\"1\":{\"609\":1}}],[\"resource或\",{\"1\":{\"601\":1}}],[\"resource进行替代\",{\"1\":{\"600\":1}}],[\"resources\",{\"1\":{\"94\":2,\"99\":2,\"382\":1,\"788\":1}}],[\"resourcesprocess\",{\"1\":{\"94\":2}}],[\"resolved\",{\"1\":{\"78\":1}}],[\"registrydirectory\",{\"1\":{\"890\":1}}],[\"registry\",{\"1\":{\"670\":1,\"673\":2,\"882\":1,\"885\":1}}],[\"register\",{\"0\":{\"399\":1},\"1\":{\"883\":1}}],[\"region\",{\"1\":{\"535\":2}}],[\"receivewarningmsg\",{\"1\":{\"768\":1}}],[\"receivemsg\",{\"1\":{\"762\":1}}],[\"receivedelayedqueue\",{\"1\":{\"757\":1}}],[\"received\",{\"1\":{\"754\":1,\"780\":1}}],[\"receivedmessage\",{\"1\":{\"701\":2}}],[\"receivelogs02\",{\"1\":{\"734\":1}}],[\"receivelogs01\",{\"1\":{\"734\":1}}],[\"records\",{\"1\":{\"832\":1}}],[\"record\",{\"1\":{\"832\":1}}],[\"recorder\",{\"1\":{\"492\":1}}],[\"recover\",{\"1\":{\"706\":1}}],[\"recursively\",{\"1\":{\"21\":1}}],[\"recur\",{\"1\":{\"21\":1}}],[\"reflection\",{\"1\":{\"614\":1}}],[\"reflect包中的两个类\",{\"1\":{\"603\":1}}],[\"ref\",{\"1\":{\"397\":3}}],[\"referenceconfig\",{\"1\":{\"883\":1}}],[\"referencequeue\",{\"1\":{\"326\":1,\"327\":1,\"328\":1}}],[\"reference\",{\"1\":{\"91\":1,\"315\":5,\"415\":1,\"417\":1,\"479\":1,\"901\":2,\"911\":1}}],[\"reentrantlock类当然也可以实现\",{\"1\":{\"286\":1}}],[\"reentrantlock类的reentrantlock\",{\"1\":{\"286\":1}}],[\"reentrantlock默认情况是非公平的\",{\"1\":{\"286\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"286\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"286\":1}}],[\"reentrantlock增加了一些高级功能\",{\"1\":{\"286\":1}}],[\"reentrantlock\",{\"0\":{\"285\":1,\"286\":1},\"1\":{\"251\":2,\"282\":1,\"285\":1,\"292\":1}}],[\"rehash\",{\"1\":{\"247\":1}}],[\"read\",{\"1\":{\"587\":1,\"634\":4}}],[\"readobject\",{\"1\":{\"240\":1}}],[\"reached\",{\"1\":{\"515\":1}}],[\"reactive\",{\"1\":{\"675\":1}}],[\"react\",{\"0\":{\"156\":1},\"1\":{\"156\":1}}],[\"reactor\",{\"1\":{\"91\":1}}],[\"reverselist\",{\"1\":{\"968\":1,\"969\":2,\"970\":3,\"975\":3}}],[\"reverse\",{\"1\":{\"235\":1,\"257\":1,\"975\":1}}],[\"relation\",{\"1\":{\"204\":2,\"205\":2}}],[\"releases\",{\"1\":{\"110\":1}}],[\"release版本需要maven版本在2\",{\"1\":{\"104\":1}}],[\"release<\",{\"1\":{\"87\":6,\"106\":1,\"671\":1}}],[\"release\",{\"1\":{\"65\":1,\"85\":5,\"292\":1}}],[\"retentionpolicy\",{\"1\":{\"791\":1,\"792\":1}}],[\"retention\",{\"1\":{\"791\":1,\"792\":1}}],[\"ret\",{\"1\":{\"189\":4,\"190\":4}}],[\"returned\",{\"1\":{\"765\":6}}],[\"returnedmessage\",{\"1\":{\"765\":3}}],[\"returncallback\",{\"1\":{\"765\":2}}],[\"returning\",{\"1\":{\"604\":1}}],[\"returnscallback\",{\"1\":{\"764\":1,\"765\":2}}],[\"returns\",{\"1\":{\"239\":1,\"242\":2,\"765\":1}}],[\"return\",{\"1\":{\"184\":1,\"186\":2,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"194\":2,\"198\":2,\"199\":3,\"200\":2,\"201\":2,\"202\":5,\"203\":2,\"204\":1,\"205\":1,\"207\":1,\"230\":2,\"234\":1,\"239\":1,\"241\":3,\"242\":1,\"244\":2,\"253\":1,\"317\":1,\"414\":1,\"424\":1,\"617\":4,\"687\":1,\"701\":1,\"752\":1,\"754\":10,\"755\":3,\"757\":4,\"762\":3,\"768\":8,\"780\":4,\"788\":3,\"819\":1,\"832\":3,\"857\":1,\"859\":1,\"860\":1,\"901\":1,\"925\":2,\"931\":2,\"934\":2,\"938\":1,\"939\":1,\"943\":2,\"944\":2,\"948\":1,\"949\":2,\"954\":2,\"957\":4,\"963\":2,\"965\":1,\"968\":1,\"969\":2,\"973\":2,\"975\":5,\"982\":2,\"983\":3,\"984\":4,\"1020\":5,\"1022\":3,\"1024\":7,\"1029\":7,\"1030\":2,\"1034\":2,\"1035\":2,\"1040\":2}}],[\"remoting\",{\"1\":{\"885\":1}}],[\"remoting层\",{\"1\":{\"883\":1}}],[\"remote\",{\"1\":{\"873\":1,\"879\":1}}],[\"removenthfromend\",{\"1\":{\"963\":1}}],[\"removelast\",{\"1\":{\"229\":1}}],[\"removefirst\",{\"1\":{\"229\":1}}],[\"remove\",{\"1\":{\"132\":1,\"139\":1,\"186\":1,\"194\":2,\"229\":1,\"233\":1,\"833\":1,\"944\":1}}],[\"remixicon\",{\"1\":{\"139\":1}}],[\"repeatedcharacter\",{\"1\":{\"948\":1,\"949\":1}}],[\"repeatable\",{\"1\":{\"634\":1}}],[\"replytext\",{\"1\":{\"765\":3}}],[\"replycode\",{\"1\":{\"765\":3}}],[\"replaced\",{\"1\":{\"619\":1}}],[\"replaceall\",{\"1\":{\"258\":1}}],[\"rep1acement\",{\"1\":{\"368\":1}}],[\"repackage目标\",{\"0\":{\"106\":1}}],[\"repackage\",{\"1\":{\"105\":2}}],[\"repositories\",{\"1\":{\"1008\":1,\"1009\":2}}],[\"repository\",{\"1\":{\"15\":1,\"61\":2,\"618\":1,\"1008\":1}}],[\"repo\",{\"1\":{\"1007\":1,\"1009\":1}}],[\"repobeats\",{\"1\":{\"127\":1}}],[\"reports\",{\"1\":{\"75\":1}}],[\"rightsideview\",{\"1\":{\"1034\":1,\"1035\":1}}],[\"rightdepth\",{\"1\":{\"1022\":4}}],[\"right\",{\"1\":{\"6\":1,\"1020\":3,\"1022\":1,\"1024\":10,\"1029\":3,\"1030\":1,\"1034\":2,\"1035\":2}}],[\"如代码所示\",{\"1\":{\"970\":1}}],[\"如加了服务可restful调用\",{\"1\":{\"914\":1}}],[\"如对服务提供\",{\"1\":{\"881\":1}}],[\"如kryo\",{\"1\":{\"878\":2}}],[\"如丝般顺滑\",{\"1\":{\"827\":1}}],[\"如互联网项目\",{\"1\":{\"806\":1}}],[\"如优先级\",{\"1\":{\"702\":1}}],[\"如在消费的时候队列被删除掉了\",{\"1\":{\"698\":1,\"779\":1}}],[\"如你想使用spring\",{\"1\":{\"682\":1}}],[\"如常用的mysql\",{\"1\":{\"664\":1}}],[\"如用户是否已经登录\",{\"1\":{\"648\":1}}],[\"如通过一个jsp路径返回一个真正的jsp页面\",{\"1\":{\"646\":1}}],[\"如ioc容器\",{\"1\":{\"644\":1}}],[\"如iso\",{\"1\":{\"573\":1}}],[\"如applicationlistener\",{\"1\":{\"630\":1}}],[\"如arraylist\",{\"1\":{\"230\":1}}],[\"如yyyy\",{\"1\":{\"573\":1}}],[\"如时分秒\",{\"1\":{\"568\":1}}],[\"如集合\",{\"1\":{\"547\":1}}],[\"如此一来\",{\"1\":{\"523\":1}}],[\"如上方代码\",{\"1\":{\"852\":1}}],[\"如上方的使用形式\",{\"1\":{\"569\":1}}],[\"如上两图\",{\"1\":{\"487\":1}}],[\"如上图的层序遍历就是\",{\"1\":{\"1024\":1}}],[\"如上图所示\",{\"1\":{\"737\":1}}],[\"如上图\",{\"1\":{\"19\":1,\"1024\":1}}],[\"如文本字符串\",{\"1\":{\"464\":1}}],[\"如eclipse\",{\"1\":{\"450\":1}}],[\"如运行时常量池\",{\"1\":{\"441\":1}}],[\"如操作系统或某些硬件交换信息时的情况\",{\"1\":{\"435\":1}}],[\"如递归不写退出条件时\",{\"1\":{\"428\":1}}],[\"如本地方法调用\",{\"1\":{\"389\":1}}],[\"如是否启用偏向锁等\",{\"1\":{\"313\":1}}],[\"如无可回收\",{\"1\":{\"291\":1}}],[\"如自旋锁\",{\"1\":{\"278\":1}}],[\"如1024\",{\"1\":{\"253\":1}}],[\"如使用\",{\"1\":{\"249\":1}}],[\"如linkedlist\",{\"1\":{\"230\":1}}],[\"如何判断一个节点的子树是否和\",{\"1\":{\"1019\":1}}],[\"如何判断一个类是无用的类\",{\"0\":{\"329\":1}}],[\"如何设计\",{\"0\":{\"919\":1}}],[\"如何更高效地对请求对象和响应结果进行序列化和反序列化操作\",{\"1\":{\"876\":1}}],[\"如何更高效地进行网络通信\",{\"1\":{\"876\":1}}],[\"如何确定客户端和服务端之间的通信协议\",{\"1\":{\"876\":1}}],[\"如何配置\",{\"1\":{\"859\":1}}],[\"如何实现呢\",{\"1\":{\"854\":1}}],[\"如何实现价值最大化的问题\",{\"1\":{\"206\":1}}],[\"如何获取自动生成的\",{\"0\":{\"815\":1}}],[\"如何快速地配置接口访问规则\",{\"1\":{\"787\":1}}],[\"如何才能进行\",{\"1\":{\"759\":1}}],[\"如何才能找到类的元数据信息\",{\"1\":{\"313\":1}}],[\"如何在\",{\"0\":{\"687\":1}}],[\"如何开启注解处理器和适配器\",{\"0\":{\"652\":1}}],[\"如何开启基于注解的自动装配\",{\"0\":{\"599\":1}}],[\"如何做异常处理\",{\"0\":{\"650\":1}}],[\"如何让sessionfactory在执行数据持久化的时候\",{\"1\":{\"628\":1}}],[\"如何解决循环依赖\",{\"1\":{\"621\":1}}],[\"如何解决\",{\"0\":{\"621\":1}}],[\"如何解决这些oom\",{\"0\":{\"450\":1}}],[\"如何处理异步未确认消息\",{\"1\":{\"724\":1}}],[\"如何处理\",{\"0\":{\"620\":1}}],[\"如何返回所有的数对呢\",{\"1\":{\"549\":1}}],[\"如何回收\",{\"1\":{\"515\":1}}],[\"如何将堆上的对象分配到栈\",{\"1\":{\"506\":1}}],[\"如何查看设置的参数\",{\"0\":{\"487\":1}}],[\"如何查看当前\",{\"0\":{\"449\":1}}],[\"如何保证分毫无差呢\",{\"1\":{\"402\":2}}],[\"如何自定义类加载器\",{\"0\":{\"387\":1}}],[\"如何选择合适的垃圾收集算法\",{\"1\":{\"518\":1}}],[\"如何选择\",{\"0\":{\"368\":1}}],[\"如何选用集合\",{\"0\":{\"216\":1}}],[\"如何检查重复\",{\"0\":{\"242\":1}}],[\"如n小时前\",{\"1\":{\"159\":1}}],[\"如jar\",{\"1\":{\"94\":1}}],[\"如pro01\",{\"1\":{\"77\":1}}],[\"如下放代码所示\",{\"1\":{\"949\":1}}],[\"如下方的最后一行\",{\"1\":{\"835\":1}}],[\"如下方的配置\",{\"1\":{\"788\":1}}],[\"如下方的distinct\",{\"1\":{\"548\":1}}],[\"如下方的filter\",{\"1\":{\"548\":1}}],[\"如下方代码\",{\"1\":{\"549\":1}}],[\"如下方代码所示\",{\"1\":{\"546\":1,\"549\":2,\"853\":1,\"1009\":1}}],[\"如下方代码中的\",{\"1\":{\"317\":1}}],[\"如下所示\",{\"1\":{\"77\":1,\"83\":1,\"202\":1,\"371\":1,\"381\":1,\"571\":1,\"687\":1,\"792\":1}}],[\"如下图所示\",{\"1\":{\"596\":1}}],[\"如下图第3行\",{\"1\":{\"569\":1}}],[\"如下图\",{\"1\":{\"18\":1,\"21\":1,\"41\":1,\"548\":1,\"974\":3,\"1023\":1}}],[\"如果深度\",{\"1\":{\"1034\":1}}],[\"如果中序遍历得到的节点的值小于等于前一个\",{\"1\":{\"1030\":1}}],[\"如果都满足才说明这是一棵二叉搜索树\",{\"1\":{\"1029\":1}}],[\"如果都相同\",{\"1\":{\"737\":1}}],[\"如果该二叉树的左子树不为空\",{\"1\":{\"1029\":1}}],[\"如果该类下有main方法\",{\"1\":{\"393\":1}}],[\"如果最左下节点无右子树\",{\"1\":{\"1024\":1}}],[\"如果根节点存在左子树\",{\"1\":{\"1024\":1}}],[\"如果下载缓慢\",{\"1\":{\"1004\":1}}],[\"如果下一个格子在范围内\",{\"1\":{\"944\":1}}],[\"如果下一个数比前面的数大\",{\"1\":{\"930\":1,\"1039\":1}}],[\"如果您的序列包含空值\",{\"1\":{\"989\":1}}],[\"如果装过了z升水\",{\"1\":{\"983\":1}}],[\"如果所有状态都执行了还是没得到z\",{\"1\":{\"982\":1}}],[\"如果所有的消费者都没有完成手上任务\",{\"1\":{\"714\":1}}],[\"如果会倒满\",{\"1\":{\"982\":2}}],[\"如果可以\",{\"1\":{\"981\":1}}],[\"如果即将传染的橘子腐烂值是4\",{\"1\":{\"943\":1}}],[\"如果即时编译出现问题\",{\"1\":{\"371\":1}}],[\"如果此时还有1\",{\"1\":{\"943\":1}}],[\"如果此时其他消费者可以处理\",{\"1\":{\"707\":1}}],[\"如果过程中遇到了腐烂值>当前腐烂值+1的场景\",{\"1\":{\"943\":1}}],[\"如果过期则丢到死信队列\",{\"1\":{\"755\":1}}],[\"如果i处元素大于j处元素\",{\"1\":{\"925\":1}}],[\"如果让你设计一个\",{\"0\":{\"919\":1}}],[\"如果where语句中的version版本不对\",{\"1\":{\"860\":1}}],[\"如果user类里的age字段改名\",{\"1\":{\"853\":1}}],[\"如果name为null或空字符串\",{\"1\":{\"852\":1}}],[\"如果n是奇数则n+1\",{\"1\":{\"198\":1}}],[\"如果更新条件为\",{\"1\":{\"848\":1}}],[\"如果表里id列名为uid\",{\"1\":{\"836\":1}}],[\"如果支持\",{\"0\":{\"821\":1}}],[\"如果采用自增长策略\",{\"1\":{\"815\":1}}],[\"如果采用固定大小的java虚拟机栈\",{\"1\":{\"409\":1}}],[\"如果开启了二级缓存\",{\"1\":{\"813\":1}}],[\"如果既不想丢失消息\",{\"1\":{\"767\":1}}],[\"如果多出了如图所示\",{\"1\":{\"756\":1}}],[\"如果这样使用的话\",{\"1\":{\"754\":1}}],[\"如果这时候队列满了\",{\"1\":{\"277\":1}}],[\"如果同时配置了队列的\",{\"1\":{\"752\":1}}],[\"如果账单一周内未支付则进行自动结算\",{\"1\":{\"751\":1}}],[\"如果数据量比较少\",{\"1\":{\"751\":1}}],[\"如果三天内没有得到处理则通知相关运营人员\",{\"1\":{\"751\":1}}],[\"如果三天内没有登陆则进行短信提醒\",{\"1\":{\"751\":1}}],[\"如果队列绑定键当中没有\",{\"1\":{\"741\":1}}],[\"如果队列满了\",{\"1\":{\"277\":1}}],[\"如果完全匹配则消息会路由到该队列\",{\"1\":{\"728\":1}}],[\"如果rabbitmq\",{\"1\":{\"720\":1}}],[\"如果消息为\",{\"1\":{\"778\":1}}],[\"如果消息成功发布确认到交换机\",{\"1\":{\"761\":1}}],[\"如果消息和队列是可持久化的\",{\"1\":{\"720\":1}}],[\"如果消费方超时\",{\"1\":{\"918\":1}}],[\"如果消费成功\",{\"1\":{\"747\":1}}],[\"如果消费者由于某些原因失去连接\",{\"1\":{\"707\":1}}],[\"如果取值为\",{\"1\":{\"717\":1}}],[\"如果之前处理过这个状态\",{\"1\":{\"982\":1}}],[\"如果之前声明的队列不是持久化的\",{\"1\":{\"711\":1}}],[\"如果之后空间还不足\",{\"1\":{\"495\":1}}],[\"如果重启的化\",{\"1\":{\"711\":1}}],[\"如果设置了队列的\",{\"1\":{\"752\":1}}],[\"如果设置了该值自动将required设置为false\",{\"1\":{\"651\":1}}],[\"如果设置太高比较吃内存和\",{\"1\":{\"697\":1,\"777\":1,\"779\":1}}],[\"如果应用程序支持多线程\",{\"1\":{\"693\":1}}],[\"如果每一次访问\",{\"1\":{\"693\":1}}],[\"如果启动的时候有多个applicationrunner和commandlinerunner\",{\"1\":{\"687\":1}}],[\"如果非要引用\",{\"1\":{\"686\":1}}],[\"如果整个过程出现异常\",{\"1\":{\"678\":1}}],[\"如果s为null\",{\"1\":{\"1019\":1}}],[\"如果springapplication的showbanner属性被设置为true\",{\"1\":{\"678\":1}}],[\"如果survivor区中相同年龄的所有对象大小的总和大于survivor空间的一半\",{\"1\":{\"498\":1}}],[\"如果满足条件\",{\"1\":{\"674\":1}}],[\"如果认证通过表示当前用户没有登陆\",{\"1\":{\"656\":1}}],[\"如果参数中没有包含该参数则使用默认值\",{\"1\":{\"651\":1}}],[\"如果类加了这个注解\",{\"1\":{\"637\":1}}],[\"如果将\",{\"1\":{\"752\":1}}],[\"如果将应用程序自己的工厂对象交给spring管理\",{\"1\":{\"625\":1}}],[\"如果将该算法应用于顺序访问列表\",{\"1\":{\"230\":1}}],[\"如果配置文件中的配置信息不要求使用单例\",{\"1\":{\"616\":1}}],[\"如果配置了死信队列被丢到死信队列中\",{\"1\":{\"752\":1}}],[\"如果配置了destroy\",{\"1\":{\"614\":1}}],[\"如果配置了init\",{\"1\":{\"614\":1}}],[\"如果有的扩展很耗时\",{\"1\":{\"909\":1}}],[\"如果有更新\",{\"1\":{\"906\":1}}],[\"如果有消息进入该队列\",{\"1\":{\"757\":1}}],[\"如果有\",{\"1\":{\"678\":1}}],[\"如果有和加载这个\",{\"1\":{\"614\":2}}],[\"如果有返回true\",{\"1\":{\"290\":1}}],[\"如果涉及到一些属性值\",{\"1\":{\"614\":1}}],[\"如果bean实现了disposablebean接口\",{\"1\":{\"614\":1}}],[\"如果bean的某一个属性没有注入\",{\"1\":{\"611\":1}}],[\"如果实体类中的属性名和字段名不一致的情况\",{\"1\":{\"837\":1}}],[\"如果实现了其他\",{\"1\":{\"614\":1}}],[\"如果实现了beanpostprocessor接口\",{\"1\":{\"614\":1}}],[\"如果实现了beannameaware接口\",{\"1\":{\"613\":1}}],[\"如果实现了xxxaware接口\",{\"1\":{\"614\":1}}],[\"如果实现applicationcontextaware\",{\"1\":{\"613\":1}}],[\"如果实现beanfactoryaware接口\",{\"1\":{\"613\":1}}],[\"如果实例成员变量是引用变量\",{\"1\":{\"471\":1}}],[\"如果proxy\",{\"1\":{\"603\":1}}],[\"如果上述查找的结果为空\",{\"1\":{\"601\":1}}],[\"如果查询的结果不止一个\",{\"1\":{\"601\":1}}],[\"如果查询结果刚好为一个\",{\"1\":{\"601\":1}}],[\"如果没找到的话就报错\",{\"1\":{\"598\":2}}],[\"如果没有岛屿\",{\"1\":{\"933\":1}}],[\"如果没有成功发布\",{\"1\":{\"761\":1}}],[\"如果没有对应的消费者接收\",{\"1\":{\"734\":1}}],[\"如果没有则不用事务\",{\"1\":{\"635\":1}}],[\"如果没有分代\",{\"1\":{\"497\":1}}],[\"如果没有回收\",{\"1\":{\"490\":1}}],[\"如果没有找到文件\",{\"1\":{\"470\":1}}],[\"如果没有太过于复杂的需求\",{\"1\":{\"387\":1}}],[\"如果没有静态变量的赋值以及没有静态代码块\",{\"1\":{\"380\":1}}],[\"如果没有使用双亲委派模型\",{\"1\":{\"333\":1}}],[\"如果没有\",{\"1\":{\"310\":1,\"318\":1,\"470\":1,\"509\":1}}],[\"如果没有返回false\",{\"1\":{\"290\":1}}],[\"如果没有被重写\",{\"1\":{\"242\":1}}],[\"如果没有重写\",{\"1\":{\"242\":1}}],[\"如果没有相符的\",{\"1\":{\"242\":1}}],[\"如果没有指定\",{\"1\":{\"106\":1}}],[\"如果利用\",{\"1\":{\"595\":1}}],[\"如果超过一个过滤\",{\"1\":{\"577\":1}}],[\"如果只返回总和能被3整除的数对呢\",{\"1\":{\"549\":1}}],[\"如果流中元素不足n个\",{\"1\":{\"548\":1}}],[\"如果limit方法的参数超过了流中元素的数量\",{\"1\":{\"548\":1}}],[\"如果指定了\",{\"1\":{\"532\":1}}],[\"如果一条消息设置了\",{\"1\":{\"752\":1}}],[\"如果一次性将所有的垃圾进行处理\",{\"1\":{\"526\":1}}],[\"如果一个队列同时使用这两种方式设置的话\",{\"1\":{\"783\":1}}],[\"如果一个队列绑定到该交换机上要求路由键\",{\"1\":{\"728\":1}}],[\"如果一个工作队列还没有处理完或者没有应答签收一个消息\",{\"1\":{\"714\":1}}],[\"如果一个\",{\"1\":{\"618\":1}}],[\"如果一个类型是由用户类加载器加载的\",{\"1\":{\"396\":1}}],[\"如果一个类加载器收到了类加载请求\",{\"1\":{\"391\":1}}],[\"如果一个对象被发现只能从一个线程被访问到\",{\"1\":{\"507\":1}}],[\"如果一个对象在子程序中被分配\",{\"1\":{\"507\":1}}],[\"如果一个对象仅持有虚引用\",{\"1\":{\"328\":1}}],[\"如果一个对象只具有弱引用\",{\"1\":{\"327\":1}}],[\"如果一个对象只具有软引用\",{\"1\":{\"326\":1}}],[\"如果一个对象具有强引用\",{\"1\":{\"325\":1}}],[\"如果一个线程获得了锁\",{\"1\":{\"278\":1}}],[\"如果垃圾回收时间过长\",{\"1\":{\"526\":1}}],[\"如果垃圾收集器选择的是\",{\"1\":{\"471\":1}}],[\"如果依然使用复制算法\",{\"1\":{\"523\":1}}],[\"如果系统中的垃圾对象很多\",{\"1\":{\"522\":1}}],[\"如果系统定义了太多的类\",{\"1\":{\"442\":1}}],[\"如果够\",{\"1\":{\"521\":1}}],[\"如果发现是大客户的订单给一个相对比较高的优先级\",{\"1\":{\"776\":1}}],[\"如果发现消息无法进行路由\",{\"1\":{\"765\":1}}],[\"如果发现该消息不可路由\",{\"1\":{\"764\":1}}],[\"如果发现某个对象在其header中没有标记为可达对象\",{\"1\":{\"521\":1}}],[\"如果发现它还有虚引用\",{\"1\":{\"328\":1}}],[\"如果经过逃逸分析\",{\"1\":{\"505\":1,\"510\":1}}],[\"如果handlepromotionfailure=false\",{\"1\":{\"504\":1}}],[\"如果handlepromotionfailure=true\",{\"1\":{\"504\":1}}],[\"如果小于\",{\"1\":{\"504\":2}}],[\"如果大于\",{\"1\":{\"504\":2}}],[\"如果分代的话\",{\"1\":{\"497\":1}}],[\"如果majorgc后\",{\"1\":{\"495\":1}}],[\"如果再次经历垃圾回收\",{\"1\":{\"490\":1}}],[\"如果再次触发垃圾回收\",{\"1\":{\"490\":1}}],[\"如果内存不是规整的\",{\"1\":{\"471\":1}}],[\"如果内存不规整\",{\"1\":{\"471\":1}}],[\"如果内存是规整的\",{\"1\":{\"471\":1}}],[\"如果内存规整\",{\"1\":{\"471\":1}}],[\"如果内存空间不足了\",{\"1\":{\"326\":1}}],[\"如果内存空间足够\",{\"1\":{\"326\":1}}],[\"如果找到的话就是用构造器自动装配\",{\"1\":{\"598\":1}}],[\"如果找到的话\",{\"1\":{\"598\":2}}],[\"如果找到\",{\"1\":{\"470\":1}}],[\"如果动态加载类过多\",{\"1\":{\"462\":1}}],[\"如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值\",{\"1\":{\"459\":1}}],[\"如果初始化的高水位线设置过低\",{\"1\":{\"448\":1}}],[\"如果释放空间过多\",{\"1\":{\"448\":1}}],[\"如果释放的空间不足\",{\"1\":{\"448\":1}}],[\"如果元数据区发生溢出\",{\"1\":{\"448\":1}}],[\"如果jvm产品不打算支持native方法\",{\"1\":{\"437\":1}}],[\"如果java虚拟机栈可以动态扩展\",{\"1\":{\"409\":1}}],[\"如果本地方法栈可以动态扩展\",{\"1\":{\"437\":1}}],[\"如果我们使用的是springapplication的静态run方法\",{\"1\":{\"678\":1}}],[\"如果我们想禁用某些自动配置特性\",{\"1\":{\"676\":1}}],[\"如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话\",{\"1\":{\"600\":1}}],[\"如果我们没有注入的话\",{\"1\":{\"600\":1}}],[\"如果我们仅需要注入int\",{\"1\":{\"600\":1}}],[\"如果我们要使用一些java语言本身没有提供封装的操作系统的特性时\",{\"1\":{\"435\":1}}],[\"如果我想让其他线程执行完指定程序\",{\"1\":{\"292\":1}}],[\"如果始终没有找到合适的方法\",{\"1\":{\"422\":1}}],[\"如果通过则返回这个方法的直接引用\",{\"1\":{\"422\":1}}],[\"如果方法区无法满足新的内存分配需求时\",{\"1\":{\"445\":1}}],[\"如果方法区域中的内存无法用于满足分配请求\",{\"1\":{\"441\":1}}],[\"如果方法在编译期就确定了具体的调用版本\",{\"1\":{\"421\":1}}],[\"如果方法的调用次数仍然不足以让它提交给即时编译器编译\",{\"1\":{\"369\":1}}],[\"如果被非懒加载的bean依赖了那么其实也就不能懒加载了\",{\"1\":{\"619\":1}}],[\"如果被调用的方法在编译期无法被确定下来\",{\"1\":{\"419\":1,\"420\":1}}],[\"如果被调用的方法带有返回值的话\",{\"1\":{\"416\":1}}],[\"如果被调用的目标方法在编译期可知\",{\"1\":{\"419\":1}}],[\"如果被请求的共享资源被占用\",{\"1\":{\"289\":1}}],[\"如果被请求的共享资源空闲\",{\"1\":{\"289\":1}}],[\"如果在消费者端设置了超时时间\",{\"1\":{\"918\":1}}],[\"如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒\",{\"1\":{\"776\":1}}],[\"如果在十天内都没有上传过商品\",{\"1\":{\"751\":1}}],[\"如果在指定时间范围内这个消息没有被确认那么它将抛出异常\",{\"1\":{\"722\":1}}],[\"如果在某个handlermapping中配置拦截\",{\"1\":{\"656\":1}}],[\"如果在bean内部没有找到相应的构造器或者是无参构造器\",{\"1\":{\"598\":1}}],[\"如果在容器中没有找到与构造器参数类型一致的bean\",{\"1\":{\"598\":1}}],[\"如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率\",{\"1\":{\"423\":1}}],[\"如果在类型\",{\"1\":{\"422\":1}}],[\"如果在该方法中调用了其他方法\",{\"1\":{\"413\":1}}],[\"如果在同一个锁对象上\",{\"1\":{\"278\":1}}],[\"如果线程请求分配的栈容量超过本地方法栈允许的最大容量\",{\"1\":{\"437\":1}}],[\"如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量\",{\"1\":{\"409\":1}}],[\"如果线程长度超过处理需要\",{\"1\":{\"291\":1}}],[\"如果父类加载器可以完成类加载任务\",{\"1\":{\"391\":1}}],[\"如果父类加载器还存在其父类加载器\",{\"1\":{\"391\":1}}],[\"如果用户创建的\",{\"1\":{\"383\":1}}],[\"如果己超过阈值\",{\"1\":{\"369\":1}}],[\"如果存在这样的值\",{\"1\":{\"926\":1}}],[\"如果存在\",{\"1\":{\"369\":1,\"944\":1}}],[\"如果存在同一时间访问同一锁的场合\",{\"1\":{\"278\":1}}],[\"如果把所有代码都编译成本地机器指令\",{\"1\":{\"349\":1}}],[\"如果需要一个小时后处理\",{\"1\":{\"754\":1}}],[\"如果需要则使用\",{\"1\":{\"600\":1}}],[\"如果需要手动指定时区\",{\"1\":{\"562\":1}}],[\"如果需要jit编译器\",{\"1\":{\"349\":1}}],[\"如果需要重置计数\",{\"1\":{\"292\":1}}],[\"如果弱引用所引用的对象被垃圾回收\",{\"1\":{\"327\":1}}],[\"如果软引用所引用的对象被垃圾回收\",{\"1\":{\"326\":1}}],[\"如果字符串常量池中没有字符串常量\",{\"1\":{\"319\":1}}],[\"如果字符串常量池中已存在字符串常量\",{\"1\":{\"319\":1}}],[\"如果字符串常量池中已经包含一个等于此\",{\"1\":{\"318\":1}}],[\"如果使用的是较早的版本\",{\"1\":{\"506\":1}}],[\"如果使用直接指针访问\",{\"1\":{\"315\":1}}],[\"如果使用句柄的话\",{\"1\":{\"315\":1}}],[\"如果使用数组那么一旦数量超过了数组的长度就将发生异常\",{\"1\":{\"227\":1}}],[\"如果不会倒满\",{\"1\":{\"982\":2}}],[\"如果不等\",{\"1\":{\"974\":1}}],[\"如果不是\",{\"1\":{\"836\":1,\"957\":1}}],[\"如果不能实现在消息粒度上的\",{\"1\":{\"756\":1}}],[\"如果不设置\",{\"1\":{\"752\":1}}],[\"如果不包含抛出异常\",{\"1\":{\"651\":1}}],[\"如果不及时对内存中的垃圾进行清理\",{\"1\":{\"515\":1}}],[\"如果不存在内存泄漏\",{\"1\":{\"450\":1}}],[\"如果不存在己被编译过的版本\",{\"1\":{\"369\":1}}],[\"如果不通过\",{\"1\":{\"422\":1}}],[\"如果不做任何设置\",{\"1\":{\"369\":1}}],[\"如果不指定大小\",{\"1\":{\"448\":1}}],[\"如果不指定大小的话\",{\"1\":{\"338\":1}}],[\"如果不指定metaspace大小的话\",{\"1\":{\"305\":1}}],[\"如果不选\",{\"1\":{\"207\":1}}],[\"如果虚拟机在动态扩展栈时无法申请到足够的内存空间\",{\"1\":{\"302\":1}}],[\"如果执行notifyall\",{\"1\":{\"286\":1}}],[\"如果还不能获得锁\",{\"1\":{\"278\":1}}],[\"如果得到锁\",{\"1\":{\"278\":1}}],[\"如果直接挂起操作系统层面的线程可能会得不偿失\",{\"1\":{\"278\":1}}],[\"如果对方法入参中的\",{\"1\":{\"431\":1}}],[\"如果对象被其他对象引用\",{\"1\":{\"523\":1}}],[\"如果对象太大\",{\"1\":{\"512\":1}}],[\"如果对象较大\",{\"1\":{\"512\":1}}],[\"如果对象在eden出生并经过第一次minorgc后仍然存活\",{\"1\":{\"498\":1}}],[\"如果对象满足这两个条件\",{\"1\":{\"280\":1}}],[\"如果对象是数组则会分配3个字\",{\"1\":{\"278\":1}}],[\"如果对于时间不是严格限制\",{\"1\":{\"751\":1}}],[\"如果对于某个锁\",{\"1\":{\"278\":1}}],[\"如果对于类的典型实例\",{\"1\":{\"230\":1}}],[\"如果正在运行的线程数量大于或等于\",{\"1\":{\"277\":1}}],[\"如果正在运行的线程数量小于\",{\"1\":{\"277\":1}}],[\"如果无限制的创建\",{\"1\":{\"274\":1}}],[\"如果申请不到\",{\"1\":{\"270\":1}}],[\"如果频繁切换就会造成整体效率低下\",{\"1\":{\"267\":1}}],[\"如果恰好给了一个二次幂\",{\"1\":{\"253\":1}}],[\"如果给的元素数据就是二次幂\",{\"1\":{\"253\":1}}],[\"如果相同的话\",{\"1\":{\"244\":1}}],[\"如果两者同时开启\",{\"1\":{\"768\":1}}],[\"如果两者相同\",{\"1\":{\"242\":1}}],[\"如果两个对象相等\",{\"1\":{\"242\":1}}],[\"如果插入位置没有元素返回null\",{\"1\":{\"242\":1}}],[\"如果你平时没有思考\",{\"1\":{\"919\":1}}],[\"如果你的项目使用spring\",{\"1\":{\"792\":1}}],[\"如果你看过\",{\"1\":{\"240\":1}}],[\"如果你要保证线程安全的话就使用\",{\"1\":{\"239\":1}}],[\"如果要通过声明的方式改变已有队列的模式的话\",{\"1\":{\"783\":1}}],[\"如果要开启需要调用方法\",{\"1\":{\"721\":1}}],[\"如果要队列实现持久化需要在声明队列的时候把\",{\"1\":{\"711\":1}}],[\"如果要代理的对象\",{\"1\":{\"596\":1}}],[\"如果要搜索的list实现类实现了randomaccess\",{\"1\":{\"230\":1}}],[\"如果要排除某个jar\",{\"1\":{\"106\":1}}],[\"如果它们在实践中获得了巨大但恒定的访问时间\",{\"1\":{\"230\":1}}],[\"如果当前节点是当前层的最后一个节点\",{\"1\":{\"1035\":1}}],[\"如果当前水量可以减去y\",{\"1\":{\"983\":1}}],[\"如果当前水量可以减去x\",{\"1\":{\"983\":1}}],[\"如果当前总水量+y后\",{\"1\":{\"983\":1}}],[\"如果当前总水量+x后\",{\"1\":{\"983\":1}}],[\"如果当前的状态\",{\"1\":{\"982\":1}}],[\"如果当前的数<=上一个数\",{\"1\":{\"938\":1}}],[\"如果当前数<=上一个数\",{\"1\":{\"957\":1}}],[\"如果当前数组的长度小于\",{\"1\":{\"222\":1,\"239\":1,\"245\":1}}],[\"如果当前元素小于等于上一个元素\",{\"1\":{\"938\":1}}],[\"如果当前元素大于上一个元素\",{\"1\":{\"938\":1}}],[\"如果当前元素数量还大于0\",{\"1\":{\"194\":1}}],[\"如果当前队列有严重的消息积压情况\",{\"1\":{\"752\":1}}],[\"如果当前存在事务就把当前事务挂起\",{\"1\":{\"635\":1}}],[\"如果当前存在事务\",{\"1\":{\"635\":2}}],[\"如果当前没有事务\",{\"1\":{\"635\":3}}],[\"如果当前没有事务则新建一个\",{\"1\":{\"635\":1}}],[\"如果当前有事务则加入\",{\"1\":{\"635\":1}}],[\"如果当前有事务\",{\"1\":{\"635\":2}}],[\"如果当前方法去调了其他方法\",{\"1\":{\"413\":1}}],[\"如果当前运行的线程数大于\",{\"1\":{\"277\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"244\":1}}],[\"如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了\",{\"1\":{\"704\":1}}],[\"如果其>=第一件物品需要的容量\",{\"1\":{\"207\":1}}],[\"如果其他地方依赖了这个jar\",{\"1\":{\"103\":1}}],[\"如果选\",{\"1\":{\"207\":1}}],[\"如果按照常见的\",{\"1\":{\"206\":1}}],[\"如果第一个消息的延时时长很长\",{\"1\":{\"755\":1}}],[\"如果第\",{\"1\":{\"204\":1,\"205\":1}}],[\"如果销售队列第一个元素的数量被减为0\",{\"1\":{\"194\":1}}],[\"如果销售订单队列不为空\",{\"1\":{\"194\":1}}],[\"如果是2\",{\"1\":{\"943\":1}}],[\"如果是以下情况则直接返回0\",{\"1\":{\"925\":1}}],[\"如果是带会话\",{\"1\":{\"877\":1}}],[\"如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能\",{\"1\":{\"774\":1}}],[\"如果是预定会议室然后提前通知这样的场景\",{\"1\":{\"754\":1}}],[\"如果是老的思维\",{\"1\":{\"566\":1}}],[\"如果是i\",{\"1\":{\"544\":1}}],[\"如果是io密集型任务\",{\"1\":{\"277\":1}}],[\"如果是数组\",{\"1\":{\"476\":1}}],[\"如果是内存泄漏\",{\"1\":{\"450\":1}}],[\"如果是在执行native方法\",{\"1\":{\"399\":1}}],[\"如果是在头尾插入或者删除元素不受元素位置的影响\",{\"1\":{\"229\":1}}],[\"如果是cpu密集型任务\",{\"1\":{\"277\":1}}],[\"如果是不可重入锁的话\",{\"1\":{\"271\":1,\"284\":1}}],[\"如果是要在指定位置\",{\"1\":{\"229\":1}}],[\"如果是\",{\"0\":{\"653\":1},\"1\":{\"194\":1,\"290\":1,\"957\":1}}],[\"如果是10\",{\"1\":{\"943\":1}}],[\"如果是1\",{\"1\":{\"182\":1}}],[\"如果添加失败\",{\"1\":{\"186\":1}}],[\"如果未指定\",{\"1\":{\"106\":1}}],[\"如果为true会在使用时生成很多以时间戳结尾的jar\",{\"1\":{\"103\":1}}],[\"如果自己生成这个文件\",{\"1\":{\"103\":1}}],[\"如果想在自己写的sql中使用分页插件\",{\"1\":{\"859\":1}}],[\"如果想要让一个\",{\"1\":{\"355\":1}}],[\"如果想让构建出来的原始jar不被重新打包\",{\"1\":{\"104\":1}}],[\"如果想给最终的jar瘦身\",{\"1\":{\"103\":1}}],[\"如果想则代码里判断变量rabbittemplate是否非null\",{\"1\":{\"10\":1}}],[\"如果\",{\"1\":{\"91\":1,\"235\":1,\"242\":1,\"477\":1,\"614\":7,\"954\":1,\"1029\":1}}],[\"如果子工程坐标中的groupid和version与父工程一致\",{\"1\":{\"88\":1}}],[\"如果能看到版本号\",{\"1\":{\"63\":1}}],[\"如d\",{\"1\":{\"62\":1,\"1007\":1,\"1008\":1}}],[\"如maven\",{\"1\":{\"14\":1}}],[\"如\",{\"1\":{\"10\":1,\"184\":1,\"335\":1,\"336\":1,\"393\":1,\"464\":3,\"519\":1,\"549\":1,\"577\":2,\"609\":1,\"697\":2,\"712\":1,\"751\":2,\"756\":1,\"758\":1,\"813\":1,\"938\":1,\"995\":1,\"1007\":1}}],[\"如有错误\",{\"1\":{\"1\":1}}],[\"操作是不能让数组的每个值唯一的\",{\"1\":{\"937\":1}}],[\"操作将会选择任意\",{\"1\":{\"937\":1}}],[\"操作智能分析阻断\",{\"1\":{\"827\":1}}],[\"操作后\",{\"1\":{\"813\":1}}],[\"操作文件流的一个依赖\",{\"1\":{\"696\":1}}],[\"操作来完成一次数据访问\",{\"1\":{\"416\":1}}],[\"操作系统错误导致终止\",{\"1\":{\"347\":1}}],[\"操作系统\",{\"1\":{\"343\":1}}],[\"操作系统在回收线程或进程的时候不是一定杀死线程或进程的\",{\"1\":{\"280\":1}}],[\"操作数栈中元素的数据类型必须与字节码指令的序列严格匹配\",{\"1\":{\"416\":1}}],[\"操作数栈并非采用访问索引的方式来进行数据访问的\",{\"1\":{\"416\":1}}],[\"操作数栈就是jvm执行引擎的一个工作区\",{\"1\":{\"416\":1}}],[\"操作数栈\",{\"0\":{\"416\":1},\"1\":{\"302\":1,\"303\":1,\"414\":1,\"416\":2,\"424\":1,\"454\":1}}],[\"操作中如果除数是\",{\"1\":{\"246\":1}}],[\"操作随机访问列表\",{\"1\":{\"230\":1}}],[\"操作哪个工程\",{\"1\":{\"72\":1}}],[\"操作\",{\"0\":{\"9\":1},\"1\":{\"246\":1,\"827\":3,\"937\":2}}],[\"2的深度为2\",{\"1\":{\"1023\":1}}],[\"2版本下的binary\",{\"1\":{\"1005\":1}}],[\"26\",{\"1\":{\"948\":1}}],[\"2就是需要的时间\",{\"1\":{\"943\":1}}],[\"2支持\",{\"1\":{\"878\":1}}],[\"2b8\",{\"1\":{\"831\":1}}],[\"2gb\",{\"1\":{\"784\":1}}],[\"28\",{\"1\":{\"722\":1}}],[\"236\",{\"0\":{\"1037\":1}}],[\"234\",{\"0\":{\"971\":1},\"1\":{\"972\":1}}],[\"2351\",{\"0\":{\"946\":1},\"1\":{\"947\":1}}],[\"231\",{\"1\":{\"753\":1,\"762\":1,\"765\":1}}],[\"23\",{\"1\":{\"708\":1,\"753\":2,\"754\":3,\"755\":1}}],[\"23277575\",{\"1\":{\"595\":1}}],[\"27\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"21\",{\"1\":{\"651\":1}}],[\"2147483647\",{\"1\":{\"246\":1}}],[\"2147483648\",{\"1\":{\"246\":1}}],[\"255\",{\"1\":{\"697\":1,\"740\":1,\"777\":1,\"779\":1}}],[\"25\",{\"1\":{\"649\":1}}],[\"250提供\",{\"1\":{\"609\":1}}],[\"2时由sun提供\",{\"1\":{\"350\":1}}],[\"22\",{\"1\":{\"722\":1,\"723\":1,\"754\":1,\"779\":2}}],[\"22t10\",{\"1\":{\"569\":1}}],[\"22756773\",{\"1\":{\"293\":1}}],[\"22h2\",{\"1\":{\"114\":1}}],[\"2n+1\",{\"1\":{\"239\":1}}],[\"2层\",{\"1\":{\"200\":1}}],[\"2<\",{\"1\":{\"101\":1}}],[\"24\",{\"1\":{\"70\":1,\"762\":1,\"853\":1,\"854\":1}}],[\"2+之后的版本无法递归导入maven问题\",{\"0\":{\"20\":1}}],[\"206\",{\"0\":{\"966\":1}}],[\"2042\",{\"0\":{\"957\":1}}],[\"2007年由facebook贡献到apache基金\",{\"1\":{\"879\":1}}],[\"2000\",{\"1\":{\"755\":1,\"757\":1}}],[\"20000\",{\"1\":{\"649\":1,\"755\":1,\"757\":1}}],[\"2008年\",{\"1\":{\"352\":1}}],[\"2018\",{\"1\":{\"1038\":1}}],[\"2016\",{\"1\":{\"614\":1}}],[\"2019\",{\"0\":{\"20\":1}}],[\"20\",{\"1\":{\"244\":1,\"562\":1,\"573\":1,\"844\":1,\"847\":1,\"848\":1,\"851\":1,\"1003\":1}}],[\"20211112224647270\",{\"1\":{\"784\":1}}],[\"20211112224619178\",{\"1\":{\"783\":1}}],[\"20211112224104960\",{\"1\":{\"779\":1,\"780\":1}}],[\"20211112222646574\",{\"1\":{\"777\":1}}],[\"20211112180434452\",{\"1\":{\"768\":1}}],[\"20211112180036082\",{\"1\":{\"768\":1}}],[\"20211112175031225\",{\"1\":{\"765\":1}}],[\"20211112173526575\",{\"1\":{\"762\":1}}],[\"20211112002641439\",{\"1\":{\"768\":1}}],[\"20211112000539340\",{\"1\":{\"762\":1}}],[\"20211112000502762\",{\"1\":{\"761\":1}}],[\"20211111181554596\",{\"1\":{\"757\":1}}],[\"20211111180629701\",{\"1\":{\"757\":1}}],[\"20211111180530451\",{\"1\":{\"756\":1}}],[\"20211111002753539\",{\"1\":{\"755\":1}}],[\"20211111002950970\",{\"1\":{\"754\":1}}],[\"20211111000716623\",{\"1\":{\"755\":1}}],[\"20211110225716769\",{\"1\":{\"754\":1}}],[\"20211110215651792\",{\"1\":{\"751\":1}}],[\"20211110194727053\",{\"1\":{\"749\":1}}],[\"20211110194202134\",{\"1\":{\"749\":1}}],[\"20211110193547802\",{\"1\":{\"748\":1}}],[\"20211110192651293\",{\"1\":{\"747\":1}}],[\"20211110192743276\",{\"1\":{\"747\":1}}],[\"20211110192243321\",{\"1\":{\"747\":1}}],[\"20211110190646829\",{\"1\":{\"746\":1}}],[\"20211110175456673\",{\"1\":{\"742\":1}}],[\"20211110175137166\",{\"1\":{\"741\":1}}],[\"20211110173046439\",{\"1\":{\"738\":1}}],[\"20211110173025837\",{\"1\":{\"738\":1}}],[\"20211110172858521\",{\"1\":{\"737\":1}}],[\"20211110172746642\",{\"1\":{\"736\":1}}],[\"20211110172121531\",{\"1\":{\"730\":1}}],[\"20211110171142496\",{\"1\":{\"734\":1}}],[\"20211110171112477\",{\"1\":{\"734\":1}}],[\"20211110171053309\",{\"1\":{\"733\":1}}],[\"20211110171016043\",{\"1\":{\"731\":1}}],[\"20211110171004071\",{\"1\":{\"731\":1}}],[\"20211110170447102\",{\"1\":{\"729\":1}}],[\"20211110165519202\",{\"1\":{\"727\":1}}],[\"20211113004348652\",{\"1\":{\"702\":1}}],[\"20211109224549666\",{\"1\":{\"724\":1}}],[\"20211109221107761\",{\"1\":{\"715\":1,\"718\":1}}],[\"20211109215549448\",{\"1\":{\"717\":1}}],[\"20211109214706617\",{\"1\":{\"714\":1}}],[\"20211109213727483\",{\"1\":{\"711\":1}}],[\"20211109213659474\",{\"1\":{\"711\":1}}],[\"20211109193534701\",{\"1\":{\"709\":1}}],[\"20211109193341523\",{\"1\":{\"709\":1}}],[\"20211109193046505\",{\"1\":{\"709\":1}}],[\"20211109191528743\",{\"1\":{\"707\":1}}],[\"20211109191455909\",{\"1\":{\"706\":1}}],[\"20211109174147712\",{\"1\":{\"701\":1}}],[\"20211109173921923\",{\"1\":{\"701\":1}}],[\"20211109173848856\",{\"1\":{\"701\":1}}],[\"20211109170150330\",{\"1\":{\"695\":1}}],[\"20211109170013018\",{\"1\":{\"695\":1}}],[\"2021\",{\"1\":{\"695\":1,\"701\":3,\"708\":2,\"711\":2,\"717\":1,\"722\":1,\"723\":1,\"734\":2,\"738\":1,\"741\":1,\"742\":1,\"747\":3,\"748\":1,\"749\":2,\"753\":1,\"754\":4,\"755\":2,\"757\":2,\"762\":4,\"765\":1,\"768\":2,\"779\":2}}],[\"20221012110139249\",{\"1\":{\"583\":1}}],[\"20221012110108730\",{\"1\":{\"583\":1}}],[\"20220603215359527\",{\"1\":{\"693\":1}}],[\"20220327132758\",{\"1\":{\"214\":1}}],[\"20220715\",{\"1\":{\"49\":1}}],[\"20220416143653974\",{\"1\":{\"21\":1}}],[\"20220416142943301\",{\"1\":{\"18\":1}}],[\"20220526104944859\",{\"1\":{\"842\":1}}],[\"20220526163354853\",{\"1\":{\"16\":1}}],[\"20220526224304005\",{\"1\":{\"642\":1}}],[\"20220525105153278\",{\"1\":{\"539\":1}}],[\"20220522225443294\",{\"1\":{\"11\":1}}],[\"2023\",{\"1\":{\"559\":1}}],[\"2020年3月3日\",{\"1\":{\"573\":2}}],[\"2020年06月15日\",{\"1\":{\"241\":1}}],[\"2020\",{\"1\":{\"559\":2,\"562\":1,\"568\":1,\"569\":4,\"573\":7}}],[\"2\",{\"0\":{\"8\":1,\"9\":1,\"10\":1,\"11\":2,\"12\":1,\"13\":1,\"16\":1,\"19\":1,\"60\":1,\"61\":1,\"62\":2,\"63\":1,\"66\":1,\"67\":1,\"68\":2,\"69\":1,\"70\":1,\"74\":1,\"81\":1,\"86\":1,\"87\":1,\"88\":2,\"95\":1,\"98\":1,\"102\":1,\"106\":1,\"246\":1,\"357\":1,\"358\":1,\"359\":2,\"362\":1,\"366\":1,\"370\":1,\"383\":1,\"396\":1,\"402\":1,\"428\":1,\"440\":1,\"441\":1,\"442\":2,\"443\":1,\"448\":1,\"453\":1,\"462\":1,\"469\":1,\"471\":1,\"475\":1,\"476\":1,\"477\":2,\"478\":1,\"495\":1,\"509\":1,\"516\":1,\"522\":1},\"1\":{\"11\":1,\"46\":1,\"65\":2,\"99\":1,\"104\":1,\"148\":1,\"170\":1,\"184\":2,\"194\":1,\"198\":1,\"200\":5,\"201\":2,\"202\":4,\"207\":5,\"231\":1,\"233\":2,\"234\":3,\"239\":6,\"246\":4,\"253\":3,\"319\":2,\"324\":1,\"337\":1,\"387\":2,\"510\":2,\"513\":1,\"539\":1,\"548\":5,\"549\":5,\"559\":1,\"584\":1,\"592\":1,\"600\":1,\"617\":1,\"627\":1,\"638\":1,\"660\":1,\"665\":1,\"671\":1,\"678\":1,\"697\":4,\"698\":2,\"701\":1,\"708\":4,\"714\":2,\"717\":2,\"718\":3,\"734\":1,\"749\":1,\"753\":1,\"755\":3,\"757\":1,\"762\":1,\"792\":2,\"836\":1,\"861\":1,\"874\":2,\"875\":1,\"876\":1,\"877\":1,\"878\":1,\"879\":1,\"902\":1,\"917\":1,\"929\":7,\"933\":1,\"937\":7,\"939\":8,\"943\":6,\"944\":2,\"954\":1,\"970\":2,\"981\":2,\"996\":1,\"998\":1,\"1005\":1,\"1006\":3,\"1007\":1,\"1008\":1,\"1018\":5,\"1023\":2,\"1028\":2,\"1033\":2,\"1038\":8}}],[\"a1b2c2d1\",{\"1\":{\"953\":1}}],[\"a2b1c5a3\",{\"1\":{\"953\":1}}],[\"a至z\",{\"1\":{\"953\":1}}],[\"avro\",{\"1\":{\"879\":1}}],[\"availability\",{\"1\":{\"797\":1}}],[\"available\",{\"1\":{\"521\":1}}],[\"azy\",{\"1\":{\"741\":1}}],[\"amqptemplate\",{\"1\":{\"754\":1}}],[\"amqp<\",{\"1\":{\"753\":1}}],[\"amqp\",{\"1\":{\"693\":2,\"697\":2,\"747\":3,\"748\":2,\"753\":1,\"754\":8,\"755\":1,\"757\":2,\"762\":7,\"768\":2,\"779\":3}}],[\"amend\",{\"1\":{\"585\":3}}],[\"a对象创建也完成\",{\"1\":{\"621\":1}}],[\"a对象的创建过程\",{\"1\":{\"621\":1}}],[\"a注入属性时\",{\"1\":{\"621\":1}}],[\"aftercompletion\",{\"1\":{\"656\":1}}],[\"afterreturning\",{\"1\":{\"605\":3}}],[\"afterthrowing\",{\"1\":{\"605\":1}}],[\"after\",{\"1\":{\"604\":3,\"605\":3}}],[\"a^\",{\"1\":{\"584\":1}}],[\"aabcccccaaa\",{\"1\":{\"953\":1}}],[\"aaabbbcccddd\",{\"1\":{\"996\":1}}],[\"aaa\",{\"1\":{\"584\":1,\"996\":1}}],[\"aaa是commit\",{\"1\":{\"584\":1}}],[\"aafafd72\",{\"1\":{\"483\":1}}],[\"aggregate\",{\"1\":{\"510\":1}}],[\"ageend\",{\"1\":{\"852\":2,\"853\":3}}],[\"agebegin\",{\"1\":{\"852\":2,\"853\":3}}],[\"age=\",{\"1\":{\"847\":1,\"848\":1}}],[\"age\",{\"1\":{\"241\":6,\"840\":1,\"844\":1,\"845\":1,\"847\":2,\"848\":2,\"849\":2,\"850\":1,\"851\":3,\"852\":5,\"859\":3}}],[\"advantage\",{\"1\":{\"740\":1}}],[\"advised\",{\"1\":{\"604\":1}}],[\"advice\",{\"1\":{\"604\":1}}],[\"advice和回调目标对象的方法所组成\",{\"1\":{\"603\":1}}],[\"admin\",{\"1\":{\"697\":1,\"698\":1,\"701\":1,\"753\":1,\"762\":1,\"765\":1}}],[\"adjuster\",{\"1\":{\"569\":1}}],[\"ad0a\",{\"1\":{\"388\":1}}],[\"addtableprefix\",{\"1\":{\"864\":1}}],[\"addinclude\",{\"1\":{\"864\":1}}],[\"addinnerinterceptor\",{\"1\":{\"857\":1,\"860\":2}}],[\"additional\",{\"1\":{\"670\":1}}],[\"addall\",{\"1\":{\"788\":6}}],[\"addfilterbefore\",{\"1\":{\"788\":1}}],[\"addfirst\",{\"1\":{\"229\":1}}],[\"addrecord\",{\"1\":{\"673\":1}}],[\"address\",{\"1\":{\"278\":1,\"414\":1}}],[\"addmapping\",{\"1\":{\"673\":1}}],[\"addcorsmappings\",{\"1\":{\"673\":1}}],[\"addclasspath>\",{\"1\":{\"103\":1,\"106\":1}}],[\"addclasspath为true时才有意义\",{\"1\":{\"103\":1}}],[\"addlast\",{\"1\":{\"229\":1}}],[\"add\",{\"1\":{\"186\":1,\"194\":2,\"201\":6,\"229\":3,\"234\":1,\"240\":1,\"242\":1,\"673\":1,\"702\":2,\"777\":2,\"944\":2,\"982\":9,\"983\":5,\"1034\":1,\"1035\":4}}],[\"ae4b5cee3179\",{\"1\":{\"381\":1}}],[\"ahead\",{\"1\":{\"367\":1}}],[\"aot编译器\",{\"1\":{\"367\":1}}],[\"aot\",{\"1\":{\"367\":1}}],[\"aop等\",{\"1\":{\"644\":1}}],[\"aop配置事务\",{\"1\":{\"633\":1}}],[\"aop是通过运行时代理实现的\",{\"1\":{\"604\":1}}],[\"aop框架在程序执行过程中触发的一些代码\",{\"1\":{\"604\":1}}],[\"aop中\",{\"1\":{\"604\":2}}],[\"aop的核心就是切面\",{\"1\":{\"604\":1}}],[\"aop的常用术语及其含义\",{\"0\":{\"604\":1}}],[\"aop的实现原理\",{\"0\":{\"603\":1}}],[\"aop在这两种方式的实现上基本一样\",{\"1\":{\"603\":1}}],[\"aop使用动态代理技术在运行期织入增强代码\",{\"1\":{\"603\":1}}],[\"aop方法在特定切入点添加了增强处理\",{\"1\":{\"603\":1}}],[\"aop有什么区别\",{\"0\":{\"602\":1}}],[\"aop和aspectj\",{\"0\":{\"602\":1}}],[\"aop会使用\",{\"1\":{\"596\":1}}],[\"aop会使用cglib\",{\"1\":{\"596\":1}}],[\"aop会使用jdk\",{\"1\":{\"596\":1}}],[\"aop就是基于动态代理的\",{\"1\":{\"596\":1}}],[\"aop解耦\",{\"1\":{\"592\":1}}],[\"aop组件用来实现面向切面编程\",{\"1\":{\"591\":1}}],[\"aop<\",{\"1\":{\"87\":1,\"88\":1}}],[\"aopalliance\",{\"1\":{\"85\":2}}],[\"aop\",{\"0\":{\"596\":1},\"1\":{\"85\":1,\"591\":2,\"592\":1,\"596\":5,\"602\":5,\"603\":4,\"604\":1,\"606\":2}}],[\"a756\",{\"1\":{\"343\":1}}],[\"aqs\",{\"1\":{\"289\":3}}],[\"ack\",{\"1\":{\"706\":1,\"707\":1,\"708\":2,\"709\":1,\"711\":1,\"712\":1,\"714\":1,\"717\":3,\"719\":1,\"720\":1,\"730\":1,\"762\":3,\"765\":3,\"772\":1}}],[\"acme\",{\"1\":{\"617\":1}}],[\"action\",{\"1\":{\"549\":1,\"656\":1}}],[\"activerecord\",{\"1\":{\"827\":2}}],[\"activebydefault>\",{\"1\":{\"61\":1}}],[\"activation>\",{\"1\":{\"61\":1}}],[\"acquire\",{\"1\":{\"292\":1}}],[\"accessdeniedhandler\",{\"1\":{\"788\":1}}],[\"access\",{\"1\":{\"588\":1}}],[\"acc\",{\"1\":{\"278\":1}}],[\"abdehcfg\",{\"1\":{\"1024\":1}}],[\"abbccd\",{\"1\":{\"953\":3}}],[\"abbreviations\",{\"1\":{\"143\":1}}],[\"abstractmap\",{\"1\":{\"982\":1}}],[\"abstractmethodetror异常\",{\"1\":{\"422\":1}}],[\"abstractlambdawrapper\",{\"1\":{\"842\":1}}],[\"abstractwrapper\",{\"1\":{\"842\":1}}],[\"abstract的一个子集\",{\"1\":{\"454\":1}}],[\"abstract\",{\"1\":{\"434\":1,\"452\":1,\"454\":2}}],[\"abc\",{\"0\":{\"319\":1},\"1\":{\"319\":3,\"728\":8}}],[\"abcdefgh\",{\"1\":{\"1024\":1}}],[\"abcd\",{\"1\":{\"317\":3}}],[\"abortpolicy\",{\"1\":{\"275\":1}}],[\"atomicreference>\",{\"1\":{\"902\":1}}],[\"atguigu\",{\"1\":{\"847\":1,\"848\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":2}}],[\"attributes\",{\"1\":{\"674\":1}}],[\"attachs\",{\"1\":{\"655\":1}}],[\"attach\",{\"1\":{\"655\":1}}],[\"atzone\",{\"1\":{\"562\":1,\"571\":1}}],[\"at\",{\"1\":{\"244\":2}}],[\"auth\",{\"1\":{\"788\":2}}],[\"authenticationmanagerbuilder\",{\"1\":{\"788\":1}}],[\"authenticationerrorhandler\",{\"1\":{\"788\":1}}],[\"authenticationentrypoint\",{\"1\":{\"788\":1}}],[\"authenticated\",{\"1\":{\"788\":1}}],[\"authorizerequests\",{\"1\":{\"788\":1}}],[\"author\",{\"1\":{\"241\":1,\"701\":3,\"708\":2,\"711\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"749\":2,\"753\":1,\"754\":4,\"755\":2,\"757\":2,\"762\":4,\"765\":1,\"768\":2,\"779\":2,\"864\":1}}],[\"autoack\",{\"1\":{\"708\":4,\"714\":2,\"717\":2}}],[\"autoconfigure\",{\"1\":{\"676\":2,\"753\":1}}],[\"autoconfigurationimportselector\",{\"1\":{\"674\":1}}],[\"automake\",{\"1\":{\"670\":1}}],[\"automatically勾选上\",{\"1\":{\"670\":1}}],[\"automatically\",{\"1\":{\"7\":1}}],[\"autoproxying\",{\"1\":{\"604\":1}}],[\"autowiring\",{\"1\":{\"619\":1}}],[\"autowired搭配按名称\",{\"1\":{\"609\":1}}],[\"autowired会根据名称来查找\",{\"1\":{\"601\":1}}],[\"autowired指定的数据\",{\"1\":{\"601\":1}}],[\"autowired时\",{\"1\":{\"601\":1}}],[\"autowired注解\",{\"1\":{\"609\":1}}],[\"autowired注解之前需要在spring配置文件进行配置\",{\"1\":{\"601\":1}}],[\"autowired注解来自动装配指定的bean\",{\"1\":{\"601\":1}}],[\"autowired注解自动装配的过程是怎样的\",{\"0\":{\"601\":1}}],[\"autowired是根据类型注入\",{\"1\":{\"599\":1}}],[\"autowired\",{\"1\":{\"599\":6,\"618\":2,\"754\":2,\"755\":1,\"757\":1,\"762\":3}}],[\"autowired的自动装配\",{\"1\":{\"597\":1}}],[\"autowied\",{\"1\":{\"601\":1}}],[\"autodetect\",{\"1\":{\"598\":1}}],[\"auto\",{\"1\":{\"47\":1,\"836\":3}}],[\"aiiocation\",{\"1\":{\"482\":1}}],[\"ai\",{\"1\":{\"139\":1,\"143\":1}}],[\"ai抠图\",{\"1\":{\"132\":1,\"139\":1}}],[\"aware接口\",{\"1\":{\"614\":1}}],[\"await\",{\"1\":{\"292\":2}}],[\"awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\",{\"1\":{\"139\":1}}],[\"awesome\",{\"1\":{\"23\":1,\"143\":1}}],[\"ans\",{\"1\":{\"931\":5,\"1040\":5}}],[\"ans为最终准备返回的长度值\",{\"1\":{\"930\":1,\"1039\":1}}],[\"answer\",{\"1\":{\"595\":1}}],[\"anonymousgetmapping\",{\"0\":{\"792\":1},\"1\":{\"792\":1}}],[\"anonymousurls\",{\"1\":{\"788\":15}}],[\"anonymousaccess的\",{\"1\":{\"789\":1}}],[\"anonymousaccess\",{\"0\":{\"791\":1},\"1\":{\"788\":6,\"791\":1,\"792\":1}}],[\"annotationattributes\",{\"1\":{\"674\":1}}],[\"annotationmetadata\",{\"1\":{\"674\":1}}],[\"annotation\",{\"1\":{\"601\":1,\"605\":1,\"652\":1,\"687\":1,\"753\":1,\"754\":13,\"755\":3,\"757\":1,\"762\":10,\"768\":1,\"788\":1,\"791\":1,\"792\":7,\"836\":1}}],[\"ances\",{\"1\":{\"577\":1}}],[\"anywhere\",{\"1\":{\"827\":1}}],[\"anyrequest\",{\"1\":{\"788\":1}}],[\"anymatch\",{\"1\":{\"550\":1}}],[\"any\",{\"1\":{\"515\":1,\"675\":1,\"728\":1}}],[\"an\",{\"1\":{\"515\":1}}],[\"analysis\",{\"1\":{\"505\":1,\"513\":1}}],[\"analyzer\",{\"1\":{\"450\":1,\"492\":1}}],[\"animate\",{\"1\":{\"158\":1}}],[\"animista\",{\"1\":{\"134\":1}}],[\"antmatchers\",{\"1\":{\"788\":15}}],[\"ant\",{\"1\":{\"156\":1}}],[\"anduser\",{\"1\":{\"819\":1}}],[\"and\",{\"1\":{\"22\":1,\"289\":1,\"471\":1,\"693\":1,\"788\":4,\"819\":1,\"840\":1,\"847\":1,\"848\":2,\"851\":3,\"852\":1,\"854\":1,\"860\":1,\"975\":2}}],[\"a\",{\"1\":{\"81\":2,\"82\":4,\"85\":3,\"91\":3,\"177\":1,\"194\":4,\"234\":1,\"235\":2,\"239\":1,\"244\":1,\"577\":1,\"584\":2,\"621\":1,\"634\":3,\"702\":1,\"777\":1,\"821\":5,\"844\":1,\"847\":1,\"848\":1,\"851\":1,\"852\":1,\"853\":1,\"854\":1,\"858\":1,\"937\":5,\"938\":9,\"939\":5,\"948\":2,\"949\":1,\"975\":1,\"995\":2,\"998\":1,\"1024\":1,\"1029\":1,\"1034\":1}}],[\"arg\",{\"1\":{\"998\":2}}],[\"argument\",{\"1\":{\"777\":1}}],[\"arguments\",{\"1\":{\"619\":1,\"687\":2,\"702\":1}}],[\"args\",{\"1\":{\"241\":1,\"332\":1,\"392\":2,\"510\":1,\"559\":1,\"562\":2,\"568\":1,\"569\":1,\"571\":1,\"573\":2,\"687\":5,\"697\":1,\"698\":1,\"701\":2,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"748\":2,\"749\":2,\"752\":1,\"753\":2,\"755\":4,\"757\":3,\"779\":2,\"780\":2,\"783\":3,\"864\":1}}],[\"around\",{\"1\":{\"604\":1,\"605\":1}}],[\"arr2\",{\"1\":{\"549\":1}}],[\"arr1\",{\"1\":{\"549\":1}}],[\"arraytolist\",{\"1\":{\"234\":2}}],[\"array\",{\"1\":{\"233\":2,\"234\":3,\"235\":2}}],[\"arraydeque\",{\"0\":{\"231\":1},\"1\":{\"231\":7}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"227\":1,\"233\":1}}],[\"arrayqueue\",{\"1\":{\"221\":1}}],[\"arraylist<integer>\",{\"1\":{\"1035\":1}}],[\"arraylist<t>\",{\"1\":{\"234\":1}}],[\"arraylist<>\",{\"1\":{\"201\":1,\"234\":1,\"788\":1,\"1034\":1}}],[\"arraylist想象成一种\",{\"1\":{\"228\":1}}],[\"arraylist内部封装了一个object类型的数组\",{\"1\":{\"228\":1}}],[\"arraylist\",{\"0\":{\"229\":1,\"232\":1},\"1\":{\"216\":1,\"219\":1,\"226\":1,\"228\":1,\"229\":7,\"233\":1,\"234\":1,\"259\":1}}],[\"arrayslist\",{\"0\":{\"230\":1}}],[\"arrays\",{\"0\":{\"233\":1},\"1\":{\"189\":1,\"190\":1,\"198\":1,\"201\":2,\"233\":4,\"234\":3,\"235\":1,\"548\":2,\"549\":7,\"925\":1,\"938\":1,\"957\":1,\"990\":2,\"991\":1}}],[\"arr\",{\"1\":{\"194\":4,\"954\":5,\"982\":18}}],[\"arkie\",{\"1\":{\"148\":1}}],[\"arthas\",{\"1\":{\"513\":1}}],[\"article\",{\"1\":{\"289\":1,\"293\":1}}],[\"articles\",{\"1\":{\"247\":1}}],[\"artifactid>\",{\"1\":{\"65\":1,\"70\":3,\"77\":1,\"83\":2,\"87\":7,\"88\":7,\"99\":1,\"101\":1,\"106\":4,\"670\":1,\"671\":2,\"679\":3,\"680\":1,\"696\":3,\"753\":7,\"830\":1,\"863\":2}}],[\"artifactid\",{\"1\":{\"65\":1,\"78\":1,\"99\":5}}],[\"artbreeder\",{\"1\":{\"144\":1}}],[\"archive>\",{\"1\":{\"106\":1}}],[\"archiverconfig>\",{\"1\":{\"99\":1}}],[\"archetypeversion\",{\"1\":{\"78\":1}}],[\"archetypeartifactid\",{\"1\":{\"78\":1}}],[\"archetypegroupid\",{\"1\":{\"78\":1}}],[\"archetypes\",{\"1\":{\"78\":1}}],[\"archetype\",{\"1\":{\"78\":6}}],[\"arenumbersascending\",{\"1\":{\"957\":2}}],[\"area=\",{\"1\":{\"819\":1}}],[\"area\",{\"1\":{\"819\":1,\"934\":4}}],[\"areturn\",{\"1\":{\"424\":1}}],[\"are\",{\"1\":{\"42\":1}}],[\"appconfig\",{\"1\":{\"617\":1}}],[\"appclassloader的父类加载器为extclassloader\",{\"1\":{\"332\":1}}],[\"appclassloader\",{\"0\":{\"384\":1},\"1\":{\"331\":1,\"381\":1}}],[\"appendable\",{\"1\":{\"994\":1}}],[\"appendto\",{\"0\":{\"991\":1},\"1\":{\"991\":2,\"994\":1}}],[\"append操作\",{\"1\":{\"431\":1}}],[\"append\",{\"1\":{\"317\":3,\"431\":1,\"954\":2}}],[\"appearance\",{\"1\":{\"12\":1}}],[\"approximately\",{\"1\":{\"244\":1}}],[\"appsource\",{\"1\":{\"110\":1}}],[\"app\",{\"1\":{\"110\":1,\"670\":1}}],[\"applicationarguments\",{\"1\":{\"687\":1}}],[\"applicationrunner\",{\"1\":{\"687\":2}}],[\"applicationcontext创建好之后\",{\"1\":{\"678\":1}}],[\"applicationcontext和beanfacotry相比\",{\"1\":{\"611\":1}}],[\"applicationcontext是对beanfactory扩展\",{\"1\":{\"611\":1}}],[\"applicationcontext是会在加载配置文件时初始化bean\",{\"1\":{\"611\":1}}],[\"applicationcontext接口继承beanfactory接口\",{\"1\":{\"611\":1}}],[\"applicationcontext\",{\"1\":{\"610\":1,\"678\":1,\"788\":1}}],[\"application\",{\"1\":{\"99\":1,\"392\":2,\"612\":1,\"685\":4,\"687\":1,\"753\":1}}],[\"api实现join\",{\"0\":{\"992\":1}}],[\"api调用繁琐\",{\"1\":{\"555\":1}}],[\"api通过map和flatmap方法提供了映射方法\",{\"1\":{\"549\":1}}],[\"api的新成员\",{\"1\":{\"544\":1}}],[\"api来加载或卸载java虚拟机时\",{\"1\":{\"347\":1}}],[\"api🫙3\",{\"1\":{\"78\":1}}],[\"api\",{\"0\":{\"285\":1},\"1\":{\"65\":2,\"78\":1,\"80\":2,\"285\":1,\"333\":1,\"393\":1,\"435\":1,\"614\":1,\"788\":1,\"883\":2}}],[\"api<\",{\"1\":{\"65\":1}}],[\"apache\",{\"1\":{\"59\":1,\"60\":1,\"78\":1,\"101\":1,\"106\":1,\"628\":1,\"696\":1,\"831\":1,\"835\":1,\"836\":1}}],[\"assets\",{\"1\":{\"1038\":1}}],[\"assertequals\",{\"1\":{\"992\":1}}],[\"assert\",{\"1\":{\"992\":1}}],[\"assembly>\",{\"1\":{\"99\":1}}],[\"assembly\",{\"1\":{\"99\":5}}],[\"assign\",{\"1\":{\"836\":2}}],[\"association\",{\"1\":{\"821\":2}}],[\"association>\",{\"1\":{\"820\":1}}],[\"asm\",{\"1\":{\"606\":1,\"894\":3}}],[\"aspectdemo\",{\"1\":{\"605\":1}}],[\"aspect注解的类实现\",{\"1\":{\"604\":1}}],[\"aspectj\",{\"1\":{\"596\":2,\"602\":5,\"605\":2}}],[\"aspect\",{\"1\":{\"596\":1,\"604\":1,\"605\":1}}],[\"asia\",{\"1\":{\"562\":3}}],[\"aslist\",{\"0\":{\"233\":1},\"1\":{\"201\":2,\"233\":3,\"234\":1,\"235\":1,\"548\":2,\"549\":6,\"990\":2,\"991\":1}}],[\"ascii\",{\"1\":{\"143\":2}}],[\"as\",{\"1\":{\"42\":1,\"840\":1,\"850\":1,\"852\":1}}],[\"alive\",{\"1\":{\"879\":1}}],[\"aliases\",{\"1\":{\"831\":1}}],[\"aliasfor\",{\"1\":{\"792\":7}}],[\"alias\",{\"1\":{\"792\":7}}],[\"alibaba<\",{\"1\":{\"753\":1}}],[\"aliyun\",{\"1\":{\"61\":2,\"1008\":1,\"1009\":2,\"1038\":1}}],[\"aliyun<\",{\"1\":{\"61\":2}}],[\"already\",{\"1\":{\"242\":1}}],[\"allprojects\",{\"1\":{\"1008\":1}}],[\"allowedmethods\",{\"1\":{\"673\":1}}],[\"allowedorigins\",{\"1\":{\"673\":1}}],[\"allowcredentials\",{\"1\":{\"673\":1}}],[\"allow\",{\"1\":{\"670\":1,\"701\":1}}],[\"alloc\",{\"1\":{\"510\":3}}],[\"allocation\",{\"0\":{\"501\":1},\"1\":{\"471\":1}}],[\"all才有用\",{\"1\":{\"577\":1}}],[\"allmatch\",{\"1\":{\"550\":1}}],[\"all\",{\"1\":{\"42\":1,\"728\":1,\"788\":6,\"822\":1}}],[\"always\",{\"1\":{\"42\":1}}],[\"alternate\",{\"1\":{\"768\":1}}],[\"alt+shift+5\",{\"1\":{\"47\":1}}],[\"alt+h\",{\"1\":{\"43\":1}}],[\"alt+t\",{\"1\":{\"43\":1}}],[\"alt+v\",{\"1\":{\"43\":1}}],[\"alt+o\",{\"1\":{\"43\":1}}],[\"alt+p\",{\"1\":{\"43\":1}}],[\"alt+e\",{\"1\":{\"43\":1}}],[\"alt+enter\",{\"1\":{\"6\":2}}],[\"alt+f\",{\"1\":{\"43\":1}}],[\"alt+7\",{\"1\":{\"6\":1}}],[\"alt\",{\"1\":{\"6\":1,\"8\":1}}],[\"eq\",{\"1\":{\"854\":1}}],[\"equals\",{\"1\":{\"22\":1,\"242\":6,\"749\":1,\"998\":1}}],[\"ew\",{\"1\":{\"832\":9}}],[\"ehcache\",{\"1\":{\"813\":1}}],[\"eureka的服务发现机制有啥缺点\",{\"0\":{\"801\":1}}],[\"eureka\",{\"1\":{\"800\":2}}],[\"eureka跟zookeeper的区别\",{\"0\":{\"800\":1}}],[\"ez\",{\"1\":{\"756\":1}}],[\"empty\",{\"1\":{\"1024\":3}}],[\"email=\",{\"1\":{\"847\":1,\"848\":1,\"851\":1}}],[\"email\",{\"1\":{\"840\":1,\"844\":1,\"846\":1,\"847\":2,\"848\":2,\"850\":1,\"851\":3,\"852\":1}}],[\"emitlogtopic\",{\"1\":{\"742\":2}}],[\"emitlogdirect\",{\"1\":{\"738\":1}}],[\"emitlog\",{\"1\":{\"734\":1}}],[\"emojis\",{\"1\":{\"143\":1}}],[\"emoji\",{\"1\":{\"131\":1,\"143\":1}}],[\"emoji表情备忘录\",{\"1\":{\"131\":1}}],[\"emoji表情\",{\"0\":{\"131\":1},\"1\":{\"131\":1}}],[\"etcd\",{\"1\":{\"878\":1}}],[\"et\",{\"1\":{\"656\":1,\"832\":2}}],[\"events\",{\"1\":{\"591\":1}}],[\"evict\",{\"1\":{\"242\":1}}],[\"errros\",{\"1\":{\"736\":1}}],[\"errno\",{\"0\":{\"587\":1,\"588\":1},\"1\":{\"587\":1}}],[\"error\",{\"1\":{\"91\":2,\"605\":1,\"687\":2,\"738\":3,\"765\":2,\"768\":1,\"991\":1}}],[\"e\",{\"1\":{\"229\":10,\"242\":3,\"708\":2,\"714\":2,\"717\":2,\"819\":1,\"957\":2,\"991\":1,\"1024\":1}}],[\"eden空间和另外两个survivor空间缺省所占的比例是8\",{\"1\":{\"488\":1}}],[\"eden\",{\"1\":{\"304\":2,\"465\":3,\"488\":2}}],[\"edge\",{\"1\":{\"204\":3,\"205\":3,\"368\":1}}],[\"editor\",{\"1\":{\"18\":1,\"19\":1}}],[\"early\",{\"1\":{\"420\":1}}],[\"easy\",{\"0\":{\"197\":1,\"1025\":1},\"1\":{\"492\":1}}],[\"each\",{\"1\":{\"42\":1,\"244\":1}}],[\"echofilter的作用是判断是否是回声测试请求\",{\"1\":{\"905\":1}}],[\"echofilter\",{\"1\":{\"905\":1}}],[\"echarts\",{\"1\":{\"159\":1}}],[\"eciipse\",{\"1\":{\"492\":1}}],[\"ecj\",{\"1\":{\"367\":1}}],[\"eclipse发布的内存分析工具\",{\"1\":{\"540\":1}}],[\"eclipse\",{\"1\":{\"367\":1}}],[\"ecma官网\",{\"1\":{\"119\":1}}],[\"ecma\",{\"1\":{\"119\":1}}],[\"elephant\",{\"1\":{\"741\":1,\"742\":1}}],[\"elementtype\",{\"1\":{\"791\":2,\"792\":1}}],[\"element\",{\"1\":{\"157\":1,\"229\":2,\"242\":1}}],[\"else\",{\"1\":{\"6\":1,\"187\":1,\"194\":1,\"202\":1,\"203\":1,\"230\":1,\"749\":1,\"762\":1,\"765\":1,\"779\":1,\"832\":2,\"931\":1,\"948\":1,\"957\":1,\"982\":2,\"1024\":4,\"1040\":1}}],[\"egghead\",{\"1\":{\"126\":1}}],[\"escape\",{\"1\":{\"505\":1,\"513\":1}}],[\"es6教程\",{\"1\":{\"119\":1}}],[\"es5教程\",{\"1\":{\"119\":1}}],[\"endoffirsthalf\",{\"1\":{\"975\":2}}],[\"end\",{\"1\":{\"722\":2,\"723\":2,\"819\":2,\"975\":1}}],[\"environment\",{\"1\":{\"681\":1}}],[\"engine\",{\"1\":{\"355\":1,\"375\":1,\"437\":1}}],[\"ensures\",{\"1\":{\"244\":1}}],[\"entity\",{\"1\":{\"832\":4}}],[\"entity层\",{\"1\":{\"643\":1}}],[\"entry<integer\",{\"1\":{\"982\":2}}],[\"entry<requestmappinginfo\",{\"1\":{\"788\":1}}],[\"entry<string\",{\"1\":{\"738\":1,\"742\":1}}],[\"entry是中的key是弱引用\",{\"1\":{\"280\":1}}],[\"entryset\",{\"1\":{\"241\":1,\"738\":1,\"742\":1,\"788\":1}}],[\"enter\",{\"1\":{\"8\":2}}],[\"enfi\",{\"1\":{\"148\":1}}],[\"enablewebsecurity\",{\"1\":{\"788\":1}}],[\"enableautoconfiguration获取的所有配置以及其他形式的ioc容器配置加载到已经准备完毕的applicationcontext\",{\"1\":{\"678\":1}}],[\"enableautoconfiguration\",{\"1\":{\"674\":2,\"676\":2}}],[\"enabled\",{\"1\":{\"670\":1}}],[\"enable\",{\"1\":{\"114\":3,\"756\":3}}],[\"encoding>\",{\"1\":{\"99\":1,\"101\":1}}],[\"encodings\",{\"1\":{\"18\":1,\"19\":1}}],[\"enhance\",{\"1\":{\"55\":1}}],[\"existing\",{\"1\":{\"1011\":1}}],[\"exists\",{\"1\":{\"832\":1}}],[\"exited\",{\"1\":{\"577\":2}}],[\"exact\",{\"0\":{\"350\":1},\"1\":{\"350\":1}}],[\"example\",{\"1\":{\"42\":1,\"660\":1}}],[\"extern\",{\"1\":{\"754\":2,\"757\":1,\"762\":3,\"768\":1}}],[\"external\",{\"1\":{\"435\":1}}],[\"extensionloader\",{\"1\":{\"904\":1}}],[\"extension\",{\"0\":{\"383\":1},\"1\":{\"381\":1}}],[\"extensionclassloader\",{\"1\":{\"331\":1}}],[\"extends\",{\"1\":{\"230\":1,\"251\":1,\"788\":1,\"832\":4,\"833\":2}}],[\"extclassloader\",{\"1\":{\"381\":3}}],[\"extclassloader的父类加载器为\",{\"1\":{\"332\":1}}],[\"ext\",{\"1\":{\"331\":2,\"383\":2}}],[\"exchangebuilder\",{\"1\":{\"768\":4}}],[\"exchangedeclare\",{\"1\":{\"734\":1,\"738\":1,\"742\":1,\"747\":4,\"748\":3,\"749\":3}}],[\"exchanges的类型\",{\"0\":{\"728\":1}}],[\"exchanges\",{\"0\":{\"727\":1}}],[\"exchange\",{\"0\":{\"732\":1,\"735\":1,\"739\":1},\"1\":{\"693\":4,\"697\":2,\"702\":1,\"727\":1,\"728\":2,\"731\":2,\"733\":1,\"734\":6,\"735\":1,\"736\":1,\"737\":1,\"738\":3,\"742\":3,\"747\":18,\"748\":14,\"749\":14,\"754\":8,\"755\":3,\"756\":4,\"757\":7,\"762\":11,\"765\":3,\"768\":14,\"780\":6,\"883\":1}}],[\"exchanger\",{\"1\":{\"292\":1}}],[\"excel等\",{\"1\":{\"646\":1}}],[\"excelsior\",{\"1\":{\"367\":1}}],[\"exceptionfilter\",{\"1\":{\"905\":1}}],[\"exceptionutils\",{\"1\":{\"832\":1}}],[\"exceptionhandling\",{\"1\":{\"788\":1}}],[\"exception\",{\"1\":{\"424\":1,\"605\":1,\"687\":4,\"701\":1,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"779\":2,\"788\":2,\"819\":1}}],[\"exclude=org\",{\"1\":{\"676\":1}}],[\"exclude\",{\"1\":{\"670\":1,\"676\":3}}],[\"excludegroupids>\",{\"1\":{\"106\":1}}],[\"excludes>\",{\"1\":{\"99\":1,\"106\":1}}],[\"exclude>\",{\"1\":{\"99\":1,\"106\":1}}],[\"excluded\",{\"1\":{\"12\":1}}],[\"exclusions>\",{\"1\":{\"83\":1,\"679\":1}}],[\"exclusion>\",{\"1\":{\"83\":1,\"679\":1}}],[\"executor\",{\"1\":{\"818\":1}}],[\"executors返回的线程池对象的弊端如下\",{\"1\":{\"291\":1}}],[\"executors\",{\"1\":{\"291\":4}}],[\"executelimitfilter\",{\"1\":{\"905\":1}}],[\"execute\",{\"1\":{\"277\":1,\"864\":1}}],[\"executions>\",{\"1\":{\"99\":1,\"106\":1}}],[\"execution>\",{\"1\":{\"99\":1,\"106\":1}}],[\"execution\",{\"1\":{\"7\":1,\"355\":1,\"375\":1,\"605\":1}}],[\"exporter\",{\"1\":{\"889\":1,\"891\":1}}],[\"export\",{\"1\":{\"889\":2,\"892\":1}}],[\"expected\",{\"1\":{\"832\":1}}],[\"expiration\",{\"1\":{\"747\":1,\"748\":1}}],[\"explorerpatcher\",{\"0\":{\"111\":1},\"1\":{\"111\":2}}],[\"expression<\",{\"1\":{\"87\":1,\"88\":1}}],[\"expression\",{\"1\":{\"85\":1,\"416\":1}}],[\">next\",{\"1\":{\"970\":4}}],[\">null\",{\"1\":{\"967\":2,\"970\":3}}],[\">1\",{\"1\":{\"967\":1,\"970\":1}}],[\">5\",{\"1\":{\"967\":1}}],[\">4\",{\"1\":{\"967\":2,\"970\":3}}],[\">3\",{\"1\":{\"967\":2,\"970\":2}}],[\">2\",{\"1\":{\"967\":2,\"970\":1}}],[\">0\",{\"1\":{\"965\":1}}],[\">绑定的是\",{\"1\":{\"741\":2,\"742\":2}}],[\">=0\",{\"1\":{\"934\":2,\"943\":2}}],[\">=\",{\"1\":{\"187\":1,\"194\":1,\"207\":2,\"239\":1,\"253\":1,\"852\":1,\"957\":1,\"983\":2,\"984\":1,\"1029\":1}}],[\">>>\",{\"1\":{\"184\":5,\"239\":5,\"244\":6,\"253\":10}}],[\">>\",{\"1\":{\"28\":1}}],[\">\",{\"1\":{\"7\":4,\"12\":1,\"14\":2,\"15\":4,\"16\":1,\"18\":2,\"19\":3,\"61\":3,\"70\":5,\"83\":3,\"87\":3,\"88\":8,\"99\":6,\"106\":4,\"186\":1,\"194\":10,\"202\":1,\"239\":1,\"241\":2,\"253\":6,\"279\":2,\"343\":6,\"381\":3,\"546\":2,\"548\":3,\"549\":9,\"601\":1,\"617\":1,\"649\":1,\"656\":4,\"670\":1,\"671\":3,\"674\":3,\"679\":1,\"687\":1,\"696\":3,\"698\":2,\"701\":2,\"708\":2,\"714\":2,\"717\":2,\"723\":1,\"747\":4,\"748\":2,\"749\":4,\"752\":1,\"753\":2,\"755\":1,\"757\":1,\"779\":2,\"780\":1,\"813\":1,\"814\":2,\"815\":1,\"819\":2,\"820\":8,\"830\":1,\"832\":2,\"847\":1,\"848\":2,\"851\":2,\"854\":1,\"864\":3,\"905\":8,\"911\":1,\"925\":1,\"926\":2,\"931\":2,\"939\":2,\"943\":2,\"957\":1,\"963\":1,\"982\":1,\"983\":1,\"1011\":2,\"1034\":2,\"1040\":2}}],[\"选项\",{\"1\":{\"506\":2}}],[\"选用\",{\"1\":{\"231\":1}}],[\"选第\",{\"1\":{\"207\":1}}],[\"选\",{\"1\":{\"207\":2}}],[\"选择\",{\"1\":{\"583\":1,\"670\":1,\"702\":1,\"783\":1,\"1011\":1}}],[\"选择线上所有分支\",{\"1\":{\"583\":1}}],[\"选择哪种分配方式由\",{\"1\":{\"311\":1,\"471\":1}}],[\"选择性通知\",{\"1\":{\"286\":1}}],[\"选择的\",{\"1\":{\"286\":1}}],[\"选择该物品时的总价值\",{\"1\":{\"207\":1}}],[\"选择第二件和第三件物品\",{\"1\":{\"207\":1}}],[\"选择排序\",{\"1\":{\"171\":1}}],[\"选择markdown\",{\"1\":{\"55\":1}}],[\"选择assign\",{\"1\":{\"11\":1}}],[\"选择add\",{\"1\":{\"11\":2}}],[\"选择rename\",{\"1\":{\"11\":1}}],[\"选择创建子类\",{\"1\":{\"6\":1}}],[\"选中\",{\"1\":{\"701\":1}}],[\"选中当前词\",{\"1\":{\"45\":1}}],[\"选中当前格式文本\",{\"1\":{\"45\":1}}],[\"选中当前行\",{\"1\":{\"45\":1}}],[\"选中接口\",{\"1\":{\"6\":1}}],[\"选中代码\",{\"1\":{\"6\":1}}],[\"ccc\",{\"1\":{\"996\":1}}],[\"cj\",{\"1\":{\"831\":1,\"866\":2}}],[\"cycle\",{\"1\":{\"614\":1}}],[\"cyclicbarrier创建时的int参数是await的数量\",{\"1\":{\"292\":1}}],[\"cyclicbarrier\",{\"1\":{\"292\":2}}],[\"cyclic\",{\"1\":{\"91\":1}}],[\"cutting\",{\"1\":{\"879\":1}}],[\"cutting功能\",{\"1\":{\"604\":1}}],[\"customexchange\",{\"1\":{\"757\":4}}],[\"cur=cur\",{\"1\":{\"1024\":1}}],[\"cur=null\",{\"1\":{\"1024\":1}}],[\"curr\",{\"1\":{\"975\":6}}],[\"currentry\",{\"1\":{\"982\":3}}],[\"currenttimemillis\",{\"1\":{\"722\":2,\"723\":2}}],[\"currentthread\",{\"1\":{\"389\":1}}],[\"current\",{\"1\":{\"413\":3}}],[\"cur指向了第二个节点\",{\"1\":{\"970\":1}}],[\"cur指向head\",{\"1\":{\"970\":1}}],[\"cur移到tmp处\",{\"1\":{\"970\":1}}],[\"curlen++\",{\"1\":{\"931\":1,\"1040\":1}}],[\"curlen\",{\"1\":{\"931\":4,\"1040\":4}}],[\"curlen为当前下标对应的长度\",{\"1\":{\"930\":1,\"1039\":1}}],[\"curd\",{\"1\":{\"827\":1}}],[\"cur\",{\"1\":{\"187\":6,\"194\":15,\"199\":4,\"957\":5,\"968\":6,\"970\":1,\"1024\":23}}],[\"cglib代理\",{\"1\":{\"878\":1}}],[\"cglib字节码生成技术代理\",{\"1\":{\"627\":1}}],[\"cglib采用底层的字节码技术\",{\"1\":{\"603\":1}}],[\"cglib的动态代理\",{\"1\":{\"603\":1}}],[\"cglib\",{\"1\":{\"464\":1,\"596\":1,\"606\":1,\"821\":1,\"894\":1}}],[\"ce0c\",{\"1\":{\"381\":1}}],[\"ceneration\",{\"1\":{\"336\":1}}],[\"central\",{\"1\":{\"61\":1}}],[\"central<\",{\"1\":{\"61\":1}}],[\"c1\",{\"1\":{\"738\":1,\"747\":7,\"748\":1,\"749\":5}}],[\"c1主要有方法内联\",{\"1\":{\"372\":1}}],[\"c1编译器会堆字节码进行简单和可靠的优化\",{\"1\":{\"372\":1}}],[\"c1编译器\",{\"1\":{\"372\":1}}],[\"c2编译会根据性能监控信息进行激进优化\",{\"1\":{\"372\":1}}],[\"c2编译器执行速度远远快于c1编译器\",{\"1\":{\"372\":1}}],[\"c2编译器启动时长比c1编译器慢\",{\"1\":{\"372\":1}}],[\"c2编译器\",{\"1\":{\"372\":1}}],[\"c2的优化主要是在全局层面\",{\"1\":{\"372\":1}}],[\"c2进行较长时间的优化\",{\"1\":{\"372\":1}}],[\"c2\",{\"1\":{\"367\":1,\"738\":1,\"747\":2,\"748\":2,\"749\":2}}],[\"ciassloader\",{\"1\":{\"381\":2}}],[\"ci\",{\"1\":{\"367\":1}}],[\"cisai\",{\"1\":{\"106\":1}}],[\"cm\",{\"1\":{\"832\":2}}],[\"cms已被移除\",{\"1\":{\"534\":1}}],[\"cms回收停顿了几次\",{\"1\":{\"518\":1}}],[\"cms解决什么问题\",{\"1\":{\"518\":1}}],[\"cms和g1了解么\",{\"1\":{\"518\":1}}],[\"cms\",{\"0\":{\"534\":1},\"1\":{\"518\":1,\"525\":3,\"531\":1,\"532\":1,\"533\":1,\"534\":3,\"535\":3,\"536\":1,\"539\":1}}],[\"cms收集器与g1收集器的特点\",{\"1\":{\"518\":1}}],[\"cms收集器的默认值是6\",{\"1\":{\"503\":1}}],[\"cms垃圾收集器\",{\"1\":{\"339\":1}}],[\"cmd\",{\"1\":{\"114\":1,\"1010\":1}}],[\"c++程序\",{\"1\":{\"434\":1}}],[\"c++\",{\"1\":{\"363\":1,\"365\":1,\"382\":1}}],[\"c++实现\",{\"1\":{\"331\":1}}],[\"c+1\",{\"1\":{\"207\":1}}],[\"csrf\",{\"1\":{\"788\":1}}],[\"csdn\",{\"1\":{\"289\":1,\"293\":1,\"674\":1}}],[\"cssicon\",{\"1\":{\"139\":1}}],[\"css动画可视化工具\",{\"1\":{\"134\":1}}],[\"css的各种demo\",{\"1\":{\"134\":1}}],[\"css技巧文章\",{\"1\":{\"134\":1}}],[\"css技巧收集与演示\",{\"1\":{\"134\":1}}],[\"css3\",{\"1\":{\"134\":1}}],[\"css渐变生成器\",{\"1\":{\"134\":1}}],[\"css生成器\",{\"1\":{\"134\":1}}],[\"css\",{\"0\":{\"134\":1},\"1\":{\"134\":4,\"139\":4,\"158\":1,\"788\":1}}],[\"cpu会不停地做任务切换\",{\"1\":{\"402\":1}}],[\"cpu\",{\"1\":{\"267\":5,\"532\":3,\"534\":1,\"535\":4,\"697\":1,\"777\":1,\"779\":1}}],[\"chronounit\",{\"1\":{\"568\":2}}],[\"checkargument\",{\"1\":{\"998\":1}}],[\"checkargument和checkstate有大量的重载方法\",{\"1\":{\"997\":1}}],[\"checkandremove\",{\"1\":{\"194\":2}}],[\"checknotnull\",{\"1\":{\"997\":1,\"998\":3}}],[\"check\",{\"1\":{\"975\":1}}],[\"checkrecord\",{\"1\":{\"673\":2}}],[\"cherry\",{\"1\":{\"584\":4}}],[\"chengxiao\",{\"1\":{\"249\":2}}],[\"changmingxie\",{\"1\":{\"910\":1}}],[\"change\",{\"1\":{\"35\":1}}],[\"channel\",{\"1\":{\"308\":1,\"693\":7,\"697\":9,\"698\":4,\"701\":10,\"702\":2,\"705\":1,\"706\":6,\"708\":12,\"711\":5,\"712\":4,\"714\":6,\"717\":7,\"721\":2,\"722\":7,\"723\":8,\"729\":1,\"730\":1,\"734\":5,\"735\":1,\"738\":5,\"742\":5,\"747\":22,\"748\":13,\"749\":17,\"754\":3,\"762\":1,\"777\":1,\"779\":10,\"780\":2,\"783\":2}}],[\"character\",{\"1\":{\"957\":3}}],[\"characterencoding=utf\",{\"1\":{\"831\":1,\"864\":1,\"866\":2}}],[\"characterencodingfilter<\",{\"1\":{\"649\":1}}],[\"charat\",{\"1\":{\"948\":1,\"949\":1,\"957\":4}}],[\"charset\",{\"1\":{\"742\":1,\"747\":2}}],[\"chars\",{\"1\":{\"188\":7}}],[\"char\",{\"1\":{\"188\":1,\"424\":1,\"948\":2,\"949\":2,\"954\":1}}],[\"crud\",{\"1\":{\"827\":3,\"833\":2}}],[\"cruip\",{\"1\":{\"142\":1}}],[\"crossorigin注解来解决\",{\"1\":{\"673\":1}}],[\"crossorigin\",{\"1\":{\"673\":3}}],[\"cross\",{\"1\":{\"604\":1}}],[\"cropper\",{\"1\":{\"160\":1}}],[\"createserver\",{\"1\":{\"889\":1}}],[\"create\",{\"1\":{\"864\":1}}],[\"createchannel\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"created\",{\"1\":{\"577\":1}}],[\"createtime\",{\"1\":{\"241\":1}}],[\"craig\",{\"1\":{\"289\":1}}],[\"cdn\",{\"1\":{\"135\":2}}],[\"cdn加速\",{\"0\":{\"135\":1}}],[\"cd\",{\"1\":{\"114\":1,\"756\":2}}],[\"cause\",{\"1\":{\"762\":3,\"765\":3}}],[\"cachingconnectionfactory\",{\"1\":{\"754\":3}}],[\"cache=\",{\"1\":{\"911\":2}}],[\"cache\",{\"1\":{\"668\":1,\"813\":1}}],[\"cachedthreadpool\",{\"1\":{\"291\":1}}],[\"call\",{\"1\":{\"873\":1}}],[\"callbacks\",{\"1\":{\"724\":1}}],[\"callback\",{\"1\":{\"687\":2}}],[\"callerrunspolicy\",{\"1\":{\"275\":1}}],[\"calendar传入0的话\",{\"1\":{\"566\":1}}],[\"case\",{\"1\":{\"617\":1,\"788\":5}}],[\"cas\",{\"1\":{\"249\":1,\"252\":1,\"471\":1}}],[\"cap理论解读\",{\"1\":{\"797\":1}}],[\"cap理论\",{\"0\":{\"797\":1}}],[\"cap\",{\"1\":{\"239\":2,\"253\":3,\"797\":1}}],[\"capacity\",{\"1\":{\"239\":6,\"253\":2}}],[\"carbon代码图片生成器\",{\"1\":{\"138\":1}}],[\"cargo\",{\"1\":{\"94\":1}}],[\"canmeasurewater\",{\"1\":{\"982\":1,\"983\":1,\"984\":1}}],[\"cancelcallback\",{\"1\":{\"698\":3,\"701\":4,\"708\":5,\"714\":3,\"717\":3,\"779\":4}}],[\"canva\",{\"1\":{\"139\":1}}],[\"can\",{\"1\":{\"129\":1,\"143\":1,\"515\":1}}],[\"catch\",{\"1\":{\"6\":1,\"708\":1,\"714\":1,\"717\":1,\"819\":1,\"991\":1}}],[\"c\",{\"1\":{\"81\":5,\"82\":4,\"91\":2,\"206\":1,\"207\":11,\"234\":1,\"257\":1,\"258\":3,\"259\":1,\"317\":5,\"363\":1,\"365\":1,\"382\":1,\"422\":3,\"434\":1,\"645\":1,\"695\":1,\"755\":5,\"780\":1,\"820\":1,\"864\":1,\"879\":1,\"944\":4,\"948\":5,\"949\":4,\"1024\":1}}],[\"cluster\",{\"1\":{\"883\":1,\"885\":1,\"890\":1,\"891\":2,\"892\":1,\"917\":6}}],[\"closesqlsession\",{\"1\":{\"819\":1}}],[\"close\",{\"1\":{\"813\":1}}],[\"cloud是基于http协议rest接口调用远程过程的通信\",{\"1\":{\"887\":1}}],[\"cloud是打造一个生态\",{\"1\":{\"886\":1}}],[\"cloud有什么哪些区别\",{\"0\":{\"887\":1}}],[\"cloud有什么关系\",{\"0\":{\"886\":1}}],[\"cloud诞生于微服务架构时代\",{\"1\":{\"886\":1}}],[\"cloud\",{\"0\":{\"1015\":1},\"1\":{\"802\":1}}],[\"cloud合集\",{\"1\":{\"795\":1}}],[\"cloud的区别\",{\"0\":{\"666\":1}}],[\"cloud相关框架技术\",{\"1\":{\"665\":1}}],[\"cloneable\",{\"1\":{\"468\":1}}],[\"clone\",{\"1\":{\"240\":1,\"468\":2,\"1004\":1}}],[\"clh\",{\"1\":{\"289\":3}}],[\"clear\",{\"1\":{\"233\":1,\"813\":1}}],[\"clean\",{\"1\":{\"73\":1,\"94\":4}}],[\"client客户端\",{\"1\":{\"874\":1}}],[\"client<\",{\"1\":{\"696\":1}}],[\"client\",{\"1\":{\"372\":1,\"697\":3,\"698\":1,\"701\":7,\"708\":4,\"711\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":2,\"742\":2,\"747\":9,\"754\":1,\"779\":5,\"874\":5}}],[\"climbstairs\",{\"1\":{\"200\":1}}],[\"clip\",{\"1\":{\"139\":1}}],[\"clippy\",{\"1\":{\"139\":1}}],[\"classcondition\",{\"1\":{\"675\":1}}],[\"class>\",{\"1\":{\"649\":1}}],[\"class>org\",{\"1\":{\"649\":1}}],[\"class注解了解吗\",{\"0\":{\"637\":1}}],[\"class=\",{\"1\":{\"617\":1,\"656\":1}}],[\"class设置为true或者使用了优化策略那么会使用cglib来创建动态代理\",{\"1\":{\"603\":1}}],[\"classnotfoundexception\",{\"1\":{\"470\":1}}],[\"class文件就已经存在了\",{\"1\":{\"607\":1}}],[\"class文件\",{\"1\":{\"470\":1}}],[\"class文件在文件开头有特定的文件标识\",{\"1\":{\"375\":1}}],[\"classfile\",{\"1\":{\"456\":2}}],[\"class对象\",{\"1\":{\"395\":1}}],[\"classic\",{\"0\":{\"349\":1}}],[\"classpath\",{\"1\":{\"331\":1,\"384\":1,\"892\":1}}],[\"classpathprefix>\",{\"1\":{\"103\":1,\"106\":1}}],[\"classloaderfilter\",{\"1\":{\"905\":1}}],[\"classloader已经填充好了并且是可用的\",{\"1\":{\"670\":1}}],[\"classloader会被丢弃\",{\"1\":{\"670\":1}}],[\"classloader对象的实例\",{\"1\":{\"614\":1}}],[\"classloadertest\",{\"1\":{\"381\":1}}],[\"classloader=\",{\"1\":{\"381\":1}}],[\"classloaderdemo\",{\"1\":{\"332\":4}}],[\"classloader\",{\"0\":{\"382\":1,\"383\":1,\"388\":1,\"389\":1},\"1\":{\"329\":1,\"331\":2,\"332\":1,\"375\":1,\"381\":7,\"382\":1,\"383\":1,\"384\":2,\"387\":2,\"388\":3,\"389\":2,\"395\":1,\"470\":1,\"670\":2}}],[\"class\",{\"0\":{\"378\":1},\"1\":{\"99\":1,\"103\":2,\"194\":1,\"234\":1,\"241\":1,\"242\":1,\"251\":1,\"278\":1,\"307\":1,\"329\":1,\"332\":4,\"343\":1,\"345\":2,\"367\":1,\"375\":3,\"378\":2,\"379\":2,\"381\":5,\"382\":1,\"384\":1,\"390\":1,\"392\":2,\"397\":1,\"413\":1,\"459\":2,\"464\":2,\"470\":1,\"510\":2,\"602\":1,\"605\":1,\"607\":1,\"617\":1,\"619\":1,\"673\":2,\"674\":1,\"676\":4,\"687\":1,\"697\":1,\"698\":1,\"701\":3,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"748\":2,\"749\":2,\"753\":2,\"754\":4,\"755\":2,\"757\":3,\"762\":4,\"765\":2,\"768\":2,\"779\":2,\"780\":3,\"788\":4,\"792\":7,\"831\":1,\"833\":1,\"857\":1,\"860\":2,\"864\":1,\"866\":2,\"904\":1,\"925\":1,\"931\":1,\"934\":1,\"938\":1,\"939\":1,\"943\":1,\"944\":1,\"954\":1,\"963\":2,\"965\":2,\"968\":2,\"973\":2,\"975\":1,\"982\":1,\"983\":1,\"984\":1,\"990\":1,\"1020\":1,\"1022\":1,\"1029\":2,\"1030\":1,\"1034\":2,\"1035\":1,\"1040\":1}}],[\"classesresultmap2\",{\"1\":{\"820\":1}}],[\"classes<\",{\"1\":{\"99\":1}}],[\"classestest\",{\"1\":{\"94\":1}}],[\"classesgenerate\",{\"1\":{\"94\":1}}],[\"classes\",{\"1\":{\"74\":2,\"686\":1,\"820\":1}}],[\"cnblogs\",{\"1\":{\"249\":2,\"614\":1}}],[\"cn\",{\"1\":{\"35\":3,\"110\":1,\"247\":1,\"1038\":1}}],[\"correlated\",{\"1\":{\"762\":3,\"765\":1}}],[\"correlationdata2\",{\"1\":{\"762\":2}}],[\"correlationdata1\",{\"1\":{\"762\":2}}],[\"correlationdata\",{\"1\":{\"752\":2,\"755\":3,\"757\":3,\"762\":11,\"765\":5,\"780\":3}}],[\"corsregistry\",{\"1\":{\"673\":1}}],[\"corsconfig\",{\"1\":{\"673\":1}}],[\"cors\",{\"1\":{\"673\":3}}],[\"corepoolsize\",{\"1\":{\"275\":1,\"277\":4}}],[\"core<\",{\"1\":{\"87\":2,\"88\":1}}],[\"core\",{\"1\":{\"78\":1,\"85\":1,\"591\":2,\"687\":2,\"753\":1,\"754\":5,\"755\":1,\"757\":1,\"762\":4,\"768\":1,\"832\":1}}],[\"copying\",{\"0\":{\"522\":1},\"1\":{\"520\":1}}],[\"copyonwritearraylist\",{\"1\":{\"292\":2}}],[\"coolshell\",{\"1\":{\"247\":1}}],[\"coolors\",{\"1\":{\"139\":1}}],[\"count\",{\"1\":{\"547\":1,\"722\":3,\"723\":3,\"832\":3,\"939\":14}}],[\"counterhalflifetime\",{\"1\":{\"369\":1}}],[\"counter\",{\"1\":{\"368\":2,\"369\":2}}],[\"countdownlatch\",{\"1\":{\"292\":1}}],[\"countbits\",{\"1\":{\"203\":2}}],[\"countgoodsubstrings\",{\"1\":{\"188\":1}}],[\"columnmap\",{\"1\":{\"832\":2}}],[\"column=\",{\"1\":{\"820\":5}}],[\"coll\",{\"1\":{\"258\":4,\"832\":2}}],[\"collisions\",{\"1\":{\"244\":1}}],[\"collecting\",{\"1\":{\"526\":1}}],[\"collectionutils\",{\"1\":{\"832\":1}}],[\"collection<\",{\"1\":{\"832\":2}}],[\"collection<t>\",{\"1\":{\"259\":1}}],[\"collection>\",{\"1\":{\"820\":1}}],[\"collection\",{\"1\":{\"258\":5,\"259\":2,\"482\":1,\"821\":2}}],[\"collections工具类\",{\"0\":{\"256\":1}}],[\"collections\",{\"1\":{\"230\":2,\"235\":1,\"256\":1,\"259\":2,\"864\":1,\"888\":1},\"2\":{\"261\":1}}],[\"collection接口\",{\"1\":{\"214\":1}}],[\"collected\",{\"1\":{\"304\":1}}],[\"collectors\",{\"1\":{\"234\":2,\"548\":1,\"549\":2,\"957\":1,\"992\":1}}],[\"collect\",{\"1\":{\"234\":2,\"546\":2,\"547\":1,\"548\":3,\"549\":4,\"957\":1,\"992\":1}}],[\"collectui\",{\"1\":{\"139\":1}}],[\"colorkitty\",{\"1\":{\"139\":1}}],[\"colorhunt\",{\"1\":{\"139\":1}}],[\"convertandsend\",{\"1\":{\"754\":2,\"755\":3,\"757\":1,\"762\":2,\"780\":1}}],[\"converandsend\",{\"1\":{\"752\":1}}],[\"conditiomalonsinglecandidate\",{\"1\":{\"675\":1}}],[\"conditiononjndi\",{\"1\":{\"675\":1}}],[\"conditiononjava\",{\"1\":{\"675\":1}}],[\"conditiononnotwebapplication\",{\"1\":{\"675\":1}}],[\"conditiononwebapplication\",{\"1\":{\"675\":1}}],[\"conditionalresource\",{\"1\":{\"675\":1}}],[\"conditional注解\",{\"1\":{\"675\":13}}],[\"conditional要配合condition的实现类\",{\"1\":{\"675\":1}}],[\"conditional相关的注解\",{\"0\":{\"675\":1}}],[\"conditionaloncloudplatform\",{\"1\":{\"675\":1}}],[\"conditionalonclass\",{\"1\":{\"674\":1,\"675\":1}}],[\"conditionalonexpression\",{\"1\":{\"675\":1}}],[\"conditionalonenabledhealthindicator\",{\"1\":{\"674\":1}}],[\"conditionalonresource\",{\"1\":{\"674\":1}}],[\"conditionalonproperty\",{\"1\":{\"674\":1,\"675\":1}}],[\"conditionalonmissingbean\",{\"1\":{\"674\":1,\"675\":1}}],[\"conditionalonmissingclass\",{\"1\":{\"674\":1,\"675\":1}}],[\"conditionalonbean\",{\"1\":{\"674\":1,\"675\":1}}],[\"conditional的引用链如下\",{\"1\":{\"674\":1}}],[\"conditional是一个条件注解\",{\"1\":{\"674\":1}}],[\"conditional来实现的\",{\"1\":{\"674\":1}}],[\"condition是\",{\"1\":{\"286\":1}}],[\"condition\",{\"0\":{\"852\":1},\"1\":{\"282\":1,\"286\":1}}],[\"condition的await\",{\"1\":{\"265\":1}}],[\"conntroller\",{\"1\":{\"651\":1}}],[\"connect\",{\"1\":{\"588\":1}}],[\"connectionfactory\",{\"1\":{\"697\":9,\"698\":7,\"701\":8,\"754\":12}}],[\"connectiontimeout=\",{\"1\":{\"649\":1}}],[\"connection\",{\"1\":{\"587\":1,\"693\":6,\"697\":4,\"698\":3,\"701\":4,\"754\":2,\"762\":2}}],[\"consul\",{\"1\":{\"878\":1}}],[\"consumes\",{\"1\":{\"792\":2}}],[\"consumer端在发起调用之前会先走filter链\",{\"1\":{\"902\":1}}],[\"consumer信息的中介\",{\"1\":{\"882\":1}}],[\"consumer02\",{\"1\":{\"747\":2,\"749\":2}}],[\"consumer01\",{\"1\":{\"747\":2,\"748\":2,\"749\":3}}],[\"consumertag\",{\"1\":{\"698\":2,\"701\":3,\"708\":1,\"714\":1,\"717\":1,\"747\":4,\"748\":2,\"749\":4,\"779\":2}}],[\"consumer\",{\"1\":{\"693\":2,\"698\":1,\"744\":1,\"754\":1,\"757\":1,\"762\":2,\"768\":1,\"882\":4}}],[\"consistency\",{\"1\":{\"797\":1}}],[\"considered\",{\"1\":{\"515\":1}}],[\"console\",{\"1\":{\"738\":1}}],[\"console结果如下\",{\"1\":{\"605\":1}}],[\"constructor\",{\"1\":{\"468\":1,\"598\":1,\"619\":2}}],[\"constanthash\",{\"1\":{\"916\":1}}],[\"constant\",{\"1\":{\"244\":1,\"317\":1,\"379\":3,\"459\":2}}],[\"concurrentlinkedqueue\",{\"1\":{\"724\":1}}],[\"concurrent\",{\"1\":{\"534\":1,\"697\":1,\"698\":1,\"701\":2,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3}}],[\"concurrenthashmap原理\",{\"1\":{\"292\":1}}],[\"concurrenthashmap\",{\"0\":{\"249\":1,\"250\":1},\"1\":{\"216\":1,\"239\":1,\"247\":1,\"249\":7,\"251\":2,\"252\":1,\"292\":1}}],[\"concat\",{\"1\":{\"319\":2}}],[\"content\",{\"1\":{\"1009\":2}}],[\"contextfilter\",{\"1\":{\"905\":1}}],[\"context<\",{\"1\":{\"87\":1,\"88\":1}}],[\"context\",{\"1\":{\"85\":1,\"591\":1,\"678\":1,\"753\":1,\"754\":5,\"755\":2,\"762\":2}}],[\"continue\",{\"1\":{\"982\":1}}],[\"controlleradvise\",{\"1\":{\"650\":1}}],[\"controller层\",{\"1\":{\"643\":1}}],[\"controller\",{\"1\":{\"605\":1,\"618\":1,\"638\":1,\"645\":2,\"651\":1,\"754\":3,\"755\":2,\"757\":1,\"762\":2,\"780\":1,\"827\":1}}],[\"control\",{\"1\":{\"595\":1}}],[\"contains\",{\"1\":{\"982\":1,\"983\":1}}],[\"containsnearbyduplicate\",{\"1\":{\"186\":1}}],[\"container\",{\"1\":{\"591\":1,\"882\":1}}],[\"contain\",{\"1\":{\"91\":1,\"242\":1}}],[\"confirmconsumer\",{\"1\":{\"762\":1}}],[\"confirmconfig\",{\"1\":{\"762\":1,\"768\":1}}],[\"confirmcallback\",{\"1\":{\"762\":1,\"765\":1}}],[\"confirmqueue\",{\"1\":{\"762\":3,\"768\":3}}],[\"confirmexchange\",{\"1\":{\"762\":3,\"768\":3}}],[\"confirmmessage2\",{\"1\":{\"723\":1}}],[\"confirmmessage\",{\"1\":{\"722\":1}}],[\"confirmselect\",{\"1\":{\"721\":2,\"722\":1,\"723\":1}}],[\"confirm\",{\"1\":{\"720\":3,\"724\":1,\"762\":23,\"765\":4,\"768\":8}}],[\"configure\",{\"1\":{\"788\":2}}],[\"configurablebeanfactory\",{\"1\":{\"754\":2}}],[\"configurablewebapplicationcontext\",{\"1\":{\"678\":1}}],[\"configurationproperties\",{\"1\":{\"681\":1}}],[\"configurations\",{\"1\":{\"671\":1,\"674\":1}}],[\"configuration\",{\"1\":{\"340\":2,\"617\":1,\"673\":1,\"674\":1,\"754\":4,\"755\":2,\"757\":1,\"762\":2,\"768\":1,\"780\":1,\"788\":2,\"822\":1,\"831\":1,\"835\":1,\"836\":1,\"857\":1,\"860\":1}}],[\"configuration>\",{\"1\":{\"99\":1,\"101\":1,\"106\":2,\"696\":1}}],[\"config代替了原有难以管理的springxml配置\",{\"1\":{\"665\":1}}],[\"config\",{\"1\":{\"587\":1,\"601\":1,\"754\":3,\"755\":1,\"762\":1,\"788\":1,\"835\":2,\"836\":2,\"883\":1}}],[\"conf\",{\"1\":{\"41\":1,\"42\":1,\"61\":1}}],[\"comixify\",{\"1\":{\"142\":1}}],[\"common\",{\"1\":{\"989\":1,\"995\":1}}],[\"commonresult<deliveryrecord>\",{\"1\":{\"673\":1}}],[\"commonresult<integer>\",{\"1\":{\"673\":1}}],[\"commons\",{\"1\":{\"85\":2,\"628\":1}}],[\"committed\",{\"1\":{\"634\":1}}],[\"commit\",{\"1\":{\"585\":3,\"633\":1}}],[\"comment\",{\"1\":{\"143\":1}}],[\"commandlinerunner\",{\"1\":{\"687\":4}}],[\"command\",{\"1\":{\"131\":1}}],[\"compressstring\",{\"1\":{\"954\":1}}],[\"componentscan\",{\"1\":{\"617\":1,\"674\":1}}],[\"component通常是通过类路径扫描来自动侦测以及自动装配到\",{\"1\":{\"617\":1}}],[\"component\",{\"0\":{\"617\":1},\"1\":{\"617\":3,\"618\":2,\"687\":1,\"754\":2,\"757\":2,\"762\":4,\"765\":1,\"768\":2,\"780\":1}}],[\"compact\",{\"0\":{\"523\":1},\"1\":{\"520\":1,\"523\":2,\"525\":2}}],[\"compactfields\",{\"1\":{\"477\":1}}],[\"compare\",{\"1\":{\"241\":3,\"471\":1}}],[\"comparator\",{\"1\":{\"257\":1,\"258\":2}}],[\"comparator<person>\",{\"1\":{\"241\":1}}],[\"comparable<\",{\"1\":{\"230\":1}}],[\"compiier\",{\"1\":{\"367\":1}}],[\"compiletestjava\",{\"1\":{\"1010\":1}}],[\"compilethreshold\",{\"1\":{\"369\":1}}],[\"compile\",{\"1\":{\"74\":2,\"80\":5,\"81\":1,\"85\":7,\"94\":2,\"98\":4}}],[\"compilerversion>\",{\"1\":{\"61\":1}}],[\"compilerversion>1\",{\"1\":{\"61\":1}}],[\"compiler\",{\"0\":{\"101\":1},\"1\":{\"61\":6,\"97\":1,\"98\":1,\"101\":1,\"343\":1,\"358\":1,\"367\":2,\"372\":2,\"670\":1,\"696\":1}}],[\"completion\",{\"1\":{\"16\":1}}],[\"com\",{\"1\":{\"41\":1,\"47\":1,\"61\":2,\"77\":1,\"110\":3,\"111\":2,\"113\":1,\"114\":1,\"249\":2,\"279\":1,\"293\":1,\"397\":1,\"588\":2,\"595\":2,\"605\":1,\"614\":2,\"617\":1,\"656\":1,\"677\":1,\"697\":4,\"698\":2,\"701\":12,\"708\":8,\"711\":3,\"722\":3,\"723\":3,\"734\":3,\"738\":4,\"742\":4,\"747\":15,\"753\":1,\"754\":5,\"755\":1,\"757\":1,\"762\":5,\"768\":1,\"779\":9,\"816\":2,\"820\":3,\"831\":3,\"832\":1,\"847\":1,\"848\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"866\":2,\"910\":1,\"989\":1,\"995\":1,\"1004\":1,\"1008\":1,\"1009\":2,\"1038\":1}}],[\"codesandbox\",{\"1\":{\"130\":1}}],[\"codepen\",{\"1\":{\"130\":1}}],[\"code\",{\"1\":{\"16\":1,\"42\":1,\"129\":1,\"362\":2,\"765\":2,\"944\":8}}],[\"ctrl\",{\"1\":{\"6\":1,\"8\":1,\"27\":1,\"42\":1}}],[\"ctrl+k\",{\"1\":{\"47\":1}}],[\"ctrl+u\",{\"1\":{\"47\":1}}],[\"ctrl+i\",{\"1\":{\"47\":1}}],[\"ctrl+b\",{\"1\":{\"47\":1}}],[\"ctrl+tab\",{\"1\":{\"48\":1}}],[\"ctrl+t\",{\"1\":{\"46\":1}}],[\"ctrl+=\",{\"1\":{\"46\":1}}],[\"ctrl+0\",{\"1\":{\"46\":1}}],[\"ctrl+1\",{\"1\":{\"46\":1}}],[\"ctrl+j\",{\"1\":{\"45\":1}}],[\"ctrl+l\",{\"1\":{\"45\":1}}],[\"ctrl+a\",{\"1\":{\"45\":1}}],[\"ctrl+alt+left\",{\"1\":{\"6\":1}}],[\"ctrl+alt+l\",{\"1\":{\"6\":1}}],[\"ctrl+c\",{\"1\":{\"45\":1}}],[\"ctrl+x\",{\"1\":{\"45\":1}}],[\"ctrl+y\",{\"1\":{\"45\":1}}],[\"ctrl+z\",{\"1\":{\"45\":1}}],[\"ctrl+w\",{\"1\":{\"44\":1}}],[\"ctrl+\",{\"1\":{\"44\":1,\"46\":3,\"47\":1,\"48\":1}}],[\"ctrl+s\",{\"1\":{\"44\":1}}],[\"ctrl+shift+=\",{\"1\":{\"48\":1}}],[\"ctrl+shift+0\",{\"1\":{\"48\":1}}],[\"ctrl+shift+3\",{\"1\":{\"48\":1}}],[\"ctrl+shift+2\",{\"1\":{\"48\":1}}],[\"ctrl+shift+1\",{\"1\":{\"48\":1}}],[\"ctrl+shift+l\",{\"1\":{\"48\":1}}],[\"ctrl+shift+i\",{\"1\":{\"47\":1}}],[\"ctrl+shift+`\",{\"1\":{\"47\":1}}],[\"ctrl+shift+\",{\"1\":{\"46\":2,\"48\":1}}],[\"ctrl+shift+q\",{\"1\":{\"46\":1}}],[\"ctrl+shift+m\",{\"1\":{\"46\":1}}],[\"ctrl+shift+k\",{\"1\":{\"46\":1}}],[\"ctrl+shift+c\",{\"1\":{\"45\":1}}],[\"ctrl+shift+s\",{\"1\":{\"44\":1}}],[\"ctrl+shift+n\",{\"1\":{\"44\":1}}],[\"ctrl+shift+v\",{\"1\":{\"42\":1,\"45\":1}}],[\"ctrl+shift+p\",{\"1\":{\"42\":1}}],[\"ctrl+shift+a\",{\"1\":{\"21\":1}}],[\"ctrl+shift+alt+t\",{\"1\":{\"6\":1}}],[\"ctrl+shift+enter\",{\"1\":{\"6\":1}}],[\"ctrl+shift+up\",{\"1\":{\"6\":1}}],[\"ctrl+shift+u\",{\"1\":{\"6\":1}}],[\"ctrl+shift+f\",{\"1\":{\"6\":1}}],[\"ctrl+p\",{\"1\":{\"44\":1}}],[\"ctrl+o\",{\"1\":{\"44\":1}}],[\"ctrl+n\",{\"1\":{\"44\":1}}],[\"ctrl+v\",{\"1\":{\"42\":1,\"45\":1}}],[\"ctrl+end\",{\"1\":{\"45\":1}}],[\"ctrl+e\",{\"1\":{\"42\":1,\"45\":1}}],[\"ctrl+home\",{\"1\":{\"45\":1}}],[\"ctrl+h\",{\"1\":{\"6\":1,\"45\":1}}],[\"ctrl+d\",{\"1\":{\"6\":1,\"45\":1}}],[\"ctrl+f4\",{\"1\":{\"6\":1}}],[\"ctrl+f\",{\"1\":{\"6\":1,\"45\":1}}],[\"f5\",{\"1\":{\"884\":1}}],[\"fegin调用service的时候是怎么样做到集成的负载均衡和熔断呢\",{\"0\":{\"799\":1}}],[\"feather\",{\"1\":{\"139\":1}}],[\"f\",{\"1\":{\"577\":3,\"1024\":1}}],[\"future\",{\"1\":{\"891\":1}}],[\"full\",{\"0\":{\"493\":1,\"495\":1,\"496\":1},\"1\":{\"448\":1,\"463\":2,\"493\":3,\"495\":1,\"496\":1,\"525\":1,\"573\":2}}],[\"function\",{\"1\":{\"244\":1}}],[\"fbc2624a\",{\"1\":{\"381\":1}}],[\"fast指向null\",{\"1\":{\"974\":1}}],[\"fast指向最后一个节点\",{\"1\":{\"974\":1}}],[\"fast指到了最后一个节点\",{\"1\":{\"964\":1}}],[\"fast分别代表慢\",{\"1\":{\"973\":1}}],[\"fast\",{\"1\":{\"963\":6,\"964\":2,\"965\":6,\"973\":6,\"975\":5}}],[\"fastjson\",{\"1\":{\"898\":1}}],[\"fastjson和protobuf等\",{\"1\":{\"878\":2}}],[\"fastautogenerator\",{\"1\":{\"864\":1}}],[\"fastautogeneratortest\",{\"1\":{\"864\":1}}],[\"fanoutexchange\",{\"1\":{\"768\":4}}],[\"fanout实战\",{\"0\":{\"734\":1}}],[\"fanout介绍\",{\"0\":{\"733\":1}}],[\"fanout\",{\"0\":{\"732\":1},\"1\":{\"693\":1,\"728\":3,\"733\":1,\"734\":1,\"736\":1,\"737\":1,\"740\":1,\"741\":1,\"767\":1,\"768\":1}}],[\"fatal\",{\"1\":{\"588\":1}}],[\"fail\",{\"1\":{\"991\":1}}],[\"failback\",{\"1\":{\"917\":1}}],[\"failsafe\",{\"1\":{\"917\":1}}],[\"failfast\",{\"1\":{\"917\":1}}],[\"failover\",{\"1\":{\"917\":1}}],[\"failovercluster\",{\"1\":{\"890\":1}}],[\"failed\",{\"1\":{\"588\":1}}],[\"failure\",{\"1\":{\"525\":1}}],[\"fair\",{\"1\":{\"286\":1}}],[\"factories文件中的配置\",{\"1\":{\"683\":1}}],[\"factories文件\",{\"1\":{\"683\":1}}],[\"factories文件的jar包\",{\"1\":{\"674\":1}}],[\"factoriesloader\",{\"1\":{\"678\":1}}],[\"factory\",{\"1\":{\"619\":2,\"754\":4,\"755\":1,\"762\":2}}],[\"factorybean\",{\"1\":{\"610\":2}}],[\"factor\",{\"1\":{\"239\":2,\"244\":1}}],[\"false表示未出现过\",{\"1\":{\"948\":1}}],[\"false使用默认数据源\",{\"1\":{\"866\":1}}],[\"false\",{\"1\":{\"186\":1,\"317\":5,\"318\":3,\"587\":1,\"599\":2,\"651\":1,\"668\":1,\"697\":5,\"698\":1,\"706\":3,\"708\":7,\"711\":2,\"712\":3,\"714\":2,\"717\":2,\"722\":3,\"723\":2,\"745\":1,\"747\":9,\"748\":6,\"749\":13,\"757\":1,\"762\":1,\"765\":1,\"777\":2,\"779\":2,\"783\":3,\"866\":1,\"957\":2,\"973\":1,\"975\":1,\"981\":1,\"982\":1,\"983\":2,\"1018\":1,\"1020\":2,\"1028\":1,\"1029\":4,\"1030\":1}}],[\"flush\",{\"1\":{\"813\":1}}],[\"flight\",{\"1\":{\"492\":1}}],[\"float\",{\"1\":{\"239\":2}}],[\"flag的值会在0和1之间切换\",{\"1\":{\"203\":1}}],[\"flag\",{\"1\":{\"203\":6,\"449\":2,\"503\":1,\"722\":2}}],[\"flatmap方法让你把一个流中的每个值都换成另一个流\",{\"1\":{\"549\":1}}],[\"flatmap\",{\"1\":{\"549\":3}}],[\"flat\",{\"1\":{\"139\":2}}],[\"fixedlength\",{\"1\":{\"996\":1}}],[\"fixedthreadpool和singlethreadpool\",{\"1\":{\"291\":1}}],[\"field注入\",{\"1\":{\"600\":1}}],[\"field\",{\"0\":{\"453\":1}}],[\"fieldref\",{\"1\":{\"379\":1}}],[\"filter>\",{\"1\":{\"649\":1}}],[\"filter包裹servlet\",{\"1\":{\"648\":1}}],[\"filter的执行顺序在interceptor之前\",{\"1\":{\"648\":1}}],[\"filter需要在web\",{\"1\":{\"648\":1}}],[\"filter接口的服务器端程序\",{\"1\":{\"648\":1}}],[\"filter\",{\"1\":{\"546\":2,\"547\":1,\"548\":3,\"549\":1,\"577\":3,\"649\":5,\"957\":1,\"992\":1}}],[\"fill\",{\"1\":{\"258\":1,\"925\":1}}],[\"filewriter\",{\"1\":{\"991\":2}}],[\"fileoverride\",{\"1\":{\"864\":1}}],[\"filesets>\",{\"1\":{\"99\":1}}],[\"fileset>\",{\"1\":{\"99\":4}}],[\"files\",{\"1\":{\"78\":1}}],[\"files即可\",{\"1\":{\"12\":1}}],[\"file\",{\"1\":{\"14\":1,\"15\":2,\"16\":1,\"18\":2,\"19\":2,\"991\":1,\"1011\":1}}],[\"firsthalfend\",{\"1\":{\"975\":3}}],[\"firstdayofmonth\",{\"1\":{\"569\":1}}],[\"first\",{\"1\":{\"242\":1,\"416\":1,\"535\":2,\"701\":3,\"708\":1,\"709\":3,\"714\":1,\"717\":1,\"975\":1}}],[\"findlengthoflcis\",{\"1\":{\"931\":1,\"1040\":1}}],[\"findstudentbyid\",{\"1\":{\"816\":2}}],[\"find\",{\"1\":{\"788\":1,\"975\":1}}],[\"findfirst和findany\",{\"1\":{\"550\":1}}],[\"findclass\",{\"1\":{\"387\":2}}],[\"findmaxaverage\",{\"1\":{\"187\":1}}],[\"final的类信息\",{\"0\":{\"455\":1}}],[\"final的某个子集\",{\"1\":{\"452\":1}}],[\"final方法\",{\"1\":{\"421\":1}}],[\"finalize\",{\"1\":{\"323\":3}}],[\"finally\",{\"1\":{\"285\":1,\"819\":1}}],[\"final\",{\"1\":{\"234\":3,\"239\":1,\"242\":1,\"244\":1,\"253\":1,\"317\":5,\"379\":2,\"453\":1,\"454\":1,\"697\":1,\"698\":1,\"701\":2,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":4,\"748\":3,\"749\":3,\"754\":5,\"755\":2,\"757\":6,\"762\":4,\"768\":6,\"779\":2,\"904\":1,\"990\":2,\"991\":1}}],[\"figure\",{\"1\":{\"184\":1}}],[\"fc在线模拟器\",{\"1\":{\"143\":1}}],[\"frameoptions\",{\"1\":{\"788\":1}}],[\"framework目录下的build\",{\"1\":{\"1011\":1}}],[\"framework\",{\"1\":{\"591\":1,\"1004\":2,\"1005\":1,\"1006\":1,\"1009\":2}}],[\"frame\",{\"1\":{\"407\":1,\"412\":2,\"413\":1}}],[\"fred\",{\"1\":{\"815\":1}}],[\"freemarkertemplateengine\",{\"1\":{\"864\":1}}],[\"freemarker<\",{\"1\":{\"863\":1}}],[\"freemarker\",{\"1\":{\"646\":1}}],[\"freelist\",{\"1\":{\"471\":1}}],[\"freepik\",{\"1\":{\"140\":1}}],[\"freturn\",{\"1\":{\"424\":1}}],[\"frequency\",{\"1\":{\"258\":1}}],[\"frontmatter配置\",{\"1\":{\"55\":1}}],[\"fromuser\",{\"1\":{\"819\":1}}],[\"from\",{\"1\":{\"42\":1,\"496\":1,\"515\":1,\"814\":2,\"817\":3,\"819\":1,\"840\":1,\"849\":1,\"850\":3,\"852\":1,\"860\":1,\"1011\":1}}],[\"found\",{\"1\":{\"1045\":1}}],[\"foo\",{\"1\":{\"814\":2}}],[\"foo=bar\",{\"1\":{\"577\":1}}],[\"foo<\",{\"1\":{\"106\":2}}],[\"folding\",{\"1\":{\"317\":1}}],[\"followers\",{\"1\":{\"127\":1}}],[\"following\",{\"1\":{\"78\":1}}],[\"fox\",{\"1\":{\"235\":1,\"741\":3,\"742\":3}}],[\"fonts\",{\"1\":{\"143\":1}}],[\"forks=\",{\"1\":{\"917\":1}}],[\"forking\",{\"1\":{\"917\":1}}],[\"form\",{\"1\":{\"655\":1}}],[\"formatstyle\",{\"1\":{\"573\":5}}],[\"formats>\",{\"1\":{\"99\":1}}],[\"format\",{\"1\":{\"573\":7,\"577\":1}}],[\"format方法可以直接进行转换\",{\"1\":{\"573\":1}}],[\"format>\",{\"1\":{\"99\":1}}],[\"forname\",{\"1\":{\"397\":1}}],[\"foreach\",{\"1\":{\"241\":1,\"547\":1,\"548\":1,\"562\":1,\"853\":1,\"858\":1}}],[\"for循环就可以只循环一半\",{\"1\":{\"198\":1}}],[\"for\",{\"1\":{\"6\":1,\"14\":1,\"15\":1,\"19\":1,\"21\":1,\"42\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"194\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":2,\"202\":3,\"203\":2,\"204\":2,\"205\":2,\"207\":3,\"230\":2,\"234\":1,\"239\":1,\"340\":4,\"353\":1,\"367\":1,\"722\":1,\"723\":1,\"738\":1,\"742\":1,\"747\":1,\"748\":1,\"779\":1,\"788\":1,\"792\":7,\"925\":2,\"931\":1,\"934\":3,\"938\":1,\"939\":2,\"943\":5,\"944\":5,\"948\":1,\"949\":1,\"957\":1,\"963\":1,\"965\":1,\"968\":1,\"973\":1,\"1029\":1,\"1034\":1,\"1035\":1,\"1040\":1}}],[\"f11\",{\"1\":{\"48\":1}}],[\"f9\",{\"1\":{\"48\":1}}],[\"f8\",{\"1\":{\"48\":1}}],[\"f3\",{\"1\":{\"45\":1}}],[\"f2\",{\"1\":{\"6\":1}}],[\"wrapper\",{\"1\":{\"842\":1,\"1005\":2,\"1006\":2}}],[\"wrapper介绍\",{\"0\":{\"842\":1}}],[\"wrapper<t>\",{\"1\":{\"832\":10}}],[\"writer\",{\"1\":{\"991\":2}}],[\"write\",{\"1\":{\"827\":1}}],[\"writeobject\",{\"1\":{\"240\":1}}],[\"whether\",{\"1\":{\"975\":1}}],[\"whereuser\",{\"1\":{\"819\":1}}],[\"where\",{\"1\":{\"814\":2,\"819\":1,\"840\":2,\"842\":1,\"847\":1,\"848\":1,\"850\":3,\"851\":1,\"852\":1,\"860\":2}}],[\"when\",{\"1\":{\"515\":1,\"617\":3,\"670\":1}}],[\"while\",{\"1\":{\"6\":2,\"194\":3,\"701\":1,\"708\":1,\"711\":1,\"712\":1,\"734\":1,\"944\":1,\"954\":2,\"957\":2,\"963\":2,\"965\":2,\"968\":1,\"973\":2,\"975\":3,\"982\":1,\"983\":1,\"1024\":7,\"1030\":2,\"1035\":1}}],[\"worker\",{\"1\":{\"714\":1}}],[\"worker03\",{\"1\":{\"708\":1,\"714\":1,\"717\":1}}],[\"worker01\",{\"1\":{\"701\":1}}],[\"work\",{\"0\":{\"699\":1},\"1\":{\"699\":1}}],[\"workqueue\",{\"1\":{\"275\":1}}],[\"world\",{\"1\":{\"521\":1,\"526\":1,\"530\":1,\"535\":1,\"536\":1,\"549\":1,\"996\":4}}],[\"wordlengths\",{\"1\":{\"549\":1}}],[\"words\",{\"1\":{\"549\":2}}],[\"word默认存储结构外\",{\"1\":{\"278\":1}}],[\"word在默认情况下存储着对象的hashcode\",{\"1\":{\"278\":1}}],[\"word\",{\"1\":{\"278\":3,\"476\":1}}],[\"w\",{\"1\":{\"207\":6}}],[\"wildcardname\",{\"1\":{\"814\":4}}],[\"withkeyvalueseparator\",{\"1\":{\"993\":1}}],[\"withargument\",{\"1\":{\"768\":1}}],[\"witharguments\",{\"1\":{\"752\":1,\"754\":2,\"755\":1,\"780\":1}}],[\"with方法有一个重载形式\",{\"1\":{\"569\":1}}],[\"with\",{\"1\":{\"569\":3,\"754\":3,\"755\":1,\"757\":1,\"762\":1,\"768\":1,\"780\":1}}],[\"withxxx\",{\"1\":{\"562\":1}}],[\"withzonesameinstant\",{\"1\":{\"562\":1}}],[\"width\",{\"1\":{\"143\":1}}],[\"window\",{\"1\":{\"614\":2}}],[\"windows下\",{\"1\":{\"448\":1}}],[\"windows系统下按win\",{\"1\":{\"131\":1}}],[\"windows平台选择\",{\"1\":{\"60\":1}}],[\"windows\",{\"1\":{\"11\":1,\"410\":1,\"577\":1}}],[\"win\",{\"1\":{\"343\":1}}],[\"win11\",{\"1\":{\"114\":1}}],[\"win11菜单优化\",{\"0\":{\"111\":1}}],[\"weaving\",{\"1\":{\"604\":1}}],[\"weakreference\",{\"0\":{\"327\":1}}],[\"weird\",{\"1\":{\"143\":1}}],[\"webjars\",{\"1\":{\"788\":1}}],[\"webservice\",{\"1\":{\"888\":1}}],[\"websecurityconfigureradapter\",{\"0\":{\"787\":1,\"788\":1},\"1\":{\"787\":1,\"788\":2}}],[\"websocket\",{\"1\":{\"612\":1,\"788\":1}}],[\"web页面添加队列\",{\"0\":{\"702\":1}}],[\"web中\",{\"1\":{\"679\":1}}],[\"web<\",{\"1\":{\"679\":1,\"753\":1}}],[\"webmvcconfigurer\",{\"1\":{\"673\":1}}],[\"web项目使用webapplicationcontext\",{\"1\":{\"611\":1}}],[\"web框架\",{\"1\":{\"591\":1}}],[\"webflux\",{\"1\":{\"591\":1}}],[\"web支持\",{\"1\":{\"591\":1}}],[\"webtestclient\",{\"1\":{\"591\":1}}],[\"webden\",{\"1\":{\"148\":1}}],[\"web技术权威文档\",{\"1\":{\"119\":1}}],[\"webapplet\",{\"1\":{\"378\":1}}],[\"webapp\",{\"1\":{\"78\":2}}],[\"web\",{\"1\":{\"78\":4,\"119\":1,\"142\":1,\"146\":2,\"462\":1,\"591\":1,\"612\":1,\"615\":1,\"649\":1,\"670\":1,\"678\":1,\"695\":1,\"702\":1,\"754\":4,\"756\":1,\"762\":4,\"777\":2,\"783\":1,\"788\":1,\"875\":1}}],[\"webify\",{\"1\":{\"1\":1}}],[\"was\",{\"1\":{\"587\":1}}],[\"waitforconfirms\",{\"1\":{\"722\":1,\"723\":2,\"762\":1}}],[\"waitforconfirmsordie\",{\"1\":{\"722\":1,\"762\":2}}],[\"wait\",{\"0\":{\"287\":1,\"288\":1},\"1\":{\"266\":1,\"267\":1,\"273\":2}}],[\"waifu2x\",{\"1\":{\"132\":1}}],[\"wallhaven\",{\"1\":{\"140\":1}}],[\"wa200000113\",{\"1\":{\"110\":1}}],[\"warningconsumer\",{\"1\":{\"768\":1}}],[\"warningbinding\",{\"1\":{\"768\":1}}],[\"warningqueue\",{\"1\":{\"768\":3}}],[\"warning\",{\"1\":{\"736\":1,\"738\":3,\"768\":7}}],[\"war格式的基础\",{\"1\":{\"378\":1}}],[\"war包\",{\"1\":{\"105\":1}}],[\"war重新打包为可执行的jar\",{\"1\":{\"105\":1}}],[\"war\",{\"1\":{\"80\":1,\"106\":1}}],[\"war代表web工程\",{\"1\":{\"70\":1}}],[\"www\",{\"1\":{\"110\":1,\"249\":2,\"279\":1,\"293\":1,\"595\":1,\"614\":1,\"677\":1}}],[\"wd=\",{\"1\":{\"41\":1}}],[\"tcc\",{\"1\":{\"910\":3}}],[\"tcp协议传输\",{\"1\":{\"888\":1}}],[\"tcp两种协议\",{\"1\":{\"879\":1}}],[\"tcp\",{\"1\":{\"693\":3,\"707\":1,\"879\":1}}],[\"ts\",{\"1\":{\"832\":4}}],[\"tmall\",{\"1\":{\"776\":1}}],[\"tmp指向它的下一个节点\",{\"1\":{\"970\":1}}],[\"tmp++\",{\"1\":{\"934\":1}}],[\"tmp\",{\"1\":{\"198\":1,\"201\":3,\"934\":3,\"968\":3}}],[\"ttltime\",{\"1\":{\"755\":5,\"780\":1}}],[\"ttlqueueconfig\",{\"1\":{\"754\":1}}],[\"ttl的两种设置\",{\"0\":{\"752\":1}}],[\"ttl是\",{\"1\":{\"745\":1}}],[\"ttl\",{\"1\":{\"745\":1,\"747\":1,\"748\":2,\"752\":16,\"753\":2,\"754\":13,\"755\":12,\"756\":2,\"757\":3,\"780\":1}}],[\"tlabwastetargetpercent\",{\"1\":{\"502\":1}}],[\"tlab空间的内存非常小\",{\"1\":{\"502\":1}}],[\"tlab的其他说明\",{\"0\":{\"502\":1}}],[\"tlab\",{\"0\":{\"499\":1},\"1\":{\"471\":3,\"482\":1}}],[\"two\",{\"1\":{\"239\":1}}],[\"that\",{\"1\":{\"244\":2}}],[\"this\",{\"1\":{\"239\":3,\"241\":1,\"242\":1,\"244\":1,\"389\":1,\"832\":2}}],[\"thrift允许你定义一个描述文件\",{\"1\":{\"879\":1}}],[\"thrift\",{\"1\":{\"879\":1}}],[\"threadlocal\",{\"1\":{\"471\":1,\"638\":2}}],[\"threadlocal在预防内存泄漏方面\",{\"1\":{\"280\":1}}],[\"threadlocalmap就会存在null\",{\"1\":{\"280\":1}}],[\"threadlocal被回收后\",{\"1\":{\"280\":1}}],[\"threadlocal必然会被回收\",{\"1\":{\"280\":1}}],[\"threadlocal自身并不储存值\",{\"1\":{\"280\":1}}],[\"threadlocal使用会有什么问题\",{\"0\":{\"280\":1}}],[\"threadpoolexecutor\",{\"1\":{\"275\":3,\"291\":1}}],[\"threadfactory创建的线程名都具有统一的风格\",{\"1\":{\"275\":1}}],[\"threadfactory创建的线程也是采用new\",{\"1\":{\"275\":1}}],[\"threadfactory\",{\"1\":{\"275\":1}}],[\"thread\",{\"0\":{\"501\":1},\"1\":{\"264\":1,\"275\":2,\"389\":1,\"435\":1,\"482\":1,\"693\":1,\"708\":2,\"714\":1,\"717\":1}}],[\"threshold\",{\"1\":{\"230\":1,\"239\":1}}],[\"throwable\",{\"1\":{\"605\":1}}],[\"throws\",{\"1\":{\"605\":1,\"687\":4,\"697\":1,\"698\":1,\"701\":3,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"748\":2,\"749\":2,\"779\":2,\"788\":2}}],[\"throwing=\",{\"1\":{\"605\":1}}],[\"throwing\",{\"1\":{\"604\":1}}],[\"throw\",{\"1\":{\"239\":2,\"832\":1}}],[\"there\",{\"1\":{\"975\":1}}],[\"thebookisclosed\",{\"1\":{\"114\":1}}],[\"the\",{\"1\":{\"42\":1,\"78\":1,\"91\":2,\"239\":1,\"242\":1,\"367\":1,\"410\":1,\"515\":1,\"521\":1,\"526\":1,\"530\":1,\"535\":1,\"536\":1,\"687\":2,\"832\":1,\"975\":3}}],[\"themes\",{\"1\":{\"38\":1}}],[\"theme\",{\"1\":{\"35\":1,\"47\":1}}],[\"t>>\",{\"1\":{\"230\":1}}],[\"tips\",{\"1\":{\"374\":1,\"375\":1,\"395\":1}}],[\"time里存的就是最大时间\",{\"1\":{\"944\":1}}],[\"time保存当前的最大时间\",{\"1\":{\"944\":1}}],[\"time为最大的腐烂值\",{\"1\":{\"943\":1}}],[\"times\",{\"1\":{\"938\":3}}],[\"timed\",{\"1\":{\"588\":1}}],[\"time包的开发\",{\"1\":{\"574\":1}}],[\"time包中\",{\"1\":{\"555\":1}}],[\"timezone\",{\"1\":{\"555\":1}}],[\"time\",{\"1\":{\"343\":1,\"358\":1,\"367\":2,\"369\":1,\"555\":1,\"573\":1,\"574\":1,\"745\":1,\"943\":5,\"944\":3}}],[\"timeoutfilter\",{\"1\":{\"905\":1}}],[\"timeoutexception\",{\"1\":{\"697\":2,\"698\":2,\"701\":4,\"722\":2,\"723\":2,\"734\":2,\"738\":2,\"742\":2,\"747\":6,\"748\":2,\"749\":2}}],[\"timeout\",{\"1\":{\"282\":1}}],[\"timeunit\",{\"1\":{\"275\":1}}],[\"timeago\",{\"1\":{\"159\":1}}],[\"tinypng图片压缩\",{\"1\":{\"132\":1}}],[\"tag=6\",{\"1\":{\"717\":1}}],[\"tag=8\",{\"1\":{\"706\":1}}],[\"tag\",{\"1\":{\"706\":2,\"708\":1,\"714\":1,\"717\":1,\"720\":1}}],[\"task03\",{\"1\":{\"708\":1,\"711\":1,\"712\":1}}],[\"task01\",{\"1\":{\"701\":1}}],[\"task\",{\"1\":{\"700\":1,\"708\":6,\"711\":3,\"712\":3,\"714\":2,\"717\":2,\"729\":1}}],[\"tasklist\",{\"1\":{\"148\":1}}],[\"tab\",{\"1\":{\"668\":3}}],[\"tabs\",{\"1\":{\"668\":1}}],[\"tab1e\",{\"1\":{\"459\":1}}],[\"tablelogic\",{\"0\":{\"838\":1},\"1\":{\"840\":1}}],[\"tablefield\",{\"0\":{\"837\":1},\"1\":{\"837\":1}}],[\"tableid\",{\"0\":{\"836\":1},\"1\":{\"836\":2}}],[\"table\",{\"0\":{\"835\":1},\"1\":{\"423\":1,\"459\":1,\"519\":1,\"819\":1,\"835\":2,\"836\":1}}],[\"tablesizefor\",{\"1\":{\"239\":2,\"253\":1}}],[\"talks\",{\"1\":{\"149\":2}}],[\"talk\",{\"0\":{\"149\":1}}],[\"taiko\",{\"1\":{\"142\":1}}],[\"tar\",{\"1\":{\"99\":1}}],[\"targetfilename\",{\"1\":{\"991\":1}}],[\"target\",{\"1\":{\"71\":1,\"73\":1,\"74\":2,\"75\":1,\"76\":1,\"99\":1,\"239\":1,\"258\":2,\"603\":1,\"604\":1,\"791\":1,\"792\":1}}],[\"target>\",{\"1\":{\"61\":1,\"101\":1,\"696\":1}}],[\"target>1\",{\"1\":{\"61\":1}}],[\"telnet\",{\"1\":{\"912\":1}}],[\"telnet命令能做什么\",{\"0\":{\"912\":1}}],[\"teacher\",{\"1\":{\"820\":2}}],[\"templateengine\",{\"1\":{\"864\":1}}],[\"template\",{\"1\":{\"632\":2,\"754\":2,\"764\":1,\"765\":1}}],[\"temporaladjusters\",{\"1\":{\"569\":2}}],[\"temporaladjuster\",{\"0\":{\"569\":1},\"1\":{\"569\":1}}],[\"temporalunit\",{\"1\":{\"568\":1}}],[\"tenured\",{\"1\":{\"525\":1}}],[\"tenure\",{\"1\":{\"483\":4}}],[\"te\",{\"1\":{\"319\":1}}],[\"technology\",{\"1\":{\"353\":1}}],[\"tech\",{\"1\":{\"106\":1}}],[\"test方法运行\",{\"1\":{\"1012\":1}}],[\"test模块\",{\"1\":{\"1012\":1}}],[\"testpreconditions\",{\"1\":{\"998\":1}}],[\"testpost\",{\"1\":{\"94\":1}}],[\"testsplitter1\",{\"1\":{\"996\":1}}],[\"test10\",{\"1\":{\"854\":1}}],[\"test09\",{\"1\":{\"853\":1}}],[\"testcontext框架\",{\"1\":{\"591\":1}}],[\"testverifyinstall将包安装至本地仓库\",{\"1\":{\"94\":1}}],[\"testintegration\",{\"1\":{\"94\":1}}],[\"test目录\",{\"1\":{\"80\":1}}],[\"test\",{\"1\":{\"74\":2,\"75\":1,\"78\":2,\"80\":6,\"81\":1,\"94\":6,\"98\":2,\"319\":1,\"393\":1,\"397\":1,\"510\":1,\"605\":6,\"853\":1,\"854\":1,\"858\":1,\"990\":1,\"991\":1,\"992\":1,\"993\":1,\"996\":1,\"998\":1,\"1012\":1}}],[\"test<\",{\"1\":{\"70\":1,\"753\":1}}],[\"text\",{\"1\":{\"42\":2,\"143\":1,\"555\":1,\"712\":2}}],[\"type属性\",{\"1\":{\"836\":1}}],[\"type=\",{\"1\":{\"820\":1}}],[\"typeform\",{\"1\":{\"148\":1}}],[\"type\",{\"1\":{\"28\":1,\"757\":1,\"762\":1,\"765\":1,\"791\":1,\"831\":2,\"836\":2}}],[\"typora主题\",{\"1\":{\"38\":1}}],[\"typoraio\",{\"1\":{\"35\":3}}],[\"typora相关\",{\"0\":{\"35\":1}}],[\"typora\",{\"1\":{\"1\":1,\"28\":1,\"35\":1,\"42\":1,\"47\":1,\"49\":1}}],[\"tomcat<\",{\"1\":{\"679\":1}}],[\"tor\",{\"1\":{\"577\":1}}],[\"tolerance\",{\"1\":{\"797\":1}}],[\"tolocaldate\",{\"1\":{\"571\":1}}],[\"tolist\",{\"1\":{\"234\":2,\"546\":1,\"548\":3,\"549\":4,\"957\":1}}],[\"toinstant\",{\"1\":{\"571\":1}}],[\"tokyo\",{\"1\":{\"562\":1}}],[\"tokyodatetime\",{\"1\":{\"562\":3}}],[\"to区\",{\"1\":{\"488\":1}}],[\"tostring\",{\"1\":{\"317\":2,\"722\":1,\"723\":1,\"754\":1,\"757\":1,\"954\":1,\"997\":1}}],[\"tostring等方法\",{\"1\":{\"22\":1}}],[\"toarray\",{\"1\":{\"235\":4,\"788\":6}}],[\"tochararray\",{\"1\":{\"188\":1,\"954\":1}}],[\"to\",{\"1\":{\"134\":1,\"496\":1,\"497\":2,\"588\":3,\"687\":2,\"693\":1,\"745\":1,\"754\":3,\"755\":1,\"757\":1,\"762\":1,\"768\":3,\"780\":1}}],[\"topic等\",{\"1\":{\"757\":1}}],[\"topic实战\",{\"0\":{\"742\":1}}],[\"topic匹配案例\",{\"0\":{\"741\":1}}],[\"topic的介绍\",{\"0\":{\"740\":1}}],[\"topics\",{\"0\":{\"739\":1}}],[\"topic\",{\"1\":{\"693\":1,\"728\":2,\"740\":3,\"742\":2}}],[\"top\",{\"1\":{\"42\":1,\"1024\":13}}],[\"toggle\",{\"1\":{\"21\":1}}],[\"todo\",{\"1\":{\"13\":1,\"193\":1,\"538\":1,\"996\":1}}],[\"tool\",{\"1\":{\"11\":1,\"340\":1,\"492\":1}}],[\"tools\",{\"1\":{\"7\":1,\"15\":1}}],[\"trunc\",{\"1\":{\"577\":1}}],[\"true表示出现过\",{\"1\":{\"948\":1}}],[\"true未匹配到指定数据源时抛异常\",{\"1\":{\"866\":1}}],[\"true\",{\"1\":{\"186\":1,\"242\":2,\"317\":2,\"318\":3,\"319\":1,\"477\":2,\"649\":1,\"670\":1,\"673\":1,\"697\":3,\"698\":2,\"701\":1,\"706\":3,\"711\":1,\"722\":1,\"723\":1,\"747\":2,\"748\":1,\"749\":1,\"757\":1,\"764\":4,\"765\":4,\"768\":1,\"777\":1,\"779\":2,\"815\":1,\"901\":1,\"911\":2,\"934\":1,\"948\":1,\"957\":2,\"973\":1,\"975\":2,\"981\":1,\"982\":1,\"983\":1,\"1018\":1,\"1020\":1,\"1028\":1,\"1029\":2,\"1030\":1}}],[\"transport\",{\"1\":{\"883\":1}}],[\"transaction\",{\"1\":{\"910\":3}}],[\"transaction框架实现\",{\"1\":{\"910\":1}}],[\"transactional\",{\"0\":{\"637\":1},\"1\":{\"633\":1,\"634\":1,\"635\":1}}],[\"transactionproxyfactorybean\",{\"1\":{\"633\":1}}],[\"transferserviceimpl\",{\"1\":{\"617\":2}}],[\"transferservice\",{\"1\":{\"617\":3}}],[\"transient的某个子集\",{\"1\":{\"453\":1}}],[\"tracefilter\",{\"1\":{\"905\":1}}],[\"trace\",{\"1\":{\"340\":1}}],[\"trimresults\",{\"1\":{\"996\":1}}],[\"trim|where|set|foreach|if|choose|when|otherwise|bind\",{\"1\":{\"811\":1,\"812\":1}}],[\"tribonacci\",{\"1\":{\"199\":1}}],[\"triangle\",{\"1\":{\"139\":1}}],[\"tricks\",{\"1\":{\"134\":2}}],[\"treenode\",{\"1\":{\"249\":1,\"1020\":4,\"1022\":2,\"1024\":15,\"1029\":6,\"1030\":1,\"1034\":6,\"1035\":2}}],[\"treeset\",{\"1\":{\"216\":1,\"220\":1,\"245\":1,\"259\":1}}],[\"treemap<>\",{\"1\":{\"241\":2}}],[\"treemap<person\",{\"1\":{\"241\":2}}],[\"treemap\",{\"0\":{\"241\":1},\"1\":{\"216\":1,\"222\":1,\"241\":12,\"245\":1,\"259\":1}}],[\"tree\",{\"1\":{\"12\":1,\"78\":1,\"1029\":1,\"1034\":1}}],[\"try\",{\"1\":{\"6\":1,\"285\":1,\"708\":1,\"714\":1,\"717\":1,\"819\":1,\"991\":1}}],[\"t\",{\"1\":{\"6\":1,\"143\":1,\"230\":1,\"234\":2,\"235\":2,\"817\":2,\"819\":1,\"820\":2,\"832\":6,\"833\":1,\"835\":1,\"836\":1,\"840\":2,\"847\":1,\"848\":1,\"849\":1,\"850\":3,\"852\":1,\"864\":2,\"1018\":4,\"1019\":3,\"1020\":10,\"1038\":1}}],[\"这三者任何一个满足\",{\"1\":{\"1019\":1}}],[\"这三个判断分别是\",{\"1\":{\"1019\":1}}],[\"这三个消息依然不会被确认收到消息应答\",{\"1\":{\"706\":1}}],[\"这三个位置都需要改\",{\"1\":{\"18\":1,\"19\":1}}],[\"这允许您在绝大多数情况下避免了基本数据类型的装箱和参数数组的分配\",{\"1\":{\"997\":1}}],[\"这使得任何joiner线程都是安全的\",{\"1\":{\"993\":1}}],[\"这使得它能像一些普通的c一样与外部交互\",{\"1\":{\"435\":1}}],[\"这么多的水\",{\"1\":{\"983\":2}}],[\"这么实现的优点是可扩展性强\",{\"1\":{\"904\":1}}],[\"这2个数组用做上下左右4个方向\",{\"1\":{\"943\":1}}],[\"这很容易看出一个人是死记硬背还是有自己的思考\",{\"1\":{\"893\":1}}],[\"这\",{\"1\":{\"818\":1}}],[\"这已经绰绰有余了\",{\"1\":{\"712\":1}}],[\"这在强调快速演化的微服务环境下\",{\"1\":{\"887\":1}}],[\"这在所有隔离级别中也是最慢的\",{\"1\":{\"634\":1}}],[\"这在理论上是可行的\",{\"1\":{\"511\":1}}],[\"这几种属于基于\",{\"1\":{\"612\":1}}],[\"这等于告诉\",{\"1\":{\"599\":1}}],[\"这大大增加了项目的可维护性且降低了开发难度\",{\"1\":{\"595\":1}}],[\"这可能是template\",{\"1\":{\"632\":1}}],[\"这可能会把人逼疯\",{\"1\":{\"595\":1}}],[\"这可应用于死锁恢复的一些场合\",{\"1\":{\"292\":1}}],[\"这比维护一个空闲列表显然少了许多开销\",{\"1\":{\"523\":1}}],[\"这其实也是一个相对耗时的过程\",{\"1\":{\"511\":1}}],[\"这其中前三种都会发生线程切换\",{\"1\":{\"267\":1}}],[\"这一句\",{\"1\":{\"649\":1}}],[\"这一点在逃逸分析相关的文档里己经说明\",{\"1\":{\"511\":1}}],[\"这一定义既清晰又易于理解\",{\"1\":{\"494\":1}}],[\"这一步保证了对象的实例字段在\",{\"1\":{\"472\":1}}],[\"这一步操作保证了对象的实例字段在\",{\"1\":{\"312\":1}}],[\"这类似于printf\",{\"1\":{\"997\":1}}],[\"这类题已经快做吐了\",{\"1\":{\"942\":1}}],[\"这类对象跟业务直接挂钩\",{\"1\":{\"525\":1}}],[\"这类对象的创建和消亡都非常迅速\",{\"1\":{\"488\":1}}],[\"这类频繁自定义类加载器的场景中\",{\"1\":{\"464\":1}}],[\"这项改动是很有必要的\",{\"1\":{\"462\":1}}],[\"这仅仅发生一次\",{\"1\":{\"420\":1}}],[\"这由编译器在编译器期间进行验证\",{\"1\":{\"416\":1}}],[\"这部分内容将在类加载后存放到方法区的运行时常量池中\",{\"1\":{\"459\":1}}],[\"这部分常量信息是\",{\"1\":{\"375\":1}}],[\"这部分和\",{\"1\":{\"357\":1}}],[\"这正好和s2的引用一致\",{\"1\":{\"319\":1}}],[\"这两棵树\",{\"1\":{\"1019\":1}}],[\"这两个接口实现方式一样\",{\"1\":{\"687\":1}}],[\"这两个环节对应\",{\"1\":{\"98\":1}}],[\"这两种机器都有代码执行能力\",{\"1\":{\"355\":1}}],[\"这两种对象访问方式各有优势\",{\"1\":{\"315\":1}}],[\"这取决于构造semaphore对象时传入的参数选项\",{\"1\":{\"292\":1}}],[\"这时\",{\"1\":{\"861\":1}}],[\"这时正在消费的消息是否会重新进入队列\",{\"1\":{\"708\":1}}],[\"这时候返回了p这个节点\",{\"1\":{\"970\":1}}],[\"这时候消费端就要实现幂等性\",{\"1\":{\"774\":1}}],[\"这时候要增强的话\",{\"1\":{\"602\":1}}],[\"这时候spring\",{\"1\":{\"596\":2}}],[\"这时候可以使用接下来的这个命令\",{\"1\":{\"585\":1}}],[\"这时候切换回来以后\",{\"1\":{\"401\":1}}],[\"这时候它们暂时处于\",{\"1\":{\"323\":1}}],[\"这时候字符串常量池还在堆\",{\"1\":{\"307\":1}}],[\"这时可以用countdownlatch\",{\"1\":{\"292\":1}}],[\"这时会调用equals\",{\"1\":{\"242\":1}}],[\"这些方式各有特点\",{\"1\":{\"758\":1}}],[\"这些场景都有一个特点\",{\"1\":{\"751\":1}}],[\"这些单词可以是任意单词\",{\"1\":{\"740\":1}}],[\"这些工作线程将一起处理这些任务\",{\"1\":{\"699\":1}}],[\"这些\",{\"1\":{\"638\":1}}],[\"这些datasource可能是各种不同类型的\",{\"1\":{\"628\":1}}],[\"这些模块是\",{\"1\":{\"591\":1}}],[\"这些只是基本的算法思路\",{\"1\":{\"528\":1}}],[\"这些垃圾对象所占的内存空间会一直保留到应用程序结束\",{\"1\":{\"515\":1}}],[\"这些底层系统常常是强大的操作系统\",{\"1\":{\"435\":1}}],[\"这些数据类型包括各类基本数据类型\",{\"1\":{\"415\":1}}],[\"这些信息存放在对象头中\",{\"1\":{\"313\":1}}],[\"这些对象生命周期会比较短\",{\"1\":{\"525\":1}}],[\"这些对象不会被gc所回收\",{\"1\":{\"280\":1}}],[\"这些对象就可以判定为java中的内存泄漏\",{\"1\":{\"280\":1}}],[\"这些对象是无用的\",{\"1\":{\"280\":1}}],[\"这些对象是可达的\",{\"1\":{\"280\":1}}],[\"这些对象有下面两个特点\",{\"1\":{\"280\":1}}],[\"这些测试代码不会被打包或部署\",{\"1\":{\"94\":1}}],[\"这也\",{\"1\":{\"1035\":1}}],[\"这也就是为什么如图的时间\",{\"1\":{\"755\":1}}],[\"这也就是它的名字\",{\"1\":{\"535\":1}}],[\"这也就解释了\",{\"1\":{\"246\":1}}],[\"这也就解释了上面的代码\",{\"1\":{\"233\":1}}],[\"这也是一种工厂模式\",{\"1\":{\"904\":1}}],[\"这也是最常见的堆外存储技术\",{\"1\":{\"505\":1}}],[\"这也是阿里java开发手册中推荐的写法\",{\"1\":{\"291\":1}}],[\"这也是称为自旋的原因\",{\"1\":{\"278\":1}}],[\"这是典型的装饰器模式\",{\"1\":{\"905\":1}}],[\"这是因为spring管理的是是任意的java对象\",{\"1\":{\"626\":1}}],[\"这是因为软引用可以加速\",{\"1\":{\"328\":1}}],[\"这是某个类的实例\",{\"1\":{\"617\":1}}],[\"这是非常麻烦的\",{\"1\":{\"607\":1}}],[\"这是spring框架的默认设置\",{\"1\":{\"598\":1}}],[\"这是\",{\"1\":{\"535\":1}}],[\"这是一种责任链的体现\",{\"1\":{\"905\":1}}],[\"这是一种新的交换类型\",{\"1\":{\"757\":1}}],[\"这是一种简单的确认方式\",{\"1\":{\"722\":1}}],[\"这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法\",{\"1\":{\"506\":1}}],[\"这是一个\",{\"1\":{\"738\":4}}],[\"这是一个完整的匹配\",{\"1\":{\"728\":1}}],[\"这是一个普遍的常识\",{\"1\":{\"505\":1}}],[\"这是一个本地方法的具体实现\",{\"1\":{\"435\":1}}],[\"这是jrockit和\",{\"1\":{\"462\":1}}],[\"这是本地方法存在的主要原因\",{\"1\":{\"435\":1}}],[\"这是使用最普遍的引用\",{\"1\":{\"325\":1}}],[\"这是基于在大多数情况下\",{\"1\":{\"278\":1}}],[\"这是不可执行的jar\",{\"1\":{\"106\":1}}],[\"这只是一个参考值\",{\"1\":{\"277\":1}}],[\"这将会占用\",{\"1\":{\"267\":1}}],[\"这就实现了前2个节点的反转\",{\"1\":{\"970\":1}}],[\"这就产生了资源的浪费\",{\"1\":{\"893\":1}}],[\"这就意味着我们的消息永远不会被消费多次\",{\"1\":{\"774\":1}}],[\"这就的由交换机的类型来决定\",{\"1\":{\"727\":1}}],[\"这就使得生产者知道消息已经正确到达目的队列了\",{\"1\":{\"720\":1}}],[\"这就好像产生了幻觉\",{\"1\":{\"634\":1}}],[\"这就导致\",{\"1\":{\"463\":1}}],[\"这就是延迟加载的基本原理\",{\"1\":{\"821\":1}}],[\"这就是我们使用队列的方式\",{\"1\":{\"692\":1}}],[\"这就是初始的高水位线\",{\"1\":{\"448\":1}}],[\"这就是沙箱安全机制\",{\"1\":{\"392\":1}}],[\"这就是自旋锁的优化方式\",{\"1\":{\"278\":1}}],[\"这就是所谓的\",{\"1\":{\"267\":1}}],[\"这就解释了\",{\"1\":{\"246\":1}}],[\"这种题有一个固定的\",{\"1\":{\"964\":1}}],[\"这种类型的\",{\"1\":{\"740\":1}}],[\"这种类型的工作方式是\",{\"1\":{\"736\":1}}],[\"这种类型来进行替换\",{\"1\":{\"736\":1}}],[\"这种类型非常简单\",{\"1\":{\"733\":1}}],[\"这种交换类型并不能给我们带来很大的灵活性\",{\"1\":{\"736\":1}}],[\"这种确认方式有一个最大的缺点就是\",{\"1\":{\"722\":1}}],[\"这种分配方式在这种情况下其实就不太好\",{\"1\":{\"714\":1}}],[\"这种分配方式称为空闲列表\",{\"1\":{\"471\":1}}],[\"这种模式需要在高吞吐量和数据传输安全性方面做权衡\",{\"1\":{\"705\":1}}],[\"这种\",{\"1\":{\"686\":2}}],[\"这种解决方案并非\",{\"1\":{\"673\":1}}],[\"这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制\",{\"1\":{\"608\":1}}],[\"这种使用\",{\"1\":{\"535\":1}}],[\"这种算法的好处是可以控制一次回收多少个小区间\",{\"1\":{\"527\":1}}],[\"这种基于压缩算法的\",{\"1\":{\"471\":1}}],[\"这种绑定方式也就被称之为晚期绑定\",{\"1\":{\"420\":1}}],[\"这种情况存在大量存活率高的对象\",{\"1\":{\"525\":1}}],[\"这种情况复制算法的回收整理\",{\"1\":{\"525\":1}}],[\"这种情况在新生代经常发生\",{\"1\":{\"523\":1}}],[\"这种情况没有创建对象\",{\"1\":{\"510\":1}}],[\"这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接\",{\"1\":{\"419\":1}}],[\"这种情况时间复杂度就是\",{\"1\":{\"229\":1}}],[\"这种方式最多提供每秒不超过数百条发布消息的吞吐量\",{\"1\":{\"722\":1}}],[\"这种方式中\",{\"1\":{\"573\":1}}],[\"这种方式清理出来的空闲内存是不连续的\",{\"1\":{\"521\":1}}],[\"这种方式可以使执行效率大幅度提升\",{\"1\":{\"363\":1}}],[\"这种方式会造成性能低下\",{\"1\":{\"290\":1}}],[\"这种方式确实也是可以提升效率的\",{\"1\":{\"278\":1}}],[\"这种设计并不是不能实现\",{\"1\":{\"288\":1}}],[\"这种设置需要在\",{\"1\":{\"14\":1}}],[\"这种优化更彻底\",{\"1\":{\"278\":1}}],[\"这种同步方式的成本非常高\",{\"1\":{\"278\":1}}],[\"这道题还是挺简单的\",{\"1\":{\"957\":1}}],[\"这道题使用动态规划解法时\",{\"1\":{\"204\":1,\"205\":1}}],[\"这道题需要计算的是数组两侧的数字和\",{\"1\":{\"190\":1}}],[\"这里把深度和结果集的元素数结合了起来\",{\"1\":{\"1034\":1}}],[\"这里把j存到code的2个低位\",{\"1\":{\"944\":1}}],[\"这里我们选择4\",{\"1\":{\"1004\":1}}],[\"这里创建哑节点\",{\"1\":{\"964\":1}}],[\"这里计算次数可以通过等差数列求和\",{\"1\":{\"939\":1}}],[\"这里就会触发错误提示\",{\"1\":{\"853\":1}}],[\"这里就会扫描具有meat\",{\"1\":{\"674\":1}}],[\"这里只有\",{\"1\":{\"754\":1}}],[\"这里是装饰器和责任链模式的混合使用\",{\"1\":{\"905\":1}}],[\"这里是\",{\"1\":{\"753\":1}}],[\"这里记录步骤\",{\"1\":{\"702\":1,\"777\":1}}],[\"这里简单介绍下starter实现自动化配置的流程\",{\"1\":{\"683\":1}}],[\"这里想要探讨另一种对template\",{\"1\":{\"632\":1}}],[\"这里假设它是集合之类的可重复的源\",{\"1\":{\"544\":1}}],[\"这里所谓的清除并不是真的置空\",{\"1\":{\"521\":1}}],[\"这里换为真实地址\",{\"1\":{\"459\":1}}],[\"这里不会为实例变量分配初始化\",{\"1\":{\"379\":1}}],[\"这里不包含用\",{\"1\":{\"379\":1}}],[\"这里主要依靠热点探测功能\",{\"1\":{\"368\":1}}],[\"这里说的仅仅是被允许\",{\"1\":{\"464\":1}}],[\"这里说的仅仅是\",{\"1\":{\"329\":1}}],[\"这里没有提到运行时常量池\",{\"1\":{\"307\":1,\"343\":1}}],[\"这里的年轻代满指的是eden满\",{\"1\":{\"494\":1}}],[\"这里的\",{\"1\":{\"244\":1,\"753\":1}}],[\"这里设置打包的类型\",{\"1\":{\"99\":1}}],[\"这里\",{\"1\":{\"92\":1,\"301\":1,\"306\":1,\"314\":1,\"330\":1}}],[\"这个思路是以前没想到的\",{\"1\":{\"1034\":1}}],[\"这个左孩子不能加到res\",{\"1\":{\"1034\":1}}],[\"这个版本最好和源码\",{\"1\":{\"1005\":1}}],[\"这个版本在运行时是不可变的\",{\"1\":{\"421\":1}}],[\"这个数字即可完成\",{\"1\":{\"954\":1}}],[\"这个数组下标的计算方法是\",{\"1\":{\"246\":1}}],[\"这个code代表的格子的感染时间为0\",{\"1\":{\"944\":1}}],[\"这个和服务分组的概念有一点类似\",{\"1\":{\"900\":1}}],[\"这个和新建一个事务的区别\",{\"1\":{\"635\":1}}],[\"这个响应会带上之前请求的\",{\"1\":{\"891\":1}}],[\"这个值代表的是插入的行数\",{\"1\":{\"815\":1}}],[\"这个注解是用来注解其他注解的\",{\"1\":{\"791\":1}}],[\"这个操作会耗费较长的时间\",{\"1\":{\"782\":1}}],[\"这个队列在\",{\"1\":{\"724\":1}}],[\"这个中间件也是通过函数回调来保证是否投递成功\",{\"1\":{\"724\":1}}],[\"这个消息刚刚被确认\",{\"1\":{\"717\":1}}],[\"这个时候p就变成了\",{\"1\":{\"970\":1}}],[\"这个时候就只能使用\",{\"1\":{\"740\":1}}],[\"这个时候就只能添加新的\",{\"1\":{\"714\":1}}],[\"这个时候就可以通过使用\",{\"1\":{\"717\":1}}],[\"这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态\",{\"1\":{\"714\":1}}],[\"这个时候可以使用调节器temporaladjuster来更方便的处理日期\",{\"1\":{\"569\":1}}],[\"这个两个工作队列会以轮询的方式消费消息\",{\"1\":{\"700\":1}}],[\"这个得有交换机类型决定\",{\"1\":{\"692\":1}}],[\"这个得益于编译器的优化\",{\"1\":{\"317\":1}}],[\"这个里边定义了依赖的版本\",{\"1\":{\"685\":1}}],[\"这个starter是mybatis提供的\",{\"1\":{\"680\":1}}],[\"这个对象永远是一个\",{\"1\":{\"604\":1}}],[\"这个对象就是需要被回收的垃圾\",{\"1\":{\"515\":1}}],[\"这个代理类的方法则由\",{\"1\":{\"603\":1}}],[\"这个命令执行后会出现psyounggen\",{\"1\":{\"537\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"534\":1}}],[\"这个闭包结构并不能保证包含当前所有的可达对象\",{\"1\":{\"534\":1}}],[\"这个取消同步的过程就叫同步省略\",{\"1\":{\"509\":1}}],[\"这个参数一般使用默认值就可以了\",{\"1\":{\"488\":1}}],[\"这个引用指向对象或者数组在堆中的位置\",{\"1\":{\"482\":1}}],[\"这个过程中会下载相关的依赖包\",{\"1\":{\"1011\":1}}],[\"这个过程是由spring来管理控制的\",{\"1\":{\"610\":1}}],[\"这个过程就是标量替换\",{\"1\":{\"510\":1}}],[\"这个过程的具体设置方式取决于\",{\"1\":{\"473\":1}}],[\"这个过程称为方法调用计数器热度的衰减\",{\"1\":{\"369\":1}}],[\"这个条件除非是经过精心设计的可替换类加载器的场景\",{\"1\":{\"464\":1}}],[\"这个字节码包含了指向常量池的引用\",{\"1\":{\"457\":1}}],[\"这个本地方法最终将调用win32\",{\"1\":{\"435\":1}}],[\"这个本地方法是用c实现的\",{\"1\":{\"435\":1}}],[\"这个特征并非java所特有\",{\"1\":{\"434\":1}}],[\"这个错误如果发生在运行时\",{\"1\":{\"422\":1}}],[\"这个会引起编译器异常\",{\"1\":{\"422\":1}}],[\"这个属性或方法\",{\"1\":{\"422\":1}}],[\"这个栈帧被称为当前栈帧\",{\"1\":{\"413\":1}}],[\"这个阈值可以通过虚拟机参数\",{\"1\":{\"369\":1}}],[\"这个计数器就用于统计方法被调用的次数\",{\"1\":{\"369\":1}}],[\"这个类继承mp提供的serviceimpl\",{\"1\":{\"833\":1}}],[\"这个类继承了abstractlist\",{\"1\":{\"233\":1}}],[\"这个类型直接接口的一个有序列表\",{\"1\":{\"452\":1}}],[\"这个类型直接父类的完整有效名\",{\"1\":{\"452\":1}}],[\"这个类型的修饰符\",{\"1\":{\"452\":1}}],[\"这个类型的完整有效名称\",{\"1\":{\"452\":1}}],[\"这个类加载使用\",{\"1\":{\"382\":1}}],[\"这个类是由虚拟机的具体实现指定的\",{\"1\":{\"345\":1}}],[\"这个类是一个同步计数器\",{\"1\":{\"292\":1}}],[\"这个类也是单例的\",{\"1\":{\"343\":1}}],[\"这个类用于交换数据\",{\"1\":{\"292\":1}}],[\"这个机制\",{\"1\":{\"289\":1}}],[\"这个功能非常重要\",{\"1\":{\"286\":1}}],[\"这个状态之间的转换需要相对比较长的时间\",{\"1\":{\"278\":2}}],[\"这个方法只有在消息被确认的时候才返回\",{\"1\":{\"722\":1}}],[\"这个方法里面首先要创建一个springapplication对象实例\",{\"1\":{\"678\":1}}],[\"这个方法的操作数栈是空的\",{\"1\":{\"416\":1}}],[\"这个方法不需要定义\",{\"1\":{\"380\":1}}],[\"这个方法实现简单\",{\"1\":{\"321\":1}}],[\"这个方法会使当前拥有该对象锁的进程等待\",{\"1\":{\"273\":1}}],[\"这个方法原本是确定hashmap内部数值的长度的\",{\"1\":{\"253\":1}}],[\"这个方法可以把数组转为list\",{\"1\":{\"233\":1}}],[\"这个算法应该如何设计呢\",{\"1\":{\"246\":1}}],[\"这个接口的实现类具有随机访问功能\",{\"1\":{\"230\":1}}],[\"这个异常表示数组下标越界\",{\"1\":{\"227\":1}}],[\"这个容器就是数组\",{\"1\":{\"217\":1}}],[\"这个更简单点\",{\"1\":{\"139\":1}}],[\"这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索\",{\"1\":{\"85\":1}}],[\"这个专门生成\",{\"1\":{\"78\":1}}],[\"这个\",{\"1\":{\"77\":1,\"612\":1,\"685\":1,\"816\":1}}],[\"这个配置文件中\",{\"1\":{\"69\":1}}],[\"这个快捷键按起来不是很方便\",{\"1\":{\"6\":1}}],[\"这样每层最右边的一个元素的值就是需要加到结果集中的\",{\"1\":{\"1035\":1}}],[\"这样每次就能先判断右边的元素\",{\"1\":{\"1034\":1}}],[\"这样才是这个橘子感染的最短时间\",{\"1\":{\"943\":1}}],[\"这样会抓不住重点\",{\"1\":{\"890\":1}}],[\"这样会大大减少最终jar包的体积\",{\"1\":{\"106\":1}}],[\"这样用户想用\",{\"1\":{\"883\":1}}],[\"这样所有那些原交换机无法被路由的消息\",{\"1\":{\"767\":1}}],[\"这样只需要消费者一直消费死信队列里的消息就完事了\",{\"1\":{\"753\":1}}],[\"这样只要\",{\"1\":{\"252\":1}}],[\"这样生产者才知道自己生产的消息成功发布出去\",{\"1\":{\"719\":1}}],[\"这样在有代码更改的时候\",{\"1\":{\"670\":1}}],[\"这样恰好是其缺点\",{\"1\":{\"665\":1}}],[\"这样恰好能覆盖int的最大值\",{\"1\":{\"253\":1}}],[\"这样有利于检查所依赖属性是否注入\",{\"1\":{\"611\":1}}],[\"这样歧义就消除了\",{\"1\":{\"599\":1}}],[\"这样也提高了系统扩展性\",{\"1\":{\"596\":1}}],[\"这样大大简化了代码量\",{\"1\":{\"596\":1}}],[\"这样更简单易懂而且不易出错\",{\"1\":{\"566\":1}}],[\"这样降低了内存泄漏和内存溢出的风险\",{\"1\":{\"517\":1}}],[\"这样暂时时间会短一些\",{\"1\":{\"496\":1}}],[\"这样必然导致经常中断或恢复\",{\"1\":{\"402\":1}}],[\"这样必然导经常中断或恢复\",{\"1\":{\"402\":1}}],[\"这样一个\",{\"1\":{\"919\":1}}],[\"这样一个延时队列就打造完成了\",{\"1\":{\"754\":1}}],[\"这样一个模型能为多个视图提供数据\",{\"1\":{\"645\":1}}],[\"这样一个真正可用的对象才算完全创建出来\",{\"1\":{\"474\":1}}],[\"这样一个真正可用的对象才算完全产生出来\",{\"1\":{\"314\":1}}],[\"这样一来\",{\"1\":{\"420\":1}}],[\"这样一来各个线程之间便可以进行独立计算\",{\"1\":{\"402\":1}}],[\"这样可以把root加到res中\",{\"1\":{\"1034\":1}}],[\"这样可以更加快速的将消息发送给消费者\",{\"1\":{\"782\":1}}],[\"这样可以很大程度上简化应用的开发\",{\"1\":{\"595\":1}}],[\"这样可以保证对java核心源代码的保护\",{\"1\":{\"392\":1}}],[\"这样可以减少栈帧的生成\",{\"1\":{\"372\":1}}],[\"这样可以省去许多不心要的编译时间\",{\"1\":{\"366\":1}}],[\"这样可以省去许多不必要的编译时间\",{\"1\":{\"365\":1}}],[\"这样可以批量插入注解\",{\"1\":{\"6\":1}}],[\"这样的需求\",{\"1\":{\"751\":1}}],[\"这样的消息如果没有后续的处理\",{\"1\":{\"744\":1}}],[\"这样的方法称为非虚方法\",{\"1\":{\"421\":1}}],[\"这样的处理方式让写的同学更加明确线程池的运行规则\",{\"1\":{\"291\":1}}],[\"这样的列表实现通常应该实现这个接口\",{\"1\":{\"230\":1}}],[\"这样做有一个非常大的问题\",{\"1\":{\"288\":1}}],[\"这样\",{\"1\":{\"288\":1,\"369\":1,\"611\":2,\"674\":1,\"707\":1,\"853\":1,\"939\":1}}],[\"这样就能跨语言了\",{\"1\":{\"919\":1}}],[\"这样就能把所有消息都投递到与其绑定的队列中\",{\"1\":{\"767\":1}}],[\"这样就能大大提高并发性和性能\",{\"1\":{\"509\":1}}],[\"这样就能在一些场景中显著提高性能\",{\"1\":{\"308\":1}}],[\"这样就无须进行垃圾回收了\",{\"1\":{\"508\":1}}],[\"这样就无需在堆上分配内存\",{\"1\":{\"505\":1}}],[\"这样就会考虑左孩子\",{\"1\":{\"1034\":1}}],[\"这样就会腾出很大的空间出来\",{\"1\":{\"497\":1}}],[\"这样就会对堆的所有区域进行扫描\",{\"1\":{\"497\":1}}],[\"这样就可以根据各个年代的特点使用不同的回收算法\",{\"1\":{\"525\":1}}],[\"这样就可以避免自己去编写\",{\"1\":{\"387\":1}}],[\"这样就可以在程序中计算与现实事物相关的数据\",{\"1\":{\"68\":1}}],[\"这样就省去了大量有关锁申请的操作\",{\"1\":{\"278\":1}}],[\"这样处理后\",{\"1\":{\"198\":1}}],[\"这样该插件就不会对原始的jar重命名操作了\",{\"1\":{\"104\":1}}],[\"这样如果要修改版本\",{\"1\":{\"87\":1}}],[\"这样我们就可以用程序来管理项目了\",{\"1\":{\"68\":1}}],[\"这样下次就能快速定位到了\",{\"1\":{\"11\":1}}],[\"再遍历该左子树的右子树\",{\"1\":{\"1024\":1}}],[\"再遍历该左子树的左子树\",{\"1\":{\"1024\":1}}],[\"再遍历右子树\",{\"1\":{\"1024\":1}}],[\"再把cur的next指向前一个节点\",{\"1\":{\"970\":1}}],[\"再同时移动fast\",{\"1\":{\"964\":2}}],[\"再完善下代码就ok\",{\"1\":{\"955\":1}}],[\"再拼\",{\"1\":{\"954\":1}}],[\"再由框架转换为特定编程语言的接口\",{\"1\":{\"919\":1}}],[\"再由另一个线程释放\",{\"1\":{\"292\":1}}],[\"再订阅自己的服务\",{\"1\":{\"906\":1}}],[\"再组装好结果返回\",{\"1\":{\"891\":1}}],[\"再通过网络传输发送给服务端\",{\"1\":{\"874\":1}}],[\"再通过zoneid\",{\"1\":{\"562\":1}}],[\"再加入一点点调味料\",{\"1\":{\"753\":1}}],[\"再加载新的对象放到eden区\",{\"1\":{\"490\":1}}],[\"再启动消费者\",{\"1\":{\"749\":1}}],[\"再根据配置信息对资源进行初始化\",{\"1\":{\"674\":1}}],[\"再也不怕面试官问了\",{\"1\":{\"661\":1}}],[\"再推荐一篇很不错的文章\",{\"1\":{\"614\":1}}],[\"再输入git\",{\"1\":{\"585\":1}}],[\"再输入要替换的内容\",{\"1\":{\"6\":1}}],[\"再看一个稍微复杂的例子\",{\"1\":{\"549\":1}}],[\"再进行一次右移\",{\"1\":{\"970\":1}}],[\"再进行一次内存碎片整理\",{\"1\":{\"523\":1}}],[\"再进一步\",{\"1\":{\"549\":1}}],[\"再进入想查看的目录\",{\"1\":{\"32\":1}}],[\"再次重新输入会刷新验证码\",{\"1\":{\"771\":1}}],[\"再次确认\",{\"1\":{\"723\":1}}],[\"再次触发gc\",{\"1\":{\"490\":1}}],[\"再次计算\",{\"1\":{\"184\":1}}],[\"再后来\",{\"1\":{\"359\":1}}],[\"再细致一点有\",{\"1\":{\"304\":1}}],[\"再一起执行后面的操作\",{\"1\":{\"292\":1}}],[\"再观察任务运行情况和系统负载\",{\"1\":{\"277\":1}}],[\"再处理\",{\"1\":{\"207\":1}}],[\"再判断下边界条件即可\",{\"1\":{\"201\":1}}],[\"再构造一个大小为k的滑动窗口\",{\"1\":{\"189\":1}}],[\"再用程序中的对象来描述这个模型\",{\"1\":{\"68\":1}}],[\"再执行\",{\"1\":{\"28\":1}}],[\"再点击不同的位置\",{\"1\":{\"6\":1}}],[\"按\",{\"1\":{\"944\":1}}],[\"按深度优先的方式进行感染\",{\"1\":{\"943\":1}}],[\"按需加载\",{\"1\":{\"893\":1}}],[\"按需构造\",{\"1\":{\"275\":1}}],[\"按序给\",{\"1\":{\"810\":1}}],[\"按顺序排放\",{\"1\":{\"523\":1}}],[\"按顺序\",{\"1\":{\"454\":1}}],[\"按照\",{\"1\":{\"1034\":1}}],[\"按照从顶部到底部的顺序\",{\"1\":{\"1033\":1}}],[\"按照递归\",{\"1\":{\"970\":1}}],[\"按照本地存储的地址进行调用\",{\"1\":{\"915\":1}}],[\"按照order排序\",{\"1\":{\"905\":1}}],[\"按照这种逻辑\",{\"1\":{\"691\":1}}],[\"按照约定去读取\",{\"1\":{\"674\":1}}],[\"按照特定规则执行相关的处理器\",{\"1\":{\"646\":1}}],[\"按照内存地址依次排列\",{\"1\":{\"523\":1}}],[\"按照继承关系从下往上依次对\",{\"1\":{\"422\":1}}],[\"按照线程等待顺序获取锁\",{\"1\":{\"290\":1}}],[\"按某一顺序申请资源\",{\"1\":{\"270\":1}}],[\"按自然排序的升序排序\",{\"1\":{\"257\":1}}],[\"按位异或\",{\"1\":{\"244\":1}}],[\"按功能组件分类的设计图\",{\"1\":{\"139\":1}}],[\"按ctrl+1\",{\"1\":{\"6\":1}}],[\"按ctrl+shift+enter即可自动补齐需要的前后括号\",{\"1\":{\"6\":1}}],[\"按ctrl+shift+enter即可自动补齐需要的分号\",{\"1\":{\"6\":1}}],[\"按住alt\",{\"1\":{\"6\":2}}],[\"+arr\",{\"1\":{\"982\":5}}],[\"+alt+s\",{\"1\":{\"16\":1}}],[\"++\",{\"1\":{\"939\":1}}],[\"++tmp\",{\"1\":{\"201\":1}}],[\"+eliminateallocations\",{\"1\":{\"510\":1}}],[\"+doescapeanalysis显式开启逃逸分析\",{\"1\":{\"506\":1}}],[\"+printcommandlineflags\",{\"1\":{\"537\":1}}],[\"+printescapeanalysis查看逃逸分析的筛选结果\",{\"1\":{\"506\":1}}],[\"+printflagsfinal\",{\"1\":{\"503\":1}}],[\"+printflagsinitial\",{\"1\":{\"503\":1}}],[\"+printgcdetails\",{\"1\":{\"487\":1,\"503\":1,\"537\":1}}],[\"+parallel\",{\"1\":{\"339\":2,\"537\":2}}],[\"+tracec1assunloading\",{\"1\":{\"464\":1}}],[\"+tracec1ass\",{\"1\":{\"464\":1}}],[\"+usetlab\",{\"1\":{\"502\":1}}],[\"+useg1gc\",{\"1\":{\"339\":1}}],[\"+useparalleloldgc\",{\"1\":{\"532\":1}}],[\"+useparallelgc\",{\"1\":{\"339\":1,\"532\":1}}],[\"+useparnewgc\",{\"1\":{\"339\":1}}],[\"+useserialgc\",{\"1\":{\"339\":1}}],[\"+w\",{\"1\":{\"207\":1}}],[\"+1\",{\"1\":{\"198\":1}}],[\"+=\",{\"1\":{\"187\":1,\"198\":1,\"204\":1,\"205\":1,\"938\":1,\"939\":4}}],[\"+f\",{\"1\":{\"170\":1}}],[\"+\",{\"1\":{\"6\":5,\"8\":3,\"11\":1,\"27\":2,\"42\":1,\"85\":5,\"131\":3,\"184\":4,\"187\":1,\"194\":1,\"198\":1,\"199\":2,\"200\":3,\"201\":2,\"203\":3,\"204\":3,\"205\":3,\"207\":2,\"221\":1,\"239\":3,\"249\":3,\"253\":1,\"317\":9,\"470\":2,\"471\":1,\"485\":1,\"510\":6,\"532\":1,\"534\":2,\"539\":2,\"671\":1,\"674\":2,\"698\":1,\"701\":3,\"708\":3,\"711\":1,\"712\":1,\"714\":2,\"717\":2,\"722\":5,\"723\":5,\"734\":1,\"738\":1,\"742\":1,\"747\":4,\"748\":3,\"749\":4,\"754\":2,\"755\":2,\"762\":6,\"779\":3,\"780\":1,\"815\":2,\"854\":1,\"858\":4,\"860\":2,\"879\":2,\"925\":1,\"926\":2,\"934\":2,\"938\":2,\"939\":4,\"943\":2,\"944\":5,\"957\":1,\"982\":2,\"983\":9,\"984\":1,\"1022\":2,\"1023\":1,\"1024\":6}}],[\"多数据源\",{\"0\":{\"865\":1}}],[\"多重绑定\",{\"0\":{\"737\":1}}],[\"多个不同版本的服务注册到注册中心\",{\"1\":{\"900\":1}}],[\"多个短连接\",{\"1\":{\"888\":4}}],[\"多个参数封装成map\",{\"1\":{\"819\":1}}],[\"多个文件上传\",{\"1\":{\"655\":1}}],[\"多个任务同时执行\",{\"1\":{\"268\":1}}],[\"多个任务都在执行\",{\"1\":{\"268\":1}}],[\"多次读同一数据\",{\"1\":{\"634\":1}}],[\"多核环境下的硬件优势\",{\"1\":{\"535\":1}}],[\"多合一故障处理工具\",{\"1\":{\"341\":1}}],[\"多出来的1个字记录的是数组长度\",{\"1\":{\"278\":1}}],[\"多加了一个偶数位\",{\"1\":{\"198\":1}}],[\"多光标\",{\"1\":{\"6\":1}}],[\"多线程同时分配内存时\",{\"1\":{\"500\":1}}],[\"多线程面试题\",{\"0\":{\"263\":1}}],[\"多线程概述\",{\"0\":{\"262\":1}}],[\"多线程访问容器里不同数据段的数据\",{\"1\":{\"249\":1}}],[\"多线程操作导致死循环问题\",{\"0\":{\"247\":1}}],[\"多线程\",{\"1\":{\"4\":1}}],[\"n叉树\",{\"0\":{\"1026\":1,\"1042\":1,\"1044\":1}}],[\"n次\",{\"1\":{\"964\":1}}],[\"ncode\",{\"1\":{\"944\":4}}],[\"ncpu\",{\"1\":{\"277\":1}}],[\"ncpu+1\",{\"1\":{\"277\":1}}],[\"n+k\",{\"1\":{\"940\":1}}],[\"n+1\",{\"1\":{\"198\":1,\"203\":2,\"634\":1}}],[\"nyse\",{\"1\":{\"740\":2}}],[\"nio通信\",{\"1\":{\"878\":1}}],[\"nio\",{\"1\":{\"308\":1,\"742\":1,\"747\":2,\"879\":1}}],[\"n>>>8意思是无符号右移16位\",{\"1\":{\"253\":1}}],[\"n>>>8意思是无符号右移8位\",{\"1\":{\"253\":1}}],[\"n>>>4意思是无符号右移4位\",{\"1\":{\"253\":1}}],[\"n>>>2意思是无符号右移2位\",{\"1\":{\"253\":1}}],[\"n>>>1意思是无符号右移1位\",{\"1\":{\"253\":1}}],[\"n>>1\",{\"1\":{\"198\":1}}],[\"n=list\",{\"1\":{\"230\":1}}],[\"nlog⁡n\",{\"1\":{\"194\":1}}],[\"nlogn\",{\"1\":{\"189\":2,\"190\":2,\"938\":1}}],[\"n是数组长度\",{\"1\":{\"189\":1,\"190\":1}}],[\"n不为0时持续进行上述计算\",{\"1\":{\"184\":1}}],[\"n为线程池内的线程编号\",{\"1\":{\"275\":1}}],[\"n为\",{\"1\":{\"184\":1}}],[\"n\",{\"1\":{\"170\":3,\"171\":1,\"184\":5,\"186\":1,\"187\":2,\"188\":2,\"189\":3,\"190\":3,\"194\":2,\"198\":5,\"199\":4,\"200\":4,\"203\":4,\"204\":3,\"205\":3,\"207\":10,\"229\":3,\"230\":1,\"239\":14,\"244\":2,\"246\":3,\"252\":3,\"253\":24,\"275\":1,\"548\":2,\"562\":3,\"577\":1,\"634\":1,\"931\":1,\"934\":5,\"948\":2,\"949\":2,\"954\":3,\"957\":1,\"963\":2,\"968\":3,\"969\":5,\"983\":13,\"1029\":8,\"1030\":7,\"1034\":1,\"1035\":1,\"1040\":1}}],[\"nginx\",{\"0\":{\"151\":1},\"1\":{\"151\":1}}],[\"noargs\",{\"1\":{\"757\":1}}],[\"normalqueue\",{\"1\":{\"747\":4,\"748\":4,\"749\":4}}],[\"normal\",{\"1\":{\"747\":9,\"748\":9,\"749\":5}}],[\"nord\",{\"1\":{\"139\":1}}],[\"now\",{\"1\":{\"562\":2}}],[\"no\",{\"1\":{\"515\":1,\"577\":1,\"598\":1,\"619\":1}}],[\"nonnull\",{\"1\":{\"992\":1}}],[\"non\",{\"0\":{\"455\":1},\"1\":{\"305\":1,\"343\":1}}],[\"nonematch\",{\"1\":{\"550\":1}}],[\"none\",{\"1\":{\"242\":1,\"762\":1,\"836\":1}}],[\"node\",{\"1\":{\"249\":3,\"289\":1,\"1029\":6,\"1034\":6,\"1035\":6}}],[\"notifyall\",{\"1\":{\"273\":2,\"286\":2}}],[\"notify\",{\"1\":{\"265\":1,\"273\":2,\"288\":2}}],[\"notion\",{\"1\":{\"148\":1}}],[\"not\",{\"1\":{\"242\":1,\"635\":2,\"975\":1,\"1045\":1}}],[\"npx\",{\"1\":{\"146\":2}}],[\"nack\",{\"1\":{\"720\":2,\"745\":1}}],[\"nativemethod\",{\"1\":{\"434\":1}}],[\"native\",{\"0\":{\"435\":1,\"437\":1},\"1\":{\"303\":1,\"308\":2,\"318\":1,\"322\":1,\"434\":1,\"454\":3}}],[\"name=\",{\"1\":{\"851\":1}}],[\"name\",{\"1\":{\"577\":1,\"619\":2,\"697\":5,\"698\":2,\"701\":4,\"708\":6,\"711\":3,\"712\":3,\"714\":2,\"717\":2,\"729\":1,\"734\":3,\"735\":1,\"738\":3,\"742\":3,\"757\":8,\"762\":9,\"768\":13,\"779\":6,\"788\":1,\"792\":2,\"810\":2,\"815\":8,\"819\":2,\"820\":6,\"831\":1,\"837\":1,\"840\":1,\"850\":1,\"851\":1,\"852\":4,\"858\":1,\"860\":2,\"866\":2}}],[\"namespacehandler里面通过beandefinitionparser来解析配置信息并转化为需要加载的\",{\"1\":{\"908\":1}}],[\"namespace\",{\"1\":{\"693\":1,\"813\":1,\"816\":2}}],[\"names\",{\"1\":{\"546\":1,\"814\":2,\"815\":1}}],[\"namecheap又一个\",{\"1\":{\"139\":1}}],[\"name>encoding<\",{\"1\":{\"649\":1}}],[\"name>characterencodingfilter<\",{\"1\":{\"649\":2}}],[\"name>\",{\"1\":{\"61\":1,\"649\":3}}],[\"navigablemap\",{\"1\":{\"241\":1}}],[\"navicat\",{\"2\":{\"30\":1}}],[\"navicat相关\",{\"0\":{\"26\":1}}],[\"navnav\",{\"1\":{\"134\":1}}],[\"numbers\",{\"1\":{\"548\":2}}],[\"number\",{\"1\":{\"244\":1}}],[\"numbering\",{\"1\":{\"47\":1}}],[\"num\",{\"1\":{\"241\":4}}],[\"numways\",{\"1\":{\"204\":1,\"205\":1}}],[\"numrows\",{\"1\":{\"201\":3}}],[\"nums\",{\"1\":{\"186\":4,\"187\":5,\"189\":7,\"190\":7,\"925\":6,\"926\":5,\"931\":6,\"1040\":6}}],[\"null||pre==cur\",{\"1\":{\"1024\":1}}],[\"null好理解\",{\"1\":{\"954\":1}}],[\"nullpointerexception\",{\"1\":{\"239\":1,\"519\":1,\"998\":3}}],[\"null\",{\"1\":{\"6\":1,\"231\":1,\"239\":7,\"242\":1,\"244\":1,\"332\":4,\"381\":3,\"697\":4,\"701\":1,\"708\":2,\"711\":2,\"712\":1,\"722\":2,\"723\":2,\"729\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":2,\"748\":3,\"749\":2,\"762\":1,\"765\":1,\"779\":1,\"788\":1,\"821\":1,\"832\":2,\"847\":1,\"848\":1,\"851\":2,\"852\":2,\"853\":2,\"901\":1,\"925\":1,\"934\":1,\"954\":1,\"963\":4,\"965\":1,\"968\":3,\"969\":3,\"970\":2,\"973\":6,\"975\":6,\"990\":3,\"998\":1,\"1020\":5,\"1022\":1,\"1024\":16,\"1028\":2,\"1029\":5,\"1030\":2,\"1033\":2,\"1034\":1,\"1035\":3,\"1038\":2}}],[\"nexus\",{\"1\":{\"1009\":2}}],[\"nexttemp\",{\"1\":{\"975\":2}}],[\"next返回需要的节点头即可\",{\"1\":{\"964\":1}}],[\"next即可删除目标节点\",{\"1\":{\"964\":1}}],[\"nextline\",{\"1\":{\"708\":1,\"711\":1,\"712\":1,\"734\":1}}],[\"next\",{\"1\":{\"229\":2,\"230\":1,\"569\":1,\"701\":1,\"963\":11,\"964\":2,\"965\":4,\"968\":3,\"969\":5,\"970\":1,\"973\":9,\"975\":12}}],[\"never\",{\"1\":{\"635\":2}}],[\"nested\",{\"1\":{\"635\":2}}],[\"neocities\",{\"1\":{\"143\":1}}],[\"need\",{\"1\":{\"134\":1}}],[\"nettyclient\",{\"1\":{\"890\":1}}],[\"nettyserver\",{\"1\":{\"889\":1}}],[\"netty\",{\"1\":{\"883\":2,\"919\":1}}],[\"network\",{\"1\":{\"577\":1}}],[\"net\",{\"1\":{\"110\":2,\"289\":1,\"293\":1}}],[\"netlify\",{\"1\":{\"1\":1}}],[\"newratio\",{\"1\":{\"503\":1}}],[\"newratio=4\",{\"1\":{\"488\":1}}],[\"newratio=2\",{\"1\":{\"488\":1}}],[\"newratio=1\",{\"1\":{\"337\":1}}],[\"newinstance\",{\"1\":{\"468\":2}}],[\"newsize=256m\",{\"1\":{\"336\":1}}],[\"newsize=<young\",{\"1\":{\"336\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"291\":1}}],[\"newscheduledthreadpool\",{\"1\":{\"291\":1}}],[\"newconnection\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"newcondition\",{\"1\":{\"282\":1}}],[\"newcachethreadpool\",{\"1\":{\"291\":1}}],[\"newfixedthreadpool\",{\"1\":{\"291\":1}}],[\"newval\",{\"1\":{\"258\":1}}],[\"new\",{\"0\":{\"319\":1},\"1\":{\"14\":2,\"15\":2,\"19\":2,\"186\":1,\"194\":2,\"198\":1,\"201\":2,\"202\":1,\"203\":2,\"204\":1,\"205\":1,\"207\":1,\"234\":2,\"235\":2,\"239\":2,\"241\":7,\"291\":1,\"308\":1,\"310\":1,\"314\":1,\"317\":3,\"318\":2,\"319\":2,\"431\":1,\"439\":2,\"468\":1,\"470\":1,\"471\":1,\"474\":1,\"483\":2,\"490\":1,\"510\":1,\"549\":2,\"571\":1,\"614\":2,\"617\":4,\"635\":2,\"697\":3,\"698\":2,\"701\":3,\"702\":1,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":4,\"748\":3,\"749\":3,\"752\":1,\"754\":10,\"755\":3,\"757\":6,\"762\":4,\"765\":2,\"768\":2,\"777\":2,\"779\":3,\"780\":4,\"783\":1,\"788\":16,\"815\":1,\"819\":1,\"832\":1,\"844\":1,\"845\":1,\"846\":1,\"847\":1,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"853\":1,\"854\":3,\"857\":2,\"858\":2,\"860\":3,\"864\":1,\"925\":1,\"934\":1,\"939\":1,\"944\":2,\"948\":1,\"954\":1,\"963\":1,\"982\":12,\"983\":2,\"991\":3,\"1011\":1,\"1024\":4,\"1030\":1,\"1034\":1,\"1035\":2}}],[\"nn并回车即可\",{\"1\":{\"10\":1}}],[\"s指示器\",{\"1\":{\"997\":1}}],[\"s模型\",{\"1\":{\"875\":1}}],[\"smi\",{\"1\":{\"814\":2}}],[\"smartmockups\",{\"1\":{\"139\":1}}],[\"slow就是目标节点\",{\"1\":{\"964\":1}}],[\"slow都指向head\",{\"1\":{\"964\":1}}],[\"slow都指向它\",{\"1\":{\"964\":1}}],[\"slow指到了目标节点的前一个节点\",{\"1\":{\"964\":1}}],[\"slow\",{\"1\":{\"963\":5,\"964\":3,\"965\":4,\"973\":11,\"975\":4}}],[\"slave\",{\"1\":{\"866\":1}}],[\"slf4j\",{\"1\":{\"754\":6,\"755\":1,\"757\":4,\"762\":9,\"765\":2,\"768\":3,\"780\":1}}],[\"sleep和wait的区别\",{\"0\":{\"273\":1}}],[\"sleep\",{\"1\":{\"267\":1,\"273\":4,\"708\":2,\"714\":1,\"717\":1}}],[\"snyk\",{\"1\":{\"662\":1}}],[\"snake\",{\"1\":{\"143\":1}}],[\"snapshot<\",{\"1\":{\"70\":1,\"77\":1,\"83\":1,\"88\":2}}],[\"snapshot\",{\"1\":{\"65\":1,\"77\":3,\"103\":1}}],[\"ssl加密\",{\"1\":{\"879\":1}}],[\"sslverify\",{\"1\":{\"587\":1}}],[\"ssl\",{\"1\":{\"587\":1}}],[\"sss\",{\"1\":{\"573\":1}}],[\"ss\",{\"1\":{\"573\":1}}],[\"ssm\",{\"1\":{\"80\":1}}],[\"skipnulls\",{\"1\":{\"990\":1,\"992\":1}}],[\"skip\",{\"1\":{\"548\":1}}],[\"sketchfab\",{\"1\":{\"141\":1}}],[\"sbgoogle\",{\"1\":{\"991\":1}}],[\"sb\",{\"1\":{\"431\":1,\"954\":4,\"991\":3}}],[\"s4来自常量池\",{\"1\":{\"318\":1}}],[\"s4\",{\"1\":{\"318\":1}}],[\"s3==s4\",{\"1\":{\"318\":1}}],[\"s3来自堆\",{\"1\":{\"318\":2}}],[\"s3会直接创建新对象\",{\"1\":{\"318\":1}}],[\"s3\",{\"1\":{\"318\":3,\"573\":3}}],[\"s2==s4\",{\"1\":{\"318\":1}}],[\"s2==s3\",{\"1\":{\"318\":1}}],[\"s2来自常量池\",{\"1\":{\"318\":1}}],[\"s2\",{\"1\":{\"318\":1,\"319\":3,\"573\":2,\"992\":2}}],[\"s1空间的比例\",{\"1\":{\"503\":1}}],[\"s1==s4\",{\"1\":{\"318\":1}}],[\"s1==s3\",{\"1\":{\"318\":1}}],[\"s1==s2\",{\"1\":{\"318\":1}}],[\"s1\",{\"0\":{\"319\":1},\"1\":{\"304\":1,\"318\":3,\"319\":4,\"488\":1,\"490\":1,\"497\":1,\"573\":2,\"992\":2}}],[\"s0\",{\"1\":{\"304\":1,\"488\":1,\"497\":1}}],[\"switch\",{\"1\":{\"788\":1}}],[\"swiper\",{\"1\":{\"158\":1}}],[\"swagger\",{\"1\":{\"788\":3}}],[\"swap\",{\"1\":{\"257\":1,\"471\":1}}],[\"sweep这两个词可以看出\",{\"1\":{\"534\":1}}],[\"sweep\",{\"0\":{\"521\":1},\"1\":{\"520\":1,\"523\":1,\"525\":2,\"534\":1}}],[\"spi区别\",{\"0\":{\"909\":1}}],[\"spi和java\",{\"0\":{\"909\":1}}],[\"spi的类extensionloader的adaptive实现是典型的动态代理实现\",{\"1\":{\"907\":1}}],[\"spi\",{\"0\":{\"892\":1,\"893\":1},\"1\":{\"883\":2,\"892\":7,\"893\":3,\"909\":2}}],[\"spel\",{\"1\":{\"591\":1}}],[\"specified\",{\"1\":{\"242\":1}}],[\"splittolist\",{\"1\":{\"996\":4}}],[\"splitter源码分析\",{\"1\":{\"996\":1}}],[\"splitter同时还支持正则\",{\"1\":{\"996\":1}}],[\"splitter\",{\"0\":{\"995\":1},\"1\":{\"988\":1,\"995\":1,\"996\":4},\"2\":{\"1000\":1}}],[\"split1\",{\"1\":{\"996\":4}}],[\"split会丢弃尾部的分隔符\",{\"1\":{\"995\":1}}],[\"split\",{\"0\":{\"996\":1},\"1\":{\"549\":1,\"957\":1,\"995\":1}}],[\"space可用内存\",{\"1\":{\"496\":1}}],[\"space1\",{\"1\":{\"496\":1}}],[\"space0\",{\"1\":{\"496\":1}}],[\"space\",{\"1\":{\"483\":5,\"496\":2}}],[\"spring源码解析\",{\"0\":{\"1014\":1}}],[\"spring源码\",{\"0\":{\"1013\":1}}],[\"spring源码下载和编译\",{\"0\":{\"1002\":1}}],[\"spring容器在启动的时候\",{\"1\":{\"908\":1}}],[\"spring容器时\",{\"1\":{\"617\":1}}],[\"spring自定义注解来编写轻量级框架\",{\"1\":{\"872\":1}}],[\"spring自动注入类型\",{\"0\":{\"609\":1}}],[\"springcloud\",{\"0\":{\"803\":1}}],[\"springcloud的注册中心只能用eureka或者自研\",{\"1\":{\"798\":1}}],[\"springcloud的接口协议约定比较自由且松散\",{\"1\":{\"798\":1}}],[\"springcloud是http协议传输\",{\"1\":{\"798\":1}}],[\"springcloud是一系列框架的集合\",{\"1\":{\"666\":1}}],[\"springcloud面试题\",{\"0\":{\"796\":1}}],[\"springcloud相关资料和教程\",{\"0\":{\"795\":1}}],[\"springsecurity\",{\"0\":{\"793\":1,\"794\":1},\"1\":{\"787\":1}}],[\"springapplication\",{\"1\":{\"753\":2}}],[\"springapplication会再次借助spring\",{\"1\":{\"678\":1}}],[\"springapplication实例初始化完成并且完成设置后\",{\"1\":{\"678\":1}}],[\"springfactoriesloader\",{\"1\":{\"674\":1}}],[\"springframework<\",{\"1\":{\"87\":7,\"88\":5,\"671\":1}}],[\"springframework\",{\"1\":{\"70\":1,\"85\":5,\"106\":1,\"605\":1,\"628\":1,\"649\":1,\"670\":1,\"671\":1,\"676\":1,\"678\":1,\"679\":3,\"687\":4,\"753\":9,\"754\":22,\"755\":4,\"757\":3,\"762\":17,\"768\":3,\"788\":1}}],[\"spring热部署\",{\"1\":{\"671\":1}}],[\"springmvc框架将配置的类似全局的拦截器注入到每个handlermapping中\",{\"1\":{\"656\":1}}],[\"springmvc配置类似全局的拦截器\",{\"1\":{\"656\":1}}],[\"springmvc拦截器针对handlermapping进行拦截设置\",{\"1\":{\"656\":1}}],[\"springmvc通过参数解析器是将request请求内容解析\",{\"1\":{\"654\":1}}],[\"springmvc是基于方法开发\",{\"1\":{\"654\":1}}],[\"springmvc的入口是一个servlet\",{\"1\":{\"654\":1}}],[\"springmvc的优点\",{\"0\":{\"644\":1}}],[\"springmvc会自动做转换\",{\"1\":{\"651\":1}}],[\"springmvc默认提供一个解决post请求乱码的过滤器\",{\"1\":{\"649\":1}}],[\"springmvc\",{\"0\":{\"649\":1,\"650\":1,\"651\":1,\"653\":1,\"654\":1,\"655\":1,\"656\":1,\"657\":1,\"658\":1}}],[\"springmvc面试题\",{\"0\":{\"641\":1}}],[\"spring有哪些重要的扩展点\",{\"0\":{\"640\":1}}],[\"spring应用销毁是在哪里\",{\"0\":{\"639\":1}}],[\"spring框架中的单例beans是线程安全的么\",{\"0\":{\"638\":1}}],[\"spring框架对单例的支持是采用单例注册表的方式进行实现的\",{\"1\":{\"616\":1}}],[\"spring是无法提供事务功能的\",{\"1\":{\"633\":1}}],[\"spring是一个通用解决方案\",{\"1\":{\"592\":1}}],[\"spring是一个轻量级的控制反转\",{\"1\":{\"592\":1}}],[\"spring事务失效的\",{\"1\":{\"636\":1}}],[\"spring事务失效的场景\",{\"0\":{\"636\":1}}],[\"spring事务中的隔离级别有哪几种\",{\"0\":{\"634\":1}}],[\"spring事务的传播行为\",{\"0\":{\"635\":1}}],[\"spring事务的本质其实就是数据库对事务的支持\",{\"1\":{\"633\":1}}],[\"spring事务的实现方式有几种\",{\"0\":{\"633\":1}}],[\"spring事务总结\",{\"1\":{\"590\":1}}],[\"spring的proxy模式在aop中有体现\",{\"1\":{\"629\":1}}],[\"spring的单例实现原理\",{\"0\":{\"616\":1}}],[\"spring提供的org\",{\"1\":{\"628\":1}}],[\"spring实现这一aop功能的原理就使用代理模式\",{\"1\":{\"627\":1}}],[\"spring中observer模式常用的地方是listener的实现\",{\"1\":{\"630\":1}}],[\"spring中用到的包装器模式在类名上有两种表现\",{\"1\":{\"628\":1}}],[\"spring中的jdbctemplate\",{\"1\":{\"632\":1}}],[\"spring中的单例模式完成了后半句话\",{\"1\":{\"626\":1}}],[\"spring中的beanfactory就是简单工厂模式的体现\",{\"1\":{\"624\":1}}],[\"spring中都用到了哪些设计模式\",{\"1\":{\"590\":1}}],[\"spring用到了哪些设计模式\",{\"0\":{\"623\":1}}],[\"spring循环依赖三级缓存是否可以减少为二级缓存\",{\"1\":{\"621\":1}}],[\"spring会采用新建实例的方式返回对象实例\",{\"1\":{\"616\":1}}],[\"spring5\",{\"1\":{\"615\":1}}],[\"springbean\",{\"1\":{\"614\":1}}],[\"springboot应用篇\",{\"1\":{\"684\":1}}],[\"springboot应用要开始执行咯\",{\"1\":{\"678\":1}}],[\"springboot读取配置相关注解有\",{\"0\":{\"681\":1}}],[\"springboot运行原理\",{\"0\":{\"678\":1}}],[\"springboot的加载流程\",{\"0\":{\"677\":1}}],[\"springboot自动配置原理\",{\"1\":{\"674\":1}}],[\"springbootapplication\",{\"1\":{\"674\":1,\"676\":2,\"753\":2}}],[\"springbootapplication=\",{\"1\":{\"674\":1}}],[\"springboot中对\",{\"1\":{\"674\":1}}],[\"springboot编译插件\",{\"1\":{\"671\":1}}],[\"springboot热部署的方式\",{\"0\":{\"669\":1}}],[\"springboot如何修改端口号\",{\"0\":{\"668\":1}}],[\"springboot只是一个快速开发框架\",{\"1\":{\"666\":1}}],[\"springboot是spring的子项目\",{\"1\":{\"664\":1}}],[\"springboot面试题\",{\"0\":{\"663\":1}}],[\"springboot启动扩展点超详细总结\",{\"1\":{\"661\":1}}],[\"springboot教程\",{\"1\":{\"660\":1}}],[\"springboot\",{\"0\":{\"676\":1,\"688\":1,\"689\":1,\"804\":1},\"1\":{\"595\":1,\"660\":1,\"669\":1,\"675\":1,\"760\":1}}],[\"springboot+spring常用注解总结\",{\"1\":{\"590\":1}}],[\"spring核心工厂是beanfactory\",{\"1\":{\"611\":1}}],[\"spring切面可以执行一下五种类型的通知\",{\"1\":{\"604\":1}}],[\"spring流程\",{\"0\":{\"593\":1}}],[\"spring可以说是一个管理bean的容器\",{\"1\":{\"592\":1}}],[\"spring也提供了很多基础功能\",{\"1\":{\"592\":1}}],[\"spring跟springmvc的区别\",{\"0\":{\"592\":1}}],[\"spring常见问题总结\",{\"1\":{\"590\":1}}],[\"spring面试题\",{\"0\":{\"589\":1}}],[\"spring\",{\"0\":{\"104\":1,\"598\":1,\"602\":1,\"603\":1,\"642\":1,\"646\":1,\"666\":1,\"667\":1,\"670\":1,\"671\":1,\"673\":1,\"674\":1,\"679\":1,\"680\":1,\"683\":1,\"684\":1,\"685\":1,\"686\":1,\"687\":1,\"1015\":1},\"1\":{\"85\":6,\"87\":3,\"104\":1,\"105\":6,\"106\":2,\"590\":2,\"591\":7,\"592\":2,\"595\":4,\"596\":2,\"599\":6,\"602\":4,\"603\":3,\"612\":1,\"614\":5,\"617\":3,\"618\":2,\"621\":2,\"643\":4,\"660\":1,\"661\":2,\"665\":4,\"667\":4,\"670\":1,\"673\":1,\"674\":6,\"676\":1,\"680\":2,\"682\":2,\"683\":2,\"685\":3,\"686\":4,\"753\":3,\"754\":4,\"762\":1,\"764\":2,\"765\":1,\"795\":1,\"802\":1,\"831\":1,\"866\":1,\"886\":2,\"887\":1,\"889\":1,\"1004\":3,\"1005\":1,\"1006\":1,\"1009\":3,\"1010\":1,\"1011\":1}}],[\"s=list\",{\"1\":{\"235\":1}}],[\"s=\",{\"1\":{\"235\":1}}],[\"svg\",{\"1\":{\"132\":1,\"140\":1}}],[\"squoosh\",{\"1\":{\"132\":1}}],[\"sqlserver\",{\"1\":{\"827\":1}}],[\"sqlsession\",{\"1\":{\"819\":1}}],[\"sqlite\",{\"1\":{\"827\":1}}],[\"sql片段的id\",{\"1\":{\"819\":1}}],[\"sql语句依赖于数据库\",{\"1\":{\"807\":1}}],[\"sql语句的编写工作量较大\",{\"1\":{\"807\":1}}],[\"sql写在xml里\",{\"1\":{\"807\":1}}],[\"sql\",{\"0\":{\"812\":3},\"1\":{\"28\":2,\"99\":1,\"628\":1,\"810\":5,\"811\":3,\"812\":7,\"816\":3,\"817\":4,\"821\":1,\"822\":1,\"823\":1,\"827\":1,\"842\":1}}],[\"soa可以看作是b\",{\"1\":{\"875\":1}}],[\"soa是一种粗粒度\",{\"1\":{\"875\":1}}],[\"soa\",{\"1\":{\"875\":1,\"881\":1}}],[\"soap在安全方面是通过使用xml\",{\"1\":{\"875\":1}}],[\"soap是一种数据交换协议规范\",{\"1\":{\"875\":1}}],[\"soap\",{\"0\":{\"875\":1},\"1\":{\"875\":2}}],[\"some\",{\"1\":{\"819\":1}}],[\"something\",{\"1\":{\"687\":1}}],[\"socket只是一个简单的网络通信方式\",{\"1\":{\"872\":1}}],[\"socket\",{\"1\":{\"525\":1}}],[\"solaris\",{\"1\":{\"410\":1}}],[\"solution\",{\"1\":{\"194\":1,\"925\":1,\"931\":1,\"934\":1,\"938\":1,\"939\":1,\"943\":1,\"954\":1,\"963\":1,\"965\":1,\"968\":1,\"973\":1,\"975\":1,\"982\":1,\"983\":1,\"984\":1,\"1020\":1,\"1022\":1,\"1029\":1,\"1030\":1,\"1034\":1,\"1035\":1,\"1040\":1}}],[\"softreference\",{\"0\":{\"326\":1}}],[\"sorted\",{\"1\":{\"547\":1}}],[\"sort\",{\"1\":{\"189\":1,\"190\":1,\"257\":2,\"938\":1}}],[\"sobooks\",{\"1\":{\"124\":1,\"148\":1}}],[\"sourcetree\",{\"0\":{\"583\":1}}],[\"source\",{\"1\":{\"258\":1}}],[\"sourceencoding\",{\"1\":{\"101\":1}}],[\"sourceencoding>\",{\"1\":{\"101\":1}}],[\"sourceencoding>utf\",{\"1\":{\"101\":1}}],[\"sources\",{\"1\":{\"1011\":1}}],[\"sourcesgenerate\",{\"1\":{\"94\":2}}],[\"sourcesprocess\",{\"1\":{\"94\":2}}],[\"source>\",{\"1\":{\"61\":1,\"101\":1,\"696\":1}}],[\"source>1\",{\"1\":{\"61\":1}}],[\"sout+回车\",{\"1\":{\"10\":1}}],[\"samanthaming\",{\"1\":{\"123\":1}}],[\"sans\",{\"1\":{\"38\":1}}],[\"signature两个规范组成了ws\",{\"1\":{\"875\":1}}],[\"signal\",{\"1\":{\"265\":1}}],[\"since\",{\"1\":{\"792\":1}}],[\"singly\",{\"1\":{\"963\":1,\"965\":1,\"968\":1,\"973\":1}}],[\"singletonmap\",{\"1\":{\"864\":1}}],[\"singleton\",{\"1\":{\"615\":1}}],[\"sington\",{\"1\":{\"612\":1}}],[\"size>\",{\"1\":{\"335\":2,\"336\":2}}],[\"size\",{\"1\":{\"201\":1,\"230\":2,\"233\":1,\"239\":1,\"335\":1,\"788\":1,\"832\":1,\"957\":1,\"996\":2,\"1034\":1,\"1035\":5}}],[\"simpleentry<>\",{\"1\":{\"982\":1}}],[\"simplemonitorservice\",{\"1\":{\"902\":1}}],[\"simplemonitorservice使用一个后台线程\",{\"1\":{\"902\":1}}],[\"simplemonitorservice将这些聚合数据塞入blockingqueue\",{\"1\":{\"902\":1}}],[\"simple注册中心\",{\"1\":{\"897\":1}}],[\"simpledateformat线程不安全\",{\"1\":{\"555\":1}}],[\"simple\",{\"1\":{\"160\":1,\"762\":1}}],[\"sidecar加速\",{\"1\":{\"1004\":1}}],[\"sidecar\",{\"0\":{\"113\":1},\"1\":{\"113\":1}}],[\"site\",{\"1\":{\"94\":5}}],[\"stub\",{\"1\":{\"874\":9,\"878\":2}}],[\"studentid\",{\"1\":{\"819\":1}}],[\"student\",{\"1\":{\"817\":2,\"820\":2}}],[\"studentdao\",{\"1\":{\"816\":2}}],[\"stdoutimpl\",{\"1\":{\"831\":1,\"835\":1,\"836\":1}}],[\"stdout\",{\"1\":{\"831\":1,\"835\":1,\"836\":1}}],[\"stereotype\",{\"1\":{\"605\":1,\"687\":1,\"754\":1,\"757\":1,\"762\":2,\"768\":1}}],[\"step1\",{\"0\":{\"376\":1}}],[\"step5\",{\"0\":{\"314\":1}}],[\"step4\",{\"0\":{\"313\":1}}],[\"step3\",{\"0\":{\"312\":1,\"380\":1}}],[\"step2\",{\"0\":{\"311\":1,\"379\":1}}],[\"stw\",{\"1\":{\"523\":1,\"526\":1}}],[\"stw的时间更长\",{\"1\":{\"495\":1}}],[\"st\",{\"1\":{\"319\":1}}],[\"strlistwithnull\",{\"1\":{\"990\":4,\"991\":1,\"992\":2}}],[\"strlist\",{\"1\":{\"990\":2,\"991\":2}}],[\"strict\",{\"1\":{\"866\":1}}],[\"stringutils\",{\"1\":{\"852\":2,\"853\":1}}],[\"strings\",{\"1\":{\"687\":1}}],[\"string和long型的变量\",{\"1\":{\"600\":1}}],[\"string对象\",{\"1\":{\"525\":1}}],[\"stringtable\",{\"0\":{\"463\":1},\"1\":{\"463\":2}}],[\"string类\",{\"1\":{\"392\":2}}],[\"stringbuilder\",{\"1\":{\"276\":1,\"317\":2,\"431\":3,\"954\":2,\"991\":4}}],[\"stringbuffer等\",{\"1\":{\"994\":1}}],[\"stringbuffer\",{\"1\":{\"276\":1}}],[\"stringbuffer跟stringbuilder哪个线程安全\",{\"0\":{\"276\":1}}],[\"string>\",{\"1\":{\"241\":2,\"738\":2,\"742\":2,\"993\":1}}],[\"string\",{\"0\":{\"316\":1,\"318\":1,\"319\":2},\"1\":{\"188\":1,\"235\":3,\"241\":1,\"242\":1,\"317\":27,\"318\":10,\"319\":4,\"332\":1,\"381\":3,\"392\":5,\"393\":1,\"510\":1,\"519\":1,\"549\":1,\"559\":1,\"562\":2,\"568\":1,\"569\":1,\"571\":1,\"573\":5,\"651\":1,\"687\":3,\"697\":7,\"698\":5,\"701\":7,\"702\":4,\"708\":7,\"711\":3,\"712\":3,\"714\":4,\"717\":4,\"722\":3,\"723\":3,\"730\":1,\"734\":3,\"738\":4,\"742\":4,\"747\":15,\"748\":10,\"749\":12,\"753\":1,\"754\":11,\"755\":5,\"757\":9,\"762\":10,\"765\":7,\"768\":8,\"779\":7,\"780\":3,\"788\":6,\"792\":7,\"814\":2,\"819\":4,\"853\":1,\"860\":1,\"864\":1,\"948\":1,\"949\":1,\"954\":2,\"957\":3,\"990\":1,\"992\":2,\"993\":1,\"995\":1,\"998\":1}}],[\"strategyconfig\",{\"1\":{\"864\":1}}],[\"struts采用值栈存储请求和响应的数据\",{\"1\":{\"654\":1}}],[\"struts2是基于类开发\",{\"1\":{\"654\":1}}],[\"strutsprepareandexecutefilter\",{\"1\":{\"654\":1}}],[\"strongreference\",{\"0\":{\"325\":1}}],[\"str5\",{\"1\":{\"317\":3}}],[\"str4\",{\"1\":{\"317\":5}}],[\"str3都会被放入常量池\",{\"1\":{\"317\":1}}],[\"str3\",{\"1\":{\"317\":6}}],[\"str2==str3\",{\"1\":{\"317\":1}}],[\"str2\",{\"1\":{\"317\":9}}],[\"str\",{\"1\":{\"317\":7,\"957\":2}}],[\"str1==str2\",{\"1\":{\"317\":1}}],[\"str1\",{\"1\":{\"317\":9}}],[\"stream时生成的单个流都被合并起来\",{\"1\":{\"549\":1}}],[\"stream<string>\",{\"1\":{\"549\":1}}],[\"stream方法\",{\"1\":{\"549\":1}}],[\"stream\",{\"1\":{\"194\":2,\"198\":1,\"234\":2,\"241\":1,\"546\":1,\"548\":4,\"549\":10,\"562\":1,\"957\":1,\"992\":1}}],[\"stock\",{\"1\":{\"740\":1}}],[\"storytale\",{\"1\":{\"139\":1}}],[\"stop\",{\"1\":{\"105\":1,\"526\":1,\"530\":1,\"535\":1,\"536\":1}}],[\"standardcharsets\",{\"1\":{\"742\":2,\"747\":4,\"748\":1,\"749\":2}}],[\"statementhandler\",{\"1\":{\"818\":1}}],[\"statement中sql的动态参数进行映射生成最终执行的sql语句\",{\"1\":{\"806\":1}}],[\"statement\",{\"1\":{\"806\":1}}],[\"stateless\",{\"1\":{\"788\":2}}],[\"statisticsmap\",{\"1\":{\"902\":1}}],[\"statistics\",{\"1\":{\"340\":1}}],[\"staticfactory\",{\"1\":{\"624\":1}}],[\"static\",{\"1\":{\"184\":1,\"230\":1,\"234\":1,\"239\":1,\"241\":1,\"244\":2,\"251\":1,\"253\":1,\"317\":1,\"332\":1,\"379\":1,\"392\":2,\"453\":1,\"454\":1,\"510\":4,\"559\":1,\"562\":2,\"568\":1,\"569\":1,\"571\":1,\"573\":2,\"697\":2,\"698\":2,\"701\":5,\"708\":4,\"711\":2,\"712\":2,\"714\":2,\"717\":2,\"722\":2,\"723\":2,\"734\":2,\"738\":2,\"742\":2,\"747\":7,\"748\":5,\"749\":5,\"753\":1,\"754\":5,\"755\":2,\"757\":6,\"762\":4,\"768\":6,\"779\":4,\"864\":1,\"904\":1,\"984\":1}}],[\"status=exited\",{\"1\":{\"577\":1}}],[\"status\",{\"1\":{\"340\":1,\"577\":1,\"617\":2}}],[\"stars\",{\"1\":{\"127\":1}}],[\"star\",{\"1\":{\"127\":1}}],[\"start\",{\"1\":{\"105\":1,\"819\":2}}],[\"starters命名\",{\"1\":{\"682\":1}}],[\"starters包含了许多项目中需要用到的依赖\",{\"1\":{\"682\":1}}],[\"starters可以理解为启动器\",{\"1\":{\"682\":1}}],[\"starters是什么\",{\"0\":{\"682\":1}}],[\"starter\",{\"0\":{\"685\":1},\"1\":{\"70\":1,\"665\":1,\"674\":1,\"679\":4,\"682\":3,\"685\":2,\"753\":4}}],[\"starter<\",{\"1\":{\"70\":1,\"680\":1,\"753\":1,\"830\":1}}],[\"stack<treenode>\",{\"1\":{\"1024\":3,\"1030\":1}}],[\"stack<>\",{\"1\":{\"982\":1,\"1024\":3}}],[\"stack<int\",{\"1\":{\"982\":1}}],[\"stack中\",{\"1\":{\"437\":1}}],[\"stack的值\",{\"1\":{\"416\":1}}],[\"stackoverflowerror\",{\"0\":{\"427\":1},\"1\":{\"302\":3,\"303\":1,\"409\":1}}],[\"stack\",{\"0\":{\"416\":1,\"437\":1},\"1\":{\"120\":1,\"302\":1,\"340\":1,\"368\":1,\"407\":2,\"412\":2,\"414\":1,\"416\":1,\"982\":12,\"1024\":13,\"1030\":5}}],[\"src\",{\"1\":{\"99\":1,\"204\":5,\"205\":5,\"670\":1,\"1012\":1}}],[\"symbol\",{\"1\":{\"459\":1}}],[\"symbolic\",{\"1\":{\"417\":1}}],[\"synchronzed不能唤醒指定线程\",{\"1\":{\"282\":1}}],[\"synchronzed不可中断\",{\"1\":{\"282\":1}}],[\"synchronzed是非公平锁\",{\"1\":{\"282\":1}}],[\"synchronzed是java关键字基于jvm层面\",{\"1\":{\"282\":1}}],[\"synchronzed会自动释放锁\",{\"1\":{\"282\":1}}],[\"synchronzed原理\",{\"0\":{\"282\":1}}],[\"synchronize跟volatile的区别\",{\"0\":{\"281\":1}}],[\"synchronize原理\",{\"0\":{\"278\":1}}],[\"synchronized保证有序性\",{\"0\":{\"295\":1}}],[\"synchronized关键字与wait\",{\"1\":{\"286\":1}}],[\"synchronized与reentrantlock的异同\",{\"0\":{\"283\":1}}],[\"synchronized属于重量级锁\",{\"1\":{\"278\":1}}],[\"synchronized使用的锁对象是存储在java对象头里的\",{\"1\":{\"278\":1}}],[\"synchronized原理\",{\"1\":{\"278\":1}}],[\"synchronizedset\",{\"1\":{\"259\":1}}],[\"synchronizedmap\",{\"1\":{\"259\":1}}],[\"synchronizedlist\",{\"1\":{\"259\":1}}],[\"synchronizedcollection\",{\"1\":{\"259\":1}}],[\"synchronized\",{\"0\":{\"285\":1,\"286\":1},\"1\":{\"249\":3,\"252\":2,\"278\":3,\"281\":3,\"285\":2,\"454\":1}}],[\"synchronized等环绕代码\",{\"1\":{\"6\":1}}],[\"systemctl\",{\"1\":{\"756\":1}}],[\"systemclassloader\",{\"1\":{\"381\":3}}],[\"systemdefault\",{\"1\":{\"555\":1,\"562\":1,\"571\":1}}],[\"system\",{\"1\":{\"80\":1,\"233\":4,\"234\":1,\"241\":1,\"317\":7,\"318\":6,\"319\":2,\"332\":3,\"381\":6,\"392\":1,\"510\":2,\"518\":1,\"548\":1,\"559\":2,\"562\":5,\"568\":1,\"569\":3,\"571\":2,\"573\":8,\"605\":6,\"697\":1,\"698\":3,\"701\":5,\"708\":6,\"711\":3,\"712\":3,\"714\":3,\"717\":3,\"722\":4,\"723\":3,\"734\":3,\"738\":1,\"742\":1,\"747\":5,\"748\":3,\"749\":5,\"779\":3,\"780\":1,\"815\":2,\"853\":1,\"854\":1,\"858\":5,\"993\":1,\"996\":4,\"1024\":8}}],[\"successful\",{\"1\":{\"1011\":1}}],[\"subscribe\",{\"1\":{\"693\":1}}],[\"sunday\",{\"1\":{\"569\":1}}],[\"sun的解释器是用c实现的\",{\"1\":{\"435\":1}}],[\"sun\",{\"0\":{\"349\":1},\"1\":{\"332\":2,\"351\":1,\"367\":1,\"381\":3,\"382\":2,\"383\":1,\"384\":1,\"435\":1}}],[\"survor\",{\"1\":{\"465\":2}}],[\"survivor满不会引发gc\",{\"1\":{\"494\":1}}],[\"survivorratio=8\",{\"1\":{\"488\":2}}],[\"survivorratio\",{\"1\":{\"488\":1,\"503\":1}}],[\"survivor1的gc是被动的\",{\"1\":{\"494\":1}}],[\"survivor1\",{\"1\":{\"488\":1,\"490\":2}}],[\"survivor0\",{\"1\":{\"488\":1,\"490\":3,\"494\":1}}],[\"survivor比例\",{\"1\":{\"465\":1}}],[\"survivor\",{\"1\":{\"304\":1,\"465\":1,\"496\":2,\"525\":1}}],[\"surefire\",{\"1\":{\"75\":1}}],[\"super\",{\"1\":{\"230\":1}}],[\"supported\",{\"1\":{\"635\":2}}],[\"supports\",{\"1\":{\"635\":2}}],[\"support\",{\"1\":{\"35\":1}}],[\"sum++\",{\"1\":{\"188\":1}}],[\"sum\",{\"1\":{\"188\":2,\"194\":2}}],[\"sum的值就是要求的结果\",{\"1\":{\"184\":1}}],[\"scanner\",{\"1\":{\"701\":6,\"708\":3,\"711\":3,\"712\":2,\"734\":3}}],[\"scalar\",{\"1\":{\"510\":1}}],[\"scavenge不兼容\",{\"1\":{\"534\":1}}],[\"scavenge\",{\"0\":{\"532\":1},\"1\":{\"339\":2,\"495\":1,\"532\":3,\"533\":1,\"534\":1,\"537\":2,\"539\":1,\"540\":1}}],[\"scripts<\",{\"1\":{\"99\":1}}],[\"scripts\",{\"1\":{\"99\":2}}],[\"scope\",{\"1\":{\"80\":1,\"619\":1,\"754\":3}}],[\"scope>\",{\"1\":{\"70\":1,\"83\":1,\"753\":1}}],[\"sc\",{\"1\":{\"38\":1,\"708\":3,\"711\":3,\"712\":3,\"734\":3}}],[\"seenset\",{\"1\":{\"982\":3}}],[\"sequence\",{\"1\":{\"827\":1}}],[\"selectpagevo\",{\"1\":{\"859\":1}}],[\"selectpage\",{\"1\":{\"832\":1,\"858\":2}}],[\"selectobjs\",{\"1\":{\"832\":1}}],[\"selectone\",{\"1\":{\"832\":1}}],[\"selectmapspage\",{\"1\":{\"832\":1}}],[\"selectmaps\",{\"1\":{\"832\":1,\"849\":2}}],[\"selectcount\",{\"1\":{\"832\":2}}],[\"selectbymap\",{\"1\":{\"832\":1}}],[\"selectbyid\",{\"1\":{\"832\":1}}],[\"selectbatchids\",{\"1\":{\"832\":1}}],[\"selectlist\",{\"1\":{\"819\":1,\"832\":2,\"844\":1,\"845\":1,\"850\":1,\"852\":1,\"853\":1}}],[\"selectlike\",{\"1\":{\"814\":4}}],[\"selectuser\",{\"1\":{\"819\":3}}],[\"select>\",{\"1\":{\"814\":2,\"819\":2}}],[\"select\",{\"1\":{\"813\":1,\"814\":2,\"817\":3,\"819\":2,\"840\":1,\"849\":2,\"850\":3,\"852\":1,\"860\":1}}],[\"select|insert|update|delete\",{\"0\":{\"811\":1}}],[\"sell\",{\"1\":{\"194\":9}}],[\"sendmessage\",{\"1\":{\"762\":3,\"765\":1,\"768\":1}}],[\"sendmsg\",{\"1\":{\"754\":3,\"755\":3,\"757\":1,\"780\":1}}],[\"sendmsgcontroller\",{\"1\":{\"754\":1,\"755\":1,\"757\":1,\"780\":1}}],[\"senddelaymsg\",{\"1\":{\"757\":3}}],[\"sendexpirationmsg\",{\"1\":{\"755\":3,\"780\":1}}],[\"sessioncreationpolicy\",{\"1\":{\"788\":4}}],[\"sessionmanagement\",{\"1\":{\"788\":2}}],[\"session定义一个bean\",{\"1\":{\"615\":2}}],[\"session\",{\"1\":{\"612\":1,\"615\":2,\"813\":4}}],[\"session对象\",{\"1\":{\"525\":1}}],[\"security来实现安全控制的\",{\"1\":{\"875\":1}}],[\"security和xml\",{\"1\":{\"875\":1}}],[\"securityconfiguration\",{\"1\":{\"788\":1}}],[\"security\",{\"1\":{\"788\":1,\"792\":2}}],[\"securityexception\",{\"1\":{\"393\":1}}],[\"secondhalfstart\",{\"1\":{\"975\":3}}],[\"second\",{\"1\":{\"701\":2,\"709\":4,\"975\":1}}],[\"second60\",{\"1\":{\"293\":1}}],[\"seconds\",{\"1\":{\"129\":1}}],[\"semaphore实现的功能就类似厕所有5个坑\",{\"1\":{\"292\":1}}],[\"semaphore\",{\"0\":{\"297\":1},\"1\":{\"292\":1}}],[\"serialize\",{\"1\":{\"883\":1}}],[\"serializable>\",{\"1\":{\"832\":1}}],[\"serializable\",{\"1\":{\"251\":1,\"634\":1,\"832\":2,\"888\":1}}],[\"serial\",{\"0\":{\"530\":1,\"533\":1},\"1\":{\"525\":2,\"530\":1,\"531\":3,\"533\":1,\"534\":1,\"539\":4,\"540\":1}}],[\"ser1\",{\"1\":{\"471\":1}}],[\"service注解\",{\"1\":{\"920\":1}}],[\"services\",{\"1\":{\"892\":1,\"1006\":1}}],[\"serviceconfig中有个字段\",{\"1\":{\"904\":1}}],[\"serviceconfig\",{\"1\":{\"883\":1}}],[\"service技术之后的自然延伸\",{\"1\":{\"875\":1}}],[\"service层\",{\"1\":{\"643\":1}}],[\"serviceimpl<usermapper\",{\"1\":{\"833\":1}}],[\"serviceimpl\",{\"1\":{\"833\":1}}],[\"serviceimpl3\",{\"1\":{\"617\":1}}],[\"serviceimpl2\",{\"1\":{\"617\":1}}],[\"serviceimpl1\",{\"1\":{\"617\":1}}],[\"service\",{\"1\":{\"595\":3,\"605\":2,\"618\":2,\"638\":1,\"827\":2,\"833\":2,\"882\":1,\"883\":1,\"892\":1}}],[\"servertimezone=gmt\",{\"1\":{\"831\":1}}],[\"server\",{\"1\":{\"372\":2,\"628\":1,\"668\":3,\"693\":2,\"753\":1,\"756\":4,\"762\":1,\"765\":1,\"874\":6,\"889\":1}}],[\"servlet暴露服务\",{\"1\":{\"888\":1}}],[\"servlet的web项目\",{\"1\":{\"675\":1}}],[\"servlet包裹interceptor\",{\"1\":{\"648\":1}}],[\"servlet中的过滤器filter是实现了javax\",{\"1\":{\"648\":1}}],[\"servlet原理\",{\"0\":{\"647\":1}}],[\"servlet\",{\"1\":{\"65\":3,\"78\":4,\"80\":1,\"615\":2,\"648\":1,\"675\":1}}],[\"servlet<\",{\"1\":{\"65\":1}}],[\"segment<k\",{\"1\":{\"251\":1}}],[\"segment\",{\"1\":{\"249\":4,\"251\":8,\"252\":1}}],[\"searchservice\",{\"1\":{\"41\":1}}],[\"search\",{\"1\":{\"21\":2}}],[\"setemail\",{\"1\":{\"847\":1,\"848\":1}}],[\"setexpiration\",{\"1\":{\"752\":1,\"755\":1}}],[\"setage\",{\"1\":{\"847\":1,\"848\":1}}],[\"setb\",{\"1\":{\"821\":1}}],[\"setbeanfactory\",{\"1\":{\"614\":1}}],[\"setbeanclassloader\",{\"1\":{\"614\":1}}],[\"setbeanname\",{\"1\":{\"614\":1}}],[\"setname\",{\"1\":{\"815\":1}}],[\"setnx\",{\"1\":{\"774\":1}}],[\"setint\",{\"1\":{\"810\":1}}],[\"setreturncallback\",{\"1\":{\"765\":1}}],[\"setmandatory\",{\"1\":{\"764\":1,\"765\":1}}],[\"setconfirmcallback\",{\"1\":{\"762\":1,\"765\":1}}],[\"setcharacterencoding\",{\"1\":{\"649\":2}}],[\"setdelay\",{\"1\":{\"757\":1}}],[\"setvirtualhost\",{\"1\":{\"754\":1}}],[\"setusername\",{\"1\":{\"697\":1,\"698\":1,\"701\":1,\"754\":1}}],[\"setup\",{\"1\":{\"14\":1,\"15\":1,\"19\":1,\"49\":1}}],[\"setpassword\",{\"1\":{\"697\":1,\"698\":1,\"701\":1,\"754\":1}}],[\"setport\",{\"1\":{\"697\":1}}],[\"setpriority0\",{\"1\":{\"435\":1}}],[\"setpriority\",{\"1\":{\"435\":2,\"780\":1}}],[\"sethost\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"setter注入适用于具有可选性和可变性的依赖注入\",{\"1\":{\"600\":1}}],[\"setter方法依赖注入\",{\"1\":{\"597\":1}}],[\"settings配置修改\",{\"0\":{\"61\":1}}],[\"settings打开设置\",{\"1\":{\"16\":1}}],[\"settings\",{\"1\":{\"14\":1,\"15\":2,\"18\":1,\"19\":1,\"61\":1}}],[\"set操作的时候会清除map里所有key为null的value\",{\"1\":{\"280\":1}}],[\"set方法\",{\"1\":{\"280\":1}}],[\"set<map\",{\"1\":{\"982\":1}}],[\"set<string>\",{\"1\":{\"788\":6}}],[\"set<string>>\",{\"1\":{\"788\":3}}],[\"set<t>\",{\"1\":{\"259\":1}}],[\"set<integer>\",{\"1\":{\"186\":1,\"983\":1}}],[\"set存储的元素是无序的\",{\"1\":{\"215\":1}}],[\"set中的元素数\",{\"1\":{\"186\":1}}],[\"set\",{\"0\":{\"215\":1,\"220\":1},\"1\":{\"22\":1,\"186\":3,\"214\":1,\"216\":1,\"240\":2,\"242\":1,\"259\":2,\"614\":1,\"840\":1,\"847\":1,\"848\":1,\"851\":3,\"854\":2,\"860\":1,\"983\":7}}],[\"shenandoah\",{\"0\":{\"538\":1}}],[\"shuffle\",{\"1\":{\"257\":1}}],[\"shuang\",{\"1\":{\"241\":1}}],[\"sharing\",{\"1\":{\"673\":1}}],[\"shanghaitime\",{\"1\":{\"562\":4}}],[\"shanghai\",{\"1\":{\"562\":2}}],[\"shapedivider\",{\"1\":{\"148\":1}}],[\"shadow\",{\"1\":{\"134\":1}}],[\"shields\",{\"1\":{\"127\":1}}],[\"shift+ctrl+alt+\",{\"1\":{\"670\":1}}],[\"shift+f12\",{\"1\":{\"48\":1}}],[\"shift+f3\",{\"1\":{\"45\":1}}],[\"shift\",{\"1\":{\"6\":5,\"8\":1,\"27\":1}}],[\"short\",{\"1\":{\"424\":1,\"573\":1}}],[\"shortcut\",{\"1\":{\"35\":2}}],[\"show\",{\"1\":{\"12\":1}}],[\"s\",{\"1\":{\"6\":1,\"41\":2,\"188\":3,\"234\":2,\"235\":1,\"259\":1,\"435\":1,\"549\":2,\"562\":3,\"577\":1,\"708\":2,\"714\":2,\"717\":2,\"820\":2,\"879\":1,\"948\":3,\"949\":3,\"954\":7,\"957\":8,\"998\":1,\"1018\":7,\"1019\":1,\"1020\":11}}],[\"p就是\",{\"1\":{\"970\":1}}],[\"php语言client可以构造一个对象\",{\"1\":{\"879\":1}}],[\"phantomreference\",{\"0\":{\"328\":1}}],[\"phase>\",{\"1\":{\"99\":1}}],[\"pink\",{\"1\":{\"741\":1,\"742\":1}}],[\"pid等强制关闭指令\",{\"1\":{\"913\":1}}],[\"pid\",{\"1\":{\"449\":2,\"913\":1}}],[\"pick\",{\"1\":{\"584\":4}}],[\"picsum\",{\"1\":{\"139\":1}}],[\"picgo\",{\"1\":{\"39\":1}}],[\"python和php和ruby\",{\"1\":{\"879\":1}}],[\"python\",{\"1\":{\"363\":1}}],[\"pc寄存器为什么被设定为线程私有\",{\"0\":{\"402\":1}}],[\"pc寄存器用来存储指向下一条指令的地址\",{\"1\":{\"399\":1}}],[\"pc寄存器就会更新下一条需要被执行的指令地址\",{\"1\":{\"356\":1}}],[\"pc\",{\"0\":{\"399\":1},\"1\":{\"424\":2}}],[\"pc端\",{\"1\":{\"157\":1}}],[\"p\",{\"1\":{\"249\":2,\"279\":1,\"614\":1,\"677\":1,\"695\":1,\"832\":4,\"969\":2,\"1038\":2}}],[\"publish\",{\"1\":{\"693\":1}}],[\"publisher\",{\"1\":{\"693\":1,\"762\":1,\"765\":2}}],[\"public\",{\"1\":{\"184\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"194\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":3,\"203\":2,\"204\":1,\"205\":1,\"207\":1,\"230\":2,\"239\":2,\"241\":5,\"242\":1,\"317\":1,\"332\":2,\"392\":3,\"452\":1,\"454\":1,\"468\":1,\"510\":3,\"559\":1,\"562\":2,\"568\":1,\"569\":1,\"571\":1,\"573\":2,\"605\":7,\"617\":3,\"651\":1,\"673\":5,\"676\":2,\"687\":5,\"697\":3,\"698\":3,\"701\":8,\"708\":4,\"711\":2,\"712\":2,\"714\":2,\"717\":2,\"722\":3,\"723\":3,\"734\":2,\"738\":2,\"742\":2,\"747\":6,\"748\":4,\"749\":4,\"753\":2,\"754\":21,\"755\":8,\"757\":14,\"762\":15,\"765\":6,\"768\":17,\"779\":4,\"780\":8,\"788\":2,\"791\":1,\"792\":1,\"819\":2,\"832\":1,\"833\":2,\"853\":1,\"854\":1,\"857\":2,\"858\":1,\"860\":3,\"864\":2,\"925\":2,\"931\":1,\"934\":2,\"938\":1,\"939\":1,\"943\":1,\"944\":1,\"948\":1,\"949\":1,\"954\":1,\"957\":2,\"963\":2,\"965\":2,\"968\":2,\"969\":1,\"973\":2,\"975\":1,\"982\":1,\"983\":1,\"984\":1,\"990\":2,\"991\":1,\"992\":1,\"993\":1,\"996\":1,\"998\":1,\"1008\":1,\"1009\":1,\"1020\":1,\"1022\":1,\"1029\":3,\"1030\":1,\"1034\":2,\"1035\":1,\"1040\":1}}],[\"pull\",{\"1\":{\"587\":1}}],[\"push时会遇到这个问题\",{\"1\":{\"587\":1}}],[\"push前使用\",{\"1\":{\"585\":1}}],[\"push\",{\"1\":{\"416\":2,\"982\":1,\"1024\":3,\"1030\":1}}],[\"putstatic\",{\"1\":{\"397\":1}}],[\"putval\",{\"1\":{\"242\":1}}],[\"put\",{\"1\":{\"240\":1,\"241\":4,\"242\":1,\"249\":2,\"673\":1,\"697\":3,\"738\":4,\"742\":8,\"747\":2,\"748\":3,\"749\":3,\"752\":1,\"754\":6,\"755\":2,\"757\":1,\"777\":1,\"779\":1,\"780\":1,\"783\":1,\"788\":14,\"819\":2,\"944\":2}}],[\"p0\",{\"1\":{\"200\":4}}],[\"p3\",{\"1\":{\"199\":4}}],[\"p2\",{\"1\":{\"199\":4,\"200\":3,\"975\":5}}],[\"p1\",{\"1\":{\"199\":3,\"200\":5,\"975\":4}}],[\"perpetualcache\",{\"1\":{\"813\":2}}],[\"persistent\",{\"1\":{\"712\":2}}],[\"person为变量\",{\"1\":{\"439\":1}}],[\"person为类信息\",{\"1\":{\"439\":1}}],[\"personstringentry\",{\"1\":{\"241\":2}}],[\"person4\",{\"1\":{\"241\":2}}],[\"person3\",{\"1\":{\"241\":2}}],[\"person2\",{\"1\":{\"241\":6}}],[\"person1\",{\"1\":{\"241\":6}}],[\"person\",{\"1\":{\"241\":9,\"439\":4}}],[\"period\",{\"1\":{\"559\":2}}],[\"period类表示一段时间的年\",{\"1\":{\"559\":1}}],[\"period类\",{\"0\":{\"559\":1}}],[\"perl\",{\"1\":{\"363\":1}}],[\"permitall\",{\"1\":{\"788\":15}}],[\"perm\",{\"1\":{\"483\":1}}],[\"perm区的oom\",{\"1\":{\"462\":1}}],[\"permsize\",{\"1\":{\"447\":1,\"449\":1}}],[\"permsize=n\",{\"1\":{\"305\":1,\"338\":1}}],[\"permgenspace\",{\"1\":{\"442\":1,\"447\":1}}],[\"permgen\",{\"1\":{\"305\":1,\"338\":1,\"462\":1}}],[\"permanent\",{\"1\":{\"304\":1,\"461\":1,\"483\":1}}],[\"peek\",{\"1\":{\"194\":8,\"1024\":1}}],[\"peerigon\",{\"1\":{\"149\":1}}],[\"pexels\",{\"1\":{\"139\":1}}],[\"ppt\",{\"1\":{\"148\":3}}],[\"psmarksweep\",{\"1\":{\"540\":1}}],[\"ps\",{\"0\":{\"577\":1},\"1\":{\"140\":1,\"340\":1,\"577\":1,\"810\":1}}],[\"psd\",{\"1\":{\"140\":1}}],[\"png\",{\"1\":{\"132\":1,\"140\":1,\"244\":1,\"1038\":1}}],[\"png等\",{\"1\":{\"132\":1}}],[\"poll\",{\"1\":{\"983\":1,\"1024\":1,\"1035\":1}}],[\"policy\",{\"1\":{\"783\":2}}],[\"pojo\",{\"1\":{\"831\":1}}],[\"pojo映射成数据库中的记录\",{\"1\":{\"806\":1}}],[\"portocol\",{\"1\":{\"883\":1}}],[\"port=8888\",{\"1\":{\"668\":2}}],[\"port=\",{\"1\":{\"649\":1}}],[\"portlet\",{\"1\":{\"615\":3}}],[\"port\",{\"1\":{\"588\":1,\"668\":2,\"753\":2,\"754\":3,\"762\":2,\"765\":2}}],[\"pointcut=\",{\"1\":{\"605\":1}}],[\"pointcut\",{\"1\":{\"602\":2,\"604\":1,\"605\":1}}],[\"pointer\",{\"1\":{\"515\":1}}],[\"point\",{\"1\":{\"510\":7,\"604\":1,\"693\":2}}],[\"pop\",{\"1\":{\"416\":2,\"982\":1,\"1024\":3,\"1030\":1}}],[\"pool\",{\"1\":{\"275\":1,\"459\":2}}],[\"poseordertraversalnor\",{\"1\":{\"1024\":1}}],[\"poseordertraversal\",{\"1\":{\"1024\":3}}],[\"pos表示当前遍历的下标\",{\"1\":{\"957\":1}}],[\"pos++\",{\"1\":{\"957\":4}}],[\"pos\",{\"1\":{\"957\":6}}],[\"position\",{\"1\":{\"244\":1}}],[\"postgre\",{\"1\":{\"827\":1}}],[\"post等\",{\"1\":{\"789\":1}}],[\"postconstruct\",{\"1\":{\"762\":2,\"765\":1}}],[\"postmapping\",{\"1\":{\"673\":1}}],[\"posthandle\",{\"1\":{\"656\":1}}],[\"post方式\",{\"1\":{\"649\":1}}],[\"post请求中文乱码问题\",{\"0\":{\"649\":1}}],[\"post\",{\"1\":{\"94\":2,\"595\":1,\"673\":1,\"788\":8}}],[\"power\",{\"1\":{\"239\":1}}],[\"pom项目\",{\"1\":{\"89\":1}}],[\"pom代表当前工程是用来管理其他工程的\",{\"1\":{\"70\":1}}],[\"pom\",{\"0\":{\"66\":1,\"70\":1},\"1\":{\"67\":2,\"68\":1,\"69\":3,\"72\":3,\"77\":5,\"82\":1,\"85\":4,\"87\":1,\"686\":1,\"696\":1}}],[\"plgins\",{\"1\":{\"756\":3}}],[\"plectica\",{\"1\":{\"133\":1}}],[\"plus实现乐观锁\",{\"1\":{\"860\":1}}],[\"plus自带分页插件\",{\"1\":{\"856\":1}}],[\"plus中如何判断参数是否为空呢\",{\"1\":{\"852\":1}}],[\"plus中有一个接口\",{\"1\":{\"833\":1}}],[\"plus会自动将下划线命名风格转化为驼峰命名风格\",{\"1\":{\"837\":1}}],[\"plus在执行sql语句时\",{\"1\":{\"837\":1}}],[\"plus的主键策略\",{\"1\":{\"836\":1}}],[\"plus操作表的默认前缀\",{\"1\":{\"835\":1,\"836\":1}}],[\"plus启动器\",{\"1\":{\"830\":1}}],[\"plus\",{\"0\":{\"825\":1},\"1\":{\"70\":1,\"559\":1,\"568\":1,\"826\":1,\"830\":1,\"831\":2,\"833\":1,\"835\":1,\"836\":1,\"863\":1,\"864\":3,\"866\":2}}],[\"plugin输出微服务jar文件进行二次spring\",{\"1\":{\"106\":1}}],[\"plugin中指定了依赖的第三方jar要放到lib目录\",{\"1\":{\"106\":1}}],[\"plugin插件实现把依赖jar定义写入输出jar的meta\",{\"1\":{\"106\":1}}],[\"plugin插件中排除了第三方jar\",{\"1\":{\"106\":1}}],[\"plugin插件中的示例\",{\"1\":{\"103\":1}}],[\"plugin插件配置classifier属性\",{\"1\":{\"104\":1}}],[\"plugin插件打出的可执行jar不建议作为jar给其他服务引用\",{\"1\":{\"104\":1}}],[\"plugins\",{\"1\":{\"756\":4}}],[\"plugins<\",{\"1\":{\"101\":1,\"106\":1,\"696\":1}}],[\"plugins>\",{\"1\":{\"99\":1,\"671\":1,\"696\":1}}],[\"plugin>\",{\"1\":{\"99\":1,\"101\":1,\"106\":2,\"671\":1,\"696\":1}}],[\"plugin<\",{\"1\":{\"99\":1,\"101\":1,\"106\":2,\"671\":1,\"696\":1}}],[\"plugin\",{\"0\":{\"101\":1,\"102\":1,\"103\":1,\"104\":1},\"1\":{\"55\":1,\"97\":1,\"98\":1,\"99\":1,\"106\":1}}],[\"plain\",{\"1\":{\"42\":1,\"712\":2}}],[\"plantuml\",{\"1\":{\"22\":1}}],[\"palindrome\",{\"1\":{\"975\":1}}],[\"paginationinnerinterceptor\",{\"1\":{\"857\":1,\"860\":1}}],[\"pagination\",{\"1\":{\"819\":1}}],[\"page对象也必须是方法的第一个参数\",{\"1\":{\"859\":1}}],[\"page<>\",{\"1\":{\"858\":1}}],[\"page<user>\",{\"1\":{\"858\":1,\"859\":2}}],[\"page\",{\"1\":{\"832\":2,\"833\":1,\"858\":11,\"859\":3}}],[\"pagehelper的分页原理\",{\"1\":{\"817\":1}}],[\"pagenum\",{\"1\":{\"651\":1}}],[\"pages\",{\"1\":{\"1\":1}}],[\"passwordencoder\",{\"1\":{\"788\":4}}],[\"password\",{\"1\":{\"753\":1,\"754\":3,\"762\":1,\"765\":1,\"831\":1,\"866\":2}}],[\"paste\",{\"1\":{\"42\":2}}],[\"paused\",{\"1\":{\"577\":1}}],[\"pairs\",{\"1\":{\"549\":2}}],[\"padding\",{\"0\":{\"478\":1}}],[\"patch\",{\"1\":{\"788\":8}}],[\"pattern>\",{\"1\":{\"649\":2}}],[\"pattern\",{\"1\":{\"134\":1}}],[\"pathinfo\",{\"1\":{\"864\":1}}],[\"paths\",{\"1\":{\"670\":1}}],[\"path=\",{\"1\":{\"656\":1}}],[\"pathvariable可以绑定占位符参数到方法参数中\",{\"1\":{\"651\":1}}],[\"pathvariable\",{\"1\":{\"651\":3,\"754\":2,\"755\":3,\"757\":2,\"762\":2,\"780\":1}}],[\"path属性的前缀\",{\"1\":{\"103\":1}}],[\"path属性\",{\"1\":{\"103\":1}}],[\"path\",{\"1\":{\"15\":1,\"72\":1,\"103\":1,\"139\":1,\"382\":1,\"384\":1,\"792\":2}}],[\"panjiachen\",{\"1\":{\"118\":1}}],[\"part1\",{\"0\":{\"988\":1}}],[\"partition\",{\"1\":{\"797\":1}}],[\"partial\",{\"1\":{\"493\":1}}],[\"parse\",{\"1\":{\"573\":3}}],[\"paroldgen字样\",{\"1\":{\"537\":1}}],[\"parallel\",{\"0\":{\"532\":1},\"1\":{\"532\":4,\"533\":1,\"534\":1,\"539\":2,\"540\":1}}],[\"parallel收集器的默认值是15\",{\"1\":{\"503\":1}}],[\"params\",{\"1\":{\"697\":5,\"747\":4,\"748\":5,\"749\":5,\"752\":2,\"754\":10,\"777\":3,\"779\":3,\"780\":1,\"792\":2}}],[\"param>\",{\"1\":{\"649\":2}}],[\"param\",{\"1\":{\"194\":1,\"649\":2,\"687\":2,\"762\":3,\"765\":8,\"810\":1,\"819\":3,\"832\":15,\"859\":4,\"943\":4}}],[\"parametermapping\",{\"1\":{\"822\":1}}],[\"parametermap\",{\"1\":{\"822\":1}}],[\"parameterhandler\",{\"1\":{\"818\":1}}],[\"parametervalue\",{\"1\":{\"810\":1}}],[\"parameter\",{\"1\":{\"16\":1}}],[\"parnew\",{\"0\":{\"531\":1},\"1\":{\"471\":1,\"531\":1,\"532\":1,\"536\":1,\"539\":1}}],[\"parent\",{\"0\":{\"685\":1},\"1\":{\"89\":1,\"685\":4,\"864\":1}}],[\"parent>\",{\"1\":{\"88\":1,\"753\":1}}],[\"parent<\",{\"1\":{\"88\":1,\"753\":1}}],[\"packageconfig\",{\"1\":{\"864\":1}}],[\"packagepackage\",{\"1\":{\"94\":1}}],[\"package\",{\"1\":{\"76\":1,\"392\":1,\"697\":1,\"698\":1,\"701\":3,\"708\":2,\"711\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"753\":1,\"754\":4,\"755\":1,\"757\":1,\"762\":4,\"768\":1,\"779\":2,\"831\":1,\"832\":1}}],[\"packaging>\",{\"1\":{\"70\":1,\"78\":1,\"85\":1}}],[\"prc架构组件\",{\"0\":{\"874\":1}}],[\"primary\",{\"1\":{\"866\":1}}],[\"price=price+50\",{\"1\":{\"860\":1}}],[\"price\",{\"1\":{\"860\":2}}],[\"prices\",{\"1\":{\"202\":22}}],[\"priorityconsumer\",{\"1\":{\"779\":1}}],[\"priorityproducer\",{\"1\":{\"779\":1}}],[\"priority\",{\"1\":{\"697\":2,\"777\":3,\"779\":5,\"780\":6}}],[\"priorityqueue\",{\"1\":{\"221\":1}}],[\"priorityqueue<>\",{\"1\":{\"194\":2}}],[\"print\",{\"1\":{\"1024\":7}}],[\"printstacktrace\",{\"1\":{\"708\":1,\"714\":1,\"717\":1}}],[\"printf\",{\"1\":{\"562\":3}}],[\"printgc\",{\"1\":{\"503\":1}}],[\"println\",{\"1\":{\"6\":1,\"10\":1,\"233\":4,\"234\":1,\"241\":1,\"317\":7,\"318\":6,\"319\":2,\"332\":3,\"381\":5,\"392\":1,\"510\":2,\"548\":1,\"559\":2,\"562\":2,\"568\":1,\"569\":3,\"571\":2,\"573\":8,\"605\":6,\"697\":1,\"698\":3,\"701\":4,\"708\":5,\"711\":2,\"712\":2,\"714\":3,\"717\":3,\"722\":2,\"723\":1,\"734\":2,\"738\":1,\"742\":1,\"747\":5,\"748\":3,\"749\":5,\"779\":3,\"780\":1,\"815\":2,\"853\":1,\"854\":1,\"858\":5,\"993\":1,\"996\":4,\"1024\":1}}],[\"private的方法\",{\"1\":{\"603\":1}}],[\"private\",{\"1\":{\"194\":2,\"241\":1,\"453\":1,\"454\":1,\"510\":4,\"599\":1,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":4,\"748\":3,\"749\":3,\"754\":5,\"755\":1,\"757\":1,\"762\":2,\"779\":2,\"788\":1,\"836\":1,\"840\":1,\"860\":4,\"904\":1,\"934\":1,\"943\":1,\"975\":2,\"990\":2,\"991\":1,\"1022\":1,\"1034\":1}}],[\"practice\",{\"1\":{\"146\":1}}],[\"pre=cur\",{\"1\":{\"1024\":1}}],[\"preordertraversalnor\",{\"1\":{\"1024\":1}}],[\"preordertraversal\",{\"1\":{\"1024\":3}}],[\"preconditions\",{\"0\":{\"997\":1},\"1\":{\"988\":1,\"998\":4}}],[\"pre和slow分别指向2和4\",{\"1\":{\"974\":1}}],[\"pre指向左边\",{\"1\":{\"973\":1}}],[\"pre指向它的上一个节点\",{\"1\":{\"970\":1}}],[\"pre在slow左侧\",{\"1\":{\"973\":1}}],[\"prepre也跟着右移\",{\"1\":{\"973\":1}}],[\"prepre\",{\"1\":{\"973\":3}}],[\"preparedstatement\",{\"1\":{\"810\":1}}],[\"prepare\",{\"1\":{\"94\":1}}],[\"pre会指到最后一个节点处\",{\"1\":{\"970\":1}}],[\"pre节点\",{\"1\":{\"970\":1}}],[\"pre移到cur处\",{\"1\":{\"970\":1}}],[\"prefix\",{\"1\":{\"835\":1,\"836\":1}}],[\"prefetchcount\",{\"1\":{\"714\":2,\"717\":4}}],[\"prehandle\",{\"1\":{\"656\":1}}],[\"prestartallcorethreads\",{\"1\":{\"275\":1}}],[\"prestartcorethread\",{\"1\":{\"275\":1}}],[\"present\",{\"1\":{\"242\":1}}],[\"previous\",{\"1\":{\"242\":1}}],[\"prev\",{\"1\":{\"229\":2,\"975\":4}}],[\"pre\",{\"1\":{\"94\":3,\"201\":4,\"957\":3,\"968\":4,\"970\":1,\"973\":8,\"1024\":1}}],[\"provider接受到notify消息后\",{\"1\":{\"906\":1}}],[\"provider在export服务时\",{\"1\":{\"904\":1}}],[\"provider端在接收到请求时也是先走filter链\",{\"1\":{\"902\":1}}],[\"provider\",{\"1\":{\"882\":3,\"892\":1,\"905\":1}}],[\"provided\",{\"1\":{\"78\":2,\"80\":6,\"81\":1}}],[\"pro\",{\"1\":{\"879\":1}}],[\"produces\",{\"1\":{\"792\":2}}],[\"producercontroller\",{\"1\":{\"762\":1,\"765\":2}}],[\"producer\",{\"1\":{\"697\":1,\"744\":1,\"747\":2,\"748\":1}}],[\"product\",{\"1\":{\"110\":1,\"147\":1,\"860\":3}}],[\"profile\",{\"1\":{\"685\":1}}],[\"profile>\",{\"1\":{\"61\":1}}],[\"propagation=propagation\",{\"1\":{\"635\":1}}],[\"propagation\",{\"1\":{\"635\":7}}],[\"property=\",{\"1\":{\"820\":7}}],[\"propertysource\",{\"1\":{\"681\":1}}],[\"property\",{\"1\":{\"619\":1}}],[\"properties内的一致\",{\"1\":{\"1005\":1}}],[\"properties\",{\"1\":{\"99\":1,\"619\":1,\"668\":1,\"685\":2,\"697\":2,\"747\":2,\"748\":1,\"779\":2,\"810\":1,\"1006\":1}}],[\"properties>\",{\"1\":{\"61\":1,\"70\":1,\"87\":1,\"101\":1}}],[\"protobuf\",{\"1\":{\"879\":1}}],[\"protocol\",{\"1\":{\"873\":1,\"879\":2,\"889\":1,\"904\":3}}],[\"prototype\",{\"1\":{\"612\":1,\"615\":1,\"638\":1,\"754\":1}}],[\"protected\",{\"1\":{\"453\":1,\"454\":1,\"788\":2}}],[\"procedure\",{\"1\":{\"873\":1}}],[\"proceed\",{\"1\":{\"605\":1}}],[\"proceedingjoinpoint\",{\"1\":{\"605\":2}}],[\"processon在线作图\",{\"1\":{\"133\":1}}],[\"process\",{\"1\":{\"94\":2,\"340\":1,\"577\":1}}],[\"proxied\",{\"1\":{\"604\":1}}],[\"proxyfactory\",{\"1\":{\"889\":1}}],[\"proxy和invocationhandler\",{\"1\":{\"603\":1}}],[\"proxy\",{\"1\":{\"596\":2,\"816\":2,\"883\":1}}],[\"programming\",{\"1\":{\"596\":1}}],[\"program\",{\"1\":{\"515\":1}}],[\"pro01\",{\"1\":{\"77\":2}}],[\"projectlombok<\",{\"1\":{\"753\":1}}],[\"project\",{\"1\":{\"21\":1,\"67\":1,\"85\":1,\"99\":7,\"101\":2,\"106\":1,\"670\":1,\"1011\":1}}],[\"projects\",{\"1\":{\"7\":1,\"14\":2,\"15\":2,\"19\":2,\"91\":1,\"1004\":1}}],[\"​\",{\"1\":{\"6\":4}}],[\"关注入参范围\",{\"1\":{\"957\":1}}],[\"关键的就是\",{\"1\":{\"891\":1}}],[\"关键的点都提到了\",{\"1\":{\"890\":1}}],[\"关键字修改之后的\",{\"1\":{\"317\":1}}],[\"关键字进行了很多优化\",{\"1\":{\"285\":1}}],[\"关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"281\":1}}],[\"关键字两者都能保证\",{\"1\":{\"281\":1}}],[\"关键字能保证数据的可见性\",{\"1\":{\"281\":1}}],[\"关键字可以修饰方法以及代码块\",{\"1\":{\"281\":1}}],[\"关键字只能用于变量而\",{\"1\":{\"281\":1}}],[\"关键字是线程同步的轻量级实现\",{\"1\":{\"281\":1}}],[\"关键字后\",{\"1\":{\"6\":1}}],[\"关系\",{\"1\":{\"738\":1}}],[\"关联集合对象的延迟加载\",{\"1\":{\"821\":1}}],[\"关联对象和\",{\"1\":{\"821\":1}}],[\"关联表多时\",{\"1\":{\"807\":1}}],[\"关联\",{\"1\":{\"380\":1}}],[\"关闭流的操作称为终端操作\",{\"1\":{\"546\":1}}],[\"关闭\",{\"1\":{\"44\":1,\"442\":1,\"705\":1}}],[\"关闭拼写检查\",{\"1\":{\"41\":1}}],[\"关闭当前标签页\",{\"1\":{\"6\":1}}],[\"关于备份的\",{\"1\":{\"768\":1}}],[\"关于逃逸分析的论文在1999年就己经发表了\",{\"1\":{\"511\":1}}],[\"关于垃圾回收\",{\"1\":{\"490\":1}}],[\"关于是否要对类型进行回收\",{\"1\":{\"464\":1}}],[\"关于那些需要被编译为本地代码的字节码\",{\"1\":{\"368\":1}}],[\"关于本站\",{\"0\":{\"1\":1}}],[\"关于\",{\"0\":{\"0\":1},\"1\":{\"797\":1}}],[\"=f\",{\"1\":{\"170\":1}}],[\"==但是这部分区域的回收有时又确实是必要的\",{\"1\":{\"464\":1}}],[\"==与\",{\"1\":{\"242\":1}}],[\"==null\",{\"1\":{\"242\":1}}],[\"==\",{\"1\":{\"6\":1,\"194\":3,\"199\":1,\"201\":1,\"203\":1,\"242\":2,\"244\":1,\"317\":7,\"319\":2,\"548\":1,\"549\":1,\"723\":1,\"779\":1,\"788\":1,\"925\":2,\"934\":5,\"935\":1,\"943\":3,\"944\":3,\"954\":2,\"963\":2,\"969\":2,\"975\":1,\"982\":3,\"984\":6,\"1020\":5,\"1022\":1,\"1024\":8,\"1029\":1,\"1034\":3,\"1035\":2}}],[\"=\",{\"0\":{\"319\":1},\"1\":{\"6\":1,\"183\":1,\"184\":8,\"186\":3,\"187\":7,\"188\":7,\"189\":4,\"190\":4,\"194\":8,\"198\":8,\"199\":9,\"200\":10,\"201\":7,\"202\":19,\"203\":12,\"204\":6,\"205\":6,\"207\":17,\"233\":4,\"234\":7,\"235\":1,\"239\":4,\"241\":5,\"244\":1,\"253\":3,\"317\":19,\"318\":5,\"319\":2,\"381\":3,\"431\":1,\"439\":1,\"510\":9,\"546\":1,\"548\":4,\"549\":8,\"559\":2,\"562\":3,\"568\":2,\"569\":3,\"571\":4,\"573\":6,\"599\":2,\"634\":1,\"651\":3,\"668\":1,\"674\":1,\"676\":2,\"697\":7,\"698\":7,\"701\":11,\"708\":11,\"711\":5,\"712\":4,\"714\":7,\"717\":8,\"722\":8,\"723\":10,\"728\":2,\"730\":1,\"734\":4,\"738\":5,\"742\":5,\"745\":1,\"747\":18,\"748\":13,\"749\":13,\"752\":1,\"754\":11,\"755\":3,\"757\":9,\"762\":12,\"765\":2,\"768\":9,\"777\":1,\"779\":11,\"780\":3,\"783\":1,\"788\":14,\"792\":9,\"814\":4,\"815\":4,\"816\":1,\"819\":4,\"832\":4,\"836\":2,\"844\":2,\"845\":2,\"846\":2,\"847\":2,\"848\":2,\"849\":2,\"850\":2,\"851\":2,\"852\":3,\"853\":7,\"854\":4,\"857\":1,\"858\":6,\"860\":1,\"904\":1,\"925\":6,\"926\":1,\"931\":5,\"934\":15,\"938\":3,\"939\":6,\"943\":14,\"944\":18,\"948\":5,\"949\":5,\"954\":7,\"957\":8,\"963\":10,\"964\":1,\"965\":7,\"968\":9,\"969\":3,\"970\":5,\"973\":19,\"975\":24,\"981\":6,\"982\":4,\"983\":3,\"984\":1,\"990\":6,\"991\":4,\"992\":2,\"993\":3,\"996\":4,\"998\":2,\"1020\":1,\"1022\":3,\"1023\":2,\"1024\":26,\"1029\":4,\"1030\":8,\"1034\":2,\"1035\":8,\"1038\":1,\"1040\":5}}],[\"dhebfgca\",{\"1\":{\"1024\":1}}],[\"d文件夹中\",{\"1\":{\"1008\":1}}],[\"d++\",{\"1\":{\"934\":1,\"943\":1,\"944\":1}}],[\"dfs暴力匹配\",{\"1\":{\"1019\":1}}],[\"dfs中进行递归前的条件\",{\"1\":{\"935\":1}}],[\"dfs\",{\"0\":{\"943\":1,\"1034\":1},\"1\":{\"934\":3,\"943\":3,\"1019\":2,\"1022\":4,\"1034\":4}}],[\"dfs算法\",{\"1\":{\"177\":1}}],[\"dy数组\",{\"1\":{\"935\":1}}],[\"dy\",{\"1\":{\"934\":2,\"943\":2,\"944\":2}}],[\"dynamic\",{\"1\":{\"414\":1,\"417\":1,\"435\":1,\"866\":1}}],[\"dx\",{\"1\":{\"934\":2,\"943\":2,\"944\":2}}],[\"dbehafcg\",{\"1\":{\"1024\":1}}],[\"dbtype\",{\"1\":{\"857\":1,\"860\":1}}],[\"db\",{\"1\":{\"835\":1,\"836\":1}}],[\"db2\",{\"1\":{\"827\":1}}],[\"dbcp\",{\"1\":{\"628\":1}}],[\"dc12081b3598\",{\"1\":{\"677\":1}}],[\"dsname可以为组名也可以为具体某个库的名称\",{\"1\":{\"866\":1}}],[\"dsname\",{\"1\":{\"866\":2}}],[\"ds\",{\"1\":{\"866\":3}}],[\"dserver\",{\"1\":{\"668\":1}}],[\"dst\",{\"1\":{\"204\":5,\"205\":5}}],[\"ddd\",{\"1\":{\"996\":1}}],[\"dd\",{\"1\":{\"573\":2,\"709\":2}}],[\"dummy\",{\"1\":{\"963\":5}}],[\"dump\",{\"1\":{\"340\":1}}],[\"dubbo源代码分析\",{\"1\":{\"921\":1}}],[\"dubbo笔记\",{\"1\":{\"921\":1}}],[\"dubbo使用过程中都遇到了些什么问题\",{\"0\":{\"920\":1}}],[\"dubbo超时设置有两种方式\",{\"1\":{\"918\":1}}],[\"dubbo超时设置有哪些方式\",{\"0\":{\"918\":1}}],[\"dubbo集群提供了哪些负载均衡策略\",{\"0\":{\"916\":1}}],[\"dubbox是继dubbo停止维护后\",{\"1\":{\"914\":1}}],[\"dubbo和dubbox之间的区别\",{\"0\":{\"914\":1}}],[\"dubbo和spring\",{\"0\":{\"886\":1,\"887\":1}}],[\"dubbo如何优雅停机\",{\"0\":{\"913\":1}}],[\"dubbo2\",{\"1\":{\"912\":1}}],[\"dubbo服务发布之后\",{\"1\":{\"912\":1}}],[\"dubbo服务降级怎么做\",{\"0\":{\"901\":1}}],[\"dubbo提供了声明式缓存\",{\"1\":{\"911\":1}}],[\"dubbo可以对结果进行缓存吗\",{\"0\":{\"911\":1}}],[\"dubbo分布式事务\",{\"1\":{\"910\":1}}],[\"dubbo分层架构\",{\"0\":{\"883\":1}}],[\"dubbo支持分布式事务吗\",{\"0\":{\"910\":1}}],[\"dubbo支持哪些协议\",{\"0\":{\"888\":1}}],[\"dubbo进行扩展\",{\"1\":{\"909\":1}}],[\"dubbo配置文件是如何加载到spring中的\",{\"0\":{\"908\":1}}],[\"dubbo需要灵活地控制实现类\",{\"1\":{\"907\":1}}],[\"dubbo扩展jdk\",{\"1\":{\"907\":1}}],[\"dubbo在启动和调用阶段都大量使用了装饰器模式\",{\"1\":{\"905\":1}}],[\"dubbo里有很多这种代码\",{\"1\":{\"904\":1}}],[\"dubbo框架在初始化和通信过程中使用了多种设计模式\",{\"1\":{\"903\":1}}],[\"dubbo用到哪些设计模式\",{\"0\":{\"903\":1}}],[\"dubbomonitortimer\",{\"1\":{\"902\":1}}],[\"dubbomonitorasyncwritelogthread\",{\"1\":{\"902\":1}}],[\"dubbomonitorsendtimer\",{\"1\":{\"902\":1}}],[\"dubbomonitor将数据进行聚合后\",{\"1\":{\"902\":1}}],[\"dubbo有哪些注册中心\",{\"0\":{\"897\":1}}],[\"dubbo推荐使用dubbo协议\",{\"1\":{\"888\":1}}],[\"dubbo底层是使用netty这样的nio框架\",{\"1\":{\"887\":1}}],[\"dubbo定位服务治理\",{\"1\":{\"886\":1}}],[\"dubbo是通过jdk的shutdownhook来完成优雅停机的\",{\"1\":{\"913\":1}}],[\"dubbo是基于nio的非阻塞实现并行调用\",{\"1\":{\"896\":1}}],[\"dubbo是soa时代的产物\",{\"1\":{\"886\":1}}],[\"dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架\",{\"1\":{\"879\":1}}],[\"dubbo核心功能有哪些\",{\"0\":{\"885\":1}}],[\"dubbo大的三层分别为\",{\"1\":{\"883\":1}}],[\"dubbo负责收集服务调用信息的监控中心\",{\"1\":{\"882\":1}}],[\"dubbo官网\",{\"1\":{\"882\":1}}],[\"dubbo架构\",{\"0\":{\"882\":1}}],[\"dubbo\",{\"0\":{\"880\":1,\"893\":1,\"894\":1,\"902\":1,\"909\":1,\"912\":1,\"922\":1,\"923\":1},\"1\":{\"879\":1,\"881\":1,\"883\":1,\"888\":2,\"889\":1,\"890\":1,\"891\":1,\"892\":3,\"893\":1,\"894\":1,\"909\":1}}],[\"dubbo基础\",{\"0\":{\"870\":1}}],[\"dubbo的集群容错方案有哪些\",{\"0\":{\"917\":1}}],[\"dubbo的注册中心集群挂掉\",{\"0\":{\"915\":1}}],[\"dubbo的注册中心可以选择zookeeper\",{\"1\":{\"798\":1}}],[\"dubbo的扩展机制能很好的支持第三方ioc容器\",{\"1\":{\"909\":1}}],[\"dubbo的provider启动时\",{\"1\":{\"906\":1}}],[\"dubbo的使用场景有哪些\",{\"0\":{\"884\":1}}],[\"dubbo的开发难度较大\",{\"1\":{\"798\":1}}],[\"dubbo由于是二进制的传输\",{\"1\":{\"798\":1}}],[\"dubbo跟springcloud的区别\",{\"0\":{\"798\":1}}],[\"durable\",{\"1\":{\"711\":3,\"752\":1,\"754\":2,\"755\":1,\"762\":1,\"768\":4,\"780\":1}}],[\"duration类表示秒或纳秒时间间隔\",{\"1\":{\"558\":1}}],[\"duration类\",{\"0\":{\"558\":1}}],[\"duration以及period\",{\"1\":{\"555\":1}}],[\"duplicate\",{\"1\":{\"6\":1}}],[\"dp数组的值都设置完了\",{\"1\":{\"925\":1}}],[\"dp\",{\"0\":{\"945\":1},\"1\":{\"200\":8,\"201\":2,\"202\":6,\"203\":16,\"204\":8,\"205\":8,\"207\":11,\"925\":8,\"926\":5}}],[\"druid\",{\"1\":{\"788\":2}}],[\"dreturn以及\",{\"1\":{\"424\":1}}],[\"driver\",{\"1\":{\"810\":2,\"831\":2,\"866\":4}}],[\"drivermanager\",{\"1\":{\"389\":1}}],[\"driven>来实现注解处理器和适配器的开启\",{\"1\":{\"652\":1}}],[\"dribbble\",{\"1\":{\"139\":2}}],[\"draggable\",{\"1\":{\"160\":1}}],[\"drawio\",{\"1\":{\"110\":2}}],[\"diameterofbinarytree\",{\"1\":{\"1022\":1}}],[\"dialect\",{\"1\":{\"817\":1}}],[\"diagrams\",{\"1\":{\"110\":2}}],[\"di\",{\"1\":{\"591\":1}}],[\"dirs\",{\"1\":{\"331\":1,\"383\":1}}],[\"directexchange\",{\"1\":{\"754\":7,\"755\":1,\"762\":3,\"768\":3,\"780\":3}}],[\"direct实战\",{\"0\":{\"738\":1}}],[\"direct介绍\",{\"0\":{\"736\":1}}],[\"direct\",{\"0\":{\"735\":1},\"1\":{\"693\":1,\"728\":2,\"736\":2,\"737\":1,\"738\":3,\"740\":2,\"741\":1,\"746\":1,\"747\":5,\"748\":4,\"749\":4,\"754\":1,\"757\":2,\"762\":1}}],[\"directbytebuffer\",{\"1\":{\"308\":1}}],[\"directory\",{\"1\":{\"99\":1,\"106\":1}}],[\"directory>\",{\"1\":{\"99\":4}}],[\"differ\",{\"1\":{\"244\":1}}],[\"did\",{\"1\":{\"242\":1}}],[\"disable\",{\"1\":{\"788\":2}}],[\"disableuploadtimeout=\",{\"1\":{\"649\":1}}],[\"disk\",{\"1\":{\"738\":1}}],[\"dispatchservlet\",{\"1\":{\"654\":1}}],[\"dispatcherservlet\",{\"1\":{\"642\":1,\"644\":1}}],[\"disposablebean\",{\"1\":{\"614\":1}}],[\"displayed\",{\"1\":{\"42\":1}}],[\"distributionurl=gradle\",{\"1\":{\"1006\":1}}],[\"distributions\",{\"1\":{\"1006\":1}}],[\"distinct\",{\"1\":{\"547\":1,\"548\":1}}],[\"distance\",{\"1\":{\"257\":1}}],[\"dishnames\",{\"1\":{\"549\":1}}],[\"dishes\",{\"1\":{\"548\":1}}],[\"dish\",{\"1\":{\"546\":1,\"548\":1,\"549\":1}}],[\"discardoldestpolicy\",{\"1\":{\"275\":1}}],[\"discardpolicy\",{\"1\":{\"275\":1}}],[\"discussions\",{\"1\":{\"128\":1}}],[\"dao接口的工作原理\",{\"0\":{\"816\":1}}],[\"dao层的函数\",{\"1\":{\"819\":1}}],[\"dao层\",{\"1\":{\"643\":1}}],[\"dao\",{\"1\":{\"618\":2,\"638\":1,\"816\":6}}],[\"dao支持\",{\"1\":{\"591\":1}}],[\"daemon\",{\"1\":{\"577\":1}}],[\"datetimeformatter\",{\"1\":{\"573\":7}}],[\"datetimeformatter类提供了大量预定义格式化器\",{\"1\":{\"573\":1}}],[\"date\",{\"1\":{\"571\":5,\"573\":3,\"701\":3,\"708\":2,\"711\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"749\":2,\"753\":1,\"754\":8,\"755\":4,\"757\":5,\"762\":4,\"765\":1,\"768\":2,\"779\":2,\"780\":1}}],[\"date转换为localdate\",{\"0\":{\"571\":1}}],[\"datasource\",{\"1\":{\"831\":1,\"866\":2}}],[\"datasourceautoconfiguration\",{\"1\":{\"676\":4}}],[\"data\",{\"0\":{\"477\":1},\"1\":{\"655\":1,\"682\":1,\"860\":1}}],[\"dayofweek\",{\"1\":{\"569\":1}}],[\"day\",{\"1\":{\"159\":1}}],[\"danger\",{\"1\":{\"91\":1}}],[\"darchetypeversion=1\",{\"1\":{\"78\":1}}],[\"darchetypeartifactid=maven\",{\"1\":{\"78\":1}}],[\"darchetypegroupid=org\",{\"1\":{\"78\":1}}],[\"debug几次\",{\"1\":{\"955\":1}}],[\"debug\",{\"1\":{\"738\":3}}],[\"delayqueue\",{\"1\":{\"758\":1}}],[\"delayqueueconsumer\",{\"1\":{\"757\":1}}],[\"delaytime\",{\"1\":{\"757\":5}}],[\"delayedexchange\",{\"1\":{\"757\":4}}],[\"delayedqueue\",{\"1\":{\"757\":2}}],[\"delayedqueueconfig\",{\"1\":{\"757\":2}}],[\"delayed\",{\"1\":{\"756\":4,\"757\":23}}],[\"delivercallback\",{\"1\":{\"698\":3,\"701\":4,\"708\":5,\"714\":3,\"717\":3,\"747\":8,\"748\":3,\"749\":6,\"779\":4}}],[\"deliverytag\",{\"1\":{\"706\":5}}],[\"deliveryid\",{\"1\":{\"673\":1}}],[\"deliveryrecord\",{\"1\":{\"673\":2}}],[\"delivery\",{\"1\":{\"673\":2,\"698\":2,\"701\":2,\"708\":4,\"714\":3,\"717\":3,\"720\":1,\"747\":4,\"748\":2,\"749\":6,\"779\":2}}],[\"deliverycontroller\",{\"1\":{\"673\":1}}],[\"deleted=0\",{\"1\":{\"840\":2,\"851\":1}}],[\"deleted=1\",{\"1\":{\"840\":1}}],[\"deleted\",{\"1\":{\"840\":2,\"850\":1,\"852\":1}}],[\"deletebatchids\",{\"1\":{\"832\":1}}],[\"deletebymap\",{\"1\":{\"832\":1}}],[\"deletebyid\",{\"1\":{\"832\":2}}],[\"delete\",{\"1\":{\"673\":1,\"788\":8,\"827\":1,\"832\":1,\"846\":1}}],[\"deadletterqueueconsumer\",{\"1\":{\"754\":1,\"780\":1}}],[\"deadletterbindingqad\",{\"1\":{\"754\":1}}],[\"deadqueue\",{\"1\":{\"747\":4,\"749\":4}}],[\"deadqueuename\",{\"1\":{\"747\":3,\"748\":3,\"749\":3}}],[\"dead\",{\"1\":{\"577\":1,\"697\":3,\"702\":1,\"747\":13,\"748\":8,\"749\":13,\"754\":10,\"755\":4}}],[\"definition\",{\"1\":{\"963\":1,\"965\":1,\"968\":1,\"973\":1,\"1029\":1,\"1034\":1}}],[\"defined\",{\"1\":{\"381\":1}}],[\"def\",{\"1\":{\"728\":3}}],[\"defaultvalue\",{\"1\":{\"651\":2}}],[\"default\",{\"1\":{\"94\":1,\"98\":1,\"239\":1,\"244\":1,\"410\":1,\"577\":1,\"634\":1,\"783\":3,\"788\":1,\"792\":7,\"832\":2,\"991\":1}}],[\"decay\",{\"1\":{\"369\":1}}],[\"decentraland\",{\"1\":{\"145\":1}}],[\"deque\",{\"1\":{\"231\":1}}],[\"demo09\",{\"1\":{\"779\":2}}],[\"demo08\",{\"1\":{\"747\":3}}],[\"demo07\",{\"1\":{\"742\":1}}],[\"demo06\",{\"1\":{\"738\":1}}],[\"demo05\",{\"1\":{\"734\":1}}],[\"demo04\",{\"1\":{\"722\":1,\"723\":1}}],[\"demo03\",{\"1\":{\"708\":2,\"711\":1}}],[\"demo02\",{\"1\":{\"701\":2}}],[\"demo01\",{\"1\":{\"605\":1,\"697\":1,\"698\":1}}],[\"demo\",{\"1\":{\"142\":1,\"668\":2}}],[\"details\",{\"1\":{\"142\":1,\"289\":1,\"293\":1}}],[\"description\",{\"1\":{\"701\":3,\"708\":2,\"711\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"749\":2,\"753\":1,\"754\":4,\"755\":2,\"757\":2,\"762\":4,\"765\":1,\"768\":2,\"779\":2,\"919\":1}}],[\"descriptors>\",{\"1\":{\"99\":1}}],[\"descriptor>\",{\"1\":{\"99\":1}}],[\"destruction\",{\"1\":{\"619\":1}}],[\"destroy\",{\"1\":{\"614\":2}}],[\"design\",{\"1\":{\"139\":1,\"156\":1}}],[\"designcap\",{\"1\":{\"139\":1}}],[\"desktop\",{\"1\":{\"110\":2}}],[\"depth++\",{\"1\":{\"1034\":1}}],[\"depth\",{\"1\":{\"944\":5,\"1034\":4}}],[\"depth=1进一步查看\",{\"1\":{\"32\":1}}],[\"depends\",{\"1\":{\"410\":1}}],[\"dependencies\",{\"1\":{\"80\":1,\"685\":1}}],[\"dependencies>\",{\"1\":{\"70\":1,\"87\":2,\"88\":1,\"671\":1,\"696\":1,\"753\":1}}],[\"dependencymanagement>\",{\"1\":{\"87\":2}}],[\"dependency>\",{\"1\":{\"70\":2,\"83\":1,\"87\":7,\"88\":5,\"670\":1,\"671\":1,\"679\":2,\"680\":1,\"696\":2,\"753\":6,\"830\":1,\"863\":2}}],[\"dependency\",{\"0\":{\"102\":1},\"1\":{\"70\":1,\"78\":2,\"80\":1}}],[\"deploy将最终的包复制到远程的仓库\",{\"1\":{\"94\":1}}],[\"deploy\",{\"1\":{\"94\":1}}],[\"devdocs\",{\"1\":{\"119\":1}}],[\"dev\",{\"0\":{\"113\":1},\"1\":{\"113\":1,\"685\":2,\"1004\":1}}],[\"devtools实现原理是使用了两个classloader\",{\"1\":{\"670\":1}}],[\"devtools<\",{\"1\":{\"670\":1}}],[\"devtools热部署\",{\"1\":{\"669\":1}}],[\"devtools\",{\"0\":{\"670\":1},\"1\":{\"62\":1,\"670\":1}}],[\"devenv\",{\"1\":{\"61\":1,\"77\":1,\"1007\":2,\"1008\":1}}],[\"doaround222\",{\"1\":{\"605\":2}}],[\"doaround111\",{\"1\":{\"605\":2}}],[\"doaround\",{\"1\":{\"605\":1}}],[\"doafterre\",{\"1\":{\"605\":1}}],[\"doafterthrow\",{\"1\":{\"605\":1}}],[\"doafter\",{\"1\":{\"605\":1}}],[\"dobefore\",{\"1\":{\"605\":1}}],[\"dog\",{\"1\":{\"235\":1,\"728\":1}}],[\"double\",{\"1\":{\"187\":1,\"1030\":2}}],[\"docs\",{\"1\":{\"788\":1}}],[\"docsify\",{\"1\":{\"1\":1}}],[\"doc\",{\"1\":{\"788\":1}}],[\"docker常见问题\",{\"0\":{\"578\":1}}],[\"docker常用命令\",{\"0\":{\"576\":1}}],[\"docker\",{\"0\":{\"577\":1,\"579\":1},\"1\":{\"577\":1}}],[\"docmirror\",{\"1\":{\"113\":1}}],[\"documented\",{\"1\":{\"791\":1,\"792\":1}}],[\"document\",{\"1\":{\"67\":1}}],[\"dom\",{\"1\":{\"67\":1}}],[\"download\",{\"1\":{\"59\":1}}],[\"down\",{\"1\":{\"6\":2}}],[\"do\",{\"1\":{\"6\":1,\"656\":1,\"687\":1}}],[\"d\",{\"1\":{\"6\":1,\"77\":1,\"317\":7,\"546\":2,\"548\":2,\"813\":1,\"864\":2,\"934\":4,\"939\":5,\"943\":4,\"944\":4,\"1007\":1,\"1008\":1,\"1024\":1}}],[\"快指针\",{\"1\":{\"973\":1}}],[\"快递员最终会把你的快递送到收件人那里\",{\"1\":{\"691\":1}}],[\"快得多\",{\"1\":{\"670\":1}}],[\"快速失败\",{\"1\":{\"917\":1}}],[\"快速生成\",{\"0\":{\"864\":1}}],[\"快速生成当前类的子类\",{\"1\":{\"6\":1}}],[\"快速的实现对单表的crud\",{\"1\":{\"826\":1}}],[\"快速\",{\"1\":{\"788\":1}}],[\"快速创建独立运行的spring应用以及与主流框架集成\",{\"1\":{\"665\":1}}],[\"快速随机访问就是通过元素的序号快速获取元素对象\",{\"1\":{\"229\":1}}],[\"快速排序\",{\"1\":{\"171\":1}}],[\"快速笔记\",{\"1\":{\"148\":1}}],[\"快速出\",{\"1\":{\"147\":1}}],[\"快速打开\",{\"1\":{\"44\":1}}],[\"快速判断变量是否等于null\",{\"0\":{\"10\":1}}],[\"快速换行\",{\"0\":{\"8\":1}}],[\"快速定位到问题行\",{\"1\":{\"6\":1}}],[\"快捷修复\",{\"1\":{\"6\":1}}],[\"快捷键文档\",{\"1\":{\"35\":1}}],[\"快捷键\",{\"0\":{\"6\":1,\"27\":1,\"42\":1}}],[\"大约1\",{\"1\":{\"1011\":1}}],[\"大约在132行\",{\"1\":{\"1009\":1}}],[\"大致流程\",{\"1\":{\"882\":1}}],[\"大致在jdk8中完成\",{\"1\":{\"352\":1}}],[\"大的\",{\"1\":{\"827\":1}}],[\"大家都知道\",{\"1\":{\"776\":1}}],[\"大家看名字就知道这个收集器是一个单线程收集器了\",{\"1\":{\"530\":1}}],[\"大原因\",{\"1\":{\"636\":1}}],[\"大对象直接分配到老年代\",{\"1\":{\"498\":1}}],[\"大厂面试题\",{\"0\":{\"518\":1},\"1\":{\"467\":1}}],[\"大部分来自尚硅谷宋红康老师的课程\",{\"1\":{\"541\":1}}],[\"大部分时候回收的都是指新生代\",{\"1\":{\"493\":1}}],[\"大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前\",{\"1\":{\"357\":1}}],[\"大部分资料中说的锁降级发生在读写锁reentrantreadwritelock中\",{\"1\":{\"279\":1}}],[\"大部分资料中说jvm不支持锁降级\",{\"1\":{\"279\":1}}],[\"大小\",{\"0\":{\"338\":1},\"1\":{\"336\":1}}],[\"大小写切换\",{\"1\":{\"6\":1}}],[\"大量的时间花费在线程调度上\",{\"1\":{\"290\":1}}],[\"大于等于\",{\"1\":{\"207\":1}}],[\"大概是对应这样的一类问题\",{\"1\":{\"206\":1}}],[\"大顶堆\",{\"1\":{\"176\":1}}],[\"大力盘\",{\"1\":{\"148\":1}}],[\"大圣\",{\"1\":{\"118\":1}}],[\"大圣编程自学网\",{\"1\":{\"118\":1}}],[\"大纲视图\",{\"1\":{\"48\":1}}],[\"大多数同时都使用的是默认的keymap\",{\"1\":{\"6\":1}}],[\"在递归调用的时候二叉树的每个节点最多被访问一次\",{\"1\":{\"1029\":1}}],[\"在递归调用左子树时\",{\"1\":{\"1029\":1}}],[\"在非递归中采用栈来保存遍历过的节点\",{\"1\":{\"1024\":1}}],[\"在非公平锁的实现上\",{\"1\":{\"290\":1}}],[\"在打印左孩子\",{\"1\":{\"1024\":1}}],[\"在打包后的文件名称的后缀显示\",{\"1\":{\"99\":1}}],[\"在当前目录的命令行窗口输入\",{\"1\":{\"1010\":1}}],[\"在当前文件内搜索\",{\"1\":{\"6\":1}}],[\"在搜索栏输入\",{\"1\":{\"1010\":1}}],[\"在repositories内\",{\"1\":{\"1009\":1}}],[\"在restful接口风格中经常使用\",{\"1\":{\"651\":1}}],[\"在resources\",{\"1\":{\"99\":1}}],[\"在gradle中的init\",{\"1\":{\"1008\":1}}],[\"在第二轮循环中\",{\"1\":{\"970\":1}}],[\"在第一次暴露的时候会调用\",{\"1\":{\"889\":1}}],[\"在循环结束后\",{\"1\":{\"957\":1}}],[\"在循环中\",{\"1\":{\"194\":1,\"957\":1,\"970\":1}}],[\"在同一时间被感染的橘子为一层\",{\"1\":{\"944\":1}}],[\"在leetcode的提交结果也能看出来\",{\"1\":{\"940\":1}}],[\"在三个\",{\"1\":{\"939\":1}}],[\"在dfs方法中不用再写4个if\",{\"1\":{\"935\":1}}],[\"在dubbo的用户文档中\",{\"1\":{\"918\":1}}],[\"在dubbo\",{\"1\":{\"901\":2}}],[\"在计算dp\",{\"1\":{\"926\":1}}],[\"在注册中心找不到对应的服务\",{\"1\":{\"920\":1}}],[\"在consumer和provider的filter链中都会有monitorfilter\",{\"1\":{\"902\":1}}],[\"在com\",{\"1\":{\"836\":1}}],[\"在查找扩展实现类的时候遍历\",{\"1\":{\"893\":1}}],[\"在查询关联对象或关联集合对象时\",{\"1\":{\"823\":1}}],[\"在依赖低版本的common\",{\"1\":{\"888\":1}}],[\"在thrift已经相当流行的情况下推出avro的目标不仅是提供一套类似thrift的通讯中间件\",{\"1\":{\"879\":1}}],[\"在threadlocal中\",{\"1\":{\"280\":1}}],[\"在网络中\",{\"1\":{\"878\":1}}],[\"在高并发网站中\",{\"1\":{\"872\":1}}],[\"在代表版本的字段上加\",{\"1\":{\"860\":1}}],[\"在代码中调用\",{\"1\":{\"633\":1}}],[\"在代码中尝试获取这个类加载器时\",{\"1\":{\"381\":1}}],[\"在代码层面上可以简单认为是\",{\"1\":{\"612\":1}}],[\"在插件的拦截方法内拦截待执行的\",{\"1\":{\"817\":1}}],[\"在所有节点同步完成之前是阻塞状态的\",{\"1\":{\"800\":1}}],[\"在该方法内\",{\"1\":{\"789\":1}}],[\"在该设置下自动装配是关闭的\",{\"1\":{\"598\":1}}],[\"在发送\",{\"1\":{\"784\":1}}],[\"在发生minorgc之前\",{\"1\":{\"504\":1}}],[\"在队列声明的时候可以通过\",{\"1\":{\"783\":1}}],[\"在被写入磁盘的同时也会在内存中驻留一份备份\",{\"1\":{\"782\":1}}],[\"在海量订单生成的业务高峰期\",{\"1\":{\"774\":1}}],[\"在以前的单应用系统中\",{\"1\":{\"771\":1}}],[\"在仅开启了生产者确认机制的情况下\",{\"1\":{\"764\":1}}],[\"在配置文件当中需要添加\",{\"1\":{\"762\":1}}],[\"在配置文件中配置\",{\"1\":{\"676\":1}}],[\"在配置文件中\",{\"1\":{\"652\":1}}],[\"在配置文件中的定义包含\",{\"1\":{\"614\":2}}],[\"在生产环境中由于一些不明原因\",{\"1\":{\"759\":1}}],[\"在我们系统中有一个订单催付的场景\",{\"1\":{\"776\":1}}],[\"在我们自定义的交换机中\",{\"1\":{\"757\":1}}],[\"在我们的项目中遇到这样一个问题\",{\"1\":{\"628\":1}}],[\"在我们的实际应用中\",{\"1\":{\"106\":1}}],[\"在创建队列的时候设置队列的\",{\"1\":{\"752\":1}}],[\"在创建对象a时spring会抛出objectcurrentlyincreationexception异常\",{\"1\":{\"600\":1}}],[\"在十分钟之后检查该订单支付状态\",{\"1\":{\"751\":1}}],[\"在指定时间到了以后或之前取出和处理\",{\"1\":{\"751\":1}}],[\"在本节我们将向其中添加一些特别的功能\",{\"1\":{\"735\":1}}],[\"在本地方法栈也会创建一个栈帧\",{\"1\":{\"303\":1}}],[\"在绑定\",{\"1\":{\"728\":1}}],[\"在出现错误的情况下可以很好地控制\",{\"1\":{\"724\":1}}],[\"在回调函数里进行确认发布\",{\"1\":{\"724\":1}}],[\"在消费者中消费消息之前\",{\"1\":{\"714\":1}}],[\"在消息生产者开启持久化\",{\"1\":{\"711\":1}}],[\"在消息量大的时候建立\",{\"1\":{\"693\":1}}],[\"在还未处理完时间里停止运行\",{\"1\":{\"709\":1}}],[\"在后台运行的工作进程将弹出任务并最终执行作业\",{\"1\":{\"699\":1}}],[\"在下面放到已经处理过的集合内\",{\"1\":{\"982\":1}}],[\"在下图中\",{\"1\":{\"695\":1}}],[\"在下方新增一行\",{\"1\":{\"1006\":1}}],[\"在下方\",{\"1\":{\"42\":1}}],[\"在启动开启\",{\"1\":{\"764\":1}}],[\"在启动的时候\",{\"1\":{\"674\":1}}],[\"在启动spring\",{\"1\":{\"601\":1}}],[\"在传统的ssm\",{\"1\":{\"673\":1}}],[\"在红色划线部位输入如图所示指令\",{\"1\":{\"671\":1}}],[\"在项目中用的不多\",{\"1\":{\"998\":1}}],[\"在项目中添加如下代码\",{\"1\":{\"671\":1}}],[\"在项目的pom文件中添加依赖\",{\"1\":{\"670\":1}}],[\"在页面form中提交enctype=\",{\"1\":{\"655\":1}}],[\"在异常处理器中添视图页面即可\",{\"1\":{\"650\":1}}],[\"在web\",{\"1\":{\"649\":1}}],[\"在winaows95的平台上\",{\"1\":{\"435\":1}}],[\"在服务器端配置url编码格式\",{\"1\":{\"649\":1}}],[\"在autoconfigurationimportselector类中会执行getcandidateconfigurations\",{\"1\":{\"674\":1}}],[\"在action的生命周期中\",{\"1\":{\"648\":1}}],[\"在a分支提交了代码\",{\"1\":{\"582\":1}}],[\"在你调用方法前打印出字符串\",{\"1\":{\"648\":1}}],[\"在视图中其实没有真正的处理发生\",{\"1\":{\"645\":1}}],[\"在mybatis\",{\"1\":{\"852\":1}}],[\"在mapper中如何传递多个参数\",{\"0\":{\"819\":1}}],[\"在maven中定义属性值\",{\"1\":{\"70\":1}}],[\"在mvc的三个部件中\",{\"1\":{\"645\":1}}],[\"在modelandview对象中\",{\"1\":{\"642\":1}}],[\"在用这个类时并不想去继承这个类\",{\"1\":{\"632\":1}}],[\"在接口中\",{\"1\":{\"612\":1}}],[\"在容器启动时\",{\"1\":{\"611\":1}}],[\"在对其进行编译\",{\"1\":{\"607\":1}}],[\"在对象被移动时只会改变句柄中的实例数据指针\",{\"1\":{\"315\":1}}],[\"在某连接点正常完成后执行的通知\",{\"1\":{\"604\":1}}],[\"在某些极端的情况下还能够与jvm的生命周期保持一致\",{\"1\":{\"488\":1}}],[\"在某些场景下\",{\"1\":{\"462\":1}}],[\"在一个方法之前执行的通知\",{\"1\":{\"604\":1}}],[\"在一条活动线程中\",{\"1\":{\"413\":1}}],[\"在idea的console里看到build\",{\"1\":{\"1011\":1}}],[\"在idea中\",{\"1\":{\"17\":1}}],[\"在invoke\",{\"1\":{\"603\":1}}],[\"在设值注入时如果对象a和对象b互相依赖\",{\"1\":{\"600\":1}}],[\"在设值注入方法支持大部分的依赖注入\",{\"1\":{\"600\":1}}],[\"在构造方法注入不支持大部分的依赖注入\",{\"1\":{\"600\":1}}],[\"在找不到匹配\",{\"1\":{\"599\":1}}],[\"在需要改进和个性化定制界面及用户交互的同时\",{\"1\":{\"645\":1}}],[\"在需要用到的地方直接使用即可\",{\"1\":{\"596\":1}}],[\"在需要收藏的代码前右击\",{\"1\":{\"11\":2}}],[\"在实际项目中一个\",{\"1\":{\"595\":1}}],[\"在bash或弹出的记事本里修改即可\",{\"1\":{\"585\":1}}],[\"在另一个时区对应的时间\",{\"1\":{\"562\":1}}],[\"在1\",{\"1\":{\"537\":1}}],[\"在相同条件下\",{\"1\":{\"527\":1}}],[\"在新生代\",{\"1\":{\"522\":1}}],[\"在垃圾回收过程中\",{\"1\":{\"526\":1}}],[\"在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中\",{\"1\":{\"522\":1}}],[\"在垃圾回收器线程扫描它所管辖的内存区域的过程中\",{\"1\":{\"327\":1}}],[\"在进行gc的时候\",{\"1\":{\"521\":1}}],[\"在动态编译同步块的时候\",{\"1\":{\"509\":1}}],[\"在动态链接的时候会用到运行时常量池\",{\"1\":{\"457\":1}}],[\"在parallel\",{\"1\":{\"495\":1}}],[\"在pom\",{\"1\":{\"99\":1}}],[\"在养老区\",{\"1\":{\"490\":1}}],[\"在哪里分配等问题\",{\"1\":{\"490\":1}}],[\"在堆空间开一片区域\",{\"1\":{\"479\":1}}],[\"在堆上创建的新的对象\",{\"1\":{\"317\":2}}],[\"在分配内存空间时\",{\"1\":{\"471\":1}}],[\"在分配的时候从列表中找到一块足够大的空间划分给对象实例\",{\"1\":{\"471\":1}}],[\"在大量使用反射\",{\"1\":{\"464\":1}}],[\"在大多数情况下\",{\"1\":{\"278\":1}}],[\"在加载类和接口到虚拟机后\",{\"1\":{\"459\":1}}],[\"在execution\",{\"1\":{\"437\":1}}],[\"在exclude标签中配置一个具体的排除\",{\"1\":{\"83\":1}}],[\"在内存溢出方面是相同的\",{\"1\":{\"437\":1}}],[\"在内存中生成一个代表这个类的\",{\"1\":{\"377\":1}}],[\"在企业级应用中己经比较少见\",{\"1\":{\"436\":1}}],[\"在定义一个native\",{\"1\":{\"434\":1}}],[\"在字节码指令中\",{\"1\":{\"424\":1}}],[\"在字节码中遇到控制流向后跳转的指令称为\",{\"1\":{\"370\":1}}],[\"在面向对象的编程中\",{\"1\":{\"423\":1}}],[\"在栈帧中\",{\"1\":{\"415\":1}}],[\"在方法调用前后触发的通知\",{\"1\":{\"604\":1}}],[\"在方法抛出异常退出时执行的通知\",{\"1\":{\"604\":1}}],[\"在方法结束后\",{\"1\":{\"482\":1}}],[\"在方法内定义\",{\"1\":{\"431\":1}}],[\"在方法退出后都返回到该方法被调用的位置\",{\"1\":{\"424\":1}}],[\"在方法执行的过程中遇到了异常\",{\"1\":{\"424\":1}}],[\"在方法执行过程中\",{\"1\":{\"416\":1}}],[\"在方法执行时\",{\"1\":{\"415\":2}}],[\"在方法运行期间是不会改变局部变量表的大小的\",{\"1\":{\"415\":1}}],[\"在这种绑定情况下\",{\"1\":{\"736\":1}}],[\"在这种情况下虽然绑定类型是\",{\"1\":{\"737\":1}}],[\"在这种情况下已传递但尚未处理的消息的数量也会增加\",{\"1\":{\"717\":1}}],[\"在这种情况下\",{\"1\":{\"704\":1}}],[\"在这种状态下\",{\"1\":{\"526\":1}}],[\"在这里新增了一个队列\",{\"1\":{\"755\":1,\"757\":1}}],[\"在这里我们将使用\",{\"1\":{\"736\":1}}],[\"在这里传到视图\",{\"1\":{\"656\":1}}],[\"在这里还可以划分线程私有的缓冲区\",{\"1\":{\"482\":1}}],[\"在这个回溯的过程中\",{\"1\":{\"1024\":1}}],[\"在这个回调对象中定义一个操纵jdbctemplate中变量的方法\",{\"1\":{\"632\":1}}],[\"在这个规则列表中\",{\"1\":{\"740\":1}}],[\"在这个线程上正在执行的每个方法都各自对应一个栈帧\",{\"1\":{\"412\":1}}],[\"在这样的条件下\",{\"1\":{\"206\":1}}],[\"在类中定义一个\",{\"1\":{\"638\":1}}],[\"在类\",{\"1\":{\"392\":1}}],[\"在类加载检查通过后\",{\"1\":{\"311\":1}}],[\"在编与自定义类加载器时\",{\"1\":{\"387\":1}}],[\"在编译的时候就会分配了\",{\"1\":{\"379\":1}}],[\"在自定义类加载器时\",{\"1\":{\"387\":1}}],[\"在程序运行时\",{\"1\":{\"607\":1}}],[\"在程序运行之前\",{\"1\":{\"607\":1}}],[\"在程序中\",{\"1\":{\"502\":1}}],[\"在程序中我们最常见的类加载器始终只有3个\",{\"1\":{\"381\":1}}],[\"在程序设计中一般很少使用弱引用与虚引用\",{\"1\":{\"328\":1}}],[\"在运行过程中\",{\"1\":{\"462\":1}}],[\"在运行期间\",{\"1\":{\"372\":1}}],[\"在运行时生成的本地机器指令\",{\"1\":{\"362\":1}}],[\"在service类\",{\"1\":{\"866\":1}}],[\"在server模式下是10000次\",{\"1\":{\"369\":1}}],[\"在sql语句中拼接通配符\",{\"1\":{\"814\":1}}],[\"在springapplication实例初始化的时候\",{\"1\":{\"678\":1}}],[\"在springmvc\",{\"1\":{\"655\":1}}],[\"在springmvc中\",{\"1\":{\"648\":1}}],[\"在spring的aop中\",{\"1\":{\"627\":1}}],[\"在spring\",{\"1\":{\"604\":2,\"615\":1,\"679\":1,\"792\":1}}],[\"在spring中默认情况下使用jdk动态代理实现aop\",{\"1\":{\"603\":1}}],[\"在spring中\",{\"1\":{\"592\":1}}],[\"在sleep的过程中\",{\"1\":{\"273\":1}}],[\"在此记录一下\",{\"1\":{\"947\":1,\"957\":1}}],[\"在此总结一下\",{\"1\":{\"942\":1}}],[\"在此模式下\",{\"1\":{\"365\":1}}],[\"在此进行总结\",{\"1\":{\"6\":1}}],[\"在今天\",{\"1\":{\"365\":1}}],[\"在执行\",{\"1\":{\"359\":1}}],[\"在最开始的时候我们学习到\",{\"1\":{\"714\":1}}],[\"在最优化的程序响应时间与最佳执行性能中取得平衡\",{\"1\":{\"351\":1}}],[\"在最下方的例子中\",{\"1\":{\"106\":1}}],[\"在协同工作的时候会默认使用\",{\"1\":{\"332\":1}}],[\"在虚拟机启动时创建\",{\"1\":{\"304\":1}}],[\"在hotspot中\",{\"1\":{\"488\":1}}],[\"在hotspot\",{\"1\":{\"303\":1,\"437\":1}}],[\"在使用\",{\"1\":{\"601\":2}}],[\"在使用设值注入时有可能还不能保证某种依赖是否已经被注入\",{\"1\":{\"600\":1}}],[\"在使用notify\",{\"1\":{\"286\":1}}],[\"在使用完threadlocal时\",{\"1\":{\"280\":1}}],[\"在调度线程上更加灵活\",{\"1\":{\"286\":1}}],[\"在繁忙的时候\",{\"1\":{\"280\":1}}],[\"在jit阶段\",{\"1\":{\"510\":1}}],[\"在jvm中\",{\"1\":{\"395\":1,\"419\":1}}],[\"在jdk6u23版本之后\",{\"1\":{\"506\":1}}],[\"在jdk6\",{\"1\":{\"504\":1}}],[\"在jdk7及以前\",{\"1\":{\"444\":1}}],[\"在jdk1\",{\"1\":{\"343\":3}}],[\"在jdk14被正式从jdk中删除\",{\"1\":{\"339\":1}}],[\"在jdk8以后又叫做元空间metaspace\",{\"1\":{\"343\":1}}],[\"在jdk8合并\",{\"1\":{\"306\":1}}],[\"在jdk\",{\"1\":{\"278\":1}}],[\"在java代码中添加sql通配符\",{\"1\":{\"814\":1}}],[\"在java8之前就出现的一个开源包\",{\"1\":{\"574\":1}}],[\"在java语言中\",{\"0\":{\"519\":1}}],[\"在java虚拟机中\",{\"1\":{\"505\":1}}],[\"在java虚拟机运行时\",{\"1\":{\"365\":1}}],[\"在java源文件被编译到字节码文件中时\",{\"1\":{\"417\":1}}],[\"在java的发展历史里\",{\"1\":{\"362\":1}}],[\"在java\",{\"1\":{\"225\":1}}],[\"在经过若干次循环后\",{\"1\":{\"278\":1}}],[\"在整个同步周期内都不存在竞争\",{\"1\":{\"278\":1}}],[\"在链表长度超过一定阈值\",{\"1\":{\"252\":1}}],[\"在openjdk8中\",{\"1\":{\"242\":2}}],[\"在解决哈希冲突时有了较大的变化\",{\"1\":{\"239\":1}}],[\"在前者使用list\",{\"1\":{\"230\":1}}],[\"在很多源码中\",{\"1\":{\"230\":1}}],[\"在日常编程中可能经常不确定会有多少个对象\",{\"1\":{\"227\":1}}],[\"在上方代码中\",{\"1\":{\"789\":1}}],[\"在上一节中\",{\"1\":{\"735\":1}}],[\"在上一个小节中\",{\"1\":{\"740\":1}}],[\"在上一个\",{\"1\":{\"6\":1}}],[\"在上面这张图中\",{\"1\":{\"736\":1}}],[\"在上面工作都完成之后\",{\"1\":{\"314\":1}}],[\"在上面结构的基础上\",{\"1\":{\"222\":1}}],[\"在上面构建自己的世界\",{\"1\":{\"145\":1}}],[\"在地址栏里面玩贪吃蛇\",{\"1\":{\"143\":1}}],[\"在地址栏里面播放\",{\"1\":{\"143\":1}}],[\"在线网页编辑器\",{\"1\":{\"148\":1}}],[\"在线取名\",{\"1\":{\"143\":1}}],[\"在线帮你使用\",{\"1\":{\"139\":1}}],[\"在线海报设计\",{\"1\":{\"139\":1}}],[\"在线ai图片处理\",{\"1\":{\"132\":1}}],[\"在线代码编辑与演示\",{\"1\":{\"130\":1}}],[\"在任意输入框快速打开emoji表情方法\",{\"1\":{\"131\":1}}],[\"在任何时候都可能被垃圾回收\",{\"1\":{\"328\":1}}],[\"在任何一个生命周期内部\",{\"1\":{\"95\":1}}],[\"在任何目录下执行都可以\",{\"1\":{\"72\":1}}],[\"在引用了所有的以来后\",{\"1\":{\"103\":1}}],[\"在总工程执行\",{\"1\":{\"90\":1}}],[\"在每一个\",{\"1\":{\"85\":1}}],[\"在父工程中统一管理项目中的依赖信息\",{\"1\":{\"85\":1}}],[\"在开发过程中需要用到的\",{\"1\":{\"80\":1}}],[\"在\",{\"1\":{\"65\":1,\"77\":1,\"81\":1,\"207\":1,\"249\":1,\"303\":1,\"304\":1,\"343\":1,\"362\":1,\"387\":1,\"399\":1,\"463\":1,\"474\":1,\"505\":1,\"525\":2,\"534\":1,\"536\":1,\"599\":1,\"673\":1,\"686\":1,\"702\":1,\"712\":1,\"757\":1,\"759\":1,\"767\":1,\"783\":1,\"810\":1,\"816\":1,\"821\":1,\"822\":1,\"826\":1}}],[\"在弹窗内选择\",{\"1\":{\"18\":1,\"19\":1}}],[\"在书签视图下\",{\"1\":{\"11\":2}}],[\"类即可进行强\",{\"1\":{\"827\":1}}],[\"类websecurityconfigureradapter已被弃用\",{\"1\":{\"792\":1}}],[\"类路径\",{\"1\":{\"788\":1,\"989\":1,\"995\":1}}],[\"类装载到jvm\",{\"1\":{\"602\":1}}],[\"类装载子系统化身为反射类class\",{\"1\":{\"343\":1}}],[\"类可能有几百甚至上千个类作为它的底层\",{\"1\":{\"595\":1}}],[\"类型为\",{\"1\":{\"747\":1,\"748\":1,\"749\":1,\"768\":1}}],[\"类型\",{\"1\":{\"702\":1,\"733\":1,\"740\":1,\"788\":1}}],[\"类型的\",{\"1\":{\"599\":1}}],[\"类型转换\",{\"1\":{\"591\":1}}],[\"类型数据的指针\",{\"1\":{\"479\":1}}],[\"类型指针\",{\"1\":{\"476\":1}}],[\"类型信息\",{\"0\":{\"452\":1},\"1\":{\"461\":1}}],[\"类对象\",{\"1\":{\"470\":1}}],[\"类对应\",{\"1\":{\"343\":1}}],[\"类或接口\",{\"1\":{\"459\":1}}],[\"类引用\",{\"1\":{\"458\":1}}],[\"类变量被类的所有实例共享\",{\"1\":{\"455\":1}}],[\"类变量会分配在方法区中\",{\"1\":{\"379\":1}}],[\"类class\",{\"1\":{\"452\":1}}],[\"类和接口的全限定名\",{\"1\":{\"464\":1}}],[\"类和接囗的初始化方法使用\",{\"1\":{\"424\":1}}],[\"类和常量池\",{\"0\":{\"316\":1}}],[\"类是一个抽象类\",{\"1\":{\"388\":1}}],[\"类并重写\",{\"1\":{\"387\":1}}],[\"类等核心类库是由引导类加载器加载的\",{\"1\":{\"381\":1}}],[\"类方法\",{\"1\":{\"379\":1}}],[\"类的常用配置\",{\"1\":{\"787\":1}}],[\"类的全限定名\",{\"1\":{\"619\":1}}],[\"类的变量初始值准备完成之后\",{\"1\":{\"423\":1}}],[\"类的主动使用和被动使用\",{\"0\":{\"397\":1}}],[\"类的完整类名必须一致\",{\"1\":{\"395\":1}}],[\"类的方式\",{\"1\":{\"387\":1}}],[\"类的加载器\",{\"1\":{\"452\":1}}],[\"类的加载器为\",{\"1\":{\"381\":1}}],[\"类的加载过程分为3个环节\",{\"1\":{\"375\":1}}],[\"类的加载过程\",{\"0\":{\"375\":1}}],[\"类的话\",{\"1\":{\"333\":1}}],[\"类实现了接口\",{\"1\":{\"374\":1}}],[\"类加载子系统\",{\"0\":{\"373\":1}}],[\"类加载器分类\",{\"0\":{\"381\":1}}],[\"类加载器系统负责从文件系统或者网络中加载\",{\"1\":{\"375\":1}}],[\"类加载器\",{\"0\":{\"331\":1}}],[\"类比int\",{\"1\":{\"258\":3}}],[\"类似于\",{\"1\":{\"702\":2}}],[\"类似于网络中的\",{\"1\":{\"693\":1}}],[\"类似全局的拦截器\",{\"1\":{\"656\":1}}],[\"类似\",{\"1\":{\"251\":1,\"340\":1,\"536\":1,\"962\":1}}],[\"类似的是\",{\"1\":{\"67\":1}}],[\"类名为\",{\"1\":{\"470\":1}}],[\"类名\",{\"1\":{\"6\":1,\"452\":1}}],[\"类\",{\"1\":{\"6\":1,\"308\":1,\"317\":1,\"333\":1,\"383\":1,\"384\":1,\"387\":1,\"435\":1,\"757\":1,\"901\":1}}],[\"但为了gwt兼容性和效率\",{\"1\":{\"997\":1}}],[\"但尾部不会\",{\"1\":{\"995\":1}}],[\"但和原来的是同一个对象\",{\"1\":{\"991\":1}}],[\"但一般来说仍应在返回结果之前恢复链表\",{\"1\":{\"975\":1}}],[\"但还需要判断是否存在新鲜橘子\",{\"1\":{\"944\":1}}],[\"但个人感觉没必要看\",{\"1\":{\"935\":1}}],[\"但需要浪费更多服务资源\",{\"1\":{\"917\":1}}],[\"但重试会带来更长延迟\",{\"1\":{\"917\":1}}],[\"但也没用上\",{\"1\":{\"909\":1}}],[\"但也不是我们最推荐的方式\",{\"1\":{\"774\":1}}],[\"但表名不同\",{\"1\":{\"861\":1}}],[\"但实际上该消费者已成功消费了该条消息\",{\"1\":{\"772\":1}}],[\"但实际可能并不是这样\",{\"1\":{\"488\":1}}],[\"但消费者只收到了一条消息\",{\"1\":{\"762\":1}}],[\"但对于数据量比较大\",{\"1\":{\"751\":1}}],[\"但对于那些看中启动时间的应用场景而言\",{\"1\":{\"365\":1}}],[\"但某些时候由于特定的原因导致\",{\"1\":{\"744\":1}}],[\"但吞吐量非常有限\",{\"1\":{\"724\":1}}],[\"但它不是连续的\",{\"1\":{\"929\":1,\"1038\":1}}],[\"但它们只能存储在队列中\",{\"1\":{\"692\":1}}],[\"但它的值来自后面的方法\",{\"1\":{\"317\":1}}],[\"但幻读仍可能发生\",{\"1\":{\"634\":1}}],[\"但幻读和不可重复读仍可能会发生\",{\"1\":{\"634\":1}}],[\"但proxy是控制\",{\"1\":{\"629\":1}}],[\"但没有从构造器级别去控制单例\",{\"1\":{\"626\":1}}],[\"但不应该如此\",{\"1\":{\"989\":1}}],[\"但不属于23种gof设计模式之一\",{\"1\":{\"624\":1}}],[\"但不能通过索引访问\",{\"1\":{\"416\":1}}],[\"但不能保证数据的原子性\",{\"1\":{\"281\":1}}],[\"但两者之间的区别是\",{\"1\":{\"611\":1}}],[\"但两者有什么区别呢\",{\"1\":{\"231\":1}}],[\"但其主要区别在于后者是延迟加载\",{\"1\":{\"611\":1}}],[\"但aop代理中的方法与目标对象的方法存在差异\",{\"1\":{\"603\":1}}],[\"但会堆积碎片\",{\"1\":{\"524\":1}}],[\"但直到jdk1\",{\"1\":{\"511\":1}}],[\"但jvm确实是将其作为内存分配的首选\",{\"1\":{\"502\":1}}],[\"但非绝对的\",{\"1\":{\"495\":1}}],[\"但如果显示地使用\",{\"1\":{\"488\":1}}],[\"但结果是一致的\",{\"1\":{\"487\":1}}],[\"但在这个阶段结束\",{\"1\":{\"534\":1}}],[\"但在逻辑上它应该被视为连续的\",{\"1\":{\"482\":1}}],[\"但在循环内\",{\"1\":{\"187\":1}}],[\"但字符串常量池\",{\"1\":{\"461\":1}}],[\"但字节码并不能够直接运行在操作系统之上\",{\"1\":{\"355\":1}}],[\"但己经逐步\",{\"1\":{\"461\":1}}],[\"但简单的实现可能选择不进行垃圾收集或压缩\",{\"1\":{\"441\":1}}],[\"但只要加载它们的ciassloader实例对象不同\",{\"1\":{\"395\":1}}],[\"但优化的代码执行效率更高\",{\"1\":{\"372\":1}}],[\"但程序在启动时必然需要花费更长的时间来进行编译\",{\"1\":{\"365\":1}}],[\"但编译为本地代码\",{\"1\":{\"365\":1}}],[\"但二者不能协同工作\",{\"1\":{\"349\":1}}],[\"但从\",{\"1\":{\"314\":1}}],[\"但有时很难确定\",{\"1\":{\"306\":1}}],[\"但并非数据进入方法区后就\",{\"1\":{\"305\":1}}],[\"但计数无法被重置\",{\"1\":{\"292\":1}}],[\"但可以根据构造参数指定为公平锁\",{\"1\":{\"282\":1}}],[\"但可以使用win的合并命令\",{\"1\":{\"28\":1}}],[\"但value不为null的entry\",{\"1\":{\"280\":1}}],[\"但这样必须引入一个计数器\",{\"1\":{\"964\":1}}],[\"但这不能说明把对象分配在了栈上\",{\"1\":{\"510\":1}}],[\"但这次minorgc依然是有风险的\",{\"1\":{\"504\":1}}],[\"但这两个引用是final修饰的\",{\"1\":{\"317\":1}}],[\"但这篇文档说明可以\",{\"1\":{\"279\":1}}],[\"但这里写成了object\",{\"1\":{\"266\":1}}],[\"但问题是一个\",{\"1\":{\"246\":1}}],[\"但\",{\"1\":{\"231\":1,\"239\":1,\"434\":1,\"535\":1}}],[\"但牺牲效率\",{\"1\":{\"228\":1}}],[\"但百度的数据仅限国内\",{\"1\":{\"122\":1}}],[\"但是只是最基础的\",{\"1\":{\"919\":1}}],[\"但是存在请求累积的问题\",{\"1\":{\"916\":1}}],[\"但是由于整数还会因为增加而变大\",{\"1\":{\"939\":1}}],[\"但是由于这种实现采用了动态代理\",{\"1\":{\"904\":1}}],[\"但是由于它处理时间较长\",{\"1\":{\"709\":1}}],[\"但是没有快一个数量级\",{\"1\":{\"894\":1}}],[\"但是没必要\",{\"1\":{\"188\":1}}],[\"但是你的代码里面又用不上它\",{\"1\":{\"893\":1}}],[\"但是安全性较低\",{\"1\":{\"875\":1}}],[\"但是效果始终不太理想\",{\"1\":{\"782\":1}}],[\"但是一定要保证唯一性\",{\"1\":{\"774\":1}}],[\"但是再响应客户端的时候也有可能出现网络中断或者异常等等\",{\"1\":{\"771\":1}}],[\"但是返回结果的时候网络异常\",{\"1\":{\"771\":1}}],[\"但是实现起来稍微难些\",{\"1\":{\"724\":1}}],[\"但是性价比最高\",{\"1\":{\"724\":1}}],[\"但是对于我们的简单任务队列而言\",{\"1\":{\"712\":1}}],[\"但是对于锁竞争比较激烈的场合\",{\"1\":{\"278\":1}}],[\"但是其右子节点值为\",{\"1\":{\"1028\":1}}],[\"但是其封装使后期学习曲线陡峭\",{\"1\":{\"665\":1}}],[\"但是其作用是不同的\",{\"1\":{\"89\":1}}],[\"但是外部回滚会把内部事务一起回滚回去\",{\"1\":{\"635\":1}}],[\"但是第二次同等条件下查询却有\",{\"1\":{\"634\":1}}],[\"但是变化的东西是一段代码\",{\"1\":{\"632\":1}}],[\"但是我们还是想用到jdbctemplate已有的稳定的\",{\"1\":{\"632\":1}}],[\"但是现在\",{\"1\":{\"628\":1}}],[\"但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定\",{\"1\":{\"624\":1}}],[\"但是未初始化完成的对象\",{\"1\":{\"621\":1}}],[\"但是仅仅适用于与有构造器相同参数的bean\",{\"1\":{\"598\":1}}],[\"但是有一些时候可能会做一些复杂的操作\",{\"1\":{\"569\":1}}],[\"但是还没有存储完\",{\"1\":{\"712\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"535\":1}}],[\"但是还是不建议在多线程下使用\",{\"1\":{\"247\":1}}],[\"但是还有一些对象\",{\"1\":{\"525\":1}}],[\"但是该算法不仅执行效率低下\",{\"1\":{\"523\":1}}],[\"但是取决于jvm设计者的选择\",{\"1\":{\"511\":1}}],[\"但是逃逸分析自身也是需要进行一系列复杂的分析的\",{\"1\":{\"511\":1}}],[\"但是不必然执行\",{\"1\":{\"496\":1}}],[\"但是不抛出异常\",{\"1\":{\"275\":1}}],[\"但是它仍然存在局限性\",{\"1\":{\"740\":1}}],[\"但是它表现的就和\",{\"1\":{\"737\":1}}],[\"但是它绑定的多个队列的\",{\"1\":{\"737\":1}}],[\"但是它也是即时编译器优化技术中一个十分重要的手段\",{\"1\":{\"511\":1}}],[\"但是它所包含的数据却比符号表要更加丰富一些\",{\"1\":{\"459\":1}}],[\"但是它实现调用的是该类里的本地方法\",{\"1\":{\"435\":1}}],[\"但是它却有一个别名叫做\",{\"1\":{\"305\":1,\"343\":1}}],[\"但是在最开始的时候\",{\"1\":{\"755\":1}}],[\"但是在某种场景下这种策略并不是很好\",{\"1\":{\"714\":1}}],[\"但是在老年代\",{\"1\":{\"523\":1}}],[\"但是在代码中己经不会再使用它\",{\"1\":{\"504\":1}}],[\"但是在加载自定义string类的时候会率先使用引导类加载器加载\",{\"1\":{\"392\":1}}],[\"但是在\",{\"1\":{\"387\":1}}],[\"但是在今天\",{\"1\":{\"363\":1}}],[\"但是java虚拟机规范却没有这么定义\",{\"1\":{\"381\":1}}],[\"但是目前主流的虚拟机中并没有选择这个算法来管理内存\",{\"1\":{\"321\":1}}],[\"但是这里依然存在当消息刚准备存储在磁盘的时候\",{\"1\":{\"712\":1}}],[\"但是这部分内存也被频繁地使用\",{\"1\":{\"308\":1}}],[\"但是这些优化都是在虚拟机层面实现的\",{\"1\":{\"285\":1}}],[\"但是需要借助于condition接口与newcondition\",{\"1\":{\"286\":1}}],[\"但是需要注意的是treemap它还实现了navigablemap接口和sortedmap\",{\"1\":{\"241\":1}}],[\"但是volatile\",{\"1\":{\"281\":1}}],[\"但是已经简化了属性\",{\"1\":{\"249\":1}}],[\"但是原理不变\",{\"1\":{\"244\":1}}],[\"但是如果是一个大型的网站\",{\"1\":{\"872\":1}}],[\"但是如果发现有相同\",{\"1\":{\"242\":1}}],[\"但是如果要在指定位置\",{\"1\":{\"229\":1}}],[\"但是每次插入数据时均需要申请新的堆空间\",{\"1\":{\"231\":1}}],[\"但是集合提高了数据存储的灵活性\",{\"1\":{\"217\":1}}],[\"但是\",{\"1\":{\"217\":1,\"246\":1,\"280\":1,\"308\":1,\"505\":1,\"511\":1,\"526\":1,\"615\":1,\"638\":1,\"673\":1,\"714\":1,\"717\":1,\"728\":1,\"776\":1,\"887\":1}}],[\"但是工程聚合之后\",{\"1\":{\"90\":1}}],[\"但搜索内容时\",{\"1\":{\"6\":1}}],[\"但当前和他人协作的过程中发现\",{\"1\":{\"6\":1}}],[\"但因为种种原因\",{\"1\":{\"1\":1}}],[\"1的深度为3\",{\"1\":{\"1023\":1}}],[\"1的非空二维数组\",{\"1\":{\"933\":1}}],[\"1的结果\",{\"1\":{\"182\":1}}],[\"1及更新版本或者spring\",{\"1\":{\"792\":1}}],[\"1kb\",{\"1\":{\"784\":1}}],[\"19\",{\"0\":{\"961\":1},\"1\":{\"708\":2,\"711\":1,\"747\":3,\"749\":2,\"754\":1,\"962\":1}}],[\"199\",{\"0\":{\"1032\":1},\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"1997年由sun收购而来\",{\"1\":{\"351\":1}}],[\"192\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"13\",{\"1\":{\"678\":1,\"712\":1,\"747\":2,\"749\":2}}],[\"14\",{\"1\":{\"614\":1,\"757\":1}}],[\"14dc4f801513\",{\"1\":{\"483\":1}}],[\"1ang\",{\"1\":{\"452\":1}}],[\"1ib\",{\"1\":{\"382\":1}}],[\"1b4505979a17\",{\"1\":{\"343\":1}}],[\"1b6d3586\",{\"1\":{\"332\":1}}],[\"18b4aac2\",{\"1\":{\"332\":1}}],[\"18\",{\"1\":{\"241\":1,\"742\":1,\"757\":2,\"847\":1,\"848\":1,\"851\":1,\"854\":1}}],[\"17\",{\"1\":{\"241\":1,\"701\":3,\"734\":1,\"738\":1,\"754\":1,\"755\":1,\"762\":1,\"765\":1,\"768\":1}}],[\"1或i\",{\"1\":{\"200\":1}}],[\"169\",{\"1\":{\"753\":1,\"762\":1,\"765\":1}}],[\"169698662\",{\"1\":{\"595\":1}}],[\"168\",{\"1\":{\"697\":1,\"698\":1,\"701\":1}}],[\"16t10\",{\"1\":{\"569\":1}}],[\"16次无符号右移呢\",{\"1\":{\"253\":1}}],[\"16\",{\"1\":{\"184\":1,\"239\":2,\"241\":1,\"244\":1,\"253\":2,\"569\":1,\"762\":1}}],[\"15672\",{\"1\":{\"695\":1}}],[\"150\",{\"1\":{\"649\":1}}],[\"1596950825906\",{\"1\":{\"483\":1}}],[\"1595518477978\",{\"1\":{\"388\":1}}],[\"1595094774889\",{\"1\":{\"381\":1}}],[\"1595048291864\",{\"1\":{\"343\":1}}],[\"15\",{\"1\":{\"184\":1,\"701\":1,\"734\":1,\"1038\":1}}],[\"1背包问题\",{\"1\":{\"178\":1,\"180\":1}}],[\"112\",{\"1\":{\"753\":1,\"762\":1,\"765\":1}}],[\"1111\",{\"1\":{\"253\":15}}],[\"1110\",{\"1\":{\"253\":1}}],[\"11\",{\"0\":{\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1},\"1\":{\"239\":1,\"562\":1,\"678\":1,\"695\":1,\"701\":3,\"708\":2,\"711\":2,\"717\":1,\"722\":1,\"723\":1,\"734\":2,\"738\":1,\"741\":1,\"742\":1,\"747\":3,\"748\":1,\"749\":2,\"753\":1,\"754\":4,\"755\":4,\"757\":4,\"762\":4,\"765\":1,\"768\":2,\"779\":3}}],[\"10步完好地封装起来\",{\"1\":{\"874\":1}}],[\"10s\",{\"1\":{\"747\":1,\"748\":1,\"754\":5,\"755\":1}}],[\"1024\",{\"1\":{\"410\":3}}],[\"1024m的内存\",{\"1\":{\"336\":1}}],[\"10进制表示为511\",{\"1\":{\"253\":1}}],[\"1010\",{\"1\":{\"253\":1}}],[\"10054\",{\"0\":{\"587\":1},\"1\":{\"587\":1}}],[\"10000\",{\"1\":{\"708\":1,\"747\":1,\"748\":1,\"754\":1}}],[\"1000000007l\",{\"1\":{\"194\":1}}],[\"1000\",{\"1\":{\"253\":5,\"708\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1}}],[\"100\",{\"1\":{\"198\":1,\"717\":1,\"723\":1,\"944\":4}}],[\"1001000\",{\"1\":{\"184\":1}}],[\"1001011\",{\"1\":{\"184\":1}}],[\"1001100\",{\"1\":{\"184\":2}}],[\"1001101\",{\"1\":{\"184\":1}}],[\"10\",{\"0\":{\"96\":1,\"97\":1,\"98\":1,\"99\":1},\"1\":{\"548\":1,\"559\":4,\"562\":2,\"568\":3,\"569\":5,\"678\":1,\"697\":3,\"708\":1,\"734\":2,\"738\":1,\"741\":1,\"742\":1,\"747\":8,\"748\":3,\"749\":4,\"753\":1,\"754\":4,\"755\":1,\"777\":3,\"779\":4,\"780\":2,\"817\":1,\"853\":1,\"957\":1,\"1005\":2,\"1006\":3,\"1007\":1,\"1008\":1}}],[\"127\",{\"1\":{\"864\":1}}],[\"123456\",{\"1\":{\"697\":1,\"698\":1,\"701\":1,\"753\":1,\"762\":1,\"765\":1,\"864\":1,\"866\":2}}],[\"12\",{\"1\":{\"78\":1,\"244\":1,\"678\":1,\"762\":4,\"765\":1,\"768\":2,\"779\":2,\"1038\":1}}],[\"1<\",{\"1\":{\"70\":1,\"830\":1,\"863\":1}}],[\"1\",{\"0\":{\"6\":1,\"7\":2,\"8\":1,\"10\":1,\"15\":1,\"18\":1,\"21\":1,\"59\":1,\"61\":1,\"65\":1,\"67\":1,\"73\":1,\"80\":1,\"83\":1,\"85\":1,\"87\":1,\"94\":1,\"97\":1,\"101\":1,\"105\":1,\"355\":1,\"356\":2,\"358\":1,\"361\":1,\"365\":1,\"369\":1,\"382\":1,\"395\":1,\"401\":1,\"427\":1,\"439\":1,\"441\":1,\"447\":1,\"452\":1,\"461\":1,\"467\":1,\"468\":2,\"469\":1,\"470\":1,\"476\":1,\"494\":1,\"508\":1,\"515\":1,\"521\":1},\"1\":{\"61\":1,\"62\":1,\"77\":3,\"78\":3,\"85\":4,\"97\":1,\"98\":1,\"104\":1,\"114\":1,\"170\":1,\"183\":1,\"184\":5,\"186\":1,\"187\":1,\"189\":1,\"190\":1,\"194\":16,\"198\":5,\"199\":3,\"200\":9,\"201\":10,\"202\":7,\"203\":9,\"204\":7,\"205\":7,\"207\":11,\"229\":2,\"231\":1,\"233\":5,\"234\":3,\"239\":4,\"244\":5,\"246\":2,\"247\":1,\"253\":5,\"258\":1,\"266\":1,\"271\":1,\"278\":2,\"284\":1,\"292\":2,\"300\":3,\"304\":2,\"305\":2,\"318\":1,\"319\":1,\"321\":2,\"337\":2,\"338\":4,\"343\":1,\"359\":1,\"442\":2,\"448\":1,\"449\":2,\"461\":3,\"483\":1,\"488\":4,\"510\":2,\"513\":1,\"534\":1,\"539\":1,\"548\":5,\"549\":5,\"559\":3,\"568\":3,\"573\":6,\"584\":1,\"592\":1,\"600\":1,\"617\":1,\"627\":1,\"651\":1,\"665\":7,\"669\":1,\"675\":3,\"678\":1,\"685\":1,\"697\":5,\"698\":2,\"701\":1,\"708\":4,\"714\":4,\"717\":5,\"720\":1,\"734\":1,\"747\":1,\"748\":1,\"749\":1,\"755\":1,\"762\":2,\"777\":1,\"779\":2,\"784\":3,\"819\":2,\"832\":1,\"836\":1,\"858\":1,\"860\":2,\"861\":1,\"864\":1,\"866\":2,\"874\":2,\"875\":1,\"876\":1,\"877\":1,\"878\":1,\"879\":1,\"902\":2,\"925\":4,\"926\":3,\"929\":5,\"931\":6,\"933\":28,\"934\":6,\"935\":1,\"937\":8,\"938\":6,\"939\":14,\"943\":9,\"944\":9,\"948\":1,\"949\":5,\"953\":1,\"957\":2,\"967\":2,\"968\":1,\"970\":1,\"981\":1,\"982\":11,\"1003\":1,\"1018\":5,\"1022\":1,\"1023\":1,\"1028\":4,\"1033\":4,\"1035\":1,\"1038\":6,\"1040\":6}}],[\"i存到code的高位\",{\"1\":{\"944\":1}}],[\"i和j的最大值是10\",{\"1\":{\"944\":1}}],[\"i处的max的值都确定了\",{\"1\":{\"925\":1}}],[\"ipage<map<string\",{\"1\":{\"832\":1}}],[\"ipage<t>>\",{\"1\":{\"832\":1}}],[\"ibaseservice\",{\"1\":{\"833\":1}}],[\"ibatis\",{\"1\":{\"831\":1,\"835\":1,\"836\":1}}],[\"ibm公司的专门研究表明\",{\"1\":{\"488\":1}}],[\"ibm\",{\"0\":{\"353\":1},\"1\":{\"353\":1,\"444\":1,\"445\":1,\"461\":1}}],[\"iuserdao\",{\"1\":{\"609\":1}}],[\"i18n\",{\"1\":{\"591\":1}}],[\"ireturn\",{\"1\":{\"424\":1}}],[\"iang\",{\"1\":{\"382\":1}}],[\"it\",{\"1\":{\"515\":1}}],[\"it4j\",{\"1\":{\"353\":1}}],[\"item\",{\"1\":{\"810\":2}}],[\"items\",{\"1\":{\"42\":1}}],[\"iteratorbinarysearch\",{\"1\":{\"230\":1}}],[\"iterator\",{\"1\":{\"230\":2}}],[\"isvalidbst\",{\"1\":{\"1029\":1,\"1030\":1}}],[\"isvegetarian\",{\"1\":{\"548\":1}}],[\"issubtree\",{\"1\":{\"1020\":3}}],[\"issametree\",{\"1\":{\"1019\":1,\"1020\":4}}],[\"ispalindrome\",{\"1\":{\"973\":1,\"975\":1}}],[\"isdigit\",{\"1\":{\"957\":3}}],[\"isdeleted\",{\"1\":{\"840\":1}}],[\"iservice<user>\",{\"1\":{\"833\":1}}],[\"iservice和其实现类\",{\"1\":{\"833\":1}}],[\"isempty\",{\"1\":{\"194\":2,\"944\":1,\"982\":1,\"983\":1,\"1024\":1,\"1030\":1,\"1035\":1}}],[\"isnull\",{\"1\":{\"846\":1,\"847\":1,\"848\":1,\"851\":1,\"854\":1}}],[\"isnotblank\",{\"1\":{\"852\":2,\"853\":1}}],[\"isnotnull\",{\"1\":{\"844\":1}}],[\"isnotempty\",{\"1\":{\"832\":1}}],[\"isnan\",{\"1\":{\"239\":1}}],[\"isolation\",{\"1\":{\"577\":1,\"634\":7}}],[\"iso\",{\"1\":{\"573\":2}}],[\"is\",{\"1\":{\"515\":1,\"832\":2,\"840\":4,\"847\":1,\"848\":1,\"850\":1,\"851\":2,\"852\":1,\"975\":1}}],[\"illegalaccesserror\",{\"1\":{\"422\":2}}],[\"illegalargumentexception\",{\"1\":{\"239\":2,\"998\":1}}],[\"illegal\",{\"1\":{\"239\":2}}],[\"i=list\",{\"1\":{\"230\":1}}],[\"i=0\",{\"1\":{\"230\":1}}],[\"i代表当前物品\",{\"1\":{\"207\":1}}],[\"i为使用的空间\",{\"1\":{\"207\":1}}],[\"i为奇数时\",{\"1\":{\"203\":1}}],[\"i>>1\",{\"1\":{\"203\":3}}],[\"i<<1\",{\"1\":{\"198\":2}}],[\"i+j\",{\"1\":{\"549\":1}}],[\"i+2\",{\"1\":{\"188\":2}}],[\"i+1\",{\"1\":{\"188\":2,\"198\":1,\"204\":1,\"205\":1,\"931\":1,\"957\":1,\"1040\":1}}],[\"i++\",{\"1\":{\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":3,\"203\":2,\"204\":1,\"205\":1,\"207\":2,\"230\":1,\"722\":1,\"723\":1,\"747\":1,\"748\":1,\"779\":1,\"925\":1,\"931\":1,\"934\":1,\"938\":1,\"943\":2,\"944\":1,\"948\":1,\"949\":1,\"957\":1,\"1035\":1,\"1040\":1}}],[\"i会在0和1之间不断切换\",{\"1\":{\"183\":1}}],[\"icomoon\",{\"1\":{\"139\":1}}],[\"icon\",{\"1\":{\"139\":2}}],[\"icons\",{\"1\":{\"139\":3}}],[\"iconfont\",{\"1\":{\"54\":1,\"139\":1}}],[\"ikonate\",{\"1\":{\"139\":1}}],[\"ihateregex\",{\"1\":{\"137\":1}}],[\"i\",{\"1\":{\"129\":1,\"183\":2,\"184\":17,\"186\":5,\"187\":6,\"188\":4,\"189\":4,\"190\":4,\"198\":4,\"199\":2,\"200\":9,\"201\":7,\"202\":17,\"203\":12,\"204\":8,\"205\":8,\"207\":33,\"229\":6,\"230\":4,\"257\":1,\"291\":2,\"308\":1,\"548\":2,\"549\":4,\"722\":3,\"723\":3,\"747\":3,\"748\":3,\"779\":4,\"848\":2,\"851\":2,\"854\":2,\"925\":9,\"926\":16,\"931\":3,\"934\":8,\"937\":2,\"938\":8,\"943\":13,\"944\":4,\"948\":3,\"949\":3,\"954\":12,\"957\":3,\"1035\":3,\"1040\":3}}],[\"idl\",{\"1\":{\"919\":2}}],[\"idlist\",{\"1\":{\"832\":2}}],[\"idtype\",{\"1\":{\"836\":1}}],[\"idtype里定义\",{\"1\":{\"836\":1}}],[\"id已经被设置到对象中\",{\"1\":{\"815\":1}}],[\"ide会警告你\",{\"1\":{\"792\":1}}],[\"idea中的快捷键\",{\"1\":{\"670\":1}}],[\"idea中maven配置\",{\"0\":{\"92\":1}}],[\"idea如何显示编译后的类\",{\"0\":{\"12\":1}}],[\"idea\",{\"0\":{\"5\":1,\"20\":1},\"1\":{\"23\":1,\"672\":1,\"867\":1},\"2\":{\"25\":1}}],[\"id+\",{\"1\":{\"774\":1}}],[\"id=1\",{\"1\":{\"860\":2}}],[\"id=\",{\"1\":{\"617\":1,\"814\":2,\"815\":1,\"819\":2,\"820\":1,\"840\":1}}],[\"id\",{\"1\":{\"65\":2,\"114\":3,\"577\":1,\"584\":1,\"585\":1,\"619\":1,\"693\":1,\"697\":2,\"720\":2,\"762\":6,\"765\":5,\"773\":4,\"774\":1,\"815\":1,\"816\":2,\"819\":1,\"820\":4,\"827\":1,\"832\":2,\"836\":3,\"840\":1,\"845\":1,\"850\":7,\"852\":1,\"860\":2,\"891\":3}}],[\"id>\",{\"1\":{\"61\":2,\"99\":2,\"106\":1}}],[\"ioexception\",{\"1\":{\"697\":2,\"698\":2,\"701\":4,\"722\":2,\"723\":2,\"734\":2,\"738\":2,\"742\":2,\"747\":6,\"748\":2,\"749\":2,\"754\":1,\"991\":1}}],[\"io<\",{\"1\":{\"696\":2}}],[\"ioc容器中仅存在一个bean实例\",{\"1\":{\"615\":1}}],[\"ioc时\",{\"1\":{\"601\":1}}],[\"ioc注入的方式\",{\"0\":{\"597\":1}}],[\"ioc源码阅读\",{\"1\":{\"595\":1}}],[\"ioc的初始化过程\",{\"1\":{\"595\":1}}],[\"ioc\",{\"0\":{\"595\":1},\"1\":{\"590\":1,\"592\":1,\"595\":9,\"610\":1,\"889\":1}}],[\"io\",{\"1\":{\"53\":1,\"267\":1,\"697\":1,\"698\":1,\"701\":2,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"754\":1,\"1009\":1}}],[\"ie=utf\",{\"1\":{\"41\":1}}],[\"inorder\",{\"1\":{\"1030\":4}}],[\"inordertraversalnor\",{\"1\":{\"1024\":1}}],[\"inordertraversal\",{\"1\":{\"1024\":3}}],[\"insql\",{\"1\":{\"850\":1}}],[\"inserted\",{\"1\":{\"815\":1}}],[\"insert>\",{\"1\":{\"815\":1}}],[\"insertname\",{\"1\":{\"815\":2}}],[\"insert\",{\"1\":{\"815\":3,\"832\":1}}],[\"instances\",{\"1\":{\"701\":1}}],[\"instance\",{\"0\":{\"477\":1}}],[\"instanceof\",{\"1\":{\"230\":1}}],[\"instant类对时间轴上的单一瞬时点建模\",{\"1\":{\"557\":1}}],[\"instant类\",{\"0\":{\"557\":1}}],[\"instant\",{\"1\":{\"139\":1,\"555\":1,\"571\":3}}],[\"install\",{\"1\":{\"77\":1,\"90\":2,\"99\":1}}],[\"inherited\",{\"1\":{\"791\":1}}],[\"inject注解\",{\"1\":{\"609\":1}}],[\"inject时\",{\"1\":{\"601\":1}}],[\"incoming\",{\"1\":{\"687\":2}}],[\"incremental\",{\"1\":{\"526\":1}}],[\"includes>\",{\"1\":{\"99\":4,\"106\":1}}],[\"include>\",{\"1\":{\"99\":4,\"106\":1}}],[\"includebasedirectory>\",{\"1\":{\"99\":1}}],[\"inverse\",{\"1\":{\"595\":1}}],[\"invisible\",{\"1\":{\"505\":1}}],[\"invoker代表一个抽象封装了的执行体\",{\"1\":{\"883\":1}}],[\"invoker\",{\"1\":{\"883\":1,\"890\":2,\"891\":1}}],[\"invokespecial\",{\"1\":{\"474\":1}}],[\"invokestatic\",{\"1\":{\"397\":1}}],[\"invokedynamic\",{\"1\":{\"421\":1}}],[\"invoke\",{\"1\":{\"397\":1,\"818\":1,\"821\":1}}],[\"invocationhandler\",{\"1\":{\"818\":1}}],[\"invocation\",{\"1\":{\"347\":1}}],[\"ing\",{\"1\":{\"317\":7}}],[\"init\",{\"0\":{\"314\":1,\"474\":1},\"1\":{\"614\":1,\"649\":1,\"687\":1,\"762\":1,\"765\":1,\"1008\":1}}],[\"initializer\",{\"1\":{\"678\":1}}],[\"initialization\",{\"0\":{\"380\":1},\"1\":{\"619\":2}}],[\"initialheapsize\",{\"1\":{\"485\":1}}],[\"initial\",{\"1\":{\"239\":1,\"345\":1}}],[\"initialcapacity\",{\"1\":{\"239\":8}}],[\"input\",{\"1\":{\"308\":1,\"836\":1}}],[\"into\",{\"1\":{\"815\":1}}],[\"introduce\",{\"1\":{\"619\":1}}],[\"introduction\",{\"1\":{\"604\":1}}],[\"int类型时使用\",{\"1\":{\"424\":1}}],[\"ints\",{\"1\":{\"198\":8}}],[\"int\",{\"1\":{\"183\":1,\"184\":2,\"186\":4,\"187\":5,\"188\":4,\"189\":5,\"190\":5,\"194\":8,\"198\":6,\"199\":5,\"200\":4,\"201\":4,\"202\":18,\"203\":12,\"204\":9,\"205\":9,\"207\":12,\"229\":3,\"230\":2,\"233\":3,\"234\":1,\"239\":5,\"241\":3,\"242\":1,\"244\":4,\"253\":3,\"257\":3,\"258\":5,\"291\":1,\"510\":6,\"549\":4,\"714\":1,\"717\":2,\"722\":2,\"723\":4,\"747\":1,\"748\":1,\"754\":1,\"765\":1,\"779\":1,\"815\":1,\"832\":8,\"846\":1,\"847\":1,\"848\":1,\"851\":1,\"854\":1,\"925\":7,\"931\":4,\"934\":14,\"938\":4,\"939\":9,\"943\":16,\"944\":16,\"948\":1,\"949\":2,\"954\":2,\"957\":3,\"963\":3,\"965\":4,\"968\":2,\"973\":2,\"982\":13,\"983\":4,\"984\":7,\"1022\":4,\"1029\":3,\"1034\":3,\"1035\":2,\"1040\":4}}],[\"intercept\",{\"1\":{\"818\":1}}],[\"interceptor\",{\"1\":{\"818\":1,\"857\":3,\"860\":4}}],[\"interceptor>\",{\"1\":{\"656\":2}}],[\"interceptors>\",{\"1\":{\"656\":2}}],[\"interceptor需要在springmvc中配置\",{\"1\":{\"648\":1}}],[\"interruptedexception\",{\"1\":{\"708\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1}}],[\"interpreter\",{\"1\":{\"362\":2}}],[\"intern字符串的缓存和静态变量并不是被转移到元数据区\",{\"1\":{\"511\":1}}],[\"intern字符串的缓存和静态变量曾经都被分配在永久代上\",{\"1\":{\"511\":1}}],[\"intern\",{\"0\":{\"318\":1},\"1\":{\"318\":4,\"319\":4}}],[\"interface\",{\"1\":{\"230\":1,\"687\":2,\"791\":1,\"792\":1,\"819\":1,\"832\":1,\"833\":1,\"892\":1,\"919\":1}}],[\"integer>>\",{\"1\":{\"982\":1}}],[\"integer>\",{\"1\":{\"944\":2,\"982\":1}}],[\"integer\",{\"1\":{\"184\":1,\"202\":1,\"233\":1,\"234\":2,\"241\":5,\"673\":1,\"757\":1,\"840\":1,\"853\":2,\"859\":1,\"860\":2,\"957\":1,\"1029\":2}}],[\"integration\",{\"1\":{\"22\":1,\"94\":2}}],[\"intellij\",{\"0\":{\"5\":1},\"1\":{\"23\":1}}],[\"inf\",{\"1\":{\"103\":2,\"670\":1,\"674\":1,\"683\":1,\"686\":1,\"892\":1}}],[\"infoentry\",{\"1\":{\"788\":9}}],[\"info5\",{\"1\":{\"749\":2,\"778\":2}}],[\"infoq\",{\"1\":{\"120\":1}}],[\"info\",{\"1\":{\"78\":4,\"85\":7,\"103\":1,\"105\":1,\"106\":1,\"340\":2,\"379\":3,\"736\":1,\"738\":3,\"740\":3,\"747\":1,\"748\":1,\"754\":2,\"755\":2,\"757\":2,\"762\":5,\"765\":2,\"779\":2,\"780\":1}}],[\"info下的三个选项都进行勾选\",{\"1\":{\"16\":1}}],[\"in\",{\"1\":{\"91\":1,\"201\":5,\"343\":1,\"358\":1,\"367\":1,\"416\":1,\"515\":1,\"549\":1,\"614\":2,\"701\":1,\"708\":1,\"711\":1,\"712\":1,\"734\":1,\"822\":1,\"850\":1}}],[\"indexofsublist\",{\"1\":{\"258\":1}}],[\"indexedbinarysearch\",{\"1\":{\"230\":1}}],[\"index\",{\"1\":{\"55\":2,\"229\":3,\"230\":1}}],[\"immutablemap\",{\"1\":{\"993\":1}}],[\"impl\",{\"1\":{\"831\":1,\"835\":1,\"836\":1}}],[\"implements\",{\"1\":{\"251\":1,\"673\":1,\"687\":1,\"762\":1,\"765\":1,\"833\":1}}],[\"importing\",{\"1\":{\"7\":1}}],[\"import\",{\"0\":{\"7\":1},\"1\":{\"7\":1,\"80\":1,\"605\":3,\"674\":1,\"687\":2,\"697\":5,\"698\":3,\"701\":14,\"708\":7,\"711\":3,\"722\":5,\"723\":5,\"734\":5,\"738\":7,\"742\":8,\"747\":24,\"753\":4,\"754\":30,\"755\":6,\"757\":5,\"762\":22,\"768\":4,\"779\":9,\"982\":1,\"983\":1}}],[\"img\",{\"1\":{\"143\":1,\"309\":1,\"874\":1,\"889\":1,\"912\":1}}],[\"images\",{\"1\":{\"71\":1,\"78\":1}}],[\"image\",{\"1\":{\"11\":1,\"16\":1,\"18\":1,\"21\":1,\"539\":1,\"583\":2,\"642\":1,\"693\":1,\"695\":2,\"701\":3,\"702\":1,\"706\":1,\"707\":1,\"709\":3,\"711\":2,\"714\":1,\"715\":1,\"717\":1,\"718\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":2,\"733\":1,\"734\":2,\"736\":1,\"737\":1,\"738\":2,\"741\":1,\"742\":1,\"746\":1,\"747\":3,\"748\":1,\"749\":2,\"751\":1,\"754\":2,\"755\":2,\"756\":1,\"757\":2,\"761\":1,\"762\":2,\"765\":1,\"768\":3,\"777\":1,\"779\":1,\"780\":1,\"783\":1,\"784\":1,\"842\":1}}],[\"if\",{\"1\":{\"6\":1,\"186\":2,\"187\":1,\"188\":1,\"194\":5,\"198\":1,\"199\":2,\"200\":1,\"201\":1,\"202\":4,\"203\":1,\"230\":1,\"239\":3,\"242\":2,\"722\":1,\"723\":2,\"749\":1,\"762\":1,\"765\":1,\"779\":1,\"788\":1,\"832\":2,\"925\":2,\"931\":2,\"934\":3,\"938\":1,\"939\":2,\"943\":4,\"944\":3,\"948\":1,\"949\":1,\"954\":1,\"957\":3,\"963\":1,\"969\":1,\"973\":2,\"975\":2,\"982\":4,\"983\":6,\"984\":2,\"1020\":3,\"1022\":1,\"1024\":10,\"1029\":5,\"1030\":1,\"1034\":2,\"1035\":4,\"1040\":2}}],[\"j最多可以移到数组的最后一个元素处\",{\"1\":{\"954\":1}}],[\"j右移\",{\"1\":{\"954\":1}}],[\"j+1\",{\"1\":{\"939\":3}}],[\"j+1这个数出现的次数\",{\"1\":{\"939\":1}}],[\"j++\",{\"1\":{\"201\":1,\"207\":1,\"925\":1,\"934\":1,\"939\":1,\"943\":2,\"944\":1,\"954\":1}}],[\"jwtaccessdeniedhandler\",{\"1\":{\"788\":1}}],[\"jwtauthenticationfilter\",{\"1\":{\"788\":1}}],[\"jndiobjectfactorybean等\",{\"1\":{\"628\":1}}],[\"jndi\",{\"1\":{\"628\":1}}],[\"jni规范描述了用jni\",{\"1\":{\"347\":1}}],[\"jcenter\",{\"1\":{\"1009\":1}}],[\"jca\",{\"1\":{\"591\":1}}],[\"jconsole\",{\"1\":{\"341\":1,\"492\":1}}],[\"jmx\",{\"1\":{\"591\":1}}],[\"jms\",{\"1\":{\"591\":1}}],[\"jmap\",{\"1\":{\"340\":1,\"492\":1}}],[\"joda\",{\"1\":{\"574\":1}}],[\"joinonwithmap\",{\"1\":{\"993\":1}}],[\"joinonjoin\",{\"1\":{\"990\":1}}],[\"joining\",{\"1\":{\"992\":1}}],[\"joinbystream\",{\"1\":{\"992\":1}}],[\"joinappendto\",{\"1\":{\"991\":1}}],[\"joiner配置方法将始终返回一个新的joiner\",{\"1\":{\"993\":1}}],[\"joiner实例总是不可变的\",{\"1\":{\"993\":1}}],[\"joinertest\",{\"1\":{\"990\":1}}],[\"joiner\",{\"0\":{\"989\":1},\"1\":{\"988\":1,\"989\":1,\"990\":4,\"991\":2,\"992\":1,\"993\":1},\"2\":{\"1000\":1}}],[\"joinpoint\",{\"1\":{\"605\":2}}],[\"join\",{\"0\":{\"297\":1,\"990\":1,\"993\":1},\"1\":{\"604\":1,\"990\":8,\"992\":1,\"993\":3}}],[\"join实际上是thread类的方法\",{\"1\":{\"266\":1}}],[\"jep363中\",{\"1\":{\"534\":1}}],[\"jep122\",{\"1\":{\"462\":1}}],[\"jetty\",{\"1\":{\"888\":1}}],[\"jet\",{\"1\":{\"367\":1}}],[\"jetbrains插件\",{\"1\":{\"55\":1}}],[\"jdbc\",{\"1\":{\"591\":1,\"664\":1,\"676\":1,\"806\":1,\"810\":1,\"831\":2,\"864\":1,\"866\":4}}],[\"jdt\",{\"1\":{\"367\":1}}],[\"jdk标准的spi会一次性加载所有的扩展实现\",{\"1\":{\"909\":1}}],[\"jdk动态代理\",{\"1\":{\"627\":1}}],[\"jdk动态代理和cglib代理有什么区别\",{\"0\":{\"606\":1}}],[\"jdk的动态代理主要涉及java\",{\"1\":{\"603\":1}}],[\"jdk的动态代理\",{\"1\":{\"603\":1}}],[\"jdk本身只提供接口的代理\",{\"1\":{\"603\":1}}],[\"jdk己经发生了很大变化\",{\"1\":{\"511\":1}}],[\"jdk6\",{\"1\":{\"504\":1}}],[\"jdk命令行\",{\"1\":{\"492\":1}}],[\"jdk8及以后\",{\"0\":{\"448\":1}}],[\"jdk8\",{\"0\":{\"445\":1},\"1\":{\"444\":1}}],[\"jdk7中将\",{\"1\":{\"463\":1}}],[\"jdk7及以前\",{\"0\":{\"444\":1,\"447\":1}}],[\"jdk7\",{\"1\":{\"397\":1}}],[\"jdk7之后称为元空间\",{\"1\":{\"374\":1}}],[\"jdk7之前称为永久代\",{\"1\":{\"374\":1}}],[\"jdki\",{\"1\":{\"387\":2}}],[\"jdk9被deprecated\",{\"1\":{\"339\":1}}],[\"jdk\",{\"0\":{\"340\":1,\"341\":1,\"893\":1},\"1\":{\"244\":4,\"247\":1,\"285\":1,\"300\":1,\"304\":1,\"338\":1,\"343\":1,\"351\":1,\"359\":1,\"383\":1,\"461\":3,\"483\":1,\"540\":1,\"596\":1,\"606\":2,\"696\":1,\"816\":1,\"818\":1,\"894\":1,\"909\":1,\"1003\":1}}],[\"jdk11\",{\"1\":{\"464\":1}}],[\"jdk1\",{\"0\":{\"244\":1,\"245\":1,\"251\":1,\"252\":1,\"532\":1},\"1\":{\"219\":2,\"222\":3,\"229\":2,\"231\":2,\"234\":1,\"239\":1,\"244\":4,\"245\":2,\"249\":11,\"278\":1,\"285\":1,\"286\":1,\"307\":3,\"308\":1,\"317\":2,\"318\":2,\"324\":1,\"338\":1,\"339\":3,\"349\":1,\"350\":1,\"351\":1,\"532\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":3}}],[\"jdk中的实现\",{\"1\":{\"184\":1}}],[\"jdk在1\",{\"1\":{\"104\":1}}],[\"jdk>\",{\"1\":{\"61\":1}}],[\"j9等来说\",{\"1\":{\"461\":1}}],[\"j9\",{\"0\":{\"353\":1},\"1\":{\"353\":1,\"444\":1,\"445\":1}}],[\"jhat\",{\"1\":{\"340\":1}}],[\"jit分类\",{\"0\":{\"372\":1}}],[\"jit\",{\"0\":{\"358\":1,\"364\":1,\"367\":1},\"1\":{\"358\":1,\"365\":2,\"372\":1,\"451\":1}}],[\"jit的缺点\",{\"1\":{\"349\":1}}],[\"jit会把热点代码\",{\"1\":{\"349\":1}}],[\"jit编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程\",{\"1\":{\"509\":1}}],[\"jit编译器在编译期间根据逃逸分析的结果\",{\"1\":{\"508\":1}}],[\"jit编译器在运行时会针对那些频繁被调用的\",{\"1\":{\"368\":1}}],[\"jit编译器才会将这些\",{\"1\":{\"368\":1}}],[\"jit编译器\",{\"1\":{\"343\":1,\"367\":2}}],[\"jinfo\",{\"1\":{\"340\":1,\"449\":2,\"492\":1,\"503\":1}}],[\"jianshu\",{\"1\":{\"279\":1,\"677\":1}}],[\"jpa启动器依赖就能使用了\",{\"1\":{\"682\":1}}],[\"jpa访问数据库\",{\"1\":{\"682\":1}}],[\"jprofiler\",{\"1\":{\"492\":1,\"540\":1}}],[\"jps获取当前进程的进程号\",{\"1\":{\"449\":1}}],[\"jps\",{\"1\":{\"340\":1,\"487\":1,\"503\":1}}],[\"jpg\",{\"1\":{\"132\":1}}],[\"jre大部分是用java实现的\",{\"1\":{\"435\":1}}],[\"jre\",{\"1\":{\"331\":1,\"382\":1,\"383\":1}}],[\"jrebel是一款热部署插件\",{\"1\":{\"672\":1}}],[\"jrebel\",{\"0\":{\"672\":1},\"1\":{\"22\":1,\"672\":1}}],[\"jrockit客户不需要配置永久代\",{\"1\":{\"462\":1}}],[\"jrockit\",{\"0\":{\"352\":1},\"1\":{\"306\":1,\"352\":2,\"365\":1,\"444\":1,\"445\":1,\"461\":1,\"462\":1}}],[\"just\",{\"1\":{\"358\":1,\"367\":1}}],[\"juc包下熟悉哪些类\",{\"0\":{\"292\":1}}],[\"juc下\",{\"1\":{\"265\":1}}],[\"juc\",{\"1\":{\"256\":1,\"259\":1}}],[\"jumps\",{\"1\":{\"235\":1}}],[\"junit\",{\"1\":{\"78\":2,\"80\":1}}],[\"j代表当前可以使用的容量\",{\"1\":{\"207\":1}}],[\"j\",{\"1\":{\"201\":5,\"204\":2,\"205\":2,\"207\":6,\"257\":1,\"549\":5,\"925\":4,\"926\":6,\"934\":8,\"939\":8,\"943\":13,\"944\":4,\"954\":14}}],[\"jgraph\",{\"1\":{\"110\":2}}],[\"jstack\",{\"1\":{\"340\":1}}],[\"jstat\",{\"1\":{\"340\":1,\"487\":1,\"492\":1}}],[\"js实现的vue拖拽插件\",{\"1\":{\"160\":1}}],[\"js\",{\"1\":{\"150\":1,\"159\":4,\"788\":1}}],[\"jsdelivr\",{\"1\":{\"135\":1}}],[\"js标准内置对象\",{\"1\":{\"119\":1}}],[\"jsp视图解析器默认使用jstl\",{\"1\":{\"654\":1}}],[\"jsp应用\",{\"1\":{\"378\":1}}],[\"jsp\",{\"1\":{\"80\":1,\"464\":2,\"646\":1}}],[\"jsonp\",{\"1\":{\"673\":2}}],[\"json\",{\"1\":{\"41\":1,\"42\":1,\"651\":3}}],[\"ja\",{\"1\":{\"319\":1}}],[\"jar包中的resources\",{\"1\":{\"683\":1}}],[\"jar包中的string类\",{\"1\":{\"392\":1}}],[\"jar包中java\",{\"1\":{\"392\":1}}],[\"jar<\",{\"1\":{\"99\":1}}],[\"jar代表生成jar\",{\"1\":{\"70\":1}}],[\"jar\",{\"0\":{\"103\":1,\"686\":2},\"1\":{\"65\":3,\"77\":4,\"78\":5,\"80\":6,\"81\":1,\"82\":1,\"85\":12,\"97\":1,\"98\":1,\"99\":1,\"103\":3,\"106\":8,\"331\":4,\"382\":2,\"383\":1,\"602\":1,\"661\":2,\"668\":4,\"686\":12,\"892\":1}}],[\"java目录下\",{\"1\":{\"1012\":1}}],[\"java内置的拆分方法有一些奇怪的行为\",{\"1\":{\"995\":1}}],[\"java内的commons\",{\"1\":{\"83\":1}}],[\"java自带序列化\",{\"1\":{\"898\":1}}],[\"javassist\",{\"0\":{\"894\":1},\"1\":{\"889\":1,\"894\":2}}],[\"javassist字节码生成技术\",{\"1\":{\"878\":1}}],[\"java提供了nio的解决方案\",{\"1\":{\"878\":1}}],[\"javatype=\",{\"1\":{\"820\":1}}],[\"javatpoint\",{\"1\":{\"318\":2}}],[\"java技术栈\",{\"1\":{\"795\":1}}],[\"java在编译之后会生成一个class文件\",{\"1\":{\"608\":1}}],[\"java反射机制是在运行状态中\",{\"1\":{\"608\":1}}],[\"javaguide\",{\"1\":{\"590\":3,\"594\":1,\"824\":1}}],[\"javagc机制\",{\"1\":{\"518\":1}}],[\"java类的引用类型静态变量\",{\"1\":{\"519\":1}}],[\"java类文章\",{\"1\":{\"262\":1}}],[\"java对象的回收方式\",{\"1\":{\"518\":1}}],[\"javap\",{\"1\":{\"492\":1}}],[\"java的垃圾回收器都有哪些\",{\"1\":{\"518\":1}}],[\"java的设计者们不仅需要考虑内存如何分配\",{\"1\":{\"490\":1}}],[\"java的指令都是根据栈来设计的\",{\"1\":{\"405\":1}}],[\"java堆区进一步细分的话\",{\"1\":{\"488\":1}}],[\"java堆区在jvm启动的时候即被创建\",{\"1\":{\"482\":1}}],[\"java7\",{\"1\":{\"483\":1}}],[\"javaa\",{\"1\":{\"472\":1}}],[\"java使用起来非常方便\",{\"1\":{\"435\":1}}],[\"java方法有两种返回函数的方式\",{\"1\":{\"413\":1}}],[\"java开头的包名\",{\"1\":{\"393\":1}}],[\"javafx\",{\"1\":{\"392\":1}}],[\"java应用的类都是由它来完成加载\",{\"1\":{\"384\":1}}],[\"java语音编写\",{\"1\":{\"383\":1}}],[\"javac\",{\"1\":{\"357\":1,\"367\":1,\"380\":1}}],[\"java程序\",{\"1\":{\"343\":1}}],[\"java程序员书单\",{\"1\":{\"124\":1}}],[\"java代码执行流程\",{\"1\":{\"343\":1}}],[\"java栈又叫做jvm虚拟机栈\",{\"1\":{\"343\":1}}],[\"java虚拟机内部的引用\",{\"1\":{\"519\":1}}],[\"java虚拟机将抛出outofmemoryerror\",{\"1\":{\"441\":1}}],[\"java虚拟机将会抛出一个stackoverflowerror异常\",{\"1\":{\"437\":1}}],[\"java虚拟机将会抛出一个\",{\"1\":{\"409\":1}}],[\"java虚拟机采用的是双亲委派模式\",{\"1\":{\"390\":1}}],[\"java虚拟机对class文件采用的是按需加载的方式\",{\"1\":{\"390\":1}}],[\"java虚拟机规范管束\",{\"1\":{\"461\":1}}],[\"java虚拟机规范允许java栈的大小是动态的或者是固定不变的\",{\"1\":{\"409\":1}}],[\"java虚拟机规范\",{\"1\":{\"379\":1,\"444\":1,\"445\":1,\"464\":1,\"482\":2}}],[\"java虚拟机的退出情况\",{\"1\":{\"347\":1}}],[\"java虚拟机的启动是通过引导类加载器\",{\"1\":{\"345\":1}}],[\"java虚拟机栈用于管理java方法的调用\",{\"1\":{\"437\":1}}],[\"java虚拟机栈是什么\",{\"0\":{\"407\":1}}],[\"java虚拟机栈\",{\"0\":{\"302\":1},\"1\":{\"407\":1}}],[\"java虚拟机在jit编译时\",{\"1\":{\"278\":1}}],[\"java线程池实现原理及其在美团业务中的实践\",{\"1\":{\"291\":1}}],[\"java中的对象就是聚合量\",{\"1\":{\"510\":1}}],[\"java中的原始数据类型就是标量\",{\"1\":{\"510\":1}}],[\"java中\",{\"1\":{\"288\":1}}],[\"java6之后加入的新锁\",{\"1\":{\"278\":1}}],[\"java6\",{\"1\":{\"278\":2}}],[\"java6及以上版本对synchronized的优化\",{\"1\":{\"278\":1}}],[\"java锁与线程的那些事\",{\"1\":{\"278\":1}}],[\"java多线程\",{\"1\":{\"270\":1}}],[\"javadoop\",{\"1\":{\"249\":1,\"595\":1}}],[\"java容器\",{\"2\":{\"223\":1,\"236\":1,\"254\":1,\"260\":1}}],[\"java基础面试题\",{\"0\":{\"211\":1,\"212\":1}}],[\"java<\",{\"1\":{\"77\":1,\"83\":1}}],[\"java版本\",{\"1\":{\"70\":1}}],[\"javax\",{\"1\":{\"65\":1,\"78\":4,\"382\":1,\"762\":1}}],[\"java8的相关操作总结\",{\"1\":{\"575\":1}}],[\"java8的日期相关类做了很多升级\",{\"1\":{\"555\":1}}],[\"java8新增的日期类都在java\",{\"1\":{\"555\":1}}],[\"java8新增的日期类\",{\"1\":{\"555\":1}}],[\"java8\",{\"0\":{\"556\":1,\"575\":1,\"1046\":1},\"1\":{\"4\":1,\"249\":1,\"465\":2,\"483\":1}}],[\"java\",{\"0\":{\"4\":1,\"300\":1,\"309\":1,\"357\":1,\"359\":1,\"365\":1,\"517\":1},\"1\":{\"59\":1,\"70\":1,\"77\":3,\"101\":3,\"106\":1,\"184\":1,\"214\":1,\"217\":1,\"227\":1,\"234\":1,\"235\":1,\"242\":2,\"252\":1,\"278\":5,\"302\":7,\"303\":2,\"304\":4,\"305\":4,\"308\":3,\"311\":3,\"312\":1,\"314\":1,\"315\":3,\"318\":1,\"319\":1,\"324\":1,\"325\":1,\"326\":1,\"327\":1,\"329\":2,\"331\":3,\"333\":3,\"338\":1,\"340\":6,\"341\":1,\"343\":2,\"353\":1,\"355\":2,\"356\":2,\"359\":3,\"360\":1,\"363\":1,\"365\":2,\"367\":4,\"377\":1,\"382\":3,\"383\":1,\"384\":2,\"387\":1,\"388\":1,\"392\":2,\"393\":3,\"397\":3,\"407\":1,\"422\":1,\"435\":2,\"442\":4,\"462\":1,\"464\":6,\"465\":2,\"467\":1,\"471\":3,\"474\":1,\"485\":1,\"492\":1,\"506\":1,\"525\":2,\"535\":2,\"537\":2,\"549\":1,\"596\":1,\"602\":1,\"614\":1,\"615\":1,\"651\":1,\"665\":1,\"668\":2,\"670\":1,\"685\":1,\"686\":1,\"695\":2,\"697\":2,\"698\":2,\"701\":5,\"708\":1,\"711\":1,\"722\":3,\"723\":3,\"734\":3,\"738\":4,\"742\":5,\"747\":12,\"754\":5,\"755\":2,\"757\":1,\"758\":1,\"779\":2,\"878\":1,\"879\":2,\"888\":2,\"892\":1,\"893\":1,\"982\":1,\"983\":1,\"990\":5,\"991\":2,\"994\":1,\"996\":2,\"998\":4}}],[\"jvm在指定的版本范围时才开启配置\",{\"1\":{\"675\":1}}],[\"jvm在进行gc时\",{\"1\":{\"493\":1}}],[\"jvm默认老年代回收是\",{\"1\":{\"540\":1}}],[\"jvm默认使用的收集器\",{\"0\":{\"537\":1}}],[\"jvm只需要持有一个内存的起始地址即可\",{\"1\":{\"523\":2}}],[\"jvmti中注册的回调\",{\"1\":{\"519\":1}}],[\"jvm参数\",{\"1\":{\"513\":1}}],[\"jvm就会直接分配到老年代\",{\"1\":{\"512\":1}}],[\"jvm就会尝试着通过使用加锁机制确保数据操作的原子性\",{\"1\":{\"502\":1}}],[\"jvm为每个线程分配了一个私有缓存区域\",{\"1\":{\"500\":1}}],[\"jvm内存分布\",{\"1\":{\"465\":1}}],[\"jvm必须保存所有方法的以下信息\",{\"1\":{\"454\":1}}],[\"jvm必须在方法区中保存类型的所有域的相关信息以及域的声明顺序\",{\"1\":{\"453\":1}}],[\"jvm必须在方法区中存储以下类型信息\",{\"1\":{\"452\":1}}],[\"jvm可以根据应用的需要动态调整\",{\"1\":{\"446\":1}}],[\"jvm支持着java语言本身和运行时库\",{\"1\":{\"435\":1}}],[\"jvm会试图直接分配在eden其他位置上\",{\"1\":{\"512\":1}}],[\"jvm会在栈上分配那些不会逃逸的对象\",{\"1\":{\"511\":1}}],[\"jvm会把该类的方法表也初始化完毕\",{\"1\":{\"423\":1}}],[\"jvm会保证子类的<clinit>\",{\"1\":{\"380\":1}}],[\"jvm直接对java栈的操作只有两个\",{\"1\":{\"408\":1,\"413\":1}}],[\"jvm的相关知识\",{\"1\":{\"541\":1}}],[\"jvm的垃圾回收器将对eden区进行垃圾回收\",{\"1\":{\"490\":1}}],[\"jvm的内存模型\",{\"1\":{\"465\":1}}],[\"jvm的字节码解释器就需要通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令\",{\"1\":{\"401\":1}}],[\"jvm的生命周期\",{\"0\":{\"344\":1}}],[\"jvm判断2个class对象是否为同一个类的两个必要条件\",{\"0\":{\"395\":1}}],[\"jvm是世界上最快的jvm\",{\"1\":{\"352\":1}}],[\"jvm发展历程\",{\"0\":{\"348\":1}}],[\"jvm整体结构\",{\"0\":{\"343\":1}}],[\"jvm简介\",{\"0\":{\"342\":1}}],[\"jvm加载的过程中\",{\"1\":{\"319\":1}}],[\"jvm中并未这么做\",{\"1\":{\"511\":1}}],[\"jvm中的pc寄存器是对物理pc寄存器的一种抽象模拟\",{\"1\":{\"399\":1}}],[\"jvm中\",{\"1\":{\"303\":1,\"437\":1}}],[\"jvm中采用2个字来存储对象头\",{\"1\":{\"278\":1}}],[\"jvm面试题\",{\"0\":{\"299\":1}}],[\"jvm很难感知到确切的锁竞争时间\",{\"1\":{\"278\":1}}],[\"jvm\",{\"0\":{\"285\":1,\"366\":1,\"541\":1},\"1\":{\"4\":1,\"278\":1,\"285\":1,\"286\":1,\"317\":2,\"318\":1,\"328\":1,\"331\":1,\"333\":1,\"340\":3,\"343\":1,\"355\":3,\"357\":1,\"359\":1,\"360\":1,\"363\":1,\"372\":1,\"381\":1,\"382\":2,\"396\":2,\"399\":1,\"423\":1,\"442\":2,\"445\":1,\"459\":1,\"465\":9,\"467\":1,\"473\":1,\"479\":1,\"518\":1,\"602\":1,\"607\":2}}],[\"谢谢\",{\"1\":{\"1\":1}}],[\"gateway\",{\"0\":{\"1015\":1}}],[\"garbage\",{\"1\":{\"304\":1,\"482\":1,\"515\":1,\"535\":2}}],[\"guide\",{\"1\":{\"1001\":1}}],[\"guava在preconditions类中提供了许多先决条件检查实用程序\",{\"1\":{\"997\":1}}],[\"guava\",{\"0\":{\"1001\":1},\"1\":{\"990\":5,\"991\":2,\"1001\":1},\"2\":{\"999\":1}}],[\"gt\",{\"1\":{\"847\":1,\"848\":1,\"851\":1}}],[\"ghi\",{\"1\":{\"728\":2}}],[\"globalconfig\",{\"1\":{\"864\":1}}],[\"globalsession\",{\"1\":{\"612\":1}}],[\"global\",{\"1\":{\"587\":1,\"615\":1,\"835\":1,\"836\":1}}],[\"g1回收器停顿时间最短而且没有明显缺点\",{\"1\":{\"537\":1}}],[\"g1\",{\"0\":{\"535\":1},\"1\":{\"535\":11,\"536\":1,\"539\":1}}],[\"g1垃圾收集器\",{\"1\":{\"339\":1}}],[\"gnu\",{\"1\":{\"367\":1}}],[\"gb\",{\"1\":{\"335\":1}}],[\"g\",{\"1\":{\"335\":1,\"1024\":1}}],[\"gcd\",{\"1\":{\"984\":3}}],[\"gcroots有哪些\",{\"1\":{\"518\":1}}],[\"gc原理\",{\"1\":{\"518\":1}}],[\"gc的两种判定方法\",{\"1\":{\"518\":1}}],[\"gc的时候要找到哪些对象没用\",{\"1\":{\"497\":1}}],[\"gc是什么\",{\"1\":{\"518\":1}}],[\"gc是开发或调优中尽量要避免的\",{\"1\":{\"496\":1}}],[\"gc算法有哪些\",{\"1\":{\"518\":1}}],[\"gc非常频繁\",{\"1\":{\"494\":1}}],[\"gc会引发stw\",{\"1\":{\"494\":1}}],[\"gc会清理年轻代的内存\",{\"1\":{\"494\":1}}],[\"gc会有单独收集老年代的行为\",{\"1\":{\"493\":1}}],[\"gc会有这种行为\",{\"1\":{\"493\":1}}],[\"gcviewer\",{\"1\":{\"492\":1}}],[\"gc分代年龄\",{\"1\":{\"476\":1}}],[\"gc多次调用\",{\"1\":{\"448\":1}}],[\"gc将会被触发并卸载没用的类\",{\"1\":{\"448\":1}}],[\"gcj\",{\"1\":{\"367\":1}}],[\"gc\",{\"0\":{\"493\":3,\"494\":1,\"495\":2,\"496\":1,\"519\":1},\"1\":{\"313\":1,\"322\":3,\"463\":2,\"473\":1,\"487\":1,\"490\":3,\"492\":1,\"493\":10,\"494\":1,\"495\":5,\"496\":2,\"497\":1,\"503\":1,\"505\":1,\"518\":2,\"525\":2,\"527\":4,\"528\":2,\"534\":3,\"535\":3,\"540\":1}}],[\"ge\",{\"1\":{\"852\":1,\"853\":1}}],[\"genericfilter\",{\"1\":{\"905\":1}}],[\"generation\",{\"1\":{\"304\":3,\"461\":1,\"483\":4}}],[\"generator<\",{\"1\":{\"863\":1}}],[\"generator\",{\"1\":{\"139\":1}}],[\"generated\",{\"1\":{\"815\":1}}],[\"generate\",{\"1\":{\"78\":2,\"201\":1}}],[\"gen\",{\"1\":{\"525\":2}}],[\"gettotal\",{\"1\":{\"858\":2}}],[\"gettype\",{\"1\":{\"788\":13}}],[\"getuname\",{\"1\":{\"854\":1}}],[\"getuserbyid\",{\"1\":{\"788\":1}}],[\"getinvoker\",{\"1\":{\"889\":1}}],[\"getitem\",{\"1\":{\"810\":1}}],[\"getid\",{\"1\":{\"762\":1,\"765\":1,\"815\":1}}],[\"getpages\",{\"1\":{\"858\":2}}],[\"getpatterns\",{\"1\":{\"788\":6}}],[\"getpatternscondition\",{\"1\":{\"788\":6}}],[\"getparent\",{\"1\":{\"332\":3,\"381\":2}}],[\"gethandlermethods\",{\"1\":{\"788\":1}}],[\"getrecords\",{\"1\":{\"858\":1}}],[\"getreplycode\",{\"1\":{\"765\":1}}],[\"getreplytext\",{\"1\":{\"765\":1}}],[\"getroutingkey\",{\"1\":{\"765\":1}}],[\"getextensionloader\",{\"1\":{\"904\":1}}],[\"getexchange\",{\"1\":{\"765\":1}}],[\"getemail\",{\"1\":{\"854\":2}}],[\"getenvelope\",{\"1\":{\"708\":2,\"714\":1,\"717\":1,\"749\":2}}],[\"getmethods\",{\"1\":{\"788\":1}}],[\"getmethodscondition\",{\"1\":{\"788\":1}}],[\"getmethodannotation\",{\"1\":{\"788\":1}}],[\"getmessage\",{\"1\":{\"765\":1}}],[\"getmessageproperties\",{\"1\":{\"752\":1,\"755\":1,\"757\":1,\"780\":1}}],[\"getmapping\",{\"1\":{\"673\":1,\"754\":2,\"755\":2,\"757\":1,\"762\":2,\"780\":1,\"792\":1}}],[\"getmaximumgenerated\",{\"1\":{\"198\":1}}],[\"getkey\",{\"1\":{\"738\":1,\"742\":1,\"788\":7}}],[\"getqueue\",{\"1\":{\"730\":1}}],[\"getdeliverytag\",{\"1\":{\"708\":2,\"714\":1,\"717\":1,\"749\":2}}],[\"getb\",{\"1\":{\"821\":3}}],[\"getbean\",{\"1\":{\"788\":1}}],[\"getbeanclassloader\",{\"1\":{\"674\":1}}],[\"getbody\",{\"1\":{\"698\":1,\"701\":1,\"708\":1,\"714\":1,\"717\":1,\"747\":2,\"748\":1,\"749\":2,\"754\":1,\"757\":1,\"762\":1,\"765\":2,\"768\":1,\"779\":1,\"780\":1}}],[\"getbytes\",{\"1\":{\"697\":2,\"701\":1,\"708\":1,\"711\":1,\"712\":1,\"722\":1,\"723\":1,\"729\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":1,\"748\":1,\"779\":2}}],[\"get方式\",{\"1\":{\"649\":1}}],[\"getname传给了map方法\",{\"1\":{\"549\":1}}],[\"getname\",{\"1\":{\"546\":1,\"549\":1,\"810\":1,\"821\":2,\"853\":1,\"854\":1}}],[\"getnumberofbacklogorders\",{\"1\":{\"194\":1}}],[\"getchannel\",{\"1\":{\"701\":3,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"748\":2,\"749\":2,\"779\":2}}],[\"getcalories\",{\"1\":{\"546\":1,\"548\":1}}],[\"getcallerclassloader\",{\"1\":{\"389\":1}}],[\"getcontextclassloader\",{\"1\":{\"389\":1}}],[\"getclassloader\",{\"1\":{\"332\":3,\"381\":2,\"389\":1}}],[\"getclass\",{\"1\":{\"234\":1,\"389\":1}}],[\"getspringfactoriesloaderfactoryclass\",{\"1\":{\"674\":1}}],[\"getservice\",{\"1\":{\"617\":1}}],[\"getstatic\",{\"1\":{\"397\":1}}],[\"getstr\",{\"1\":{\"317\":2}}],[\"getsystemclassloader\",{\"1\":{\"381\":1,\"384\":1,\"389\":1}}],[\"getsum\",{\"1\":{\"194\":2}}],[\"getvalue\",{\"1\":{\"241\":1,\"738\":1,\"742\":1,\"788\":1}}],[\"getadaptiveextension\",{\"1\":{\"904\":1}}],[\"getanonymousurl\",{\"1\":{\"788\":2}}],[\"getavailablezoneids\",{\"1\":{\"562\":1}}],[\"getage的语法\",{\"1\":{\"853\":1}}],[\"getage\",{\"1\":{\"241\":5,\"853\":2,\"854\":2}}],[\"getasint\",{\"1\":{\"198\":1}}],[\"get\",{\"0\":{\"649\":1},\"1\":{\"201\":4,\"230\":2,\"233\":3,\"249\":1,\"673\":2,\"788\":16,\"789\":1,\"792\":2,\"832\":1,\"833\":1,\"944\":2,\"957\":2}}],[\"ggtalk\",{\"1\":{\"143\":1}}],[\"gi回收器讲下回收过程\",{\"1\":{\"518\":1}}],[\"given\",{\"1\":{\"239\":1}}],[\"gif\",{\"1\":{\"139\":1}}],[\"giscus\",{\"1\":{\"128\":1}}],[\"git来下载这个版本\",{\"1\":{\"1004\":1}}],[\"git常用操作\",{\"0\":{\"580\":1}}],[\"git\",{\"1\":{\"131\":1,\"584\":4,\"585\":1,\"587\":1,\"910\":1}}],[\"gitmoji\",{\"1\":{\"131\":1}}],[\"gitter\",{\"1\":{\"121\":1}}],[\"git的注释等\",{\"1\":{\"6\":1}}],[\"github\",{\"0\":{\"127\":1},\"1\":{\"1\":1,\"47\":1,\"53\":1,\"110\":2,\"111\":2,\"113\":1,\"114\":1,\"120\":1,\"127\":1,\"128\":1,\"587\":1,\"588\":2,\"756\":1,\"910\":1,\"1004\":2}}],[\"google\",{\"1\":{\"122\":1,\"879\":1,\"989\":1,\"990\":5,\"991\":1,\"995\":1,\"1001\":1}}],[\"goals>\",{\"1\":{\"99\":1,\"106\":1}}],[\"goal>\",{\"1\":{\"99\":1,\"106\":1}}],[\"gradlew\",{\"1\":{\"1010\":1}}],[\"gradle文件内gradle的镜像地址\",{\"1\":{\"1009\":1}}],[\"gradle文件\",{\"1\":{\"1008\":1,\"1011\":1}}],[\"gradle\",{\"1\":{\"1005\":3,\"1006\":4,\"1007\":6,\"1008\":1}}],[\"grantedauthoritydefaults\",{\"1\":{\"788\":3}}],[\"grid\",{\"1\":{\"933\":1,\"934\":11,\"935\":1,\"943\":18,\"944\":7}}],[\"gridea\",{\"1\":{\"1\":1}}],[\"green\",{\"1\":{\"736\":1}}],[\"groups\",{\"1\":{\"1009\":1}}],[\"groupid>\",{\"1\":{\"65\":1,\"70\":3,\"77\":1,\"83\":2,\"87\":7,\"88\":7,\"101\":1,\"106\":4,\"670\":1,\"671\":2,\"679\":3,\"680\":1,\"696\":3,\"753\":7,\"830\":1,\"863\":2}}],[\"groupid\",{\"1\":{\"65\":1,\"78\":1}}],[\"groovy\",{\"1\":{\"591\":1}}],[\"托管\",{\"1\":{\"1\":1}}],[\"x版本\",{\"1\":{\"1004\":1}}],[\"x满\",{\"1\":{\"982\":1}}],[\"x是当前两桶水之和\",{\"1\":{\"982\":1}}],[\"x中会有剩余\",{\"1\":{\"982\":1}}],[\"x空\",{\"1\":{\"982\":1}}],[\"x往y中倒水\",{\"1\":{\"982\":1}}],[\"x升\",{\"1\":{\"981\":1}}],[\"xftp\",{\"1\":{\"756\":1}}],[\"xb\",{\"1\":{\"754\":2,\"755\":1}}],[\"xbootclasspath参数指定的路径中的所有类\",{\"1\":{\"331\":1}}],[\"xa\",{\"1\":{\"754\":2,\"755\":1}}],[\"xexchange\",{\"1\":{\"754\":9,\"755\":3}}],[\"xc\",{\"1\":{\"752\":1,\"755\":2,\"780\":1}}],[\"xcomp\",{\"1\":{\"371\":1}}],[\"x基础教程\",{\"1\":{\"660\":1}}],[\"xnoclassgc\",{\"1\":{\"464\":1}}],[\"x64\",{\"1\":{\"410\":2}}],[\"xss1048576\",{\"1\":{\"410\":1}}],[\"xss1024k\",{\"1\":{\"410\":1}}],[\"xss1m\",{\"1\":{\"410\":1}}],[\"xss\",{\"1\":{\"410\":1,\"427\":1}}],[\"xint\",{\"1\":{\"371\":1}}],[\"xx\",{\"1\":{\"305\":4,\"336\":4,\"337\":1,\"338\":4,\"339\":4,\"369\":3,\"444\":1,\"447\":2,\"448\":7,\"464\":2,\"471\":1,\"485\":2,\"487\":1,\"488\":5,\"490\":1,\"498\":2,\"502\":2,\"503\":8,\"504\":1,\"506\":2,\"510\":1,\"532\":3,\"537\":2,\"831\":1,\"934\":7,\"935\":1,\"943\":7,\"944\":7}}],[\"xxxfactory\",{\"1\":{\"468\":1}}],[\"xxxbuilder\",{\"1\":{\"468\":1}}],[\"xxx的静态方法\",{\"1\":{\"468\":1}}],[\"xxxxxx\",{\"1\":{\"831\":2}}],[\"xxxxx\",{\"1\":{\"588\":1}}],[\"xxxx\",{\"1\":{\"114\":1}}],[\"xxx\",{\"1\":{\"77\":4,\"83\":1,\"468\":1,\"651\":1,\"686\":1}}],[\"xmn\",{\"1\":{\"503\":1}}],[\"xmn设置新生代最大内存大小\",{\"1\":{\"488\":1}}],[\"xmn256m\",{\"1\":{\"336\":1}}],[\"xmixed\",{\"1\":{\"371\":1}}],[\"xmind\",{\"0\":{\"112\":1}}],[\"xmx\",{\"1\":{\"485\":5,\"503\":1}}],[\"xmx与\",{\"1\":{\"450\":1}}],[\"xmx5g\",{\"1\":{\"335\":1}}],[\"xmx<heap\",{\"1\":{\"335\":1}}],[\"xms\",{\"1\":{\"450\":1,\"485\":4,\"503\":1}}],[\"xms2g\",{\"1\":{\"335\":1}}],[\"xms<heap\",{\"1\":{\"335\":1}}],[\"xml自定义分页\",{\"0\":{\"859\":1}}],[\"xml配置\",{\"1\":{\"648\":1}}],[\"xml配置的\",{\"1\":{\"648\":1}}],[\"xml配置文件中存在office和office2两个bean\",{\"1\":{\"599\":1}}],[\"xml文件中的namespace即是mapper接口的类路径\",{\"1\":{\"809\":1}}],[\"xml文件配置好要拦截的客户端请求\",{\"1\":{\"648\":1}}],[\"xml文件需要修改\",{\"1\":{\"61\":1}}],[\"xml<\",{\"1\":{\"99\":1}}],[\"xml中定义的每个sql的resulttype的类型相同\",{\"1\":{\"809\":1}}],[\"xml中定义的每个sql的id相同\",{\"1\":{\"809\":1}}],[\"xml中定义的每个sql\",{\"1\":{\"809\":1}}],[\"xml中配置multipart类型解析器\",{\"1\":{\"655\":1}}],[\"xml中配置即可\",{\"1\":{\"649\":1}}],[\"xml中配置\",{\"1\":{\"648\":1}}],[\"xml中配置插件依赖\",{\"1\":{\"99\":1}}],[\"xml中会出现下面的标签\",{\"1\":{\"87\":1}}],[\"xml中\",{\"1\":{\"78\":1}}],[\"xml采用的标签结构\",{\"1\":{\"70\":1}}],[\"xml解读\",{\"0\":{\"70\":1}}],[\"xml\",{\"0\":{\"86\":1,\"87\":1,\"88\":1,\"811\":1,\"822\":1},\"1\":{\"69\":2,\"72\":3,\"77\":2,\"82\":1,\"85\":2,\"99\":2,\"595\":2,\"617\":1,\"649\":1,\"652\":1,\"673\":1,\"686\":1,\"696\":1,\"806\":1,\"812\":1,\"816\":1,\"822\":2,\"875\":1}}],[\"xrebel\",{\"1\":{\"22\":1}}],[\"x\",{\"1\":{\"1\":2,\"32\":1,\"60\":3,\"510\":9,\"697\":3,\"728\":3,\"731\":1,\"736\":1,\"747\":2,\"748\":3,\"749\":3,\"752\":3,\"754\":17,\"755\":6,\"757\":2,\"777\":2,\"779\":1,\"780\":2,\"783\":2,\"943\":1,\"944\":3,\"949\":6,\"963\":2,\"965\":2,\"968\":2,\"973\":2,\"981\":2,\"982\":5,\"983\":10,\"984\":7,\"1004\":2,\"1029\":2,\"1034\":2,\"1038\":3}}],[\"vhost\",{\"1\":{\"693\":2}}],[\"vs\",{\"0\":{\"456\":1}}],[\"vmw\",{\"1\":{\"740\":1}}],[\"vm对虚拟机规范中方法区的一种实现方式\",{\"1\":{\"374\":1}}],[\"vm是采用解释器与即时编译器并存的架构\",{\"1\":{\"371\":1}}],[\"vm所采用的热点探测方式是基于计数器的热点探测\",{\"1\":{\"368\":1}}],[\"vm\",{\"0\":{\"349\":1,\"350\":1,\"351\":1,\"371\":1,\"372\":1},\"1\":{\"341\":1,\"350\":1,\"353\":1,\"362\":1,\"365\":1,\"367\":1,\"374\":1,\"493\":1}}],[\"volume\",{\"1\":{\"577\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"281\":1}}],[\"volatile\",{\"1\":{\"281\":2,\"453\":1}}],[\"void\",{\"1\":{\"194\":1,\"241\":1,\"257\":6,\"258\":1,\"332\":1,\"392\":2,\"424\":1,\"510\":3,\"559\":1,\"562\":2,\"568\":1,\"569\":1,\"571\":1,\"573\":2,\"605\":6,\"673\":1,\"687\":3,\"697\":1,\"698\":1,\"701\":2,\"708\":2,\"711\":1,\"712\":1,\"714\":1,\"717\":1,\"722\":1,\"723\":1,\"734\":1,\"738\":1,\"742\":1,\"747\":3,\"748\":2,\"749\":2,\"753\":1,\"754\":2,\"755\":2,\"757\":2,\"762\":4,\"765\":4,\"768\":1,\"779\":2,\"780\":2,\"788\":2,\"853\":1,\"854\":1,\"858\":1,\"864\":1,\"934\":1,\"943\":1,\"990\":1,\"991\":1,\"992\":1,\"993\":1,\"996\":1,\"998\":1,\"1024\":7,\"1034\":1}}],[\"v>\",{\"1\":{\"251\":1,\"259\":1}}],[\"var\",{\"0\":{\"579\":1}}],[\"variables数据项中\",{\"1\":{\"415\":1}}],[\"variables\",{\"0\":{\"415\":1},\"1\":{\"414\":1}}],[\"va\",{\"1\":{\"319\":1}}],[\"val+\",{\"1\":{\"1024\":1}}],[\"val\",{\"1\":{\"963\":2,\"965\":3,\"968\":2,\"973\":4,\"975\":2,\"1020\":2,\"1024\":6,\"1029\":13,\"1030\":2,\"1034\":3,\"1035\":1}}],[\"valueof\",{\"1\":{\"957\":1}}],[\"value服务过期时间\",{\"1\":{\"897\":1}}],[\"value属性\",{\"1\":{\"836\":1}}],[\"values\",{\"1\":{\"815\":1}}],[\"value>\",{\"1\":{\"649\":1}}],[\"value>utf\",{\"1\":{\"649\":1}}],[\"value\",{\"1\":{\"202\":1,\"215\":2,\"239\":2,\"242\":2,\"291\":2,\"410\":1,\"595\":1,\"651\":2,\"681\":1,\"702\":2,\"738\":1,\"754\":5,\"792\":2,\"814\":2,\"815\":1,\"836\":1,\"1030\":1}}],[\"valid\",{\"1\":{\"651\":1}}],[\"validator校验框架校验\",{\"1\":{\"651\":1}}],[\"validator\",{\"1\":{\"159\":1}}],[\"validategenerate\",{\"1\":{\"94\":1}}],[\"valinet\",{\"1\":{\"111\":1}}],[\"vant\",{\"1\":{\"157\":1}}],[\"vue工具类\",{\"0\":{\"160\":1}}],[\"vue\",{\"0\":{\"157\":1},\"1\":{\"160\":5}}],[\"vuepress\",{\"1\":{\"1\":1,\"53\":1}}],[\"vuepress😊\",{\"1\":{\"1\":1}}],[\"vegetarianmenu\",{\"1\":{\"548\":1}}],[\"ventusky\",{\"1\":{\"152\":1}}],[\"vector\",{\"1\":{\"219\":1,\"226\":1}}],[\"vectorizer\",{\"1\":{\"132\":1,\"140\":1}}],[\"vectormagic\",{\"1\":{\"132\":1}}],[\"verbose\",{\"1\":{\"464\":1,\"503\":1}}],[\"version注解\",{\"1\":{\"860\":1}}],[\"version=1\",{\"1\":{\"860\":1}}],[\"version=version\",{\"1\":{\"860\":1}}],[\"version查看\",{\"1\":{\"505\":1}}],[\"version>4\",{\"1\":{\"87\":1}}],[\"version>1\",{\"1\":{\"70\":1,\"101\":1}}],[\"version>\",{\"1\":{\"65\":1,\"70\":3,\"77\":1,\"83\":1,\"87\":8,\"88\":2,\"99\":1,\"101\":2,\"106\":1,\"671\":1,\"680\":1,\"696\":2,\"753\":2,\"830\":1,\"863\":2}}],[\"version\",{\"1\":{\"65\":1,\"78\":1,\"87\":2,\"99\":1,\"101\":2,\"537\":1,\"860\":4}}],[\"vercel\",{\"1\":{\"1\":1,\"136\":1}}],[\"v0\",{\"1\":{\"114\":1}}],[\"virtual\",{\"1\":{\"353\":1,\"407\":1,\"410\":1,\"423\":1,\"693\":1}}],[\"vis\",{\"1\":{\"948\":3,\"949\":4}}],[\"visited\",{\"1\":{\"934\":5}}],[\"visio\",{\"1\":{\"110\":1}}],[\"visualvm\",{\"1\":{\"492\":1}}],[\"visual\",{\"1\":{\"341\":1}}],[\"viewresolver\",{\"1\":{\"642\":1,\"644\":1}}],[\"view\",{\"1\":{\"157\":1,\"645\":2,\"646\":2}}],[\"videofk\",{\"1\":{\"148\":2}}],[\"video\",{\"1\":{\"143\":1}}],[\"vivetool\",{\"1\":{\"114\":4}}],[\"vive\",{\"0\":{\"114\":1},\"1\":{\"114\":1}}],[\"v\",{\"1\":{\"63\":1,\"72\":1,\"207\":13,\"242\":2,\"645\":1,\"944\":2,\"1007\":1}}],[\"v1\",{\"1\":{\"49\":1}}],[\"v2ex\",{\"1\":{\"120\":1}}],[\"v2\",{\"1\":{\"1\":2}}],[\"hsql\",{\"1\":{\"827\":1}}],[\"h2\",{\"1\":{\"827\":1}}],[\"hyperv\",{\"1\":{\"577\":1}}],[\"hh\",{\"1\":{\"573\":1}}],[\"hreadpoolexecutor\",{\"1\":{\"275\":1}}],[\"http接口是在接口不多\",{\"1\":{\"872\":1}}],[\"httpmethod\",{\"1\":{\"788\":7}}],[\"http\",{\"1\":{\"340\":1,\"525\":1,\"587\":1,\"615\":1,\"651\":2,\"754\":1,\"755\":2,\"757\":2,\"762\":1,\"765\":1,\"768\":1,\"888\":5}}],[\"httpsecurity\",{\"1\":{\"788\":3}}],[\"https\",{\"1\":{\"35\":3,\"41\":1,\"47\":1,\"53\":1,\"61\":1,\"110\":5,\"111\":2,\"113\":1,\"114\":1,\"247\":1,\"249\":2,\"279\":1,\"289\":1,\"293\":1,\"588\":1,\"595\":2,\"614\":2,\"677\":1,\"910\":1,\"1004\":1,\"1008\":1,\"1009\":3,\"1038\":1}}],[\"htmlopen\",{\"1\":{\"614\":1}}],[\"html>\",{\"1\":{\"249\":2}}],[\"html\",{\"1\":{\"247\":1,\"340\":1,\"615\":1,\"788\":4}}],[\"helper\",{\"1\":{\"1029\":4}}],[\"help\",{\"1\":{\"1029\":2}}],[\"hello前有一个空格\",{\"1\":{\"996\":1}}],[\"hello=zs\",{\"1\":{\"993\":1}}],[\"hello2\",{\"1\":{\"757\":2}}],[\"hello1=ls\",{\"1\":{\"993\":1}}],[\"hello1\",{\"1\":{\"757\":3,\"993\":1}}],[\"hello~~~~~~~~\",{\"1\":{\"605\":1}}],[\"hello\",{\"0\":{\"695\":1},\"1\":{\"549\":1,\"605\":1,\"697\":1,\"730\":1,\"777\":1,\"993\":1,\"996\":5}}],[\"hession\",{\"1\":{\"888\":1}}],[\"hessian序列化\",{\"1\":{\"888\":1}}],[\"hessian\",{\"1\":{\"879\":1,\"888\":3}}],[\"heapdump\",{\"1\":{\"340\":1}}],[\"heap\",{\"1\":{\"302\":1,\"304\":1,\"305\":1,\"335\":1,\"340\":1,\"343\":2,\"441\":1,\"505\":2}}],[\"headmap\",{\"1\":{\"724\":2}}],[\"headers\",{\"1\":{\"728\":3,\"788\":1,\"792\":2}}],[\"header\",{\"0\":{\"476\":1}}],[\"head\",{\"1\":{\"229\":2,\"242\":1,\"963\":4,\"965\":3,\"968\":2,\"969\":8,\"973\":4,\"975\":9}}],[\"hexo\",{\"1\":{\"1\":1}}],[\"hd\",{\"1\":{\"184\":1}}],[\"h5带笔锋手写签名\",{\"1\":{\"161\":1}}],[\"hikaridatasource\",{\"1\":{\"831\":1}}],[\"hikari\",{\"1\":{\"831\":1}}],[\"hibernate\",{\"1\":{\"823\":2}}],[\"hibernate查询关联对象或者关联集合对象时\",{\"1\":{\"806\":1}}],[\"history\",{\"1\":{\"127\":1}}],[\"highlight\",{\"1\":{\"42\":1}}],[\"hard类型\",{\"0\":{\"1044\":1}}],[\"hard\",{\"0\":{\"1043\":1}}],[\"haha\",{\"1\":{\"996\":2}}],[\"handlepromotionfailure参数不会再影响到虚拟机的空间分配担保策略\",{\"1\":{\"504\":1}}],[\"handlepromotionfailure\",{\"0\":{\"504\":1},\"1\":{\"498\":1,\"503\":1,\"504\":1}}],[\"handlermethod\",{\"1\":{\"788\":3}}],[\"handlermethodmap\",{\"1\":{\"788\":4}}],[\"handlermethod>\",{\"1\":{\"788\":3}}],[\"handlermapping映射成功的handler最终使用该\",{\"1\":{\"656\":1}}],[\"handlermapping\",{\"1\":{\"644\":1}}],[\"handler方法之前执行\",{\"1\":{\"656\":1}}],[\"handleradapter\",{\"1\":{\"644\":1}}],[\"handler执行完成给处理器适配器返回modelandview\",{\"1\":{\"642\":1}}],[\"handler\",{\"1\":{\"275\":1,\"646\":1}}],[\"hagersten\",{\"1\":{\"289\":1}}],[\"hasprevious\",{\"1\":{\"858\":2}}],[\"hasnext\",{\"1\":{\"230\":1,\"701\":1,\"708\":1,\"711\":1,\"712\":1,\"734\":1,\"858\":2}}],[\"hash表\",{\"0\":{\"948\":1}}],[\"hashedpassword\",{\"1\":{\"819\":5}}],[\"hashentry\",{\"1\":{\"249\":1,\"251\":6}}],[\"hash\",{\"1\":{\"242\":1,\"244\":13,\"246\":3,\"252\":1}}],[\"hashcodes\",{\"1\":{\"244\":1}}],[\"hashcode\",{\"1\":{\"240\":3,\"242\":10,\"244\":4,\"473\":1,\"476\":1}}],[\"hashtable全表锁\",{\"1\":{\"249\":1}}],[\"hashtable\",{\"0\":{\"239\":1,\"249\":1},\"1\":{\"222\":2,\"239\":8,\"249\":4,\"728\":1}}],[\"hashset都会直接插入\",{\"1\":{\"242\":1}}],[\"hashset的add\",{\"1\":{\"242\":1}}],[\"hashset\",{\"0\":{\"240\":1,\"242\":1},\"1\":{\"216\":1,\"220\":2,\"240\":6,\"242\":3,\"259\":1}}],[\"hashset<>\",{\"1\":{\"186\":1,\"788\":6,\"982\":1,\"983\":1}}],[\"hashmap<integer\",{\"1\":{\"944\":1}}],[\"hashmap<string\",{\"1\":{\"742\":1,\"783\":1}}],[\"hashmap<>\",{\"1\":{\"738\":1,\"742\":1,\"747\":1,\"748\":1,\"749\":1,\"752\":1,\"754\":2,\"755\":1,\"757\":1,\"780\":1,\"788\":1}}],[\"hashmap的tablesizefor方法能衍生出来一个很有意思的问题\",{\"1\":{\"253\":1}}],[\"hashmap1\",{\"1\":{\"249\":1,\"252\":1}}],[\"hashmap\",{\"0\":{\"239\":1,\"240\":1,\"241\":1,\"243\":1,\"246\":1,\"247\":1,\"248\":1},\"1\":{\"216\":1,\"220\":3,\"222\":4,\"239\":12,\"240\":4,\"244\":6,\"245\":1,\"246\":3,\"247\":2,\"248\":1,\"249\":3,\"251\":1,\"259\":1,\"697\":1,\"738\":1,\"742\":1,\"747\":2,\"754\":1,\"755\":1,\"777\":1,\"779\":2,\"813\":2,\"819\":1}}],[\"half\",{\"1\":{\"198\":2,\"369\":1,\"975\":2}}],[\"hacksplaining\",{\"1\":{\"146\":1}}],[\"hamcrest\",{\"1\":{\"78\":2}}],[\"have\",{\"1\":{\"78\":1,\"244\":1}}],[\"hpt\",{\"1\":{\"38\":1,\"88\":2,\"397\":1,\"605\":1,\"854\":1}}],[\"h\",{\"1\":{\"32\":2,\"244\":10,\"1024\":1}}],[\"host\",{\"1\":{\"693\":1,\"753\":1,\"754\":3,\"762\":1,\"765\":1}}],[\"hotsppt\",{\"1\":{\"464\":1}}],[\"hotspot中默认就己经开启了逃逸分析\",{\"1\":{\"506\":1}}],[\"hotspot采用\",{\"1\":{\"479\":1}}],[\"hotspotjvm\",{\"1\":{\"441\":1}}],[\"hotspot场景下\",{\"1\":{\"437\":1}}],[\"hotspot将会为每一个方法都建立2个不同类型的计数器\",{\"1\":{\"368\":1}}],[\"hotspott\",{\"1\":{\"353\":1}}],[\"hotspot\",{\"0\":{\"351\":1,\"366\":1,\"371\":1,\"372\":1,\"443\":1},\"1\":{\"303\":1,\"305\":1,\"306\":1,\"307\":3,\"338\":1,\"340\":1,\"351\":1,\"352\":1,\"362\":2,\"365\":2,\"367\":1,\"372\":1,\"374\":1,\"461\":2,\"462\":1,\"464\":3,\"493\":1,\"506\":1,\"511\":1,\"525\":3,\"534\":1,\"535\":1}}],[\"home\",{\"1\":{\"15\":1,\"62\":2,\"331\":2,\"382\":1,\"1007\":3}}],[\"hope\",{\"1\":{\"1\":1}}],[\"hunt\",{\"1\":{\"147\":1}}],[\"hutool中关于时间的api\",{\"1\":{\"574\":1}}],[\"hutool\",{\"1\":{\"4\":1}}],[\"hugo\",{\"1\":{\"1\":1}}],[\"🎃\",{\"0\":{\"975\":1}}],[\"🏠\",{\"0\":{\"1\":1}}],[\"🎈🎈🎈\",{\"1\":{\"0\":1}}],[\"🤝\",{\"1\":{\"0\":1}}],[\"欢迎光临\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
